\input{galop08-slides.pre}

\pstrSetArrowColor{black}

\title{\texorpdfstring{A Concrete Presentation of Game Semantics}{A Concrete Presentation of Game Semantics}}

\author[W. Blum, C.-H. L. Ong]{\texorpdfstring{\\ William Blum\\ \ \\
 Joint work with C.-H. Luke Ong}{William Blum}}


\institute[Oxford University -- Edinburgh University]{School of Informatics, University of Edinburgh -- Oxford University Computing Laboratory}

\date{\small \color{red}{Galop 2008, 5 April 2008}}


\begin{document}

\frame{\titlepage}

\frame{\frametitle{Overview}

\begin{itemize}
\item
We briefly present a new representation theory for game semantics which is very concrete: instead of playing in an arena game in which P plays the innocent strategy given by a term, the same game is played out over (a souped up version of) the abstract syntax tree of the term itself. The plays that are thus traced out are called \highlight{traversals}. More abstractly, traversals are the justified sequences that are obtained by performing parallel-composition \emph{less} the hiding. After stating and explaining a number of Path-Traversal Correspondence Theorems, we present a tool for game semantics based on the new representation.

\end{itemize}
}


%\section<presentation>*{Outline}
\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

\AtBeginSection[] {
   \begin{frame}
     \frametitle{Outline}
     \tableofcontents[currentpart,currentsection]
   \end{frame}
 }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The correspondence}

\subsection{Game semantics}

%%% The Correspondence in one slide
%\frame{ \frametitle{Correspondence Theorem}
%Let $\vdash M:T$ be a pure simply typed term.
%
%\begin{itemize}
%\item \highlight{Game-semantics} provides a model of $\lambda$-calculus.
%$M$ is denoted by a strategy $\sem{M}$ on a 2-player game induced by $T$.
%\item A \highlight{strategy} is represented by a set of sequences of moves together with \highlight{links}: each move points
%to a preceding move.
%\pause
%\item \textcolor{DarkGreen}{Computation tree} = canonical tree representation of a term.
%\item \textcolor{DarkGreen}{Traversals $\travset(M)$ } = sequences of nodes with links respecting some formation rules.
%\end{itemize}
%\pause
%
%\begin{block}{The Correspondence Theorem}
%The game semantics of a term can be represented on the computation
%tree:
%$$ \textcolor{DarkGreen}{\travset(M)} \cong \textcolor{blue}{\intersem{M}} $$
%$$ \textcolor{DarkGreen}{Reduction(\travset(M))} \cong \textcolor{blue}{\sem{M}}$$
%where $\textcolor{blue}{\intersem{M}}$ is the revealed game-semantic denotion (i.e. internal moves are uncovered).
%\end{block}
%}

\frame{\frametitle{Game semantics}
 Model of programming languages based on games (Abramsky et al.; Hyland and Ong; Nickau)
\begin{itemize}
\item 2 players: \highlight{O}pponnent (system) and \highlight{P}roponent (program)
\item The term type induces an \highlight{arena} defining the possible moves
$\sem{\nat} = \begin{tikzpicture}[baseline=(root.base),level distance=7mm,inner ysep=0.5mm,sibling distance=5mm]
 \node (root) {$q$}
    child {node {$\scriptstyle 0$}}
    child {node {$\scriptstyle 1$}}
    child {node {$\scriptstyle \ldots$}}
;
\end{tikzpicture}$
\hspace{2cm}
$\sem{\nat \rightarrow \nat} = \begin{tikzpicture}[baseline=(root.base),level distance=7mm,inner ysep=0.5mm,sibling distance=5mm]
 \node (root) {$q^0$}
    child{
      node{$q^1$}
      child{node {$\scriptstyle 0$} }
      child{node {$\scriptstyle 1$} }
      child {node {$\scriptstyle \ldots$}}
    }
    child {node {$\scriptstyle 0$}}
    child {node {$\scriptstyle 1$}}
    child {node {$\scriptstyle \ldots$}}
;
\end{tikzpicture}$
\item \highlight{Play} = sequence of moves played alternatively by O and P with justification pointers.
\item \highlight{Strategy for P} = prefix-closed set of plays. $s  a  b$ in the strategy means that
P should respond $b$ when O plays $a$ in position $s$.
\item The \highlight{denotation} of a term $M$, written $\sem{M}$, is a strategy for P.
\item $\sem{ 7 : \nat} = \{ \epsilon, q, q\ 7 \}$\\
$\sem{ \pcfsucc : \nat \rightarrow \nat} = Pref( \{ q^0 q^1 n ( n+1)
\ | \ n \in \nat \} )$
\item Compositionality: $\sem{ \pcfsucc\  7} = \sem{ \pcfsucc } ; \sem{7}$
\end{itemize}
}



\def\highlightat#1#2{\temporal<#1>{#2}{\underline{#2}}{\textcolor{blue}{#2}}}

\subsection{Computation tree, traversals}
\frame{ \frametitle{Computation trees and traversals}
\highlight{\it Computation tree:} AST of the $\eta$-long normal form of a term.

Example: $M \equiv \lambda f z .
(\lambda g x . f x) (\lambda y. y) z$ of type $(o \typear o) \typear
o \typear o$. \vspace{0.5cm}
\begin{columns}
\column{6cm}
 \visible<2->{\highlight{\it Traversal:} justified
sequence of nodes representing the computation. }

\setbox0=\hbox{$\textcolor{blue}{
\pstr{\only<3->{\nd t= (q1){\lambda f z}}
        \only<4->{\nd \cdot (n2) {@}}
        \only<5->{\nd \cdot (n3-n2){\lambda g x}}
        \only<6->{\nd \cdot (q3-q1,35){f}}
        \only<7->{\nd \cdot (q4-q3){\lambda}}
        \only<8->{\nd \cdot (n8-n3,35){x}}
        \only<9->{\nd \cdot (n9-n2,30){\lambda}}
        \only<10->{\nd \cdot (q2-q1,30){z}}
}}$}
\ht0 1cm\box0 % Make sure the height of box containing the traversal remains constant across the different generated slides

\vspace*{0.5cm}
\visible<11->{\highlight{\it Traversal reduction:} keep only
nodes hereditarily justified by the root.
$\color{red}{
\Pstr[0.7cm]{t \upharpoonright r = (q1){\lambda f z} \cdot (q3-q1,50){f}
\cdot (q4-q3,50){\lambda} \cdot (q2-q1){z} } }$
}

\vspace*{0.8cm}
\visible<12->{
\highlight{\it @-nodes removal:}
 $\Pstr[0.7cm]{ t - @ = (q1){\lambda f z}
 \cdot (n3-q1){ \lambda g x}
 \cdot (q3-q1,35){ f}
 \cdot (q4-q3){ \lambda}
 \cdot (n8-n3,30){ x}
 \cdot (n9-q1,30){ \lambda}
 \cdot (q2-q1,35){z}
} $}
\column{3.5cm}
\begin{tikzpicture}[level distance=7mm,inner ysep=0.5mm]
 \node {\highlightat{3}{$\lambda f z$}}
    child {
        node {\highlightat{4}{@}}
        child {
            node {\highlightat{5}{$\lambda g x$}}
            child{
                node{\highlightat{6}{$f$}}
                child {
                    node{\highlightat{7}{$\lambda$}}
                    child {
                        node{\highlightat{8}{$x$}}
                    }
                }
            }
        }
        child {
            node {$\lambda y$}
            child{ node {$y$} }
        }
        child {
            node {$\highlightat{9}{\lambda}$}
            child{ node {\highlightat{10}{$z$}} }
            }
        };
\end{tikzpicture}
\end{columns}
}


\frame{
\frametitle{Traversals}
The set $\travset(M)$ of \defname{traversals}
over $\tau(M)$ is given by the rules:
%\begin{FramedTable}
%\noindent {\bf Initialization rules}
\begin{itemize}[]
\item\rulenamet{Empty} $\epsilon \in\travset(M)$. \qquad\qquad
\rulenamet{Root} $\theroot \in \travset(M)$ where $\theroot$ is $\tau(M)$'s root.
%\end{itemize}
%\noindent {\bf Structural rules}
%\begin{itemize}[]
    \item \rulenamet{Lam} If $t \cdot \lambda \overline{\xi} \in\travset(M)$ then 
        $t \cdot \lambda \overline{\xi} \cdot n \in\travset(M)$ where $n$
        is $\lambda \overline{\xi}$'s child and its justifier is the only occurrence of 
        its enabler in the P-view
    \item \rulenamet{App} If $t \cdot @$ is a traversal then so is \Pstr[0.4cm]{t \cdot (m) @  \cdot (n-m,40:0) n}.
%\end{itemize}
%\emph{\bf Input-variable rules}
%\begin{itemize}[]
\item \rulenamet{ContextVar} If $t\in\travset(M)$ where $t^\omega \in N_{\sf var}^{\theroot\vdash} \union L_\lambda^{\theroot\vdash}$
and $x$ is an occurrence of a variable node in $\oview{t}$ then
$t \cdot n \in\travset(M)$ for any child $\lambda$-node $n$ of $x$, $n$
pointing to $x$.

\item \rulenamet{ContextValue} If $t_1
\cdot x \cdot t_2 \in\travset(M)$ with pending node $x \in
N_{\sf var}^{\theroot\vdash}$ then so is \Pstr[0.5cm]{t_1 \cdot
(x){x} \cdot t_2 \cdot (xv-x,38:v){v_x} } for all $v \in
\mathcal{D}$.
%\end{itemize}
%\emph{\bf Copy-cat rules}
%\begin{itemize}[]
\item\rulenamet{Var}
If \Pstr[0.2cm]{t \cdot (n){n} \cdot (lx){\lambda \overline{x}}
    \ldots (x-lx,40:i){x_i} } $\in\travset(M)$, $x_i \in
    N_{\sf var}^{@\vdash}$ then \Pstr[0.5cm]{ t \cdot
(n){n} \cdot (lx){\lambda \overline{x}}  \ldots (x-lx,25:i){x_i}
    \cdot (letai-n,32:i){\lambda \overline{\eta_i}}} $\in\travset(M)$.
\item\rulenamet{Value}
  If \Pstr{t \cdot (m){m} \cdot (n){n}  \ldots
(vn-n,50:v){v}_{n} } $\in\travset(M)$ where $n\in N$ then 
\Pstr[0.6cm]{t \cdot (m){m} \cdot (n){n} \ldots
(vn-n,50:v){v}_{n} \cdot (vm-m,45:v){v}_m} $\in\travset(M)$.
\end{itemize}
%\caption[Traversal rules for the simply-typed
%lambda-calculus]{Traversal rules for the simply-typed
%$\lambda$-calculus.}
%\label{tab:trav_rules}
%\end{FramedTable}

}

\subsection{The Correspondence Theorem}
\frame{ \frametitle{The Correspondence Theorem}
\begin{block}{}
Let $M$ be a simply typed term of type $T$. There exists a partial function $\textcolor{DarkGreen}{\varphi}$
from the nodes of the \highlight{computation tree} to the
moves of the \highlight{arena} $\sem{T}$ such that
$$ \textcolor{DarkGreen}{\varphi}  : \travset(M)^{-@} \textcolor{DarkGreen}{\stackrel{\cong}{\longrightarrow}}
\revsem{M} $$
$$ \textcolor{DarkGreen}{\varphi}  : \travset(M)^{\upharpoonright r}  \textcolor{DarkGreen}{\stackrel{\cong}{\longrightarrow}} \sem{M} \ .$$
\end{block}
where
\begin{itemize}
\item $\highlight{\travset(M)}$ = set of traversals of the computation tree of $M$
\item $\highlight{\travset(M)^{\upharpoonright r}} = \{ t \upharpoonright r \ | \  t \in {\travset(M)} \}$
\item $\highlight{\travset(M)^{-@}} = \{ t - @ \ | \  t \in {\travset(M)} \}$
\item $\highlight{\sem{M}}$ = game-semantic denotation of $M$
\item $\highlight{
\revsem{M}}$ = revealed denotion ({\it i.e.}~internal moves are uncovered.)
\end{itemize}

}


\frame{ \frametitle{The Correspondence Theorem (2)}
\begin{center}
\begin{tabular}{c|c}
Computation tree notions & Game-semantic equivalents \\ \hline \hline \\
computation tree & arena(s) \\ \\
traversal & uncovered play \\ \\
reduced traversal & play \\ \\
path in the computation tree & P-view of an uncovered play
\end{tabular}
\end{center}
}


\subsection{Example}
\frame{\frametitle{Example: $\lambda f z . (\lambda g x. f x) (\lambda y . y) z$}

Left: computation tree. Right: arena.
\begin{center}
\begin{tikzpicture}[level distance=7mm,inner ysep=0.5mm,inner xsep=0.5mm,sibling distance=10mm]
%\color{blue}
\node (root) {$\lambda f z$}
    child{
      node{$@$}
          child{
            node {$\lambda g x$}
            child{
              node (f) {$f$}
              child{
                node (lmd) {$\lambda$}
                child{
                  node {$x$}
                }
              }
            }
          }
          child{
            node {$\lambda y$}
            child{
              node {$y$}
            }
          }
          child{
            node {$\lambda$}
            child{
              node (z) {$z$}
            }
          }
      }
;
%\color{red}
\draw +(5,0) node (q1) {$q^1$}
    [level distance=20mm]
      child{
        node (q3) {$q^3$}
        [level distance=10mm]
        child{ node (q4) {$q^4$} }
      }
      child{ node (q2) {$q^2$} }
      child{ node (q5) {$q^5$} }
;
\color{DarkGreen}
\draw[->] (root) -- node[above] {$\varphi$} (q1);
\draw[->] (f) -- (q3);
\draw[->] (lmd) -- (q4);
\draw[->] (z) to [bend right=20]  (q2);
\end{tikzpicture}
\end{center}
Example of traversal: \Pstr{t = (q1){\lambda f z} \cdot (n2){@}
\cdot (n3-n2){\lambda g x}
\cdot (q3-q1,35){f}
\cdot (q4-q3){\lambda}
\cdot (n8-n3){x}
\cdot (n9-n2,35){\lambda}
\cdot (q2-q1,35){z}}.

\begin{itemize}
\item $\Pstr{\pview{t} = (q1){\lambda f z} \cdot (n2){@}
\cdot (n9-n2,35){\lambda}
\cdot (q2-q1,35){z}}$

\item
$
\textcolor{DarkGreen}{
\varphi (} %\textcolor{blue}
{t \upharpoonright r}
\textcolor{DarkGreen}{)} = \textcolor{DarkGreen}{\varphi (}
\textcolor{blue}{
\Pstr[70mm]{ (q1){\lambda f z}
            \cdot (q3-q1){f}
            \cdot (q4-q3){\lambda}
            \cdot (q2-q1){z} }
}
\textcolor{DarkGreen}{)} = %\textcolor{red}
{
\Pstr[70mm]{
    (q1){q}^1\
    (q3-q1){q}^3\
    (q4-q3){q}^4\
    (q2-q1){q}^2
}}
\in %\textcolor{red}
{\sem{M}}.
$



\end{itemize}
}



\begingroup
\newcommand\sigcol[1]{{\color{blue} #1}}
\newcommand\mucol[1]{{\color{red} #1}}
\newcommand\mynodeex[2]{\node[name=#1]{$#2$};}

\subsection{Composition}
\begin{frame}[fragile]
\frametitle{Composition}

Take $\sigcol{\sigma} = \sem{ \vdash \sigcol{\lambda x^o v^o .x} : o\typear (o,o)}$
 and  $\mucol{\mu} = \sem{ \vdash \mucol{\lambda y^{(o,o)} \varphi^{((o,o),o)}. \varphi (\lambda u^o . y~u)} : (o,o) \typear (((o,o),o),o)}$.

We then have $\sigcol{\sigma} \fatcompos \mucol{\mu} = \sem{ \lambda x \varphi. \varphi (\lambda u . x) : o \typear (((o,o),o),o)}$.
\bigskip

\begin{tikzpicture}
  [every node/.style={anchor=base}]
  \matrix [matrix of nodes]
  {
    o & $\stackrel{\sigcol{\sigma}}\longrightarrow$ & (o,& o) & $\stackrel{\mucol{\mu}}\longrightarrow$ &  (((o,&o),&o), & o) \\
&&&&&&&&\mynodeex{n0}{\lambda x \varphi \omove  \mucol {\lambda y \varphi}}\\
&&&&&&&\mynodeex{n1}{\varphi  \pmove \mucol \varphi}\\
&&&&&&\mynodeex{n2}{\lambda u \omove  \mucol {\lambda u}} \\
&&&  \mynodeex{n3}{\sigcol {\lambda x v} \opmove \mucol y} \\
\mynodeex{n4}{x \pmove \sigcol x}\\
  };
\draw[->] (n4) .. controls +(60:1cm) and +(-1,0) .. (n0.west);
\draw[->] (n2) .. controls +(60:0.2cm) and +(-0.4cm,0) .. (n1.west);
\draw[->] (n1) .. controls +(60:0.2cm) and +(-0.4cm,0) .. (n0.west);
\draw[->] (n3) .. controls +(30:1cm) and +(-1,0) .. (n0.west);
\draw[->] (n4) .. controls +(30:1cm) and +(-1,0) .. (n3.west);
\end{tikzpicture}
\end{frame}
\endgroup


\subsection{Demo}
\frame{\frametitle{Tool demo}
\includegraphics[width=11cm]{sshot.jpg}
 
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Applications}


\subsection{Higher-order grammars}
\frame{\frametitle{Higher-order grammars}
\emph{Notation for types:} $A_1 \rightarrow (A_2 \rightarrow (\ldots (A_n \rightarrow o)) \ldots )$
is written $(A_1,A_2,\ldots, A_n,o)$.

\begin{itemize}

\item Higher-order grammars (Maslov, 1974) are used as generators of word languages, trees or graphs.

\item A \highlight{higher-grammar} is formally given by a tuple
$\langle \Sigma, \mathcal{N}, \mathcal{R}, \mathcal{S} \rangle$
(terminals, non-terminals, rewritting rules, starting symbol)

\item Example of a tree-generating order-2 grammar:
\begin{columns}
      \column{.3\textwidth}
$\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}$
      \column{.3\textwidth}
\begin{tikzpicture}[baseline=(root.base),level distance=5mm,inner ysep=0.5mm,sibling distance=10mm]
 \node (root) {$g$}
    child {node {$a$}}
    child {node {$g$}
        child { node{$a$} }
        child { node{$h$}
                child { node{$h$}
                        child { node{$\vdots$} }
                }
        }
    } ;
\end{tikzpicture}
\end{columns}
Non-terminals: $S :o$, $H:(o,o)$ and $F:((o,o),o)$. Terminals: $a:o$ and $g,h:(o,o)$.
\end{itemize}
}

\subsection{Other applications}
\frame{\frametitle{Other applications}
\begin{itemize}
\item Studying the game semantics of syntactic restrictions.
For instance it can be used to show that
for terms verifying the \emph{safety restriction} (a syntactic restriction that constrains the occurrences of variables according to their orders) pointers are uniquely recoverable in the game denotation of terms verifying the .
\pause

\end{itemize}

}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simply Typed \texorpdfstring{$\lambda$}{Lambda}-Calculus}
\frame{\frametitle{Simply Typed $\lambda$-Calculus}
\begin{itemize}
\item \highlight{Simple types} $A := o\ |\ A \rightarrow A$.
%We write $(A_1,\ldots, A_n)$ for $A_1\rightarrow \ldots \rightarrow A_n$.

\item The \highlight{order} of a type is given by $\textsf{order}(o) = 0$,
$\textsf{order}(A \rightarrow B) = \max(\textsf{order}(A) + 1, \textsf{order}(B))$.


\end{itemize}
}




\section{Conclusion and Future Works}
\frame{ \frametitle{Conclusion and Future Works}

\highlight{Conclusion:}


\highlight{Future works:}
\begin{itemize}
\item Implement other transformations: from CPDA to HORS
%\item Implement decision procedures: MSO decidability
\end{itemize}


\highlight{Related works:}
\begin{itemize}
\item Ong introduced computation trees in LICS2006 to prove decidability of MSO theory on infinite trees
generated by higher-order grammars.
\item Stirling recently proved decidability of higher-order pattern matching with a game-semantic approach
relying on equivalent notions of computation tree and traversal.
\end{itemize}
}



\begin{frame} \frametitle<presentation>{Bibliography}

  \begin{thebibliography}{10}
  \beamertemplatearticlebibitems
    \bibitem{abramsky:game-semantics-tutorial}
    Samson Abramsky and Guy McCusker.
    \newblock Game semantics, Lecture notes.
    \newblock In {\em Proceedings of the 1997 Marktoberdorf Summer School}. Springer-Verlag, 1998.

%    \bibitem{safety-mirlong2004}
%    Klaus Aehlig, Jolie~G. de~Miranda, and C.-H.~Luke Ong.
%    \newblock Safety is not a restriction at level 2 for string languages.
%    \newblock Technical report. University of Oxford, 2004.

    \bibitem{OngLics2006}
    C.-H.~Luke Ong.
    \newblock On model-checking trees generated by higher-order recursion schemes.
    \newblock In {\em Proceedings of LICS.} Computer Society Press, 2006.

    \bibitem{DBLP:conf/icalp/Stirling06}
    Colin Stirling
    \newblock A Game-Theoretic Approach to Deciding Higher-Order Matching.
    \newblock In {\em Proceedings of ICALP.} Springer, 2006.

  \end{thebibliography}
\end{frame}


\frame{\frametitle{Bibliography 2}
\begin{description}
\item [Damm82] For generating word languages, order-$n$ safe grammars are
equivalent to order-$n$ pushdown automata.

\item [KNU02] Generalization of Damm's result to
\emph{tree generating} safe grammars/PDAs.

\item [KNU02] The Monadic Second Order (MSO) model checking problem for trees generated by
    \highlight{safe} higher-order grammars of any order is decidable.

\item [Ong06] But anyway, KNU02 result's is also true for unsafe grammars...

\item [Caucal02] Graphs generated by safe grammars have a decidable MSO theory.

\item [HMOS06] Caucal's result does not extend to unsafe grammars.
However deciding $\mu$-calculus theories is $n$-EXPTIME complete.
\end{description}


\note{
\begin{itemize}
\item nPDA = finite state machines + order n stack
\item For words: 1PDA recognizes context-free language.
        and 0PDA = recognizes regular language.
\item MSO is very expressive: more than the modal mu-calculus (into which LTL CTL CTL* can be embedded.
But over trees, MSO and modal mu-calculus are equi-expressive.)
\end{itemize}
}
}


\end{document}
