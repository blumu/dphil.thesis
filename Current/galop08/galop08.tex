\input{galop08.pre}


\title{A tool illustrating the Correspondence Theorem
\\ GALOP 2008}

\author{William~Blum~~~~~~~~~~~C.-H.~Luke~Ong\\
Oxford University Computing Laboratory\\
Wolfson Building, Parks Road, Oxford OX1 3QD, ENGLAND\\
\{william.blum,luke.ong\}@comlab.ox.ac.uk }



\begin{document}
\maketitle \thispagestyle{empty}

\begin{abstract}
Todo...
\end{abstract}


\section{Luke's description of the paper:}

 We have developed a number of what we call Path-Traversal
Correspondence Theorems. One way to think of the work is as a kind
of representation theory of the game semantics of higher-type
programs (such as recursion schemes, PCF and Idealized Algol) that
is very concrete, involving combinatorics over (possibly) infinite
structures defined by the abstract syntax trees of the programs
being modelled. The idea is that we represent a play in the
strategy-denotation of a term as the underlying "hereditarily
uncovered" interaction sequence, called traversal. Another way to
put it is that traversals are built up by performing
parallel-composition but WITHOUT the hiding. This is what William
Greenland has called (in his thesis) "revealed semantics" (or
"interaction semantics"). A consequence of the representation is
that we show how the "innocent game" given by a term can be played
out very concretely over what is in essence the abstract syntax tree
of the term itself.

This "representation theory" was first developed to prove the result
in my LICS06 paper (i.e. trees generated by higher-order recursion
schemes have decidable MSO theories). The theory has at least two
other applications. First as a justification of the game
characterization of the Higher-Order Matching Problem (but NOT the
algorithm) developed by Colin Stirling, and secondly as a key lemma
underpinning the result that
 the following are equivalent (i.e. equi-expressive:
i. order-n recursion schemes (= order-n PCF terms generated from
uninterpreted order-1 symbols) ii. order-n collapsible pushdown
automata CPDA. iii. order-n "pure" innocent strategies

What we are thinking of submitting is a short paper describing a
tool developed by William Blum that illustrates the representation
theory. The tool has many capabilities. For example, it can perform
the inter-translation between CPDA and recursion schemes; it can
demonstrate the path-traversal correspondence in the form of a
2-player game (and lets users play it out over the abstract syntax
tree of the term); and it is a very impressive tool for drawing
justified sequences!

What we intend to talk about in the paper is first an overview of
the correspondence theorems, illustrate their many applications, and
then showcase the tool.

\section{Computation tree, traversal and the Correspondence}

In \cite{OngLics2006}, one of us introduced the notion of
computation tree and traversals over a computation tree for the
purpose of studying trees generated by higher-order recursion
scheme. Here we extend these concepts to the pure (\ie without
constants) simply-typed lambda calculus. Our setting allows the
presence of free variable of any order. Moreover the term studied is
not necessarily of ground type. (This contrasts with
\cite{OngLics2006}'s setting where the term is of ground type and
contains only \emph{uninterpreted constant}\footnote{A constant $f$
is  \emph{uninterpreted} if the small-step semantics of the language
  does not contain any rule of the form $f \dots \rightarrow e$. $f$
  can be regarded as a data constructor.} of order 1 at most and no
free variables.) Note that our setting automatically accounts for
the presence of uninterpreted constants since they can be regarded
as free variables. We will then state the \emph{Correspondence
Theorem} (Theorem \ref{thm:correspondence}).

In the following we fix a simply-typed term $\Gamma \vdash M :T$.

\subsection{Computation tree}
 In \cite{OngLics2006} the computation tree of a grammar is
defined as the unravelling of a finite graph representing the long
transform of a grammar. Similarly we define the computation tree of
a $\lambda$-term as an abstract syntax tree of its $\eta$-long
normal form.  We write $l\langle t_1, \ldots, t_n \rangle$ with $n
\geq 0$ to denote the tree with a root labelled $l$ with $n$
children subtrees $t_1$, \ldots, $t_n$.

\begin{definition}\rm
\label{dfn:comptree}
  The \defname{computation tree} $\tau(M)$ of a simply-typed term
  $\Gamma \vdash M:T$ with variable names in a countable set
  $\mathcal{V}$ is a tree with labels in $ \{ @ \} \union \mathcal{V}
  \union \{ \lambda x_1 \ldots x_n \ | \ x_1 ,\ldots, x_n \in
  \mathcal{V}, n\in\nat \}$ defined from its $\eta$-long form as follows. Suppose $\overline{x} = x_1 \ldots x_n$ for $n\geq 0$ then
\begin{eqnarray*}
  \mbox{for $m\geq 0$, $z \in \mathcal{V}$: } \tau(\lambda \overline{x} . z s_1 \ldots s_m : o) &=& \lambda \overline{x} \langle z \langle\tau(s_1),\ldots,\tau(s_m)\rangle\rangle \\
  \mbox{for $m \geq 1$: } \tau(\lambda \overline{x} . (\lambda y.t) s_1 \ldots s_m :o) &=& \lambda \overline{x} \langle @ \langle \tau(\lambda y.t),\tau(s_1),\ldots,\tau(s_m) \rangle \rangle \ .
\end{eqnarray*}
\end{definition}

Even-level nodes are $\lambda$-nodes (the root is on level 0). A
single $\lambda$-node can represent several consecutive variable
abstractions or it can just be a \emph{dummy lambda} if the
corresponding subterm is of ground type.  Odd-level nodes are
variable or application nodes.

We say that a variable node $n$ labelled $x$ is \defname{bound} by a
node $m$, and $m$ is called the \defname{binder} of $n$, if $m$ is
the closest node in the path from $n$ to the root such that $m$ is
labelled $\lambda \overline{\xi}$ with $x\in \overline{\xi}$.




\subsection{Notations}
We first fix some notations. We write $\theroot$ to denote the root
of the computation tree $\tau(M)$. The set of nodes of the
computation tree is denoted by $N$. The sets $N_@$, $N_\lambda$ and
$N_{\sf var}$ are the subset of $N$ consisting of the @-nodes,
$\lambda$-nodes and variable nodes respectively.


\subsection{Justified sequences of nodes}

We define the \defname{enabling relation} on the set of nodes of the
computation tree as follows: $m$ enables $n$, written $m \vdash n$,
if and only if $n$ is bound by $m$ (and we sometimes write $m
\vdash_i n$ to precise that $n$ is the $i^{\sf th}$ variable bound
by $m$); or $m$ is the root $\theroot$ and $n$ is a free variable;
or $n$ is a $\lambda$-node and $m$ is its parent node.


We say that a node $n_0$ of the computation tree is
\defname{hereditarily enabled} by $n_p \in N$ if there are nodes
$n_1,\ldots, n_{p-1} \in N$ such that $n_{i+1}$ enables $n_{i}$ for
all $i\in 0..p-1$.

For any set of nodes $S, H \subseteq N$ we write $S^{H\vdash}$ for
$S \inter \vdash^*(H) = \{ n \in S \ | \exists n_0 \in H \mbox{ s.t.
}n_0  \vdash^* n \}$ -- the subset of $S$ constituted of nodes
hereditarily enabled by some node in $H$. We will abbreviate
$S^{\{n_0\}\vdash}$ into $S^{n_0\vdash}$.

We call \defname{input-variables nodes} the elements of $V_{\sf
var}^{\theroot\vdash}$ \ie variables that are hereditarily enabled
by the root of $\tau(M)$. Thus we have $V_{\sf var}^{\theroot\vdash}
= V \setminus ( V_{\sf var}^{N_@\vdash} \union V_{\sf
var}^{N_\Sigma\vdash})$.

A \defname{justified sequence of nodes} is a sequence of nodes with
pointers such that each occurrence of a variable or $\lambda$-node
$n$ different from the root has a pointer to some preceding
occurrence $m$ verifying $m \vdash n$. In particular, occurrences of
@-nodes do not have pointer. We represent the pointer in the
sequence as follows \Pstr[0.4cm]{ (m){m} \ldots (n-m,45:i) n }.
 where the label indicates that either $n$ is labelled with the $i$th variable
abstracted by the $\lambda$-node $m$ or that $n$ is the $i^{\sf th}$
child of $m$.  Children nodes are numbered from $1$ onward except
for @-nodes where it starts from $0$. Abstracted variables are
numbered from $1$ onward. The $i^{\sf th}$ child of $n$ is denoted
by $n.i$.

We say that a node $n_0$ of a justified sequence is
\defname{hereditarily justified} by $n_p$ if there are occurrences $n_1,
\ldots, n_{p-1}$ in the sequence such that $n_i$ points to $n_{i+1}$
for all $i\in 0..p-1$. Let $n$ be an occurrence in a justified
sequence $s$. We write $s \filter r$ to denote the subsequence of
$s$ consisting of the occurrences hereditarily justified by $n$.


The notion of \defname{P-view} $\pview{t}$ of a justified sequence
of nodes $t$ is defined the same way as the P-view of a justified
sequences of moves in Game Semantics:\footnote{ The equalities in
the
  definition determine pointers implicitly. For instance in the second
  clause, if in the left-hand side, $n$ points to some node in $s$
  that is also present in $\pview{s}$ then in the right-hand side, $n$
  points to that occurrence of the node in $\pview{s}$.}
$$\begin{array}{rclrcl}
\pview{\epsilon} &=&  \epsilon
& \pview{\Pstr[0.5cm]{ s \cdot (m) m \cdot \ldots \cdot (lmd-m,40){\lambda\overline{\xi}}
}}
 &=& \Pstr{
\pview{s} \cdot (m2) m \cdot (lm2-m2,50) {\lambda \overline{\xi}} } \\
\mbox{for $n \notin N_\lambda$, } \pview{s \cdot n }  &=&  \pview{s} \cdot n \qquad
& \pview{s \cdot \theroot }  &=&  \theroot
\end{array}$$

The O-view of $s$, written $\oview{s}$, is defined dually. We will
borrow the game semantic terminology: A justified sequences of nodes
satisfies \defname{alternation} if for any two consecutive nodes one
is a $\lambda$-node and the other is not, and \defname{P-visibility}
if every variable node points to a node occurring in the P-view a
that point.

\subsection{Adding value-leaves to the computation tree}

We now add another ingredient to the computation tree that was not
originally used in \cite{OngLics2006}.  We write $\mathcal{D}$ to
denote the set of values of the base type $o$.  We add
\defname{value-leaves} to $\tau(M)$ as follows: For each value $v
\in \mathcal{D}$ and for each node $n \in N$ we attach the child
leaf $v_n$ to $n$.  We write $V$ for the set of vertices of the
resulting tree (\ie inner nodes and leaf nodes). For $\$$ ranging in
$\{@, \lambda, var \}$, we write $V_\$$ to denote the set of inner
nodes from $N_\$$ plus the leaf-nodes whose parent is in $N_\$$ \ie
$V_\$ = N_\$ \union \{ v_n \ | \ n \in N_\$, v \in \mathcal{D} \}$.


Everything that we have defined can be lifted to this new version of
computation tree. The enabling relation $\vdash$ is extended so that
every leaf is enabled by its parent node. A link going from a
value-leaf $v_n$ to a node $n$ is labelled by $v$: \Pstr[0.4cm]{ (n)
n \ldots (vn-n,35:v){v_n} }. For the definition of P-view and
visibility, value-leaves are treated as $\lambda$-nodes if they are
at an odd level in the computation tree, and as variable nodes if
they are at an even level.

We say that an occurrence of an inner node $n \in N$ is
\defname{answered} by an occurrence $v_n$ if $v_n$ in
the sequence that points to $n$, otherwise we say that $n$ is
\defname{unanswered}. The last unanswered node is called the
\defname{pending node}.  A justified sequence of nodes is
\defname{well-bracketed} if each value-leaf occurring in it is justified by the pending node at that point.  If $t$ is a traversal then we write
$?(t)$ to denote the subsequence of $t$ consisting only of
unanswered nodes.

\subsection{Traversals of the computation tree}
\label{subsec:traversal}

A \emph{traversal} is a justified sequence of nodes of the
computation tree where each node indicates a step that is taken
during the evaluation of the term.

\input{../thesis/traversal_rules_def}

\parpic[r]{
 $\pssetcomptree\tree[levelsep=3ex,treesep=0.5cm]{\lambda} {
    \tree{@}{
        \pstree[linestyle=dotted]{\TR{\lambda y}\arclabel{0} }{
            \tree{y}{
                \tree{\lambda \overline{\eta_1}}{\vdots}%\arclabel{1}
                \tree{\lambda \overline{\eta_i}}{\vdots}%\arclabel{i}
                \tree{\lambda \overline{\eta_n}}{\vdots}%\arclabel{n}
            }
        }
        \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}
            \arclabel{1}}{ \tree{x_i}{\TR{} \TR{}}}
}}$ } A traversal always starts by visiting the root. Then it mainly
follows the structure of the tree. The (Var) rule permits to jump
across the computation tree. The idea is that after visiting a
variable node $x$, a jump is allowed to the node corresponding to
the subterm that would be substituted for $x$ if all the
$\beta$-redexes occurring in the term were reduced. The sequence
\Pstr[0.8cm]{\lambda \cdot (app) @  \cdot (ly) {\lambda y}  \ldots
(y-ly,35:1) y  \cdot (lx-app,38:1) {\lambda \overline{x}} \ldots
(x-lx,30:i) {x_i} \cdot (leta-y,40:i) {\lambda \overline{\eta_i} }
\ldots}
 is an example of traversal of the computation tree shown on the right.

\begin{proposition}[counterpart of proposition 6 from \cite{OngHoMchecking2006}]
\label{prop:pviewtrav_is_path} Let $t$ be a traversal. Then:
\begin{enumerate}[(i)]
\item $t$ is a well-defined and well-bracketed justified sequence;
\item $t$ is a well-defined justified sequence verifying alternation, P-visibility and O-visibility;
\item If $t$'s last node is not a value-leaf, then $\pview{t}$ is the path in the computation tree going from the root to $t$'s last node.
\end{enumerate}
\end{proposition}

The \defname{reduction} of a traversal $t$ is the subsequence of $t$
obtained by keeping only occurrences of nodes that are hereditarily
enabled by the root $\theroot$. This has the effect of eliminating
the ``internal nodes'' of the computation. If $t$ is a non-empty
traversal then the root $\theroot$ occurs exactly once in $t$ and
the reduction of $t$ is equal to $t \filter r$. We write
$\travset(M)^{\filter \theroot}$ for the set or reduction of
traversals of $M$.

Application nodes are used to connect the operator and the operand
of an application in the computation tree but since they do not play
any role in the computation of the term, we can remove them from the
traversals.  We write $t-@$ for the sequence of nodes-with-pointers
obtained by removing from $t$ all @-nodes and value-leaves of
@-nodes, any link pointing to an @-node being replaced by a link
pointing to the immediate predecessor of @ in $t$. We write
$\travset(M)^{-@}$ for the set $\{ t - @ \ | \  t \in \travset(M)
\}$.
\begin{remark}
If $M$ is $\beta$-normal then $\tau$ does not contain any @-node
therefore all nodes are hereditarily justified by $r$ and we have
$\travset(M)^{-@} = \travset(M) = \travset(M)^{\filter \theroot }$.
\end{remark}

\subsection{Computation trees and arenas}
We consider the well-bracketed game model of the simply-typed lambda
calculus.  We choose to represent strategies using ``prefix-closed
set of plays''. \footnote{In the literature, a strategy is commonly
defined as a set of plays closed by taking a prefix of \emph{even}
length. However for the purpose of showing the correspondence with
traversals, the ``prefix-closed''-based definition is more
adequate.} We fix a term $\Gamma \vdash M : T$ and write
$\sem{\Gamma \vdash M : T}$ for its strategy denotation. The answer
moves of a question $q$ are written $v_q$ where $v$ ranges in
$\mathcal{D}$.

\begin{proposition}
There exists a function $\varphi_M$, constructible from $\tau(M)$,
that maps nodes from $V\setminus (V_@ \union V_\Sigma)$ to moves of
the interaction arena underlying the revealed strategy
$\syntrevsem{\Gamma \vdash M : T}$ and such that $\varphi$ maps
$\lambda$-nodes to O-questions, variable nodes to P-questions,
value-leaves of $\lambda$-nodes to P-answers and value-leaves of
variable nodes to O-answers.
\end{proposition}
If $t = t_0 t_1 \ldots$ is a justified sequence of nodes in
$V_\lambda \union V_{\sf var}$ then $\varphi(t)$ is defined to be
the sequence of moves $\varphi(t_0)\ \varphi(t_1) \ldots$ equipped
with the pointers of $t$.


\begin{example}
Take $\lambda x . (\lambda g . g x) (\lambda y . y)$ with $x,y:o$
and $g:(o,o)$. The diagram below represents the computation tree
(middle), the arenas $\sem{(o,o), o}$ (left), $\sem{o , o}$ (right),
$\sem{o\rightarrow o}$ (rightmost) and $\varphi = \psi \union
\psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}} \union \psi_{\lambda
y.y}^{\lambda y, q_{\lambda y}}$ (dashed-lines).
$$\psset{levelsep=3.5ex}
\pstree{\TR[name=root]{\lambda x}}
{
    \pstree{\TR[name=App]{@}}
    {
            \pstree{\TR[name=lg]{\lambda g}}
                { \pstree{\TR[name=lgg]{g}}{
                        \pstree{\TR[name=lgg1]{\lambda}}
                        { \TR[name=lgg1x]{x}  } } }
            \pstree{\TR[name=ly]{\lambda y}}
                    {\TR[name=lyy]{y}}
    }
}
\rput(4.5cm,-1cm){
  \pstree{\TR[name=A1lx]{q_{\lambda x}}}
        { \TR[name=A1x]{q_x} }
}
\rput(-6cm,-1.5cm){
    \pstree{\TR[name=A2lg]{q_{\lambda g}}}
    {
        \pstree{\TR[name=A2g]{q_g}}
        {  \TR[name=A2g1]{q_{g_1}}   }
    }}
\rput(2.5cm,-1.5cm){
    \pstree{\TR[name=A3ly]{q_{\lambda y}}}
        { \TR[name=A3y]{q_y}
        }
}
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{A1lx} \mput*{\psi}
\ncarc{->}{lgg1x}{A1x}
\ncline{->}{lg}{A2lg} \mput*{\psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}}}
\ncline{->}{lgg}{A2g}
\ncline{->}{lgg1}{A2g1}
\ncline{->}{ly}{A3ly} \mput*{\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}}
\ncline{->}{lyy}{A3y}
$$
\end{example}


\subsection{The Correspondence Theorem}

In game semantics, strategy composition is achieved by performing a
CSP-like ``composition + hiding''. If the internal moves are not
hidden then we obtain an alternative semantics called
\defname{revealed semantics} in \cite{willgreenlandthesis} and
\emph{interaction} semantics in \cite{DBLP:conf/sas/DimovskiGL05}.
The fully revealed semantics of a term $\Gamma \vdash M :T$, written
$\revsem{\Gamma \vdash M : T}$, is obtained by
uncovering\footnote{An algorithm that uniquely recovers hidden moves
is given in Part II of
  \cite{hylandong_pcf}.}  the internal moves from $\sem{\Gamma \vdash
  M : T}$ that are generated by the composition with the evaluation map
$ev$ at each @-node of the computation tree.  The inverse operation
consists in filtering out the internal moves.

In the simply-typed lambda calculus, the set $\travset(M)$ of
traversals of the computation tree is isomorphic to the set of
uncovered plays of the strategy denotation. Moreover the set of
traversal reductions is isomorphic to the standard strategy
denotation.

\begin{theorem}[The Correspondence Theorem]
\label{thm:correspondence} $\varphi_M$ gives us the following two
isomorphisms:
\begin{eqnarray*}
(i)~\varphi_M  &: \travset(M)^{-@} \stackrel{\cong}{\longrightarrow} \syntrevsem{\Gamma \vdash M :T} \\
(ii)~\varphi_M  &: \travset(M )^{\filter \theroot} \stackrel{\cong}{\longrightarrow} \sem{\Gamma \vdash M : T} \ .
\end{eqnarray*}
\end{theorem}

\begin{example}
Take $M = \lambda f z . (\lambda g x . f x) (\lambda y. y) (f z) :
((o,o),o, o)$.  The figure below represents the computation tree
(left tree), the arena $\sem{((o,o),o, o)}$ (right tree) and
$\psi_M$ (dashed line). (Only question moves are shown for clarity.)
The justified sequence of nodes $t$ defined hereunder is an example
of traversal:

\begin{tabular*}{\textwidth}{lcp{6.3cm}}
$\pssetcomptree\pstree[levelsep=2.5ex,treesep=0.3cm]{ \TR[name=root]{\lambda f z} }
     {  \tree[levelsep=4ex]{@}
        {   \tree{\lambda g x}{
                  \pstree{\TR[name=f]{f^{[1]}}}{
                            \pstree{\TR[name=lmd]{\lambda^{[2]}}}
                                {\TR{x}}
                  }
                }
            \tree{\lambda y }{\TR{y}}
            \tree{\lambda ^{[3]}}{
                \pstree{\TR[name=f2]{f^{[4]}}} {
                \pstree{\TR[name=lmd2]{\lambda^{[5]}}}{\TR[name=z]{z}}
                }
            }
        }
     }
\hspace{1cm}
  \pstree[levelsep=8ex, treesep=0.3cm]{ \TR[name=q0]{q^0} }
    {   \pstree[levelsep=4ex]{\TR[name=q1]{q^1}} {\TR[name=q2]{q^2}}
        \TR[name=q3]{q^3}
    }
\psset{nodesep=1pt,arrows=->,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q0} \mput*{\psi_M}
\ncarc[arcangle=-25]{->}{z}{q3}
\ncarc[arcangle=10]{->}{f}{q1}
\ncarc[arcangle=10]{->}{lmd}{q2}
\ncline{->}{f2}{q1}
\ncline{->}{lmd2}{q2}$
&  &
\begin{asparablank}
  \item  \Pstr[0.8cm]{
t = (n){\lambda f z} \
(n2){@} \
(n3-n2,60){\lambda g x} \
(n4-n,45){f^{[1]}} \
(n5-n4,45){\lambda^{[2]}} \
(n6-n3,45){x} \
(n7-n2,35){\lambda^{[3]}} \
(n8-n,35){f^{[4]}} \
(n9-n8,45){\lambda^{[5]}} \
(n10-n,35){z}
}

\item \Pstr[0.9cm]{
t\filter r = (n){\lambda f z} \ (n4-n,50){f}^{[1]} \
(n5-n4,60){\lambda}^{[2]} \ (n8-n,45){f}^{[4]} \
(n9-n8,60){\lambda}^{[5]} \ (n10-n,40){z}}
\item
\Pstr[0.8cm]{ {\varphi_M(t\filter r) =\ } (n){q^0}\ (n4-n,60){q^1}\
(n5-n4,60){q^2}\ (n8-n,45){q^1}\ (n9-n8,60){q^2}\ (n10-n,38){q^3}
\in \sem{M}\ .}
\end{asparablank}
\end{tabular*}
\end{example}


    \bibliographystyle{plain}
    \bibliography{../bib/dphil-all}

\end{document}
