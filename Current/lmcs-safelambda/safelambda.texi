\section*{Introduction}

\subsection*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and
Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars. The
idea, however, goes back some twenty years to Damm \cite{Dam82} who
introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe} grammars
  form an infinite hierarchy as $n$ varies over the natural numbers.
  The hierarchy gives an attractive classification of the
  semi-decidable languages: Levels 0, 1 and 2 of the hierarchy are
  respectively the regular, context-free, and indexed languages (in
  the sense of Aho \cite{Aho68}), although little is known about
  higher orders.

  Remarkably, for generating word languages, order-$n$ \emph{safe}
  grammars are equivalent to order-$n$ pushdown automata \cite{DG86},
  which are in turn equivalent to order-$n$ indexed grammars
  \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have decidable
    MSO theories. More precisely, the MSO theory of trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to Damm
  and Goerdt \cite{DG86} to an equivalence result with respect to
  generating trees: A ranked tree is generated by an order-$n$ \emph{safe}
  grammar if and only if it is generated by an order-$n$ pushdown
  automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a recent preprint, however,
  Hague \emph{et al.} have
  shown that the MSO theories of graphs generated by order-$n$
  \emph{unsafe} grammars are undecidable, but deciding their modal
  mu-calculus theories is $n$-EXPTIME complete \cite{hmos-lics08}.
\end{itemize}

\subsection*{Overview}

In this paper, we aim to understand the safety condition in the
setting of the lambda calculus. Our first task is to transpose it to
the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and cleaner
version where terms are no longer required to be homogeneously typed
(see Section~\ref{sec:safe} for a definition). The formation rules of
the calculus are designed to maintain a simple invariant: Variables
that occur free in a safe $\lambda$-term have orders no smaller than
that of the term itself.  We can now explain the sense in which the
safe lambda calculus is safe by establishing its salient property: No
variable capture can ever occur when substituting a safe term into
another. In other words, in the safe lambda calculus, it is
\emph{safe} to use capture-\emph{permitting} substitution when
performing $\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable names
in the input term. Safe lambda calculus is thus cheaper to compute in
this na\"ive sense. Intuitively one would expect the safety constraint
to lower the expressivity of the simply-typed lambda calculus. Our
next contribution is to give a precise measure of the expressivity
deficit of the safe lambda calculus. An old result of Schwichtenberg
\cite{citeulike:622637} says that the numeric functions representable
in the simply-typed lambda calculus are exactly the multivariate
polynomials \emph{extended with the conditional function}.  In the
same vein, we show that the numeric functions representable in the
safe lambda calculus are exactly the multivariate polynomials.

Our last contribution is to give a game-semantic account of the safe
lambda calculus.
% Not much is known about the safe $\lambda$-calculus, and many problems
% remain to be studied concerning its computational power, the
% complexity classes that it characterizes, its interpretation under the
% Curry-Howard isomorphism and its game-semantic characterization. This
% paper is a contribution to the last problem.
%
% The difficulty in giving a game-semantic account of safety lies in the
% fact that it is a syntactic restriction whereas game semantics is
% syntax-independent. The solution consists in finding a particular
% syntactic representation of terms on which the plays of the game
% denotation can be represented.  To achieve this, we use ideas recently
% introduced by the second author \cite{OngLics2006}: A term is
% canonically represented by a certain abstract syntax tree of its
% $\eta$-long normal form referred as the \emph{computation tree}. This
% abstract syntax tree is specially designed to establish a
% correspondence with the game arena of the term. A computation is
% described by a justified sequence of nodes of the computation tree
% respecting some formation rules and called a
% \emph{traversal}. Traversals permit us to model $\beta$-reductions
% without altering the structure of the computation tree via
% substitution. A notable property is that \emph{P-views} (in the
% game-semantic sense) of traversals corresponds to paths in the
% computation tree.  We show that traversals are just representations of
% the uncovering of plays of the game-semantic denotation. We then
% define a \emph{reduction} operation which eliminates traversal nodes
% that are ``internal'' to the computation, this implements the
% counterpart of the hiding operation of game semantics. Thus, we obtain
% an isomorphism between the strategy denotation of a term and the set
% of reductions of traversals of its computation tree.
Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are denoted
by \emph{P-incrementally justified strategies}. In such a strategy,
pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically, a P-question always
points to the last pending O-question (in the P-view) of a greater
order. Consequently pointers in the game semantics of safe
$\lambda$-terms are only necessary from order 4 onwards. Finally we
prove that a $\beta$-normal $\lambda$-term is \emph{safe}
if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.



% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, the second author obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtained by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: Hague et al. \cite{hmos-lics08}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

% \medskip

% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent Asperti et.~al \cite{DBLP:conf/lics/AspertiDLR94} introduced a notion of graph
% based on Lamping's graphs \cite{lamping} to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda calculus.


\section{The safe lambda calculus}
\label{sec:safe}
\subsection*{Higher-order safe grammars}
We first present the safety restriction as it was originally defined
\cite{KNU02}. We consider simple types generated by the grammar $A \,
::= \, o \; | \; A \typear A$. By convention, $\rightarrow$ associates
to the right. Thus every type can be written as $A_1 \typear \cdots
\typear A_n \typear o$, which we shall abbreviate to $(A_1, \cdots,
A_n, o)$ (in case $n = 0$, we identify $(o)$ with $o$).
We will also use the notation $A^n \typear B$ for every types $A, B$ and positive natural number $n>0$ defined by induction as: $A^1 \typear B = A \typear B$  and $A^{n+1} \typear B = A\typear (A^n \typear B)$. The \emph{order} of a type is given by $\ord{o} = 0$ and $\ord(A \typear
B) = \max(\ord{A}+1, \ord{B})$. We assume an infinite set of typed
variables. The order of a typed term or symbol is defined to be the
order of its type. The set of \emph{applicative terms} over a set of typed symbols is defined as its closure under the application operation (\ie, if $M : A\rightarrow B$ and $N :A$ are in the closure then so does $M N :B$).

A (higher-order) \defname{grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ is assumed to have type $o^r\typear o$ where $r$ is the \emph{arity} of $f$) of \emph{terminals}; $\mathcal{N}$ is a finite set of typed
\emph{non-terminals}; $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol; $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form $ F z_1 \ldots z_m
\rightarrow e$ where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the typed symbols in $\Sigma \union \mathcal{N} \union \{z_1,
\ldots, z_m \}$. We say that the grammar is \emph{order-$n$} just in
case the order of the highest-order non-terminal is $n$.

We call \defname{higher-order recursion scheme} a higher-order
grammar that is deterministic (\ie, for each non-terminal $F \in
\mathcal{N}$ there is exactly one production rule with $F$ on the
left hand side). Higher-order recursion schemes are used as
generators of infinite trees. The \defname{tree generated by a
recursion scheme} $G$ is a possibly infinite applicative term, but
viewed as a $\Sigma$-labelled tree; it is \emph{constructed from the
terminals in $\Sigma$}, and is obtained by unfolding the rewrite
rules of $G$ \emph{ad infinitum}, replacing formal by actual
parameters each time, starting from the start symbol $S$. See
e.g.~\cite{KNU02} for a formal definition.

\pssetcomptree
\parpic[r]{
\raisebox{-15pt}
{$\tree[levelsep=3ex,nodesep=1pt,treesep=1cm,linewidth=0.5pt]{g}
{  \TR{a}
    \tree{g}{\TR{a} \tree{h}{\tree{h}{\vdots}}}
}$}
}
\begin{example}\rm\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}

A type $(A_1, \cdots, A_n, o)$ is said to be \defname{homogeneous} if
$\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$, and each $A_1$,
\ldots, $A_n$ is homogeneous \cite{KNU02}.  We reproduce the following
Knapik et al.'s definition \cite{KNU02}.

\begin{definition}[Safe grammar]\rm
\label{def:safegrammar}
  (All types are assumed to be homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
%   A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be
%   \defname{unsafe} if the righthand term $e$ has a subterm $t$ such
%   that
% \begin{enumerate}[(i)]
% \item $t$ occurs in an {\em operand} (\ie,~second) position of some
%   occurrence of the implicit application operator {\ie,~$e$ has the
%   form $\cdots (s \, t) \cdots $ for some $s$
% \item $t$ contains an occurrence of a parameter $z_i$ (say) whose
%   order is less than that of $t$.
% \end{enumerate}
% A homogeneous grammar is said to be \defname{safe} if none of its
% rewrite rules is unsafe.
\end{definition}

\begin{example}\begin{inparaenum}[(i)] \item Take $H : ((o, o), o)$ and $f : (o, o, o)$; the
    following rewrite rules are unsafe (In each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x
\end{array}\]
\item The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{inparaenum}
% The
% reader is referred to the literature
% \cite{KNU02,demirandathesis,safety-mirlong2004}
% for details about the safety restriction for higher-order grammars.
\end{example}

\subsection*{Safety adapted to the lambda calculus}
We assume a set $\Xi$ of higher-order constants. We use sequents of
the form $\Gamma \vdash_\$^\Xi M : A$ to represent term-in-context
where $\Gamma$ is the context and $A$ is the type of $M$. For
convenience, we shall omit the superscript from $\sentail^\Xi$
whenever the set of constants $\Xi$ is clear from the context. The
subscript in $\vdash_\$^\Xi$ specifies which type system is used to form the judgment: We use the subscript `st' to refer to
the traditional system of rules of the Church-style simply-typed
lambda calculus augmented with constants from $\Xi$. We will introduce a new subscripts for each type system that we define. For simplicity we write $(A_1, \cdots, A_n, B)$ to mean
$A_1 \typear \cdots \typear A_n \typear B$, where $B$ is not
necessarily ground.

\begin{definition}\rm
\label{def:safelambda}
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus. It is defined as the set of judgments of the form $\Gamma \sentail M : A$ that are derivable from the following Church-style system of rules:
$$ \rulename{var} \ \rulef{}{x : A\sentail x : A} \qquad
\rulename{const} \ \rulef{}{\sentail f : A}~f \in \Xi \qquad
\rulename{wk} \ \rulef{\Gamma \sentail M : A}{\Delta \sentail M : A} \quad
\Gamma \subset \Delta$$

$$ \rulename{app_{as}} \ \rulef{\Gamma \asappentail M : A\typear B
\quad \Gamma \sentail N : A} {\Gamma \asappentail M\, N : B}
\qquad
\rulename{\delta} \ \rulef{\Gamma \sentail M : A}{\Gamma \asappentail M : A}
$$

$$ \rulename{app} \ \rulef{\Gamma \asappentail M : A\typear B
\quad \Gamma \sentail N : A} {\Gamma \sentail M\, N : B} \quad \ord{B} \leq
\ord{\Gamma}$$

$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail M : B} {\Gamma \sentail \lambda x_1^{A_1} \ldots x_n^{A_n} . M :
  (A_1, \ldots ,A_n,B)} \quad \ord(A_1, \ldots ,A_n,B) \leq
\ord{\Gamma}$$
\smallskip

\noindent where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in
\Gamma \}$ and ``$c \leq S$'' means that $c$ is a lower-bound of the
set $S$. The subscripts in $\sentail$ and $\asappentail$ stand
for ``safe'' and ``almost safe application''.

%\noindent
\item The sub-system that is defined by the same rules in
(i), such that all types that occur in them are homogeneous, is called
the \defname{homogeneous safe lambda calculus}.

\item We say that a \emph{term} $M$ is \defname{safe} if the judgement $\Gamma \sentail M : T$ is derivable in the safe lambda calculus for some context $\Gamma$ and type $T$.
\end{inparaenum}
\end{definition}


The safe lambda calculus deviates from the standard definition of
the simply-typed lambda calculus in a number of ways. %First the
%rules $\rulename{app}$ and $\rulename{abs}$ respectively can perform
%multiple applications and abstract several variables at once.
First the rule $\rulename{abs}$ can abstract several variables at once. (Of course this feature alone does not alter expressivity.) Crucially,
the side conditions in the application rule and abstraction rule
require the variables in the typing context to have orders no
smaller than that of the term being formed.  We do not impose any
constraint on types. In particular, type-homogeneity, which was an
assumption of the original definition of safe grammars \cite{KNU02},
is not required here. Another difference is that we allow
$\Xi$-constants to have
arbitrary higher-order types.
\bigskip


\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f^{((o,o),o)} . f (\lambda x^o . f (\lambda y^o . y
))$ and $M_2 = \lambda f^{((o,o),o)} . f (\lambda x^o . f (\lambda y^o .x ))$. The term $M_2$ is not safe because in the subterm $f (\lambda y^o . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord(\lambda y^o . x) = 1$.  On the other hand, $M_1$
is safe.
%On the other hand, $M_1$ is safe as the following proof tree shows:
%$$
% \rulef{
%     \rulef{
%        \rulef{}{f \sentail f} {\sf(var)}
%        \
%        \rulef{
%             \rulef{
%                \rulef{
%                    \rulef{}{f \sentail f} {\sf(var)}
%                }
%                {f , x \sentail f } {\sf(wk)}
%                \
%                \rulef{
%                    \rulef{
%                        \rulef{}{y \sentail y} {\sf(var)}
%                    }
%                    {y \sentail \lambda y . y } \rulenamet{abs}
%                }
%                {f , x \sentail \lambda y .y } {\sf(wk)}
%             }
%             {f , x \sentail f (\lambda y .y )} {\sf(app)}
%        }
%        { f  \sentail \lambda x . f (\lambda y .y )} \rulenamet{abs}
%     }
%     {
%        f  \sentail f (\lambda x . f (\lambda y .y ))} {\sf(app)}
%     }
% { \sentail M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } \rulenamet{abs}
%$$
\end{example}

It is easy to see that valid typing judgements of the safe lambda
calculus satisfy the following simple invariant:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \sentail M : A$ then every variable in $\Gamma$ occurring
free in $M$ has order at least $\ord M$.
\end{lemma}


\begin{definition}
A term is an \defname{almost safe applications}
if it is safe or if it is of the form $N_1 \ldots N_m$ for some $m\geq 1$ where $N_1$ is not an application and for every $1 \leq i\leq m$, $N_i$ is safe.

A term is \defname{almost safe} if either it is an almost safe application, or if it is of the form
$\lambda x_1^{A_1} \ldots x_n^{A_n}. M$ for $n\geq 1$ and some almost safe application $M$.
\end{definition}
An \emph{almost safe application} is not necessarily safe but it can be used to form a safe term by applying sufficiently many safe terms to it. An \emph{almost safe term} can be turned into a safe term by either applying sufficiently many safe terms (if it is an application), or
by abstracting sufficiently many variables (if it is an abstraction).

We have the following immediate lemma:
\begin{lemma}
\label{lem:almostsafeapp_is_appplicative_safe}
A term $M$ is
\begin{enumerate}[(i)]
\item an \emph{almost safe application} iff there is a derivation of $\Gamma \asappentail M : T$ for some $\Gamma, T$;

\item \emph{almost safe} iff $\Gamma \asappentail M : T$ or if $M\equiv \lambda x_1^{A_1} \ldots x_n^{A_n}. N$ and $\Gamma \asappentail N : T$ for some $\Gamma, T$.
\end{enumerate}
\end{lemma}
In particular, terms constructed with the rule \rulenamet{app_{as}} are almost safe applications.
\bigskip

When restricted to the homogeneously-typed sub-system, the safe
lambda calculus captures the original notion of safety due to Knapik
\emph{et al.}~in the context of higher-order grammars:

\begin{proposition}
\label{prop:safegram_safelmd}
 Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe (in the original sense of Knapik \emph{et al.}) if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \sentail^{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} safe lambda calculus.
\end{proposition}
\begin{proof}
We show by induction that \begin{asparaenum}[(i)]
\item  $z_1,\ldots, z_m \asappentail t:A$ is a valid judgment of the homogeneous safe lambda calculus containing no abstraction if and only if in the Knapik sense, all the occurrences of unsafe subterms of $t$ are safe occurrences.
\item $z_1,\ldots, z_m \sentail t:A$ is a valid judgment of the homogeneous safe lambda calculus containing no abstraction if and only if in the Knapik sense, all the occurrences of unsafe subterms of $t$ are safe occurrences, and all parameters occurring in $t$ have order greater than $\ord{t}$. \end{asparaenum}
The constant and variable rule are trivial. Application case: By definition, a term $t_0 \ldots t_n$ is Knapik-safe iff for all $0\leq i \leq n$, all the occurrences of unsafe subterms of $t_i$ are safe occurrences (in the Knapik sense), and for all $1\leq j \leq n$, the operands occurring in $t_j$ have order greater than $\ord{t_j}$. The \rulenamet{app_{as}} rule and the induction hypothesis permit us to conclude.

Now since $e$ is an applicative term of \emph{ground type}, the previous result gives:
$z_1,\ldots, z_m \sentail e:o$ is a valid judgment of the homogeneous safe lambda calculus iff all the occurrences of unsafe subterms of $e$ are safe occurrences, which by definition of Knapik-safety is in turn equivalent to saying that the rule $F z_1 \ldots z_m \rightarrow e$ is safe.
\end{proof}

\emph{In what sense is the safe lambda calculus safe?} It is an
elementary fact that when performing $\beta$-reduction in the lambda
calculus, one must use capture-\emph{avoiding} substitution, which
is standardly implemented by renaming bound variables afresh upon
each substitution. In the safe lambda calculus, however, variable
capture can never happen (as the following lemma shows).
Substitution can therefore be implemented simply by
capture-\emph{permitting} replacement, without any need for variable
renaming. In the following, we write $M\captsubst{N}{x}$ to denote
the capture-\emph{permitting} substitution\footnote{This
substitution is done by textually replacing all free occurrences of
$x$ in $M$ by $N$ without performing variable renaming.  In
particular for the abstraction
  case we have
$(\lambda y_1\ldots y_n . M)\captsubst{N}{x} = \lambda y_1\ldots y_n . M\captsubst{N}{x}$ when $x\not\in
  \{ y_1\ldots y_n \}$.}
%\footnote{This substitution is implemented by textually
%  replacing all free occurrences of $x$ in $M$ by $N$ without
%  performing variable renaming.  In particular for the abstraction
%  case $(\lambda \overline{y} . P)\captsubst{N}{x}$ is defined as
%  $\lambda \overline{y} . P\captsubst{N}{x}$ if $x\not\in
%  \overline{y}$ and $\lambda \overline{y} . P$ elsewhere.}
of $N$ for $x$ in $M$.

\begin{lemma}[No variable capture]\label{lem:nvc}
\label{lem:nocapture} There is no variable capture when performing
capture-permitting substitution of $N$ for $x$ in $M$ provided that
$\Gamma, x:B \sentail M : A$ and $\Gamma \sentail  N : B$ are valid
judgments of the safe lambda calculus.
\end{lemma}

\begin{proof}
  We proceed by structural induction on $M$. The variable, constant and
  application cases are trivial. For the abstraction case, suppose $M \equiv \lambda \overline{y}. R$ where $\overline{y} = y_1 \ldots y_p$. If $x \in \overline{y}$ then $M \captsubst{N}{x} = M$ and there is no variable capture.

 Otherwise, $x \not\in \overline{y}$. By Lemma \ref{lem:almostsafeapp_is_appplicative_safe} $R$ is of the
  form $M_1 \ldots M_m$ for some $m\geq 1$ where $M_1$ is not an application and for every $1 \leq i\leq m$, $M_i$ is safe.
 Thus we have $M \captsubst{N}{x} \equiv \lambda \overline{y} . M_1 \captsubst{N}{x} \ldots M_m \captsubst{N}{x}$.  Let $i\in\{1..m\}$. By the induction hypothesis there is no variable capture in $M_i \captsubst{N}{x}$.  Thus variable capture can only happen if the following two conditions are met: (i) $x$ occurs freely in $M_i$, (ii) some variable $y_i$ for $1 \leq i \leq p$ occurs freely in $N$. By Lemma \ref{lem:ordfreevar}, (ii) implies $\ord{y_i} \geq \ord{N} = \ord{x}$ and since $x \not \in \overline{y}$, condition (i) implies that $x$ occurs freely in the safe term $\lambda \overline{y}. R$
  thus by Lemma \ref{lem:ordfreevar} we have $ \ord{x} \geq
  \ord{\lambda \overline{y} . R} \geq 1+ \ord{y_i} > \ord{y_i}$ which  gives a contradiction.
\end{proof}

\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \stentail (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    x}) : (o,o)\] one should rename the bound variable $x$ to a fresh name to
  prevent the capture of the free occurrence of $x$ in the underlined term during substitution. Consequently, by the previous lemma,
  the term is not safe (because $\ord{x} = 0 < 1
  = \ord{f x}$).
\end{example}

Note that $\lambda$-terms that `satisfy' the No-variable-capture
Lemma are not necessarily safe. For instance the $\beta$-redex in
$\lambda y^o z^o. (\lambda x^o .y) z$ can be contracted using
capture-permitting substitution, even though the term is not safe.
\bigskip

\emph{Related work:} In her thesis \cite{demirandathesis}, de Miranda proposed a different notion of safe lambda calculus. This notion corresponds to (a less general version of) our notion of \emph{homogeneous} safe lambda calculus. It can be showed that for pure applicative terms (\ie, with no lambda-abstraction) the two systems coincide. In particular a version of Proposition \ref{prop:safegram_safelmd} also holds in de Miranda's setting \cite{demirandathesis}. In the presence of lambda abstraction, however, our system is less restrictive. For instance the term $\lambda f^{(o,o,o)} x^o.  f x : (o,o)$ is typable in the homogeneous safe lambda calculus but not in the safe lambda calculus \emph{\`a la} de Miranda. One can show that de Miranda's system is in fact equivalent to the \emph{homogeneous long-safe lambda calculus} (\ie, the restriction of the system of Def.\ \ref{dfn:longsafe} to homogeneous types).

\subsection*{Safe beta reduction}

From now on we will use the standard notation $M\subst{N}{x}$ to
denote the substitution of $N$ for $x$ in $M$.  It is understood that,
provided that $M$ and $N$ are safe, this substitution is
capture-permitting.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserves_safety}
Let $\Gamma \sentail N : B$. Then
\begin{enumerate}[(i)]
  \item $\Gamma, x :B \sentail M : A$ implies $\Gamma \sentail M[N/x] : A$;
  \item $\Gamma, x :B \asappentail M : A$ implies $\Gamma \asappentail M[N/x] : A$.
\end{enumerate}
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.
\smallskip

It is desirable to have an appropriate notion of reduction for our
calculus. However the standard $\beta$-reduction rule is not
adequate. Indeed, safety is not preserved by $\beta$-reduction as
the following example shows. Suppose that $w,z : o$ and $f :
(o,o,o) \in \Sigma$ then the safe term $(\lambda x^o y^o . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y^o . f z y}) w$, which is
unsafe since the underlined first-order subterm contains a free
occurrence of the ground-type variable $z$. However if we perform one more
reduction we obtain the safe term $f z w$. This suggests
simultaneous contraction of ``consecutive'' $\beta$-redexes. In
order to define this notion of reduction we first introduce the
corresponding notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:

\begin{definition}\rm
A \defname{safe redex} is an almost safe application of the form
$$(\lambda x_1^{A_1} \ldots x_n^{A_n}. M) N_1 \ldots N_l$$ for $l,n\geq 1$ such that $M$ is an almost safe application.
(Consequently each $N_i$ is safe as well as $\lambda x_1^{A_1} \ldots x_n^{A_n} . M$, and $M$ is either safe or is an application of safe terms.)
\end{definition}
For instance, in the case $n<l$, a safe redex has a derivation tree of the following form:
\def\defaultHypSeparation{}
\begin{prooftree}
    \AxiomC{\ldots}
  \UnaryInfC{$\Gamma', \overline{x}:\overline{A} \sentail M : (A_{n+1}, \ldots, A_l, B)$}
  \RightLabel{\rulenamet{abs}}
  \UnaryInfC{$\Gamma' \sentail \lambda x_1^{A_1} \ldots x_n^{A_n} . M : (A_1, \ldots, A_l, B)$}
  \RightLabel{\rulenamet{wk}}
  \UnaryInfC{$\Gamma \sentail \lambda x_1^{A_1} \ldots x_n^{A_n} . M : (A_1, \ldots, A_l, B)$}
  \RightLabel{\rulenamet{\delta}}
  \UnaryInfC{$\Gamma \asappentail \lambda x_1^{A_1} \ldots x_n^{A_n} . M : (A_1, \ldots, A_l, B)$}
  \AxiomC{\ldots}
  \UnaryInfC{$\Gamma \sentail N_1 :A_1$}
  \RightLabel{\rulenamet{app_{as}}}
   \BinaryInfC{$\Gamma \asappentail (\lambda x_1^{A_1} \ldots x_n^{A_n} . M) N_1 : (A_2, \ldots A_l, B)$}
%  \AxiomC{\ldots}
%  \RightLabel{\rulenamet{app_{as}}}
%  \BinaryInfC{\vdots\raisebox{0.5cm}{}}
  \noLine\UnaryInfC{\vdots\raisebox{0.5cm}{}}
  \RightLabel{\rulenamet{app_{as}}}
  \UnaryInfC{$\Gamma \asappentail (\lambda x_1^{A_1} \ldots x_n^{A_n} . M) N_1 \ldots N_{l-1} : (A_l, B)$}
  \AxiomC{\ldots}
  \UnaryInfC{$\Gamma \sentail N_l :A_l$}
  \RightLabel{\rulenamet{app}}
  \BinaryInfC{$\Gamma \sentail (\lambda x_1^{A_1} \ldots x_n^{A_n} . M) N_1 \ldots N_l : B$}
\end{prooftree}
\smallskip

A \emph{safe redex} is by definition an almost term,
but it is not necessarily a \emph{safe term}. For instance the term $(\lambda x^o y^o. x) z$ is a safe redex but it is only an \emph{almost} safe term.
The reason why we call such redexes ``safe'' is because when they occur within a safe term, it is possible to contract them without braking the safety of the whole term. Before showing this result, we first need to define how to contract safe redexes:
\begin{definition}[Redex contraction]\rm
\label{dfn:saferedex_contraction} We use the abbreviations $\overline{x} =
x_1 \ldots x_n$, $\overline{N} = N_1 \ldots N_l$. The relation
$\beta_s$ (when viewed as a function) is defined on the set of \emph{safe redexes} as follows:
\begin{eqnarray*}
  \beta_s &=&
  \{  \ (\lambda x_1^{A_1} \ldots x_n^{A_n} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1}^{A_{l+1}} \ldots x_n^{A_{n}}. M\subst{\overline{N}}{x_1 \ldots x_l} \ | \ n> l  \} \\
  &\cup&
  \{ \ (\lambda x_1^{A_1} \ldots x_n^{A_n} . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \ | \ n\leq l \} \ .
\end{eqnarray*}
where $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution in $M$ of $R_1$,\ldots,$R_k$ for $z_1, \ldots, z_k$.
\end{definition}

\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:betas_preserves_safety}
Suppose that $M_1\, \beta_s\, M_2$. Then
\begin{enumerate}[(i)]
  \item $M_2$ is almost safe;
  \item If $M_1$ is safe then so is $M_2$.
\end{enumerate}
\end{lemma}
\begin{proof}
Let $M_1\, \beta_s\, M_2$ for some safe redex $M_1$ and term $M_2$ of type $A$. By definition, $M_1$ is of the form $(\lambda x_1^{B_1} \ldots x_n^{B_n} . M) N_1 \ldots N_l $ for some safe terms $N_1$, \ldots, $N_l$ and almost safe term $M$ of type $C$ such that $(\lambda x_1^{B_1} \ldots x_n^{B_n} . M)$ is safe.
\begin{compactitem}[-]
\item
Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$.
(i) By the Substitution Lemma
\ref{lem:subst_preserves_safety}, the term $M\subst{\overline{N}}{x_1
\ldots x_l}$ is an almost safe application: we have $\Gamma, x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\asappentail M\subst{\overline{N}}{x_1
\ldots x_l} : C$. (Indeed, if $M$ is safe then we apply the Substitution Lemma once; otherwise it is of the form $R_1 \ldots R_q$ where $R_i$ is a safe term and we apply the lemma on each $R_i$.)
Thus by definition, $\lambda x_{l+1}^{B_{l+1}} \ldots x_n^{B_n} . M\subst{\overline{N}}{x_1
\ldots x_l} \equiv M_2$ is almost safe.

(ii) Suppose that $M_1$ is safe. W.l.o.g.~we can assume that the last rule used to form  $M_1$ is \rulenamet{app} (and not the weakening rule
\rulenamet{wk}), thus the variables of the typing context $\Gamma$ are precisely the free variables of $M_1$, and Lemma \ref{lem:ordfreevar} gives us $\ord{A} \leq \ord{\Gamma}$. This allows us to use the rule \rulenamet{abs} to form the safe term-in-context $\Gamma
\sentail \lambda x_{l+1}^{B_{l+1}} \ldots x_n^{B_n} . M\subst{\overline{N}}{x_1
\ldots x_l} \equiv M_2 : A$.

\item Suppose $n \leq l$. (i) Again by the Substitution Lemma
we have that $M\subst{N_1 \ldots N_n}{\overline{x}}$ is an almost safe application: $\Gamma \asappentail M\subst{N_1 \ldots N_n}{\overline{x}} : C$. If $n=l$ then the proof is finished; otherwise ($n<l$) we further apply the rule \rulenamet{app_{as}} $l-n$ times which gives us the almost safe application $\Gamma \asappentail M_2 :A$.

(ii) Suppose that $M_1$ is safe.  If $n=l$ then $M_2\equiv M\subst{N_1 \ldots N_n}{\overline{x}}$ is safe by the Substitution Lemma;
If $n<l$ then we obtain the judgement $\Gamma \sentail M_2 :A$ by
applying the rule \rulenamet{app_{as}} $l-n-1$ times on $\Gamma \sentail M\subst{N_1 \ldots N_n}{\overline{x}} : C$ followed by one application of \rulenamet{app}.
\qedhere
\end{compactitem}
\end{proof}

We can now define a notion of reduction for safe terms.
\begin{definition}\rm
The \defname{safe $\beta$-reduction}, written $\betasred$, is the
compatible closure of the relation $\beta_s$ with respect to the
formation rules of the safe lambda calculus (\ie, it is the smallest relation such that
if $M_1\, \beta_s\, M_2$ and $C[M]$ is a safe term for some context $C[-]$ formed with the rules of the simply typed lambda calculus then $C[M_1]\betasred C[M_2]$).
\end{definition}

\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:safered_preserves_safety}
If $\Gamma \sentail M_1 :A$ and $M_1\betasred M_2$ then $\Gamma \sentail M_2 :A$.
\end{lemma}
\begin{proof}
Follows from Lemma \ref{lem:betas_preserves_safety} by an easy induction.
\end{proof}


\begin{lemma} The safe reduction relation $\betasred$:
\begin{enumerate}[(i)]
\item is a subset of the transitive closure of $\betared$ ($\betasred \subset \betaredtr$);
\item is strongly normalizing;
\item has the unique normal form property;
\item has the Church-Rosser property.
\end{enumerate}
\end{lemma}
\begin{proof}
(i) Immediate from the definition: Safe $\beta$-reduction is just a multi-step $\beta$-reduction.
(ii) This is because $\betasred \subset \betaredtr$ and, $\betared$ is
strongly normalizing in the simply typed $\lambda$-calculus. (iii) It is easy to see that if a safe term has a beta-redex if and only if it has a safe beta-redex (because a beta-redex can always be ``widen'' into consecutive beta-redex of the shape of those in Def.~\ref{dfn:saferedex_contraction}). Therefore the set
of $\beta_s$-normal forms is equal to the set of $\beta_s$-normal
forms. The uniqueness of $\beta$-normal form then implies the uniqueness
of $\beta_s$-normal form. (iv) is a consequence of (i) and (ii).
\end{proof}

\subsection*{Eta-long expansion}

The $\eta$-long normal form (or simply $\eta$-long form) of a term
% (also called \emph{long reduced form}, \emph{$\eta$-normal form} and
% \emph{extensional form} in the literature
% \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding the body of every
lambda abstraction as well as every subterm occurring in an
\emph{operand position} (\ie, occurring as the second argument of
some occurrence of the binary application operator). Formally the
\defname{$\eta$-long form}, written $\elnf{M}$, of a (type-annotated) term $M$ of type
$(A_1,\ldots,A_n,o)$ with $n \geq 0$ is defined by cases according to
the syntactic shape of $M$:
\begin{eqnarray*}
  \elnf{\lambda x^\tau . N } &\equiv& \lambda x^\tau . \elnf{N} \\
  \elnf{x N_1 \ldots N_m } &\equiv& \lambda \overline{\varphi}^{\overline{A}} . x \elnf{N_1}\ldots \elnf{N_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x^\tau . N) N_1 \ldots N_p } &\equiv& \lambda \overline{\varphi}^{\overline{A}} . (\lambda x^\tau . \elnf{N}) \elnf{N_1} \ldots \elnf{N_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is either a variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.
The binder notation `$\lambda \overline{\varphi}^{\overline A}$' stands for
`$\lambda \varphi_1^{A_1} \ldots \varphi_n^{A_n}$' if $n\geq 1$, and for `$\lambda$' (called the \emph{dummy lambda}) in the case $n=0$. The base case of this inductive definition lies in the second clause for $m=n=0$: $\elnf{x} \equiv \lambda. x$.

\begin{remark}
  This transformation does not introduce
  new redexes therefore the $\eta$-long normal form of a $\beta$-normal
  term is also $\beta$-normal.
\end{remark}

Let us introduce a new typing system:
\begin{definition}
\label{dfn:longsafe}
We define the set of \defname{long-safe terms}
by induction over the following system of rules:
  $$ \rulename{var_l} \ \rulef{}{x : A\lsentail x : A} \qquad
\rulename{const_l} \ \rulef{}{\lsentail f : A}\quad f \in \Xi \qquad
\rulename{wk_l} \ \rulef{\Gamma \lsentail M : A}{\Delta \lsentail M : A}\quad
\Gamma \subset \Delta$$

$$ \rulename{app_l} \ \rulef{\Gamma \lsentail M : (A_1,\ldots,A_n,B)
\quad
  \Gamma \lsentail N_1 : A_1 \quad \ldots \quad \Gamma \lsentail N_n : A_n
} {\Gamma \lsentail M N_1 \ldots N_n : B} \quad \ord B \leq
\ord \Gamma$$

$$ \rulename{abs_l} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \lsentail M : B} {\Gamma \lsentail \lambda x_1^{A_1} \ldots x_n^{A_n} . M :
  (A_1, \ldots ,A_n,B)} \quad \ord(A_1, \ldots ,A_n,B) \leq
\ord \Gamma$$
\end{definition}
The subscript in $\lsentail$ stands for ``long-safe''. This terminology is deliberately suggestive of a forthcoming lemma. Note that long-safe terms are not necessarily in $\eta$-long normal form.

Observe that the system of rules from Def.~\ref{dfn:longsafe} is a sub-system of the typing system of Def.~\ref{def:safelambda} where the application rule is  restricted the same way as the abstraction rule (\ie, it can perform multiple applications at once provided that all the variables in the context of the resulting term have order greater than the order of the term itself). Thus we clearly have:
\begin{lemma}
\label{lem:longsafe_imp_safe}
If a term is long-safe then it is safe.
\end{lemma}
\smallskip

In general, long-safety is not preserved by $\eta$-expansion. For
instance we have
% $f:o,o \lsentail f$ but $f:o,o \not \lsentail \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\lsentail \lambda y^o z^o . y : (o,o,o)$ but
performing one eta-expansion produces the term $\lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$ which is not long-safe.
On the other hand, $\eta$-reduction (of one variable) preserves long-safety:

\begin{lemma}[$\eta$-reduction of one variable preserves long-safety]
\label{lem:etared_preserve_longsafety}
  $\Gamma \lsentail \lambda \varphi^\tau . M\, \varphi :A $ with $\varphi$ not
  occurring free in $s$ implies $\Gamma \lsentail M :A$.
\end{lemma}
\begin{proof}
  Suppose $\Gamma \lsentail \lambda \varphi^\tau . M\, \varphi :A$. If $M$ is an  abstraction then by construction of $M$ is necessarily safe.  If $M \equiv N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi^\tau . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for every variable $z$ occurring free in $\lambda \varphi . M\, \varphi$, $\ord{z} \geq \ord(\lambda \varphi^\tau . M\, \varphi) = \ord M$. Since  $\varphi$ does not occur free in $M$, the terms $M$ and $\lambda \varphi^\tau . M\, \varphi$ have the same set of free variables, thus we can use the application rule to form $\Gamma' \lsentail N_0 \ldots N_p : A$ where $\Gamma'$ consists of the typing-assignments for the free variables of $M$. The weakening rules permits us to conclude $\Gamma \lsentail M :A$.
\end{proof}

\begin{lemma}[Long-safety is preserved by $\eta$-long expansion]
\label{lem:longsafe_imp_elnf_longsafe}
$\Gamma \lsentail M :A$ then $\Gamma \lsentail \elnf{M} :A$.
\end{lemma}
\begin{proof}
 First we observe that for every variable or constant $x:A$ we have $x:A \lsentail \elnf{x} :A$. We show this by induction on $\ord{x}$.
It is verified for every ground type variable $x$
since $x = \elnf{x}$.
Step case: $x:A$ with $A=(A_1, \ldots, A_n,o)$ and $n>0$. Let $\varphi_i:A_i$ be fresh variables for $1\leq i\leq n$.
Since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i :A_i \lsentail \elnf{\varphi_i} : A_i$. Using \rulenamet{wk_l} we obtain $x:A, \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \lsentail x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \lsentail \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} =
  \elnf{x} :A$.


We now prove the lemma by induction on $M$.
The base case is covered by the previous observation.
\emph{Step case:}
\begin{compactitem}
\item $M \equiv x N_1 \ldots N_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $N_i : B_i$ for $1 \leq i \leq
  m$.  Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \lsentail \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \lsentail x N_1 \ldots N_m : A$ is formed using the \rulenamet{app_l} rule, each $N_j$ must be long-safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \lsentail \elnf{N_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \lsentail \elnf{N_j} : B_j$.  The \rulenamet{app_l}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \lsentail x \elnf{N_1} \ldots \elnf{N_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the \rulenamet{abs_l} rule gives $\Gamma \lsentail \lambda \overline{\varphi} . x
  \elnf{N_1} \ldots \elnf{N_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} \equiv \elnf{M} : A$, the side-condition of \rulenamet{abs_l} being verified since $\ord{\elnf{s}} = \ord{s}$.


\item $M \equiv N_0 \ldots N_m$ where $N_0$ is an abstraction and $m\geq 1$.
The eta-long normal form is $\elnf{M} \equiv \lambda \overline{\varphi}. \elnf{N_0} \ldots \elnf{N_m} \elnf{\varphi_1}  \ldots \elnf{\varphi_n}$ for some fresh variables $\varphi_1$, \ldots, $\varphi_n$. Again, using the induction hypothesis we can easily derive $\Gamma \lsentail
 \elnf{M} : A$.

\item $M \equiv \lambda \overline{\eta}^{\overline{B}} . N $ where
$N$ of type $C$ and is not an abstraction. The induction hypothesis gives $\Gamma,
  \overline{\eta} : \overline{B} \lsentail \elnf{N} : C$ and using
\rulenamet{abs_l} we get $\Gamma \lsentail \lambda \overline{\eta} . \elnf{N} \equiv \elnf{M} : A$.  \qedhere
\end{compactitem}
\end{proof}
\smallskip

\begin{remark}\hfill
\begin{enumerate}[(i)]
\item
The converse of this lemma does not hold: performing
$\eta$-reduction over a large abstraction does not in general
preserve long-safety. (This does not contradict Lemma
  \ref{lem:etared_preserve_longsafety} which states that safety is
  preserved when performing $\eta$-reduction on an abstraction
  of a \emph{single} variable.) A counter-example is
 $\lambda f^{(o,o,o)} g^{((o,o,o),o)} . g(\lambda x^o . f
\underline{x})$, which is not long-safe but whose eta-normal form $\lambda f^{(o,o,o)}
g^{((o,o,o),o)} . g(\lambda x^o y^o. f x y)$ is long-safe.
There are also closed terms \emph{in eta-normal form}
that are not long-safe but have an $\eta$-long normal form that is long-safe!
Take for instance the closed $\beta\eta$-normal term  $\lambda
f^{(o,(o,o),o,o)} g^{((o,o),o,o,o),o)} . g(\lambda y^{(o,o)} x^o
. f \underline{x} y)$.

  \item After performing $\eta$-long expansion of a term, all the occurrences of the application rule are made long-safe. Thus if a term remains not long-safe after $\eta$-long expansion, this means that
  some variable occurrence is not bound by the
  first following application of the \rulenamet{abs} rule in the
  typing tree.
  \end{enumerate}
\end{remark}

\begin{lemma}
  \label{lem:safe_iff_etalong_lsafe}
  A simply-typed term is safe if and only if its $\eta$-long normal form is long-safe.
\end{lemma}
\begin{proof}
Let $\Gamma \stentail M : T$. We want to show that we have $\Gamma \sentail M : T$ if and only if $\Gamma \lsentail \elnf{M} : T$. The
`Only if' part can be proved by a trivial induction on the structure of
$\Gamma \sentail M : T$. For the `if' part we proceed by
induction on the structure of the simply-typed term $M$: The variable and constant cases are
trivial. Suppose that $M$ is an application of the form $x N_1
\ldots N_m : A$ for $m\geq 1$. Its $\eta$-long normal form is of the
form $x \elnf{N_1} \ldots \elnf{N_m} \elnf{\varphi_1} \ldots
\elnf{\varphi_m}: o$ for some fresh variables $\varphi_1$, \ldots
$\varphi_m$. By assumption this term is long-safe term therefore we
have $\ord{A}\leq\ord{\Gamma}$ and for $1\leq i \leq m$,
$\elnf{N_i}$ is also long-safe. By the induction hypothesis this
implies that the $N_i$s are all safe. We can then form the judgment
$\Gamma \sentail x N_1 \ldots N_m : A$ using the rules
$\rulename{var}$ and $\rulename{\delta}$ followed by $m-1$
applications of the rule $\rulename{app_{as}}$ and one application
of $\rulename{app}$ (this is allowed since we have
$\ord{A}\leq\ord{\Gamma}$). The case $M\equiv (\lambda x. N) N_1
\ldots N_m$ for $m\geq 1$ is treated identically.

Suppose that $M \equiv \lambda \overline{x}^{\overline B} . N : A$. By assumption,
its  $\eta$-long n.f.\ $\lambda {\overline x}^{\overline B} {\overline \varphi}^{\overline C} .
\elnf{N} \elnf{\varphi_1} \ldots \elnf{\varphi_m}: A$ (for some
fresh variables $\overline\varphi = \varphi_1 \ldots \varphi_m$ and types
$\overline C = C_1 \ldots C_m$) is long-safe. Thus
we have $\ord{A}\leq\ord{\Gamma}$. Furthermore the long-safe subterm
$\elnf{N} \elnf{\varphi_1} \ldots \elnf{\varphi_m}$ is precisely the
eta-long normal form of $N\, \varphi_1 \ldots \varphi_m : o$ therefore by
the induction hypothesis we have that $N \varphi_1 \ldots \varphi_m
:o$ is safe. Since the $\varphi_i$'s are all safe (by rule
$\rulename{var}$), we can ``peel-off'' $m$ applications (performed using
the rules $\rulename{app_{as}}$ or $\rulename{app}$) from the sequent $\Gamma,
\overline{x}:\overline B,
\overline{\varphi}:\overline C \sentail N\, \varphi_1 \ldots
\varphi_m :o$ which gives us the sequent $\Gamma, \overline{x}:\overline B,
\overline{\varphi}:\overline C \asappentail N : A$. Since the
variables $\overline{\varphi}$ are fresh for $N$, we can further peel-off
applications of the weakening rule to obtain the judgment $\Gamma,
\overline{x}:\overline B \sentail N : A$.

Finally since we have $\ord{A}\leq\ord{\Gamma}$, we can use
the rule $\rulename{abs}$ to form the sequent $\Gamma \sentail \lambda \overline{x}^{\overline{B}} . N : A$.
\end{proof}



\begin{proposition}
\label{prop:safe_iff_elnfsafe}
A term is safe if and only if its $\eta$-long normal form is safe.
\end{proposition}
\begin{proof}
\begin{align*}
  \mbox{(If):}\qquad  \Gamma \sentail \elnf{M}:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies   \Gamma \sentail M:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (if).}
\end{align*}
\begin{align*}
  \mbox{(Only if):}\qquad \Gamma \sentail M:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies \Gamma \sentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:longsafe_imp_safe}. }
\end{align*}
\qedhere
\end{proof}

%%%% The statement
%%%%  ``In the homogeneous safe lambda calculus, the notion of safe terms and long-safe terms coincide''
%%%% is wrong because of the example given earlier (which is homogeneously typed).

\subsection*{The type inhabitation problem}

It is well known that the simply-typed lambda calculus corresponds
to intuitionistic implicative logic via the Curry-Howard
isomorphism. The theorems of the logic correspond to inhabited
types, and every inhabitant of a type represents a proof of the
corresponding formula. Similarly, we can consider the fragment of
intuitionistic implicative logic that corresponds to the safe lambda
calculus under the Curry-Howard isomorphism; we call it the
\emph{safe fragment of intuitionistic implicative logic}.

We would like to compare the reasoning power of these
two logics, in other words, to determine which types are inhabited
in the lambda calculus but not in the safe lambda
calculus.\footnote{This problem was raised to our attention by Ugo
dal Lago.}

If types are generated from a single atom $o$, then there is a
positive answer: Every type generated from one atom that is
inhabited in the lambda calculus is also inhabited in the safe
lambda calculus. Indeed, one can transform any unsafe inhabitant $M$
into a safe one of the same type as follows: Compute the eta-long
beta normal form of $M$. Let $x$ be an occurrence of a ground-type
variable in a subterm of the form $\lambda \overline{x} . C[x]$
where $\lambda \overline{x}$ is the binder of $x$ and for some
context $C[-]$ different from the identity (defined as $C[R]\equiv R$ for all $R$). We replace
the subterm $\lambda \overline{x} . C[x]$ by $\lambda \overline{x}.
x$ in $M$. This transformation is sound because both $C[x]$ and $x$
are of the same ground type. We repeat this procedure until the term
stabilizes. This procedure clearly terminates since the size of the
term decreases strictly after each step. The final term obtained is
safe and of the same type as $M$.

This argument cannot be generalized to types generated from multiple
atoms. In fact there are order-$3$ types with only $2$ atoms that
are inhabited in the simply-typed lambda calculus but not in the
safe lambda calculus. Take for instance the order-$3$ type
 $( ((b, a), b),  ((a, b), a),  a)$ for some distinct atoms $a$ and $b$. It is only inhabited by the following family of terms which are all unsafe:
 \begin{align*}
& \lambda f^{((b, a), b)} g^{((a, b), a)} . g (\lambda x_1^a . f (\lambda y_1^b . x_1)) \\
&\lambda f^{((b, a), b)} g^{((a, b), a)} . g (\lambda x_1^a . f (\lambda y_1^b . g (\lambda x_2^a . y_1))) \\
&\lambda f^{((b, a), b)} g^{((a, b), a)} . g (\lambda x_1^a . f (\lambda y_1^b . g (\lambda x_2^a . f (\lambda y_2^b . x_i))) \qquad\mbox{where $i = 1, 2$} \\
&\lambda f^{((b, a), b)} g^{((a, b), a)} . g (\lambda x_1^a . f (\lambda y_1^b . g (\lambda x_2^a . f (\lambda y_2^b . g (\lambda x_3^a . y_i))) \qquad\mbox{where $i = 1, 2$} \\
&\ldots
\end{align*}

Another example is the type of function composition. For any atom
$a$ and natural number $n\in\nat$, we define the types $n_a$ as
follows: $0_a = a$ and $(n+1)_a = n_a \typear a$. Take three
distinct atoms $a$, $b$ and $c$. For any $i,j,k\in\nat$, we write
$\sigma(i,j,k)$ to denote the type
$$\sigma(i,j,k) \equiv (i_a \typear j_b) \typear (j_b \typear k_c) \typear i_a \typear
k_c \ .$$

For all $i$, $j$, $k$, this type is inhabited in the lambda calculus
by the ``function composition term'':
$$\lambda x y z . y (x\,z) \enspace .$$
This term is safe if and only if $i\geq j$ (for the subterm $x\,z$ is safe iff $i = \ord(i_a) = \ord z \geq \ord(x\,z) = \ord(j_b) = j$). In the case $i<j$, the type
$\sigma(i,j,k)$ may still be safely inhabited. For instance
$\sigma(1,3,4)$ is inhabited by the safe term
$$ \lambda x^{1_a \typear 3_b} y^{3_b \typear 4_c} z^{1_c} . y (x (\lambda u^a . u)) \ .$$
The order-$4$ type $\sigma(0,2,0)$, however, is only inhabited by the unsafe term $\lambda x y z . y (x z) $.


Statman showed \cite{Statman1979} that the problem of deciding
whether a type \emph{defined over an infinite number of ground
atoms} is inhabited (or equivalently of deciding validity of an
intuitionistic implicative formula) is PSPACE-complete. The previous
observations suggest that the validity problem for the safe fragment
of implicative logic may not be PSPACE-hard.
