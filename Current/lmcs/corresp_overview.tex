In \cite{OngLics2006}, one of us introduced the notion of
computation tree and traversals over a computation tree for the
purpose of studying trees generated by higher-order recursion
scheme. Here we extend these concepts to the simply-typed lambda
calculus. Our setting allows the presence of free variables of any
order and the term studied is not required to be of ground type.
(This contrasts with \cite{OngLics2006}'s setting where the term is
of ground type and contains only \emph{uninterpreted
constant}\footnote{A constant $f$ is \emph{uninterpreted} if the
small-step semantics of the language
  does not contain any rule of the form $f \dots \rightarrow e$. $f$
  can be regarded as a data constructor.} of order 1 at most and no
free variables.) Note that we automatically accounts for the
presence of uninterpreted constants since they can just be regarded
as free variables. We will then state the \emph{Correspondence
Theorem} (Theorem \ref{thm:correspondence}) that was used in Sec.
\ref{sec:gamesemaccount}.

In the following we fix a simply typed term $\Gamma \stentail M :T$
(not necessarily safe) and we consider its computation tree
$\tau(M)$ as defined in Def.\ \ref{dfn:comptree}.

\subsection{Notations}
We first fix some notations. We write $\theroot$ to denote the root
of the computation tree $\tau(M)$. The set of nodes of the
computation tree is denoted by $N$. The sets $N_@$, $N_\lambda$ and
$N_{\sf var}$ are respectively the subset of @-nodes,
$\lambda$-nodes and variable nodes. For $n \in N$ we will write
$\kappa(n)$ to denote the subterm of $\elnf{M}$ corresponding to the
subtree of $\tau(M)$ rooted at $n$. In particular $\kappa(\theroot)
= \elnf{M}$. The \defname{type} of a variable-labelled node is the
type of the variable which labels it; the type of the root is
$(A_1,\ldots,A_p, T)$ where $x_1:A_1,\ldots, x_p:A_p$ are the
variables in the context $\Gamma$; and the type of a node $n\in
(N_\lambda \union N_@) \setminus \{ \theroot \}$ is the type of the
corresponding subterm $\kappa(n)$.


\subsection{Pointers and justified sequences of nodes}

We define the \defname{enabling relation} on the set of nodes of the
computation tree as follows: $m$ enables $n$, written $m \enable n$,
if and only if $n$ is bound by $m$ (and we sometimes write $m
\enable_i n$ to precise that $n$ is the $i^{\sf th}$ variable bound
by $m$); or $m$ is the root $\theroot$ and $n$ is a free variable;
or $n$ is a $\lambda$-node and $m$ is its parent node.


We say that a node $n_0$ of the computation tree is
\defname{hereditarily enabled} by $n_p \in N$ if there are nodes
$n_1,\ldots, n_{p-1} \in N$ such that $n_{i+1}$ enables $n_{i}$ for
all $i\in 0..p-1$.

For any set of nodes $S, H \subseteq N$ we write $S^{H\enable}$ for
$S \inter \enable^*(H) = \{ n \in S \ | \exists n_0 \in H \mbox{
s.t. }n_0  \enable^* n \}$ -- the subset of $S$ constituted of nodes
hereditarily enabled by some node in $H$. We will abbreviate
$S^{\{n_0\}\enable}$ into $S^{n_0\enable}$.

We call \defname{input-variables nodes} the elements of $V_{\sf
var}^{\theroot\enable}$ \ie variables that are hereditarily enabled
by the root of $\tau(M)$. Thus we have $V_{\sf
var}^{\theroot\enable} = V \setminus ( V_{\sf var}^{N_@\enable}
\union V_{\sf var}^{N_\Sigma\enable})$.

A \defname{justified sequence of nodes} is a sequence of nodes with
pointers such that each occurrence of a variable or $\lambda$-node
$n$ different from the root has a pointer to some preceding
occurrence $m$ verifying $m \enable n$. In particular, occurrences
of @-nodes do not have pointer. We represent the pointer in the
sequence as follows \Pstr[0.4cm]{ (m){m} \ldots (n-m,45:i) n }.
 where the label indicates that either $n$ is labelled with the $i$th variable
abstracted by the $\lambda$-node $m$ or that $n$ is the $i^{\sf th}$
child of $m$.  Children nodes are numbered from $1$ onward except for
@-nodes where it starts from $0$. Abstracted variables are numbered
from $1$ onward. The $i^{\sf th}$ child of $n$ is denoted by $n.i$.

We say that a node $n_0$ of a justified sequence is
\defname{hereditarily justified} by $n_p$ if there are occurrences $n_1,
\ldots, n_{p-1}$ in the sequence such that $n_i$ points to $n_{i+1}$
for all $i\in 0..p-1$. For any occurrence $n$ in a justified
sequence $s$, we write $s \filter n$ to denote the subsequence of
$s$ consisting of occurrences that are hereditarily justified by
$n$.


The notion of \defname{P-view} $\pview{t}$ of a justified sequence of
nodes $t$ is defined the same way as the P-view of a justified
sequences of moves in Game Semantics:\footnote{ The equalities in the
  definition determine pointers implicitly. For instance in the second
  clause, if in the left-hand side, $n$ points to some node in $s$
  that is also present in $\pview{s}$ then in the right-hand side, $n$
  points to that occurrence of the node in $\pview{s}$.}
$$\begin{array}{rclrcl}
\pview{\epsilon} &=&  \epsilon
& \pview{\Pstr[0.5cm]{ s \cdot (m) m \cdot \ldots \cdot (lmd-m,40){\lambda\overline{\xi}}
}}
 &=& \Pstr{
\pview{s} \cdot (m2) m \cdot (lm2-m2,50) {\lambda \overline{\xi}} } \\
\mbox{for $n \notin N_\lambda$, } \pview{s \cdot n }  &=&  \pview{s} \cdot n \qquad
& \pview{s \cdot \theroot }  &=&  \theroot
\end{array}$$

The O-view of $s$, written $\oview{s}$, is defined dually. We will
borrow the game semantic terminology: A justified sequences of nodes
satisfies \defname{alternation} if for any two consecutive nodes one
is a $\lambda$-node and the other is not, and \defname{P-visibility}
if every variable node points to a node occurring in the P-view a
that point.

\subsection{Computation tree with value-leaves}


We now add another ingredient to the computation tree that was not
originally used in \cite{OngLics2006}.  We write $\mathcal{D}$ to
denote the set of values of the base type $o$.  We add
\defname{value-leaves} to $\tau(M)$ as follows: For each value $v
\in \mathcal{D}$ and for each node $n \in N$ we attach the child
leaf $v_n$ to $n$.  We write $V$ for the set of vertices of the
resulting tree (\ie inner nodes and leaf nodes). For $\$$ ranging in
$\{@, \lambda, var \}$, we write $V_\$$ to denote the set of inner
nodes from $N_\$$ plus the leaf-nodes whose parent is in $N_\$$ \ie
$V_\$ = N_\$ \union \{ v_n \ | \ n \in N_\$, v \in \mathcal{D} \}$.


Everything that we have defined can be lifted to this new version of
computation tree. A value-leaf has order $0$. The enabling relation
$\enable$ is extended so that every leaf is enabled by its parent
node. A link going from a value-leaf $v_n$ to a node $n$ is labelled
by $v$: \Pstr[0.4cm]{ (n) n \ldots (vn-n,35:v){v_n} }. For the
definition of P-view and visibility, value-leaves are treated as
$\lambda$-nodes if they are at an odd level in the computation tree,
and as variable nodes if they are at an even level.

We say that an occurrence of an inner node $n \in N$ is
\defname{answered} by an occurrence $v_n$ if $v_n$ in
the sequence that points to $n$, otherwise we say that $n$ is
\defname{unanswered}. The last unanswered node is called the
\defname{pending node}.  A justified sequence of nodes is
\defname{well-bracketed} if each value-leaf occurring in it is justified by the pending node at that point.  If $t$ is a traversal then we write
$?(t)$ to denote the subsequence of $t$ consisting only of
unanswered nodes.

\subsection{Traversals of the computation tree}
\label{subsec:traversal}

A \emph{traversal} is a justified sequence of nodes of the computation tree where each node
indicates a step that is taken during the evaluation of the term.

\begin{definition}[Traversals for simply-typed $\lambda$-terms] \rm
\label{def:traversal} The set $\travset(M)$ of \defname{traversals}
over $\tau(M)$ is defined by induction over the rules of Table
\ref{tab:trav_rules}. A traversal that cannot be extended by any
rule is said to be \emph{maximal}.
\end{definition}
\begin{FramedTable}
\noindent {\bf Initialization rules}
\begin{itemize}[]
\item\rulenamet{Empty} $\epsilon \in \travset(M)$.
\item\rulenamet{Root} The sequence constituted of a single occurrence of $\tau(M)$'s root is a traversal.
\end{itemize}

\noindent {\bf Structural rules}
\begin{itemize}[]
    \item \rulenamet{Lam} If $t \cdot \lambda \overline{\xi}$ is a traversal then so is
        $t \cdot \lambda \overline{\xi} \cdot n$ where $n$
        denotes $\lambda \overline{\xi}$'s child and:
        \begin{compactitem}
            \item If $n \in N_@ \union N_\Sigma$ then it has no justifier;
            \item if  $n \in N_{\sf var}\setminus N_{\sf fv}$ then it points to the only occurrence\footnote{Prop.\ \ref{prop:pviewtrav_is_path} shows that P-views
            are paths in the tree thus $n$'s enabler occurs
            exactly once in the P-view.} of its enabler in
            $\pview{t\cdot \lambda \overline{\xi}}$;
            \item if  $n \in N_{\sf fv}$ then it points
            to the only occurrence of the root $\theroot$ in
            $\pview{t \cdot \lambda \overline{\xi}}$.
        \end{compactitem}
    \item \rulenamet{App} If $t \cdot @$ is a traversal then so is \Pstr[0.4cm]{t \cdot (m) @  \cdot (n-m,40:0) n}.
\end{itemize}

\emph{\bf Input-variable rules}
\begin{itemize}[]
\item \rulenamet{InputVar} If $t$ is a traversal where $t^\omega \in N_{\sf var}^{\theroot\enable} \union L_\lambda^{\theroot\enable}$
and $x$ is an occurrence of a variable node in $\oview{t}$ then
so is $t \cdot n$ for any child $\lambda$-node $n$ of $x$, $n$
pointing to $x$.



\item \rulenamet{InputValue} If $t_1
\cdot x \cdot t_2$ is a traversal with pending node $x \in
N_{\sf var}^{\theroot\enable}$ then so is \Pstr[0.5cm]{t_1 \cdot
(x){x} \cdot t_2 \cdot (xv-x,38:v){v_x} } for all $v \in
\mathcal{D}$.
\end{itemize}

\emph{\bf Copy-cat rules}
\begin{itemize}[]
\item\rulenamet{Var}
If \Pstr[0.5cm]{t \cdot (n){n} \cdot (lx){\lambda \overline{x}}
    \ldots (x-lx,50:i){x_i} } is a traversal where $x_i \in
    N_{\sf var}^{@\enable}$ then so is \Pstr[0.5cm]{ t \cdot
(n){n} \cdot (lx){\lambda \overline{x}}  \ldots (x-lx,30:i){x_i}
    \cdot (letai-n,40:i){\lambda \overline{\eta_i}}
     }.

\item\rulenamet{Value}
  If \Pstr{t \cdot (m){m} \cdot (n){n}  \ldots
(vn-n,60:v){v}_{n} } is a traversal where $n\in N$ then so is
\Pstr[0.6cm]{t \cdot (m){m} \cdot (n){n} \ldots
(vn-n,60:v){v}_{n} \cdot (vm-m,45:v){v}_m}.
\end{itemize}
\caption[Traversal rules for the simply-typed
lambda-calculus]{Traversal rules for the simply-typed
$\lambda$-calculus.} \label{tab:trav_rules}
\end{FramedTable}

\parpic[r]{
 $\pssetcomptree\tree[levelsep=3ex,treesep=0.5cm]{\lambda} {
    \tree{@}{
        \pstree[linestyle=dotted]{\TR{\lambda y}\arclabel{0} }{
            \tree{y}{
                \tree{\lambda \overline{\eta_1}}{\vdots}%\arclabel{1}
                \tree{\lambda \overline{\eta_i}}{\vdots}%\arclabel{i}
                \tree{\lambda \overline{\eta_n}}{\vdots}%\arclabel{n}
            }
        }
        \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}
            \arclabel{1}}{ \tree{x_i}{\TR{} \TR{}}}
}}$ } A traversal always starts by visiting the root. Then it mainly
follows the structure of the tree. The (Var) rule permits to jump
across the computation tree. The idea is that after visiting a
variable node $x$, a jump is allowed to the node corresponding to
the subterm that would be substituted for $x$ if all the
$\beta$-redexes occurring in the term were reduced. The sequence
\Pstr[0.8cm]{\lambda \cdot (app) @  \cdot (ly) {\lambda y}  \ldots
(y-ly,35:1) y  \cdot (lx-app,38:1) {\lambda \overline{x}} \ldots
(x-lx,30:i) {x_i} \cdot (leta-y,40:i) {\lambda \overline{\eta_i} }
\ldots}
 is an example of traversal of the computation tree shown on the right.

\begin{proposition}[counterpart of proposition 6 from \cite{OngHoMchecking2006}]
\label{prop:pviewtrav_is_path}
Let $t$ be a traversal. Then:
\begin{enumerate}[(i)]
\item $t$ is a well-defined and well-bracketed justified sequence;
\item $t$ is a well-defined justified sequence verifying alternation, P-visibility and O-visibility;
\item If $t$'s last node is not a value-leaf, then $\pview{t}$ is the path in the computation tree going from the root to $t$'s last node.
\end{enumerate}
\end{proposition}

The \defname{reduction} of a traversal $t$ is the subsequence of $t$
obtained by keeping only occurrences of nodes that are hereditarily
enabled by the root $\theroot$. This has the effect of eliminating
the ``internal nodes'' of the computation. If $t$ is a non-empty
traversal then the root $\theroot$ occurs exactly once in $t$ thus
the reduction of $t$ is equal to $t \filter r$ where $r$ is the
first occurrence in $t$ (the only occurrence of the root). We write
$\travset(M)^{\filter \theroot}$ for the set or reductions of
traversals of $M$.

Application nodes are used to connect the operator and the operand
of an application in the computation tree but since they do not play
any role in the computation of the term, we can remove them from the
traversals.  We write $t-@$ for the sequence of nodes-with-pointers
obtained by removing from $t$ all @-nodes and value-leaves of
@-nodes, any link pointing to an @-node being replaced by a link
pointing to the immediate predecessor of @ in $t$. We write
$\travset(M)^{-@}$ for the set $\{ t - @ \ | \  t \in \travset(M)
\}$.
\begin{remark}
Clearly if $M$ is $\beta$-normal then $\tau(M)$ does not contain any
@-node therefore all nodes are hereditarily enabled by the root and
we have $\travset(M)^{-@} = \travset(M) = \travset(M)^{\filter
\theroot }$.
\end{remark}



\begin{lemma}
% version of the lemma for the pure simply-typed lambda calculus
\label{lem:betanf_trav_pview_red} Suppose that $M$ is a
$\beta$-normal simply-typed term. Let $t$ be a non-empty traversal
of $M$ and $r$ denote the only occurrence of $\tau(M)$'s root in
$t$. If $t$'s last occurrence is not a leaf then
$$ \pview{t} \filter r = \pview{?(t) \filter  r }\ .$$
\end{lemma}
In the lambda calculus without interpreted constants this lemma
follows immediately from the fact that $\travset(M) =
\travset(M)^{\filter \theroot}$. But this Lemma remains valid in the
presence of interpreted constants provided that the traversal rules
implementing the constants are \emph{well-behaved}\footnote{A
traversal rule is \defname{well-behaved} if it can be stated under
the form ``$t = t_1\cdot n \cdot t_2 \in \travset(M)\ \zand\ ?(t) =
?(t_1) \cdot n \zand n \in N_{\Sigma}\union N_{\sf var} \zand P(t)
\zand m\in S(t) \imp\ $\Pstr{ t_1\cdot (n){n} \cdot t_2 \cdot
(m-n,25){m} \in {\travset(M)}}'' for some expression $P$ expressing
a condition on $t$ and function $S$ mapping traversals of the form
of $t$ to a subset of the children of $n$.}.

\subsection{Computation trees and arenas}
We consider the well-bracketed game model of the simply-typed lambda
calculus.  We choose to represent strategies using ``prefix-closed
set of plays''.\footnote{In the literature, a strategy is commonly
defined as a set of plays closed by taking a prefix of \emph{even}
length. However for the purpose of showing the correspondence with
traversals, the ``prefix-closed''-based definition is more
adequate.} We fix a term $\Gamma \stentail M : T$ and write
$\sem{\Gamma \stentail M : T}$ for its strategy denotation. The
answer moves of a question $q$ are written $v_q$ where $v$ ranges in
$\mathcal{D}$.

\begin{proposition}
There exists a function $\varphi_M$, constructible from $\tau(M)$,
that maps nodes from $V\setminus (V_@ \union V_\Sigma)$ to moves of
the interaction arena underlying the revealed strategy
$\syntrevsem{\Gamma \stentail M : T}$ and such that
\begin{itemize}
\item $\varphi$ maps $\lambda$-nodes to O-questions, variable
nodes to P-questions, value-leaves of $\lambda$-nodes to
P-answers and value-leaves of variable nodes to O-answers.

\item $\varphi$ maps nodes of a given order to moves of
the same order.
\end{itemize}
\end{proposition}
If $t = t_0 t_1 \ldots$ is a justified sequence of nodes in
$V_\lambda \union V_{\sf var}$ then $\varphi(t)$ is defined to
be the sequence of moves $\varphi(t_0)\ \varphi(t_1) \ldots$
equipped with the pointers of $t$.


\begin{example}
Take $\lambda x . (\lambda g . g x) (\lambda y . y)$ with $x,y:o$ and $g:(o,o)$.
The diagram below represents the computation tree (middle), the arenas
$\sem{(o,o), o}$ (left), $\sem{o , o}$ (right), $\sem{o\rightarrow o}$ (rightmost)
and $\varphi = \psi \union \psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}} \union
\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}$
(dashed-lines).
$$\psset{levelsep=3.5ex}
\pstree{\TR[name=root]{\lambda x}}
{
    \pstree{\TR[name=App]{@}}
    {
            \pstree{\TR[name=lg]{\lambda g}}
                { \pstree{\TR[name=lgg]{g}}{
                        \pstree{\TR[name=lgg1]{\lambda}}
                        { \TR[name=lgg1x]{x}  } } }
            \pstree{\TR[name=ly]{\lambda y}}
                    {\TR[name=lyy]{y}}
    }
}
\rput(4.5cm,-1cm){
  \pstree{\TR[name=A1lx]{q_{\lambda x}}}
        { \TR[name=A1x]{q_x} }
}
\rput(-6cm,-1.5cm){
    \pstree{\TR[name=A2lg]{q_{\lambda g}}}
    {
        \pstree{\TR[name=A2g]{q_g}}
        {  \TR[name=A2g1]{q_{g_1}}   }
    }}
\rput(2.5cm,-1.5cm){
    \pstree{\TR[name=A3ly]{q_{\lambda y}}}
        { \TR[name=A3y]{q_y}
        }
}
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{A1lx} \mput*{\psi}
\ncarc{->}{lgg1x}{A1x}
\ncline{->}{lg}{A2lg} \mput*{\psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}}}
\ncline{->}{lgg}{A2g}
\ncline{->}{lgg1}{A2g1}
\ncline{->}{ly}{A3ly} \mput*{\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}}
\ncline{->}{lyy}{A3y}
$$
\end{example}


\subsection{The Correspondence Theorem}

In game semantics, strategy composition is performed using a
CSP-like ``composition + hiding''. If some of the internal moves are
not hidden then we obtain alternative denotations called
\defname{revealed semantics} in \cite{willgreenlandthesis} and
\emph{interaction} semantics in \cite{DBLP:conf/sas/DimovskiGL05}.
We obtain different notions of revealed semantics depending on the
choice of internal moves that we hide. For instance the
\defname{fully revealed denotation} of $\Gamma \stentail M
:T$, written $\revsem{\Gamma \stentail M : T}$, is obtained by
uncovering all the internal moves from $\sem{\Gamma \stentail M :
T}$ that are generated during composition.\footnote{An algorithm
that uniquely recovers hidden moves from $\sem{\Gamma \stentail M :
T}$ is given in Part II of
  \cite{hylandong_pcf}.} The inverse operation consists in filtering out the internal moves.

The \defname{syntactically-revealed denotation}, written
$\syntrevsem{\Gamma \stentail M : T}$, differs from the
fully-revealed one in that only certain internal moves are preserved
during composition: when computing the denotation of an application
joint by an @-node in the computation tree, all the internal moves
are preserved. When computing the denotation of $\revsem{y_i N_1
\ldots N_p}$ for some variable $y_i$, however, we only preserve the
internal moves of $N_1$, \ldots, $N_p$ while omitting the internal
moves produced by the copy-cat projection strategy denoting $y_i$.


In the simply-typed lambda calculus, the set $\travset(M)$ of
traversals of the computation tree is isomorphic to the
syntactically-revealed denotation, and the set of traversal
reductions is isomorphic to the standard strategy denotation:
\begin{theorem}[The Correspondence Theorem]
\label{thm:correspondence} $\varphi_M$ gives us the following two
isomorphisms:
\begin{eqnarray*}
(i)~\varphi_M  &: \travset(M)^{-@} \stackrel{\cong}{\longrightarrow} \syntrevsem{\Gamma \stentail M :T} \\
(ii)~\varphi_M  &: \travset(M )^{\filter \theroot} \stackrel{\cong}{\longrightarrow} \sem{\Gamma \stentail M : T} \ .
\end{eqnarray*}
\end{theorem}

\begin{example}
Take $M = \lambda f z . (\lambda g x . f x) (\lambda y. y) (f z) :
((o,o),o, o)$.  The figure below represents the computation tree
(left tree), the arena $\sem{((o,o),o, o)}$ (right tree) and
$\psi_M$ (dashed line). (Only question moves are shown for clarity.)
The justified sequence of nodes $t$ defined hereunder is an example
of traversal:

\begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}p{6cm}p{7cm}}
$\pssetcomptree\pstree[levelsep=2.5ex,treesep=0.3cm]{ \TR[name=root]{\lambda f z} }
     {  \tree[levelsep=4ex]{@}
        {   \tree{\lambda g x}{
                  \pstree{\TR[name=f]{f^{[1]}}}{
                            \pstree{\TR[name=lmd]{\lambda^{[2]}}}
                                {\TR{x}}
                  }
                }
            \tree{\lambda y }{\TR{y}}
            \tree{\lambda ^{[3]}}{
                \pstree{\TR[name=f2]{f^{[4]}}} {
                \pstree{\TR[name=lmd2]{\lambda^{[5]}}}{\TR[name=z]{z}}
                }
            }
        }
     }
\hspace{2cm}
  \pstree[levelsep=8ex, treesep=0.3cm]{ \TR[name=q0]{q^0} }
    {   \pstree[levelsep=4ex]{\TR[name=q1]{q^1}} {\TR[name=q2]{q^2}}
        \TR[name=q3]{q^3}
    }
\psset{nodesep=1pt,arrows=->,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q0} \mput*{\psi_M}
\ncarc[arcangle=-25]{->}{z}{q3}
\ncarc[arcangle=10]{->}{f}{q1}
\ncarc[arcangle=10]{->}{lmd}{q2}
\ncline{->}{f2}{q1}
\ncline{->}{lmd2}{q2}$
&
\begin{asparablank}
  \item  \Pstr[0.8cm]{
t = (n){\lambda f z} \
(n2){@} \
(n3-n2,60){\lambda g x} \
(n4-n,45){f^{[1]}} \
(n5-n4,45){\lambda^{[2]}} \
(n6-n3,45){x} \
(n7-n2,35){\lambda^{[3]}} \
(n8-n,35){f^{[4]}} \
(n9-n8,45){\lambda^{[5]}} \
(n10-n,35){z}
}

\item \Pstr[0.9cm]{
t\filter r = (n){\lambda f z} \ (n4-n,50){f}^{[1]} \
(n5-n4,60){\lambda}^{[2]} \ (n8-n,45){f}^{[4]} \
(n9-n8,60){\lambda}^{[5]} \ (n10-n,40){z}}
\item
\Pstr[0.8cm]{ {\varphi_M(t\filter r) =\ } (n){q^0}\ (n4-n,60){q^1}\
(n5-n4,60){q^2}\ (n8-n,45){q^1}\ (n9-n8,60){q^2}\ (n10-n,38){q^3}
\in \sem{M}\ .}
\end{asparablank}
\end{tabular*}
\end{example}
