\newcommand\bigo{\mathcal{O}} % big O notation
\newcommand\booltype{\mathsf{B}}

\section{Complexity of the Safe Lambda Calculus}
This section aims at studying the complexity of the problem of deciding beta-eta equivalence of two safe lambda terms.

\subsection{Statman's result}

A famous result by Statman  states that deciding the $\beta\eta$-equality of two first-order typable lambda terms is not elementary recursive \cite{Statman:1979:TLE}.
The proof proceeds by encoding the Henkin quantifier elimination of Type Theory into the simply-typed lambda calculus.
Mairson gave a simpler proof in \cite{mairson1992spt} which also proceeds by encoding the Henkin quantifier elimination procedure into the lambda-calculus but is much easier to understand as it makes use of list iteration to perform quantifier elimination.

It turns out that both encodings rely on the use of unsafe terms to implement the quantifier elimination procedure: Statman's encoding makes use of the conditional
function $\sf sg$ which is not definable in the safe lambda-calculus (\cite{blumong:safelambdacalculus}), and Mairson's encoding uses unsafe terms for encoding both quantifier elimination and set membership. Hence the argument does not carry on in the Safe Lambda Calculus.

In fact the unsafey of Mairson's encoding can be alleviated: the quantifier elimination procedure can be made safe provided that we use multiple domains of representation to encode values of the type hierarchy. Set-membership, however, seems to be intrinsically unsafe.

We start this section by presenting an adaptation of Mairson's encoding where quantifier elimination is safely encoded and by showing why it is problematic to encode set-membership safely. We will then use this encoding to interpret the True Quantifier Boolean Formula (TQBF) problem into the Safe Lambda Calculus, thus showing that deciding beta-eta equality is PSPACE-hard.


\subsection{Mairson's encoding}

We recall the definition of Finite Type Theory. Let $\mathcal{D}_0 = \{\mathbf{true},\mathbf{false}\}$ and $\mathcal{D}_{k+1} =powerset(\mathcal{D}_k)$.
For any $k\geq0$, we write $x^k$, $y^k$ and $z^k$ to denote variables ranging over $\mathcal{D}_k$. Prime formulae are $x^0$, $\mathbf{true}\in y^1$, $\mathbf{false}\in y^1$, and  $x^k \in y^{k+1}$. Formulae are built up from prime formulae using the logical connectives $\zand$,$\zor$,$\rightarrow$,$\neg$ and the quantifiers
$\forall$ and $\exists$. Meyer showed that deciding the truth of such formulae requires nonelementary time \cite{Meyer1974}.
\smallskip

In Mairson's encoding, variables of a given order $k$ are all encoded by terms of the same type $\Delta_k$. Using this encoding,
unsafety manifests itself in two different ways.
\begin{enumerate}[1.]
  \item
        First in the encoding of set membership. The prime formula $x^k \in y^{k+1}$ is encoded as \begin{equation} x^k : \Delta_k, y^{k+1}:\Delta_{k+1} \vdash y^{k+1} (\lambda y^k : \Delta_k . OR (eq_k~\underline{x^k}~y^k)~F : \Delta_k \typear \Delta_{k+1} \typear \Delta_0 \label{eqn:setmembership}\end{equation}
for some terms $OR$, $F$, $eq_k$.
This term is unsafe because of the underline occurrence of $x^k$ which is not abstracted together with $y^k$.

\item Secondly, quantifier elimination is performed by using a list iterator $\mathbf{D}_{k+1}$ which acts like the $fold\_right$ function from functional programming languages over the list of all elements of $\mathcal{D}_k$.
Thus for instance the formula $\forall x^0 . \exists y^0 . x^0 \zor y^0$
is encoded as $$\vdash \mathbf{D}_1 (\lambda x^0:\Delta_0. AND (\mathbf{D}_1 (\lambda y^0:\Delta_0. OR (\underline{x^0} \zor y^0)) F)) T \ .$$
This term is unsafe since the underlined occurrence is unsafely bound. This is due to the presence of two nested quantifiers in the formula, which are encoded as two nested list iterations. More generally, nested binding will be encoded safely if and only if every variable $x$ in the formula is bound by the first quantifier $\exists z$ or $\forall z$ in the path to the root of the AST of the formula verifying $\ord{z} \geq \ord{x}$. For instance if set-membership could be encoded safely then the interpretation of $\forall x^k . \exists y^{k+1} . x^k \in y^{k+1}$ would be unsafe whereas the encoding of $\forall y^{k+1} . \exists x^k . x^k \in y^{k+1}$ would be safe.
\end{enumerate}

Surprisingly, the unsafety of the quantifier elimination procedure can be easily overcome. The idea is as follows. We introduce multiple domains of representation for a given formula. An element of $\mathcal{D}_k$ is thereby represented by countably many terms of type $\Delta_k^n$ where $n\in\nat$ indicates the level of the domain of representation. The type $\Delta_k^n$ is defined in such a way that its order strictly increases as $n$ grows. Furthermore, there exists a term that can lower the domain of representation of a given term. Thus each formula variable can have a different domain of representation, and since there are infinitely many such domains, it is always possible to find an assignment of representation domains to variables such that the resulting encoding term is safe.

For set-membership, however, there is no obvious way to obtain a safe encoding. In order to turn Mairson's encoding of set-membership (Eq.\ \ref{eqn:setmembership}) into a safe term, we would need to have access to a function that increases the domain of representation of an encoded variable. Unfortunately, such transformation is intrinsically unsafe!
\smallskip

We now present the encoding in details.

\subsubsection{Encoding basic boolean operations}

Let $o$ be a base type and define the family of types $\sigma_0 \equiv o$, $\sigma_{n+1} \equiv \sigma_n\typear\sigma_n$ verifying $\ord{\sigma_n} = n$.


Booleans are encoded over domains $\booltype_n \equiv \sigma_n\typear o\typear o\typear o$ for $n\geq0$, each type $\booltype_n$ being of order $n+1$. We write $\underline{i}_{n+1}$ to denote the term $\lambda x^{\sigma_n}.x : \sigma_{n+1}$ for $n\geq0$.

The truth values $\mathbf{true}$ and $\mathbf{false}$ are represented by the following terms parameterized by $n \in \nat$:
\begin{align*}
  T^n &\equiv \lambda u^{\sigma_n} x^o y^o .x : \booltype_{n}\\
  F^n &\equiv \lambda u^{\sigma_n} x^o y^o .y : \booltype_{n}
\end{align*}
Clearly these terms as safe. Moreover the following relations hold for all $n,n'\geq 0$:
\begin{align*}
  \lambda u^{\sigma_{n'}} . T^{n+1}~\underline{i}_{n+1}  &\betared  T^{n'} \\
  \lambda u^{\sigma_{n'}} . F^{n+1}~\underline{i}_{n+1}  &\betared  F^{n'}
\end{align*}
Hence it is possible to change the domain of representation of a Boolean value from a higher-level to another arbitrary level using the transformation:
$$ \mathbf{C}^{n+1\mapsto n'}_0 \equiv \lambda m^{\booltype_{n+1}} u^{\sigma_{n'}}. m~\underline{i}_{n+1}$$
so that if a term $M : \booltype_n$ for $n\geq1$ is beta-eta convertible to $T^n$ (resp.\ $F^n$) then $\mathbf{C}^{n\mapsto n'}_0~M :\booltype_{n'}$ is beta-eta convertible to $T^{n'}$ (resp.\ $F^{n'}$).

Observe that although the term $\mathbf{C}^{n+1\mapsto n'}_0$ is safe for all $n,n'\geq 0$, if we apply it to a variable then the resulting term
$$ x:B_{n+1} \vdash \mathbf{C}_{n+1\mapsto n'}~x : B_{n}$$
is safe if and only if the transformation decreases the domain of representation of $x$ \ie $\ord{B_{n+1}}\geq\ord{B_{n'}}$.


Boolean functions are encoded by the following safe terms parameterized by $n$:
\begin{align*}
AND^n &\equiv \lambda p^{\booltype_n} q^{\booltype_n} u^{\sigma_n} x^o y^o . p~u~(q~u~x~y)~y : \booltype_n\typear\booltype_n\typear\booltype_n \\
OR^n &\equiv \lambda p^{\booltype_n} q^{\booltype_n} u^{\sigma_n} x^o y^o . p~u~x~(q~u~x~y) : \booltype_n\typear\booltype_{n}\typear\booltype_n \\
NOT^n &\equiv \lambda p^{\booltype_n} u^{\sigma_n} x^o \lambda y^o . p~u~y~x : \booltype_n\typear\booltype_n\typear\booltype_n
%\\ IF^n &\equiv \lambda p^{\booltype_n} q^{\booltype_n} u^{\sigma_n} x^o y^o. OR^n (NOT^n p)~q : \booltype_n\typear\booltype_n\typear\booltype_n
\end{align*}

\subsubsection{Coding elements of the type hierarchy}
For any $n\in\nat$ we define the hierarchy of type $\Delta_k^n$ as follows:
$\Delta_0^n \equiv \booltype_n$ and $\Delta_{k+1}^n \equiv {\Delta_k^n}^*$ where for any type $\alpha$, $\alpha^* = (\alpha \typear \tau \typear \tau)\typear \tau \typear \tau$.

An occurrence of a formula variable $x^k$ will be encoded as a term variable $x^k$ of type $\Delta_{k}^n$ for some level of domain representation $n\in\nat$.
Following Mairson's  encoding, each set $\mathcal{D}_k$ is represented by a list $\mathbf{D}_k^n$ constituted of all its elements:
\begin{align*}
\mathbf{D}_0^n &\equiv \lambda c^{\booltype_n \typear \tau \typear \tau} e^\tau . c~T^n~(c~F^n~e) : \Delta_1^n \\
\mathbf{D}_{k+1}^n &\equiv powerset~\mathbf{D}_k^n : \Delta_{k+2}^n
\end{align*}
where
\begin{align*}
  powerset &\equiv \lambda {A^*}^{(\alpha \typear \alpha^{**} \typear \alpha^{**}) \typear \alpha^{**} \typear \alpha^{**}}. \\
&\qquad  A^*~double~(\lambda c^{\alpha^* \typear \tau\typear \tau} b^\tau . c~(\lambda c'^{\alpha\typear \tau\typear \tau} b'^\tau.b')~b)\\
 &: ((\alpha \typear \alpha^{**} \typear \alpha^{**}) \typear \alpha^{**} \typear \alpha^{**})\typear \alpha^{**} \\
  double &\equiv \lambda x^\alpha~l^{(\alpha^* \typear \tau\typear \tau)\typear \tau\typear \tau}~ c^{\alpha^*\typear \tau\typear \tau}~b^\tau. \\
  & \qquad \qquad l(\lambda e^{\alpha^*}.c~(\lambda c'^{\alpha\typear \tau\typear \tau}~ b'^\tau.c'~\underline{x}~(e~c'~b')))(l~c~b)\\
 &: \alpha \typear \alpha^{**} \typear \alpha^{**}
\end{align*}
In all these terms, the only variable occurrence that is potentially unsafe is the underlined occurrence $x$ in $double$. This occurrence if safely bound just when $\ord{\alpha} \geq \ord{\tau}$.
Consequently for all $k,n\geq0$, $\mathbf{D}_k^n$ is safe if and only if $\ord{\alpha} \geq \ord{\tau}$.


\subsubsection{Quantifier elimination}
Terms of type $\Delta_{k+1}^n$ are now used as iterators over list of elements of type $\Delta_k^n$ and we set $\tau \equiv \booltype_n$ in the type $\Delta_{k+1}^n$ in order to iterate a level-$n$ Boolean function. Since $\ord{\Delta_k^n} \geq \ord{\booltype_n}$ for all $n$, all the instantiations of the terms $\mathbf{D}_k^n$ will be safe. Following \cite{mairson1992spt}, quantifier elimination interprets the formula $\forall x^k.\Phi(x^k)$ as the iterated conjunction:
$\mathbf{C}_0^{n\mapsto 0} \left( \mathbf{D}_k^n(\lambda x^k:\Delta_k^n.AND^n(\hat\Phi~x^k))~T^n \right)$ where $\hat\Phi$ is the interpretation of $\Phi$
and $n$ is the representation level chosen for the variable $x^k$; similarly $\exists x^k.\Phi(x^k)$  is interpreted by the iterated disjunction $\mathbf{C}_0^{n\mapsto 0} \left( \mathbf{D}_k^n(\lambda x^k:\Delta_k^n.AND^n(\hat\Phi~x^k))~T^n\right)$.

Let $x^{k_p}_p \ldots x^{k_1}_1$ for $p\geq1$ be the list of variables appearing in the formula. W.l.o.g.\ we can assume that they are given in the order of appearance of their binder in the formula \ie $x^{k_p}_p$ is bound by the leftmost binder. We fix the domain of representation of each variable as follows. The right-most variable $x^{k_1}_1$ will be encoded in the domain $\Delta^0_{k_1}$; suppose that for $1\leq i< p$ the domain of representation of $x^{k_i}_i$ is $\Delta^l_{k_l}$ then the domain of representation of $x^{k_{i+1}}_{i+1}$ is defined as
$\Delta^{l'}_{k_{i+1}}$ where $l'$ is the smallest natural number such that $\ord{\Delta^{l'}_{k_{i+1}}}$ is strictly greater than $\ord{\Delta^{l}_{k_i}}$.

This way, since variables that are bound first have higher order, the variables that are bound in the nested list-iterations (corresponding to the nested quantifiers in the formula) are necessarily safely bound.

\begin{example}
The formula  $\forall x^0 . \exists y^0 . x^0 \zor y^0$, encoded by an unsafe term using Mairson's encoding, is represented in our encoding by the safe term:
 $$\vdash \mathbf{C}_0^{1\mapsto 0} \left( \mathbf{D}_0^1~(\lambda x^0:\Delta_0^1. AND^0 ( \mathbf{D}_0^0 ~(\lambda y^0:\Delta_0^0. OR^0 (OR^0~(\mathbf{C}_0^{1\mapsto 0}~x^0)~y^0))~F^0))~T^1 )\ .$$
\end{example}


\subsubsection{Set-membership}
To complete the interpretation of prime formulae, we would need to show how to encode set membership. The use of multiple domains of representation does not suffice to turn Mairson's encoding into a safe term. We would further need to have a version of the Booleans conversion term $\mathbf{C}^{n+1\mapsto n'}_0$ generalized to higher-order sets.
This transformation can be interpreted as the simply-typed term:
$$ \mathbf{C}^{n\mapsto n'}_{k+1} \equiv \lambda m^{\Delta_{k+1}^n} u^{\Delta_k^n\typear \tau\typear \tau} v^\tau. m (\lambda z^{\Delta_k^n} w^\tau . \underline{u (\underline{\mathbf{C}^{n\mapsto n'}_k z}) w}) v : \Delta_{k+1}^n \typear \Delta_{k+1}^{n'}$$
Unfortunately this term is safe if and only if $n=n'$ (the largest underlined subterm is safe just when $n\geq n'$ and the other underline subterm is safe just when $n'\geq n$), thus making this transformation useless in the Safe Lambda Calculus.

This leads us to conjecture that the set-membership test function is intrinsically unsafe.
\smallskip


%%%%%%%%%%%%%%%%%%%%%%%
%% The following commented section gives an UNSAFE encoding of set-memberhsip.

If $\mathbf{C}^{n\mapsto n'}_{k+1}$ were safely representable then the encoding would go as follows: We set $\tau \equiv \booltype_0$ in the types  $\Delta_{k+1}^n$ for all $n,k\geq 0$ in order to iterate a level-$0$ Boolean function.
Firstly, the formulae ``$\mathbf{true} \in y^1$'' and ``$\mathbf{false} \in y^1$'' can be encoded by the safe terms $y^1 (\lambda x^0 . OR^0~x^0) F^0$ and $y^1 (\lambda x^0. OR^0(NOT^0~x^0)) F^0$ respectively.
For the general case ``$x^k\in y^{k+1}$''
we proceed as in \cite{mairson1992spt} by introducing lambda-terms encoding set equality, set membership and subset tests, and we further parameterize these encoding by $n\in\nat$.
\begin{align*}
member_{k+1}^{n+1} &\equiv \lambda x^{\Delta_k^{n+1}} y^{\Delta_{k+1}^{n+1}}. \\
& \quad\ (\mathbf{C}_{k+1}^{n+1\mapsto n}~y)~(\lambda z^{\Delta_k^n} . OR^0 (eq_k^n~(\mathbf{C}^{n+1\mapsto n}_k~x)~z))~F^0\\
  & : \Delta_k^{n+1} \typear \Delta_{k+1}^{n+1} \typear \booltype_0
\\
subset_{k+1}^n &\equiv \lambda x^{\Delta_{k+1}^n} y^{\Delta_{k+1}^n}. \\
  & \qquad x~(\lambda x^{\Delta_k^n} . AND^0 (member_{k+1}^n~x~y))~T^0 \\
  & : \Delta_{k+1}^n \typear \Delta_{k+1}^n \typear\booltype_0
\\
eq_0^n &\equiv \lambda x^{\booltype_n} .\lambda y^{\booltype_n}. \mathbf{C}_0^{n\mapsto 0}~ \left(OR^n (AND^n~x~y) (AND^n (NOT^n~x)(NOT^n~y))\right) \\
 &: \booltype_n \typear \booltype_n \typear\booltype_0
\\
eq_{k+1}^n &\equiv \lambda x^{\Delta_{k+1}^n}~ y^{\Delta_{k+1}^n}. \\
   & \qquad
   (\lambda op^{\Delta_{k+1}^n\typear\Delta_{k+1}^n\typear\booltype_0}. AND^0 (op~x~y)(op~y~x))~subset_{k+1}^n \\
  & : \Delta_{k+1}^n \typear \Delta_{k+1}^n \typear \booltype_0
\end{align*}
The variables in the definition of $eq_{k+1}^n$ and $subset_{k+1}^n$ are safely bounds. Moreover, the occurrence of $x$ in $member_{k+1}^{n+1}$ is now safely bound (this was not the case in Mairson's original encoding) thanks to the fact that the representation domain of $z$ is lower than that of $x$. Unfortunately, unsafety is still present due to the use of the conversion terms $\mathbf{C}_k^{n\mapsto n'}$ for $k\geq1$.

The formula $x^k\in y^{k+1}$ can then encoded by
$$x:\Delta_k^n, y:\Delta_{k+1}^{n'}\vdash member_{k+1}^{u}~ (\mathbf{C}_k^{n\mapsto u}~x)~(\mathbf{C}^{n'\mapsto u}_{k+1} ~y) : \booltype_0$$
for some $n,n'\geq 2$ and $u = \min(n,n')+1$.

%%
%%%%%%%%%%%%%%%%%%%%%%%


\subsection{NP-hardness}
Instances of the Boolean satisfaction problem SAT can be seen as special instances of the decision problem for truth formulae of Finite Type Theory. These instances corresponds to formulae in which set membership is not allowed and variables are all taken from the base domain $\mathcal{D}_0$ and are bound by existential quantifiers.
As we have shown in the previous section, such restricted formulae can be safely encoded in the Safe Lambda Calculus thus since SAT is NP-complete we obtain that the equivalence problem for the Safe Lambda Calculus is NP-hard.

In the paper  \cite{asperti-np}, the author gives an encoding of SAT in the simply-typed lambda calculus. This encoding relies on safe terms only, thus giving us another proof of NP-hardness.

\subsection{PSPACE-hardness}
Again, quantified boolean formulae are just restricted cases of formuale of Type Theory which are all representable in the Safe Lambda Calculus using the previously defined encoding. Therefore since the True Quantified Boolean Problem (TQBF) is PSPACE-complete, deciding $\beta\eta$-equality of two terms of the Safe Lambda Calculus is PSPACE-hard.

%%We assume that the quantified propositional formula is given in prenex form:
%%$$\$_{n-1} x_{n-1} \ldots \$_0 x_0 . \psi(x_0, \ldots, x_{n-1})$$
%%where $\$_i \in \{\exists,\forall\}$ for $0\leq i\leq n-1$.
%%
%%The encoding is as follows:
%%\begin{align*}
%%\sem{1} &= T^0  : \booltype \\
%%\sem{0} &= F^0 : \booltype \\
%%\sem{x_i} &= x_i\downarrow_0 = x_i~T^{i-1}~F^{i-1}\ldots T^1~F^1: \booltype \qquad \hbox{where $x_i:\booltype_i$}\\
%%\sem{\psi_1\zand \psi_2} &= AND^0~\sem{\psi_1}~\sem{\psi_2}
%%:\booltype  \\
%%\sem{\psi_1\zor \psi_2} &= OR^0~\sem{\psi_1}~\sem{\psi_2}
%%:\booltype  \\
%%\sem{\neg \psi} &= NOT^0~\sem{\psi}
%%:\booltype  \\
%%\sem{\forall x_i.\psi(\ldots, x_i, \ldots)} & = \mathbf{D}_0^i(\lambda x^{\booltype_i}. AND^0~\sem{\psi(\ldots, x_i, \ldots)})~T^0 :\booltype\\
%%\sem{\exists x_i.\psi(\ldots, x_i, \ldots)} & = \mathbf{D}_0^i(\lambda x^{\booltype_i}.OR^0~\sem{\psi(\ldots, x_i, \ldots)})~F^0 :\booltype
%%\end{align*}
%%The size of $\sem{\psi}$ is in $\bigo(|\psi|^2)$.
%
%It is easy to check that this encoding is safe.
\begin{example}
Using the encoding where $\tau \equiv \booltype_0$ in the types $\Delta_k^n$ for all $k,n\geq 0$, the formula $\forall x \exists y \exists z (x\zor y\zor z)\zand(\neg x\zor \neg y\zor \neg z)$ is represented by the safe term:
\begin{align*}
\vdash &\mathbf{D}_0^2(\lambda x^{\booltype_2}. AND^0\\
&\quad\quad (\mathbf{D}_0^1(\lambda y^{\booltype_1}.OR^0\\
&\quad\quad\quad (\mathbf{D}_0^0(\lambda z^{\booltype_0}.OR^0\\
&\quad\quad\quad\quad (AND^0 (OR^0(OR^0~(\mathbf{C}_0^{2\mapsto 0}~x)~(\mathbf{C}_0^{1\mapsto 0}~y))z) \\
&\quad\quad\quad\quad\quad (OR^0(OR^0(NEG^0 (\mathbf{C}_0^{2\mapsto 0}~x))(NEG^0 (\mathbf{C}_0^{1\mapsto 0}~y)))(NEG^0~z))) \\
&\quad\quad\quad )F^0)\\
&\quad\quad)F^0)\\
&\quad) T^0
\end{align*}
\end{example}

\subsection{Better bounds on the complexity}
At present, no upper bound is known for the problem of deciding equality of two safe lambda terms. 

Normalization in the Safe Lambda Calculus problem
We know however 
We strongly suspect it to be hyper-exponential since at preseIt is not known at present what is t
% NP \subseteq PSPACE \subseteq EXP

