\section{Expressivity}
\subsection{Numeric functions representable in the safe lambda
calculus}

Natural numbers can be encoded into the simply-typed lambda calculus
using the Church Numerals: each $n\in\nat$ is encoded into the term
$\encode{n} = \lambda s z. s^n z$ of type $I = ((o,o),o,o)$ where
$o$ is a ground type. In 1976 Schwichtenberg \cite{citeulike:622637}
showed the following:


\begin{theorem}[Schwichtenberg 1976]
The numeric functions representable by simply-typed $\lambda$-terms
of type $I\rightarrow \ldots \rightarrow I$ using the Church Numeral
encoding are exactly the multivariate polynomials \emph{extended
with the conditional function}.
\end{theorem}

If we restrict ourselves to safe terms, the representable functions
are exactly the multivariate polynomials:
\begin{theorem}
\label{thm:polychar} The functions representable by safe
$\lambda$-expressions of type $I\rightarrow \ldots \rightarrow I$
are exactly the multivariate polynomials.
\end{theorem}

\begin{corollary}
The conditional operator $C:I\rightarrow I\rightarrow I \rightarrow
I$ verifying  $C t y z \rightarrow_\beta y$  if $t \rightarrow_\beta
\encode{0}$ and $C t y z \rightarrow_\beta z$ if $t
\rightarrow_\beta \encode{n+1}$ is not definable in the safe
simply-typed lambda calculus.
\end{corollary}
\proof
  Natural numbers are encoded using Church Numerals: $\encode{n} =
  \lambda s z. s^n z$.  Addition: For $n,m \in \nat$, $\encode{n+m} =
  \lambda \alpha^{(o,o)} x^o . (\encode{n} \alpha) (\encode{m} \alpha
  x)$. Multiplication: $\encode{n . m} = \lambda \alpha^{(o,o)}
  . \encode{n} (\encode{m} \alpha)$.  All these terms are safe and
  clearly any multivariate polynomial $P(n_1, \ldots, n_k)$ can be
  computed by composing the addition and multiplication terms as
  appropriate.

For the converse, let $U$ be a safe $\lambda$-term of type
$I\rightarrow I\rightarrow I$.  The generalization to terms of type
$I^n \rightarrow I$ for $n>2$ is immediate (they correspond to
polynomials with $n$ variables). W.l.o.g we can assume that $U =
\lambda x y \alpha z. u$ where $u$ is a safe term of ground type in
$\beta$-normal form with $fv(u) \subseteq \{ x, y : I, z :o, \alpha
: o\rightarrow o \}$.

\emph{Notation:} Let $T$ be a set of terms of type $\tau \rightarrow
\tau$ and $T'$ be a set of terms of type $\tau$ then $T \cdot T'$
denotes the set of terms $\{ s s' : \tau \ | \ s \in T \wedge s' \in
T' \}$. We also define $T^k \cdot T'$ recursively as follows:  $T^0
\cdot T' = T'$ and for $k\geq 0$, $T^{k+1} \cdot T' = T \cdot (T^k
\cdot T')$ ({\it i.e.}~$T^k \cdot T'$ denotes $\{ s_1( \ldots (s_k
s'))  \ | \ s_1, \ldots, s_k \in T \wedge s' \in T' \}$). We define
$T^+\cdot T' = \Union_{k > 0} T^k \cdot T'$ and $T^*\cdot T' =
(T^+\cdot T') \union T'$. For two sets of terms $T$ and $T'$, we
write $T =_\beta T'$ to express that any term of $T$ is
$\beta$-convertible to some term $t'$ of $T'$ and reciprocally.

Let us write $\mathcal{N}^\tau$ for the set of $\beta$-normal terms
of type $\tau$ where $\tau$ ranges in $\{ o, o\rightarrow o, I \}$
and with free variables in $\{ x,y:I, z:o, \alpha:o\rightarrow o\}$.
We write $\mathcal{A}^\tau$ for the subset of $\mathcal{N}^\tau$
consisting of applications only ({\it i.e.}~not abstractions). Let
$B$ be the set of terms of type $(o,o)$ defined by $B = \{ \alpha \}
\union \{ \lambda a.b \ | \ b \in \{a,z\}, a \neq z \}$. It is easy
to see that the following equations hold:
\begin{eqnarray*}
\mathcal{A}^I &=& \{ x,y \} \\
\mathcal{N}^{(o,o)} &=& B \union \mathcal{A}^I \cdot
\mathcal{N}^{(o,o)} = (\mathcal{A}^I)^* \cdot B \\
\mathcal{A}^{(o,o)} &=& \{ \alpha \} \union (\mathcal{A}^I)^+ \cdot B \\
\mathcal{A}^o = \mathcal{N}^o &=& \{ z \} \union \mathcal{A}^{(o,o)} \cdot \mathcal{N}^o = (\mathcal{A}^{(o,o)})^* \cdot \{ z \}
\end{eqnarray*}
Hence $\mathcal{A}^o = \left( \{\alpha \} \union \{x,y\}^+ \cdot
\left( \{\alpha \} \union \{\lambda a.b \ | \ b \in \{a,z\}, a \neq
z \} \right) \right)^* \cdot \{ z \}$. Since $u$ is safe, it cannot
contain terms of the form $\lambda a . z$ with $a \neq z$ occurring
at an operand position, therefore since $u$ belongs to
$\mathcal{A}^o$ we have:
\begin{equation}
u \in \left( \{\alpha\} \union \{x,y\}^+ \cdot \{\alpha,
\underline{i} \} \right)^* \cdot \{ z \} \label{eqn:u}
\end{equation}
where $\underline{i}$ is the identity term of type $o\rightarrow o$.


We observe that $\encode{k} \underline{i} =_\beta \underline{i}$ for
all $k \in \nat$ and for $l\geq 1$, for all $k_1, \ldots k_l \in
\nat$, $\encode{k_1}\ldots \encode{k_l} \alpha =_\beta
\encode{k_1\times \ldots \times k_l} \alpha$. Hence for all $m,n \in
\nat$ we have:
\begin{equation}
\begin{array}{llr}
\{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} &=_\beta
\{ \underline{i} \} \union
\{ \encode{m^i n^j} \alpha \ |\ i+j \geq 1 \} \nonumber \\
&= \{ \encode{m^i n^j} \alpha \ |\ i,j \geq 0 \} & ( \mbox{since } \underline{i} = \encode{0} \alpha) \end{array}
\label{eqn:intermediate}
\end{equation}
therefore:
$$\begin{array}{llr}
u[\encode{m}, \encode{n}/x,y] &\in \left( \{ \alpha \} \union \{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} \right)^* \cdot \{ z \}  & \mbox{(by Eq.\ \ref{eqn:u})} \\
&=_\beta \left( \{\alpha \} \union \{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \} \right)^* \cdot \{ z \} & \mbox{(by Eq.\ \ref{eqn:intermediate})}  \\
&=_\beta \left\{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \right\}^* \cdot \{ z \} & \mbox{($\alpha z =_\beta \encode{1} \alpha z$)}.
\end{array}$$

Furthermore, for all $m,n,r,i,j\in \nat$ we have $\encode{m^i n^j}
\alpha (\alpha^r z) =_\beta \alpha^{r + m^i n^j} z$, hence
we have $u[\encode{m} \encode{n}/x,y] =_\beta \alpha^{p(m,n)} z$ where
$p(m,n) = \sum_{0\leq k \leq d} m^{i_k} n^{j_k}$ for some $i_k,j_k
\geq 0$, $k \in\{ 0,..,d \}$ and $d\geq 0$. Thus $U \encode{m}
\encode{n} =_\beta \encode{p(m,n)}$. \qed


For instance, the term $ C = \lambda F G H \alpha x . H (
\underline{\lambda y . G \alpha x} ) (F \alpha x)$ used by
Schwichtenberg \cite{citeulike:622637} to define the conditional
operator is unsafe since the underlined subterm is of order $1$,
occurs at an operand position and contains an occurrence of $x$ of
order $0$.






\newcommand{\zaioncencode}{\underline} % Zaionc's notation for word encoding in the lambda calculus

\newcommand{\zaiwordtyp}{\mathbf{B}} % Zaionc's type for word encoded in the lambda calculus
\newcommand{\closedof}[1]{{\rm Cl}(#1)} % notation for the set of closed terms of a certain type

\newcommand{\openedof}[2]{{\rm Op}(#1,#2)} % notation for the set of opened terms M such that \fatlambda{M} in \openedof

\newcommand\wordnum[1]{\mathbf{#1}} % Zaionc's encoding of numbers as words
\newcommand\safedefset{$\lambda^{safe}${\rm def}}

\newcommand\fatlambda{\lambda\kern-0.7em\lambda}
\newcommand\wordapp{{\sf app}}
\newcommand\wordsub{{\sf sub}}


\subsection{Word functions definable in the Safe lambda calculus.}
Schwichtenberg's result on numeric functions definable in the lambda
calculus was extended to the case of other structures: Zaionc
studied the problem for words functions, then functions over trees
and eventually the general case of functions over free algebras
\cite{DBLP:journals/tcs/Leivant93,DBLP:journals/apal/Zaionc91,702481,DBLP:journals/tcs/Zaionc87}.
In this section we will consider the case of word functions
expressible in the Safe Lambda Calculus.
\smallskip

\emph{Notations} For any simple type $\tau$, we write
$\closedof{\tau}$ for the set of closed simply-terms of type $\tau$.
We consider a binary alphabet $\Sigma = \{a,b\}$. The result
naturally extend to any alphabet. We consider the set $\Sigma^*$ of
all words over $\Sigma$. The empty words is denoted $\epsilon$. We
write $|w|$ to denote the length of the word $w\in\Sigma^*$. For any
$k\in nat$ we write $\wordnum{k}$ to denote the term $a \ldots a$
with $k$ occurrences of $a$, so that $|\wordnum{k}| = k$ for any
$k\in\nat$. For any $k,n\geq 1$, we write $c(n,k)$ to denote the
n-ary function mapping constantly on the word $\wordnum{k}$. The
function $\wordapp : (\Sigma^*)^2 \rightarrow \Sigma^*$ is the usual
concatenation function: $\wordapp(x,y)$ is the word obtain by
concatenating $x$ and $y$. The substitution function $\wordsub :
(\Sigma^*)^3 \rightarrow \Sigma^*$ is defined as folllows:
$\wordsub(x,y,z)$ is the word obtained from $x$ by substituting the
word $y$ for all occurrences of $a$ and $z$ for all occurrences of
$b$.

Take the type $\zaiwordtyp = (o\typear o)\typear ((o\typear
o)\typear (o\typear o))$ called the binary word type in
\cite{DBLP:journals/tcs/Zaionc87}. There is a 1-1 correspondence
between words over $\Sigma$ and closed term of type $\zaiwordtyp$:
the empty word $\epsilon$ is represented by $\lambda u v x.x$, and
if $w\in \Sigma^*$ is represented by a term $W \in
\closedof{\zaiwordtyp}$ then $a \cdot w$ is represented by $\lambda
u v x. u(W uvx)$ and $a \cdot w$ is represented by $\lambda u v x.
v(W uvx)$. The term representing the word $w$ is denoted by
$\zaioncencode{w}$. A closed term of type $\zaiwordtyp^n \typear
\zaiwordtyp$ is called a \defname{$\lambda$-word theoretic
function}. The function on words $h:(\Sigma^*)^n \rightarrow
\Sigma^*$ is \defname{represented} by the term $H \in
\closedof{\zaiwordtyp^n \typear \zaiwordtyp}$ if and only if for all
$x_1, \ldots, x_n \in \zaiwordtyp^*$, $H \zaioncencode{x_1} \ldots
\zaioncencode{x_n} = \zaioncencode{h x_1 \ldots x_n}$. \bigskip

It was shown in \cite{DBLP:journals/tcs/Zaionc87} that there is a
finite base of word functions such that any $\lambda$-definable word
function is some composition of functions from the base:
\begin{theorem}[Zaionc, \cite{DBLP:journals/tcs/Zaionc87}]
The set of $\lambda$-definable word functions is the minimal set containing the following word functions and closed by compositions:
\begin{itemize}
  \item concatenation $\wordapp$;
  \item substitution $\wordsub$;
  \item extraction of the maximal prefix containing only a given letter;
  \item non-emptiness check:  returns $\wordnum{0}$ if the word is $\epsilon$ and $\wordnum{1}$ otherwise, as well as emptiness check;
  \item occurrence checking: returns $\wordnum{1}$ if the word contain an occurrence of a given letter and $\wordnum{0}$ otherwise;
  \item first-occurrence check:  test whether the word begins with a given letter;
  \item all the projections;
  \item all the constant functions.
\end{itemize}
\end{theorem}
The lambda terms representing the base functions are:
\begin{align*}
  {\rm APP} &= \lambda c d u v x.c u v(d u v x), & {\rm SUB} &= \lambda x d e u v x.c(\lambda y.d u v y)(\lambda y . e u v y) x, \\
  {\rm CUT}_a &= \lambda c u v x . c u (\lambda y.x) x, & {\rm CUT}_b &= \lambda c u v x . c (\lambda y.x) v x, \\
  {\rm SQ} &= \lambda c u v x . c (\lambda y.u x) (\lambda y.u x) x, & \overline{{\rm SQ}} &= \lambda c u v x . c (\lambda y.x) (\lambda y.x) (u x), \\
  {\rm BEG}_a &= \lambda c u v x . c (\lambda y.u x) (\lambda y.x) x, & {\rm BEG}_b &= \lambda c u v x . c (\lambda y.x) (\lambda y.u x) x, \\
  {\rm OCC}_a &= \lambda c u v x . c (\lambda y.u x) (\lambda y.y) x, & {\rm OCC}_b &= \lambda c u v x . c (\lambda y.y) (\lambda y.u x) x.
\end{align*}
where {\rm APP} represents concatenation, {\rm SUB} substitution,
{\rm SQ} and $\overline{{\rm SQ}}$ non-emptiness and emptiness checking, ${\rm BEG}_a$ and
${\rm BEG}_b$ first-occurrence test, and ${\rm OCC}_a$ and ${\rm OCC}_a$ occurrence test.

We observe that among these terms only {\rm APP} and {\rm SUB} are
safe. All the other terms are unsafe because they contain terms of
the form $ N (\lambda y .x)$ where $x$ and $y$ are of the same
order. It turns out that this constitutes a base of terms generating
all the functions definable in the safe lambda calculus as the
following theorem states:
\begin{theorem}
\label{thm:wordfunctions_safely_definable}
Let \safedefset\ denote the minimal set containing the following word functions and closed by compositions:
\begin{itemize}
  \item concatenation of two words;
  \item substitution of all occurrences of a given letter in some word by another word;
  \item all the projections;
  \item all the constant functions.
\end{itemize}
The set of word-functions definable definable in the Safe Lambda Calculus is precisely
\safedefset.
\end{theorem}

The proof follows the same steps as Zaionc's proof.
The first direction is immediate: the terms {\rm APP} and {\rm SUB} are safe
and represent concatenation and substitution. Projections are represented by safe terms of the form $\lambda x_1 \ldots x_n . x_i$ for some $i\in\{1..n\}$, and constant
functions by $\lambda x_1 \ldots x_n . \zaioncencode{w}$ for some $w\in\Sigma^*$.
For composition, take a functions $g:(\Sigma^*)^n \rightarrow \Sigma^*$ represented by safe term $G\in \closedof{\zaiwordtyp^n \typear \zaiwordtyp}$ and functions $f_1,\ldots,f_n :
(\Sigma^*)^p \rightarrow \Sigma^*$ represented by
safe terms $F_1,\ldots F_n$ respectively then the function $$(x_1,\ldots,x_p) \mapsto g(f_1(x_1,\ldots,x_p),\ldots,f_n(x_1,\ldots,x_p))$$ is represented by the term
$\lambda c_1\ldots x_p. G (F_1 c_1 \ldots c_p)\ldots (F_n c_1 \ldots c_p)$ which is also safe.
\bigskip

To show the other directions we need to introduce some more definitions.
We will write $\openedof{n}{k}$ to denote the set of open terms
of the form:
$$c_1:\zaiwordtyp, \ldots c_n :\zaiwordtyp, u:(o,o), v:(o,o), x_{k-1}:o, \ldots, x_0 :o \vdash M : o \ .$$
Thus  we have the following equality up to alpha-conversion:
$$\closedof{\tau(n,k)} = \{ \lambda c_1^\zaiwordtyp \ldots c_n^\zaiwordtyp u^{(o,o)} v^{(o,o)} x_{k-1}^o \ldots x_0^o . M \ | \ M \in \openedof{n}{k}  \} \ .$$

We define the type $\tau(n,k)$ where $n, k\geq1$ as $(\zaiwordtyp^n,(o,o),(o,o),\overbrace{o,\ldots,o}^{k\hbox{ times}},o)$.
and we generalized the notion of representability to terms of type $\tau(n,k)$ as follows:
\begin{definition}[Function pair representation]
A closed term $T\in\closedof{\tau(n,k)}$ \defname{represents the pair of functions}
$(f,p)$ where $f:(\Sigma^*)^n \rightarrow \Sigma^*$ and $p:(\Sigma^*)^n \rightarrow \{\wordnum{0}, \ldots, \wordnum{k-1}\}$ if for all $w_1,\ldots,w_n\in\Sigma^*$
and for every $i\in \{0\ldots,k-1\}$ we have:
$$
T \zaioncencode{w_1} \ldots \zaioncencode{w_n} =_{\beta\eta} \lambda u v x_{k-1}\ldots x_0 . \zaioncencode{f(w_1,\ldots,w_n)} u v x_{|p(w_1,\ldots,w_n)|} \ .
$$
By extension we will say that an \emph{open} term $M$ from $\openedof{n}{k}$
represents the pair $(f,p)$
iif $M[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n] =_{\beta\eta} \zaioncencode{f(w_1,\ldots,w_n)} u v x_{|p(w_1,\ldots,w_n)|}$.
\end{definition}

We will call \defname{safe pair} any pair of function of the form
$(w,c(n,i))$ where $0\leq i\leq k-1$ and $w$ is an $n$-ary function
from \safedefset.

\begin{theorem}[Characterization of the representable pairs]
\label{thm:zaionc_pair_characterization_safe} The function pairs
representable in the Safe Lambda Calculus are precisely the safe
pairs.
\end{theorem}

\begin{proof}
  (Soundness). Take a pair $(w,c(n,i))$ where
  $0\leq i\leq k-1$ and $w$ is an $n$-ary function from \safedefset.
  As observed earlier, all the functions from \safedefset\ are representable
  in the Safe Lambda Calculus: let $\zaioncencode{w}$ be the representative of $w$.
  The pair $(w,c(n,i))$ is then represented by the term
  $ \lambda c_1 \ldots c_n u v x_{k-1} \ldots x_0 . \zaioncencode{w} c_1\ldots c_n u v x_i$.
\smallskip

(Completeness) It suffices to consider safe beta-normal terms from
$\openedof{\tau(n,k)}$ only. The result then immediately follows for
any closed safe beta-normal term in $\closedof{\tau(n,k)}$. The
subset of $\openedof{\tau(n,k)}$ constituted of $\beta$-normal terms
is generated by the following grammar (see
\cite{DBLP:journals/tcs/Zaionc87}):
\begin{eqnarray*}
  (\alpha_i^k) &R^k &\rightarrow\ x_i \\
  (\beta^k) && \quad|\  u R^k \\
  (\gamma^k) && \quad|\  v R^k \\
  (\delta^k_j) && \quad|\  c_j\ (\overbrace{\lambda z^k. R^{k+1}[z^k,x_0,\ldots, x_{k-1}/x_0,x_1, \ldots, x_k]}^{Q^k(R^{k+1})}) \\
  && \quad\  \quad \ (\lambda z^k. R^{k+1}[z^k,x_0,\ldots, x_{k-1}/x_0,x_1, \ldots, x_k]) \\
  && \quad\  \quad \ R^k
\end{eqnarray*}
for $k\geq 1$, $0\leq i< k$, $0\leq j\leq n$. The notation
$M[\ldots/\ldots]$ denotes the usual simultaneous substitution. The
name of each rule is given in parenthesis. The non-terminals are
$R^k$ for $k\geq1$ and the set of terminals $\{ z^k, \lambda z^k \
|\ k\geq 1\} \union \{ x_i ~| i\geq 0 \} \union \{ c_1, \ldots, c_n,
u, v \}$.

We identify a rule name with the right-hand side of the rule, thus
$\alpha_i^k$ belongs to $\openedof{n}{k}$, $\beta^k$ and $\gamma^k$
are functions from $\openedof{n}{k}$ to $\openedof{n}{k}$, and
$\delta^k_j$ is a function from $\openedof{n}{k+1} \times
\openedof{n}{k+1} \times \openedof{n}{k}$ to $\openedof{n}{k}$.

We now want to characterize the subset consisted of all \emph{safe}
terms generated by this grammar. The term $\alpha_i^k$ is always
safe, $\beta^k(M)$ and $\gamma^k(M)$ are safe if and only if $M$ is,
and  $\delta^k_j(F,G,H)$ is safe if and only if $Q^k(F)$, $Q^k(G)$
and $H$ are safe. The free variables of $Q^k(F)$ all belong to $\{
c_1, \ldots c_n, u, v, x_0,\ldots x_{k}\}$. All these variables have
order greater than $\ord{z}$ except the $x_i$s which have same order
as $z$. Hence since the $x_i$s are not abstracted together with $z$
we have that $Q^k(F)$ is safe if and only if $F$ is safe and the
variables $x_0\ldots x_k$ do not appear free in $F[z^k,x_0,\ldots,
x_{k-1}/x_0,x_1, \ldots, x_k]$, which is the same as saying that the
variables $x_1\ldots x_k$ do not appear free in $F$. Similarly,
$Q^k(G)$ is safe if and only if $G$ is safe and variables $x_1\ldots
x_k$ do not appear free in $G$.

We therefore need to identify the subclass of terms generated by the non-terminal $R^k$ which are safe and which do not have free occurrences of variables in $\{x_1 \ldots x_{k-1}\}$. By applying this requirement to the rules of the previous grammar we obtain the following specialized grammar characterizing the desired subclass:
\begin{eqnarray*}
  (\overline\alpha_0^k) &\overline R^k &\rightarrow\ x_0 \\
  (\overline\beta^k) && \quad|\  u \overline R^k \\
  (\overline\gamma^k) && \quad|\  v \overline R^k  \\
  (\overline\delta^k_j) && \quad|\  c_j\ (\lambda z^k. \overline R^{k+1}[z^k/x_0]) \ (\lambda z^k. \overline R^{k+1} [z^k/x_0]) \ \overline R^k \ .
\end{eqnarray*}
For any term $M$, $Q^k(M)$ is safe if and only if $M$ can be
generated from the non-terminal $\overline R^k$. Thus the subset of
$\closedof{\tau(n,k)}$ consisting of safe beta-normal terms is given
by the grammar:
\begin{eqnarray*}
  (\widetilde\pi^k) &\widetilde S &\rightarrow \lambda c_1 \ldots c_n u v x_{k-1} \ldots x_0 . \widetilde R^k \\
  (\widetilde\alpha_i^k) &\widetilde R^k &\rightarrow\ x_i \\
  (\widetilde\beta^k) && \quad|\  u \widetilde R^k \\
  (\widetilde\gamma^k) && \quad|\  v \widetilde R^k \\
  (\widetilde\delta^k_j) && \quad|\  c_j\ (\lambda z^k. \overline{R^{k+1}}[z^k/x_0]) \ (\lambda z^k. \overline{R^{k+1}}[z^k/x_0]) \ \widetilde R^k \ .
\end{eqnarray*}

We now need to show that every term that can be generated by this
grammar starting with the non-terminal $\widetilde S$ represents a
safe pair.

We proceed by induction and show that the non-terminal $\overline R^k$ generates terms representing pairs of the form $(c(n,\epsilon),c(n,\wordnum{0}))$
while non-terminals $\widetilde S$ and $\widetilde R^k$ generate terms representing pairs of the form $(c(n,\epsilon),c(n,\wordnum{i}))$
for $0 \leq i<k$.

\emph{Base case:} The terms $\overline\alpha_0^k$ and
$\widetilde\alpha_i^k$ represents the pairs
$(c(n,\epsilon),c(n,\wordnum{0}))$ and
$(c(n,\epsilon),c(n,\wordnum{i}))$ respectively. \emph{Step case:}
Suppose $T\in \openedof{n}{k}$ represents
 a pair $(w,p)$.  Then $\overline\alpha^k(T)$ and
 $\widetilde\alpha^k(T)$ represent the pair
 $(\wordapp(a,w),p)$; $\overline\beta^k(T)$ and
 $\widetilde\beta^k(T)$ represent the pair
 $(\wordapp(b,w),p)$; and $\overline\pi^k(T) \in \closedof{\tau(n,k)}$ represents the pair $(w,p)$. Now suppose that $E$, $F$ and $G$ represent the pairs
 $(w_e,c(n,\wordnum{0}))$, $(w_f,c(n,\wordnum{0}))$ and $(w_g,c(n,\wordnum{i}))$ respectively.
 Then we have:
 \begin{align*}
   \widetilde \delta^k_j (E,F,G) &[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n] \\
   &= \zaioncencode{w_j}\  (\lambda z^k. E[z^k/x_0])[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n] \\
       & \qquad\quad (\lambda z^k. F[z^k/x_0])[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n] \\
       & \qquad\quad  G[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n] \\
   &=_{\beta\eta} \zaioncencode{w_j}\  (\lambda z^k. E[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n][z^k/x_0]) \\
       & \qquad\qquad (\lambda z^k. F[\zaioncencode{w_1}\ldots \zaioncencode{w_n}/c_1\ldots c_n][z^k/x_0]) \\
       & \qquad\qquad  (\zaioncencode{w_g(w_1\ldots w_n)}~u~v~x_i) \hspace{4cm}\mbox{$G$ represents $(h,c(n,i))$}\\
   &=_{\beta\eta} \zaioncencode{w_j}\  (\lambda z^k. (\zaioncencode{w_e(w_1\ldots w_n)}~u~v~x_0)[z^k/x_0]) \hspace{2cm}\mbox{$E$ represents $(f,c(n,0))$} \\
       & \qquad\qquad (\lambda z^k. (\zaioncencode{w_f(w_1\ldots w_n)}~u~v~x_0)[z^k/x_0]) \hspace{1.8cm}\mbox{$F$ represents $(g,c(n,0))$} \\
       & \qquad\qquad  (\zaioncencode{w_g(w_1\ldots w_n)}~u~v~x_i)\\
%
   &=_{\beta\eta} \zaioncencode{w_j}\  (\lambda z^k. \zaioncencode{w_e(w_1\ldots w_n)}~u~v~z^k) \\
       & \qquad\qquad (\lambda z^k. \zaioncencode{w_f(w_1\ldots w_n)}~u~v~z^k) \\
       & \qquad\qquad (\zaioncencode{w_g(w_1\ldots w_n)}~u~v~x_i)\\
%
   &=_\eta \zaioncencode{w_j}\  (\zaioncencode{w_e(w_1\ldots w_n)}~u~v)  \ (\zaioncencode{w_f(w_1\ldots w_n)}~u~v) \  (\zaioncencode{w_g(w_1\ldots w_n)}~u~v~x_i)\\
%
   &=_{\beta\eta}  \zaioncencode{w}~u~v~ x_i
 \end{align*}
where the word-function $w$ is defined as
$$w: w_1,\ldots,w_n \mapsto \wordapp(\wordsub(w_j,w_e(w_1,\ldots,w_n),w_f(w_1,\ldots,w_n)),w_g(x_1,\ldots,w_n)) \ .$$
  Hence $\widetilde \delta^k_j (E,F,G)$ represents the pair $(w,c(n,i))$.

  The same argument shows that if $E$, $F$ and $G$ all represent safe pairs
then so does $\overline \delta^k_j (E,F,G)$.
\end{proof}


By setting $k=1$ in Theorem \ref{thm:zaionc_pair_characterization_safe} we obtain that every safe term in $T \in \closedof{\tau(n,k)}$ represents some function from \safedefset. This concludes the proof of the characterization Theorem \ref{thm:wordfunctions_safely_definable}.


\subsection{Representability of other structures}\hfill

\notetoself{ What about functions on free-algebras? }
