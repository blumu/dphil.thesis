\section{Introduction}

\subsection*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and
Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars. The
idea, however, goes back some twenty years to Damm \cite{Dam82} who
introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe} grammars
  form an infinite hierarchy as $n$ varies over the natural numbers.
  The hierarchy gives an attractive classification of the
  semi-decidable languages: Levels 0, 1 and 2 of the hierarchy are
  respectively the regular, context-free, and indexed languages (in
  the sense of Aho \cite{Aho68}), although little is known about
  higher orders.

  Remarkably, for generating word languages, order-$n$ \emph{safe}
  grammars are equivalent to order-$n$ pushdown automata \cite{DG86},
  which are in turn equivalent to order-$n$ indexed grammars
  \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have decidable
    MSO theories. More precisely, the MSO theory of trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to Damm
  and Goerdt \cite{DG86} to an equivalence result with respect to
  generating trees: A ranked tree is generated by an order-$n$ \emph{safe}
  grammar if and only if it is generated by an order-$n$ pushdown
  automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a recent preprint \cite{hague-sto07}, however,
  Hague \emph{et al.} have
  shown that the MSO theories of graphs generated by order-$n$
  \emph{unsafe} grammars are undecidable, but deciding their modal
  mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}

\subsection*{Overview}

In this paper, we aim to understand the safety condition in the
setting of the lambda calculus. Our first task is to transpose it to
the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and cleaner
version where terms are no longer required to be homogeneously typed
(see Section~\ref{sec:safe} for a definition). The formation rules of
the calculus are designed to maintain a simple invariant: Variables
that occur free in a safe $\lambda$-term have orders no smaller than
that of the term itself.  We can now explain the sense in which the
safe lambda calculus is safe by establishing its salient property: No
variable capture can ever occur when substituting a safe term into
another. In other words, in the safe lambda calculus, it is
\emph{safe} to use capture-\emph{permitting} substitution when
performing $\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable names
in the input term. Safe lambda calculus is thus cheaper to compute in
this na\"ive sense. Intuitively one would expect the safety constraint
to lower the expressivity of the simply-typed lambda calculus. Our
next contribution is to give a precise measure of the expressivity
deficit of the safe lambda calculus. An old result of Schwichtenberg
\cite{citeulike:622637} says that the numeric functions representable
in the simply-typed lambda calculus are exactly the multivariate
polynomials \emph{extended with the conditional function}.  In the
same vein, we show that the numeric functions representable in the
safe lambda calculus are exactly the multivariate polynomials.

Our last contribution is to give a game-semantic account of the safe
lambda calculus.
% Not much is known about the safe $\lambda$-calculus, and many problems
% remain to be studied concerning its computational power, the
% complexity classes that it characterizes, its interpretation under the
% Curry-Howard isomorphism and its game-semantic characterization. This
% paper is a contribution to the last problem.
%
% The difficulty in giving a game-semantic account of safety lies in the
% fact that it is a syntactic restriction whereas game semantics is
% syntax-independent. The solution consists in finding a particular
% syntactic representation of terms on which the plays of the game
% denotation can be represented.  To achieve this, we use ideas recently
% introduced by the second author \cite{OngLics2006}: a term is
% canonically represented by a certain abstract syntax tree of its
% $\eta$-long normal form referred as the \emph{computation tree}. This
% abstract syntax tree is specially designed to establish a
% correspondence with the game arena of the term. A computation is
% described by a justified sequence of nodes of the computation tree
% respecting some formation rules and called a
% \emph{traversal}. Traversals permit us to model $\beta$-reductions
% without altering the structure of the computation tree via
% substitution. A notable property is that \emph{P-views} (in the
% game-semantic sense) of traversals corresponds to paths in the
% computation tree.  We show that traversals are just representations of
% the uncovering of plays of the game-semantic denotation. We then
% define a \emph{reduction} operation which eliminates traversal nodes
% that are ``internal'' to the computation, this implements the
% counterpart of the hiding operation of game semantics. Thus, we obtain
% an isomorphism between the strategy denotation of a term and the set
% of reductions of traversals of its computation tree.
Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are denoted
by \emph{P-incrementally justified strategies}. In such a strategy,
pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically, a P-question always
points to the last pending O-question (in the P-view) of a greater
order. Consequently pointers in the game semantics of safe
$\lambda$-terms are only necessary from order 4 onwards. Finally we
prove that a $\eta$-long $\beta$-normal $\lambda$-term is \emph{safe}
if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.



% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, one of us obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the forthcoming paper \cite{hague-sto07}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

% \medskip

% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph
% based on Lamping's graphs \cite{lamping} is introduced to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The safe lambda calculus}
\label{sec:safe}
\subsection*{Higher-order safe grammars}
We first present the safety restriction as it was originally defined
\cite{KNU02}. We consider simple types generated by the grammar $A \,
::= \, o \; | \; A \typear A$. By convention, $\rightarrow$ associates
to the right. Thus every type can be written as $A_1 \typear \cdots
\typear A_n \typear o$, which we shall abbreviate to $(A_1, \cdots,
A_n, o)$ (in case $n = 0$, we identify $(o)$ with $o$). The
\emph{order} of a type is given by $\ord{o} = 0$ and $\ord{A \typear
  B} = \max(\ord{A}+1, \ord{B})$. We assume an infinite set of typed
variables. The order of a typed term or symbol is defined to be the
order of its type.

A (higher-order) \defname{grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ has an
arity $\mathit{ar}(f) \geq 0$) of \emph{terminals}\footnote{Each $f \in
  \Sigma$ of arity $r \geq 0$ is assumed to have type $(\underbrace{o,
    \cdots, o}_r, o)$.}; $\mathcal{N}$ is a finite set of typed
\emph{non-terminals}; $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol; $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form $ F z_1 \ldots z_m
\rightarrow e$ where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the typed symbols in $\Sigma \union \mathcal{N} \union \{z_1,
\ldots, z_m \}$. We say that the grammar is \emph{order-$n$} just in
case the order of the highest-order non-terminal is $n$.

The \defname{tree generated by a recursion scheme} $G$ is a possibly
infinite applicative term, but viewed as a $\Sigma$-labelled tree;
it is \emph{constructed from the terminals in $\Sigma$}, and is obtained by
unfolding the rewrite rules of $G$ \emph{ad infinitum}, replacing
formal by actual parameters each time, starting from the start symbol
$S$. See e.g.~\cite{KNU02} for a formal definition.

\pssetcomptree
\parpic[r]{
$\tree[levelsep=3ex,nodesep=1pt,treesep=1cm,linewidth=0.5pt]{g}
{  \TR{a}
    \tree{g}{\TR{a} \tree{h}{\tree{h}{\vdots}}}
}$
}
\begin{example}\rm\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}

A type $(A_1, \cdots, A_n, o)$ is said to be \defname{homogeneous} if
$\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$, and each $A_1$,
\ldots, $A_n$ is homogeneous \cite{KNU02}.  We reproduce the following
definition from \cite{KNU02}.

\begin{definition}[Safe grammar]\rm
  (All types are assumed to be homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
%   A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be
%   \defname{unsafe} if the righthand term $e$ has a subterm $t$ such
%   that
% \begin{enumerate}[(i)]
% \item $t$ occurs in an {\em operand} ({\it i.e.}~second) position of some
%   occurrence of the implicit application operator {\it i.e.}~$e$ has the
%   form $\cdots (s \, t) \cdots $ for some $s$
% \item $t$ contains an occurrence of a parameter $z_i$ (say) whose
%   order is less than that of $t$.
% \end{enumerate}
% A homogeneous grammar is said to be \defname{safe} if none of its
% rewrite rules is unsafe.
\end{definition}

\begin{example}\begin{inparaenum}[(i)] \item Take $\; H : ((o, o), o), \; f : (o, o, o)$; the
    following rewrite rules are unsafe (in each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x
\end{array}\]
\item The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{inparaenum}
% The
% reader is referred to the literature
% \cite{KNU02,demirandathesis,safety-mirlong2004}
% for details about the safety restriction for higher-order grammars.
\end{example}

\subsection*{Safety adapted to the lambda calculus}
We assume a set $\Xi$ of higher-order constants.
We use sequents of the form $\Gamma \vdash_\Xi M : A$ to represent
terms-in-context where $\Gamma$ is the context and $A$ is the type of
$M$. For simplicity
we write $(A_1, \cdots, A_n, B)$ to mean $A_1 \typear \cdots \typear
A_n \typear B$, where $B$ is not necessarily ground.

\begin{definition}\rm
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus defined by induction over the
  following rules:
$$ \rulename{var} \ \rulef{}{x : A\vdash_\Xi x : A} \quad
\rulename{const} \ \rulef{}{\vdash_\Xi f : A} \quad f \in \Xi \quad
\rulename{wk} \ \rulef{\Gamma \vdash_\Xi s : A}{\Delta \vdash_\Xi s : A} \quad
\Gamma \subset \Delta$$
$$ \rulename{app} \ \rulef{\Gamma \vdash_\Xi s : (A_1,\ldots,A_n,B) \
  \Gamma \vdash_\Xi t_1 : A_1 \; \ldots \; \Gamma \vdash_\Xi t_n : A_n
} {\Gamma \vdash_\Xi s t_1 \ldots t_n : B} \ \ord{B} \sqsubseteq
\ord{\Gamma}$$
$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \vdash_\Xi s : B} {\Gamma \vdash_\Xi \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \ \ord{A_1, \ldots ,A_n,B} \sqsubseteq
\ord{\Gamma}$$ where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y
\in \Gamma \}$ and ``$c \sqsubseteq S$'' means that $c$ is a
lower-bound of the set $S$. For convenience, we shall omit the
subscript from $\vdash_\Xi$ whenever the generator-set $\Xi$ is clear from
the context.

\noindent \item The sub-system that is defined by the same rules in
(i), such that all types that occur in them are homogeneous, is called
the \defname{homogeneous safe lambda calculus}.
\end{inparaenum}
\end{definition}

The safe lambda calculus deviates from the standard definition of the simply-typed lambda calculus in a number of ways. First the rules $\rulename{app}$ and $\rulename{abs}$
respectively can perform multiple applications and abstract several
variables at once. (Of course this feature alone does not alter
expressivity.) Crucially, the side-conditions in the application rule
and abstraction rules require that variables in the typing context
have order no smaller than that of the term being formed.  We do not
impose any constraint on types. In particular, type-homogeneity as
used originally to define safe grammars \cite{KNU02} is not required
here. Another difference is that we allow $\Xi$-constants to have
arbitrary higher-order types.  % Thus our formulation
% of the safe lambda calculus is more general than the one proposed in
% the technical report \cite{safety-mirlong2004}. (It is possible to
% reconcile the two definitions by adding the further constraint that
% each type occurring in our rules is homogeneous and by restricting
% constants to at most order 1.)

\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y
))$ and $M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where
$x,y:o$ and $f:((o,o),o)$. The term $M_2$ is not safe because in the
subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{\lambda y . x} = 1$.  On the other hand, $M_1$
is safe.
%On the other hand, $M_1$ is safe as the following proof tree shows:
%$$
% \rulef{
%     \rulef{
%        \rulef{}{f \vdash f} {\sf(var)}
%        \
%        \rulef{
%             \rulef{
%                \rulef{
%                    \rulef{}{f \vdash f} {\sf(var)}
%                }
%                {f , x \vdash f } {\sf(wk)}
%                \
%                \rulef{
%                    \rulef{
%                        \rulef{}{y \vdash y} {\sf(var)}
%                    }
%                    {y \vdash \lambda y . y } \rulenamet{abs}
%                }
%                {f , x \vdash \lambda y .y } {\sf(wk)}
%             }
%             {f , x \vdash f (\lambda y .y )} {\sf(app)}
%        }
%        { f  \vdash \lambda x . f (\lambda y .y )} \rulenamet{abs}
%     }
%     {
%        f  \vdash f (\lambda x . f (\lambda y .y ))} {\sf(app)}
%     }
% { \vdash M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } \rulenamet{abs}
%$$
\end{example}

It is easy to see that valid typing judgements of the safe lambda
calculus satisfy the following simple invariant:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \vdash M : A$ then every variable in $\Gamma$ occurring
free in $M$ has order at least $ord(M)$.
\end{lemma}


When restricted to the homogeneously-typed
sub-system, the safe lambda calculus captures the original notion
of safety due to Knapik \emph{et al.} in the context of higher-order
grammars:

\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \vdash_{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} safe lambda calculus.
\end{proposition}

\emph{In what sense is the safe lambda calculus safe?} A basic idea
in the lambda calculus is that when performing $\beta$-reduction, one
must use capture-\emph{avoiding} substitution, which is standardly
implemented by renaming bound variables afresh upon each substitution.
In the safe lambda calculus, however, variable capture can never
happen (as the following lemma shows). Substitution can therefore be
implemented simply by capture-\emph{permitting} replacement, without
any need for variable renaming. In the following, we write
$M\captsubst{N}{x}$ to denote the capture-\emph{permitting}
substitution\footnote{This substitution is done by
textually replacing all free occurrences of $x$ in $M$ by $N$ without performing variable renaming.  In particular for the abstraction
  case we have
$(\lambda y_1\ldots y_n . M)\captsubst{N}{x} = \lambda y_1\ldots y_n . M\captsubst{N}{x}$ when $x\not\in
  \{ y_1\ldots y_n \}$.}
%\footnote{This substitution is implemented by textually
%  replacing all free occurrences of $x$ in $M$ by $N$ without
%  performing variable renaming.  In particular for the abstraction
%  case $(\lambda \overline{y} . P)\captsubst{N}{x}$ is defined as
%  $\lambda \overline{y} . P\captsubst{N}{x}$ if $x\not\in
%  \overline{y}$ and $\lambda \overline{y} . P$ elsewhere.}
of $N$ for $x$ in $M$.

\begin{lemma}[No variable capture]\label{lem:nvc}
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x:B \vdash M : A$ and $\Gamma \vdash  N : B$ are valid judgments of the safe lambda calculus.
\end{lemma}

\proof
  We proceed by structural induction. The variable, constant and
  application cases are trivial. For the abstraction case, suppose $M = \lambda \overline{y}. R$ where $\overline{y} = y_1
  \ldots y_p$. If $x \in \overline{y}$ then $M \captsubst{N}{x} = M$ and there is no variable capture.

 If $x \not\in \overline{y}$ then we have $M \captsubst{N}{x} = \lambda \overline{y} . R \captsubst{N}{x}$.  By the induction hypothesis there is no variable capture in $R \captsubst{N}{x}$.  Thus variable capture can only happen if the following two conditions are met: $x$ occurs freely in $R$, and some variable $y_i$ for $1 \leq i \leq p$ occurs freely in $N$. By Lemma \ref{lem:ordfreevar}, the latter condition  implies $\ord{y_i} \geq \ord{N} = \ord{x}$.  Since $x \not \in \overline{y}$, the former condition implies that $x$ occurs freely in the safe term $\lambda \overline{y}. R$
  therefore Lemma \ref{lem:ordfreevar} gives $ \ord{x} \geq
  \ord{\lambda \overline{y} . R} \geq 1+ \ord{y_i} > \ord{y_i}$ which  gives a contradiction.
\qed


\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \vdash (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    x}) : (o,o)\] one should rename the bound variable $x$ with a fresh name to
  prevent the capture of the free occurrence of $x$ in the underlined term during substitution. Consequently, by the previous lemma,
  the term is not safe. Indeed, it cannot be because $\ord{x} = 0 < 1
  = \ord{f x}$.
\end{example}

Note that it is not the case that $\lambda$-terms
that satisfy the No-variable-capture Lemma are necessarily safe. For instance the $\beta$-redex in $\lambda y^o
z^o. (\lambda x^o .y) z$ can be contracted using capture-permitting
substitution, even though the term is not safe.

\subsection*{Reductions and transformations preserving safety}

From now on we will use the standard notation $M\subst{N}{x}$ to
denote the substitution of $N$ for $x$ in $M$.  It is understood that,
provided that $M$ and $N$ are safe, this substitution is
capture-permitting.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x :B \vdash M : A$ and $\Gamma \vdash N : B$ then $\Gamma \vdash M[N/x] : A$.
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.


It is desirable to have an appropriate notion of reduction for our
calculus. However the standard $\beta$-reduction rule is not
adequate. Indeed, safety is not preserved by $\beta$-reduction as the
following example shows. Suppose that $w,x,y,z : o$ and $f : (o,o,o)
\in \Sigma$ then the safe term $(\lambda x y . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y . f z y}) w$ which is unsafe
since the underlined order-1 subterm contains a free occurrence of the
ground-type $z$. However if we perform one more reduction we obtain
the safe term $f z w$. This suggests an alternative notion of
reduction that performs simultaneous reduction of ``consecutive''
$\beta$-redexes. In order to define this reduction we first introduce
the appropriate notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:

\begin{definition}\rm
Let $l\geq 1$ and $n\geq 1$. We use the abbreviations $\overline{x}$ and $\overline{x}:\overline{A}$  for $x_1 \ldots x_n$ and $x_1:A_1, \ldots, x_n : A_n$ respectively.

A \defname{safe redex} is a safe term of the form $(\lambda
\overline{x} . M) N_1 \ldots N_l$ such that the variables
$\overline{x}$ are abstracted altogether by one instance of the
\rulenamet{abs} rule (possibly followed by \rulenamet{wk}) and the
term $(\lambda \overline{x}.M)$ is applied to $N_1$, \ldots, $N_l$
by one instance of the \rulenamet{app} rule. Thus $M$, the and the
$N_i$'s are also safe.
\end{definition}
For instance, in the case $n<l$, a safe redex has a derivation tree of the following  form:
$$   \rulef{
            \rulef{\rulef{\rulef{\ldots}{\Gamma', \overline{x}:\overline{A} \vdash M : (A_{n+1}, \ldots, A_l, B)}}{\Gamma' \vdash \lambda \overline{x} . M : (A_1, \ldots, A_l, B)} \rulename{abs}}{\Gamma \vdash \lambda \overline{x} . M : (A_1, \ldots, A_l, B)}\rulename{wk}
            \quad
            \rulef{\ldots}{\Gamma \vdash N_1 :A_1}  \ \ldots \  \rulef{\ldots}{\Gamma \vdash N_l :A_l}
    }
    {
       \Gamma \vdash (\lambda \overline{x} . M) N_1 \ldots N_l : B
    } \rulename{app}
$$


We are now in a position to define a notion of reduction for safe terms.
\begin{definition}\rm
\label{dfn:safereduction} We use the
abbreviations $\overline{x} = x_1 \ldots x_n$,
$\overline{N} = N_1 \ldots N_l$.
The relation $\beta_s$ is defined on the set of safe redexes as:
\begin{eqnarray*}
  \beta_s &=&
  \{  \ (\lambda \overline{x} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1 \ldots x_l} \mbox{, for $n> l$}
  \} \\
  &\cup&
  \{ \ (\lambda \overline{x}  . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}
where $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution in $M$ of $R_1$,\ldots,$R_k$ for $z_1, \ldots, z_k$.  The
\defname{safe $\beta$-reduction}, written $\betasred$, is the
compatible closure of the relation $\beta_s$ with respect to the
formation rules of the safe lambda calculus.
\end{definition}

\noindent \emph{Remark:} The $\beta_s$-reduction is a multi-step
$\beta$-reduction \ie it is a subset of the transitive closure of $\betared$.


\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:safered_preserve_safety}
If $\Gamma \vdash s :A$ and $s \betasred t$ then $\Gamma \vdash t :A$.
\end{lemma}

\proof
  It suffices to show that the relation $\beta_s$ preserves safety.
Suppose that $s\ \beta_s\ t$ where $s$ is the
safe-redex $(\lambda x_1 \ldots x_n . M) N_1
  \ldots N_l $ with $x_1 : B_1, \ldots, x_n: B_n$
and $M$ of type $C$.  W.l.o.g we can assume that the last rule used
to form the term $s$ is \rulenamet{app} (and not the weakening rule
\rulenamet{wk}, thus  we have $\Gamma = fv(s)$.

Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$. By Lemma \ref{lem:subst_preserve_safety} we can form the safe term %\begin{equation}
$\Gamma, x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\vdash M\subst{\overline{N}}{x_1 \ldots x_l} : C$. %\label{jud:substsafe}\ .
%\end{equation}
By Lemma \ref{lem:ordfreevar}, since $s$ is safe, all the variables
in $\Gamma$ have order $\geq \ord{A}$. This ensures that the
side-condition of the \rulenamet{abs} rule is verified when
abstracting the variables $x_{l+1} \ldots x_n$, which gives us the
judgement $\Gamma \vdash t :A$.

Suppose $n \leq l$. The substitution lemma gives
$\Gamma \vdash M\subst{N_1 \ldots N_n}{\overline{x}} : C$ and using \rulenamet{app} we form $\Gamma \vdash t :A$.
  \qed


In general, safety is not preserved by $\eta$-expansion; for instance we have
% $f:o,o \vdash f$ but $f:o,o \not \vdash \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\vdash \lambda y^o z^o . y : (o,o,o)$ but
$\not \vdash \lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$.
However safety is preserved by $\eta$-reduction:

\begin{lemma}[$\eta$-reduction preserves safety]
  $\Gamma \vdash \lambda \varphi . s \varphi :A $ with $\varphi$ not
  occurring free in $s$ implies $\Gamma \vdash s :A$.
\end{lemma}
\proof
  Suppose $\Gamma \vdash \lambda \varphi . s \varphi :A$. If $s$ is an  abstraction then by construction of the safe term $\lambda \varphi . s \varphi$, $s$ is necessarily safe.  If $s = N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for any $z\in fv(\lambda \varphi . s \varphi)$, $\ord{z} \geq
  \ord{\lambda \varphi . s \varphi} = \ord{s}$. Since  $\varphi$ does not occur free in $s$ we have $fv(s) = fv(\lambda \varphi . s \varphi)$, thus we can use the application rule to form $fv(s) \vdash N_0 \ldots N_p : A$. The weakening rules permits us to conclude $\Gamma \vdash s :A$. \qed



The $\eta$-long normal form (or simply $\eta$-long form) of a term
% (also called \emph{long reduced form}, \emph{$\eta$-normal form} and
% \emph{extensional form} in the literature
% \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding every subterm occurring
at an operand position. Formally the \defname{$\eta$-long form}
$\elnf{t}$ of a term $t: (A_1,\ldots,A_n,o)$ with $n \geq 0$ is
defined by cases according to the syntactic shape of $t$:
\begin{eqnarray*}
  \elnf{\lambda x . s } &=& \lambda x . \elnf{s} \\
  \elnf{x s_1 \ldots s_m } &=& \lambda \overline{\varphi} . x \elnf{s_1}\ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x . s) s_1 \ldots s_p } &=& \lambda \overline{\varphi} . (\lambda x . \elnf{s}) \elnf{s_1} \ldots \elnf{s_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is a  variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.

%\begin{remark}
%  Converting a term to its $\eta$-long normal form does not introduce
%  new redex therefore the $\eta$-long normal form of $\beta$-normal
%  term is a $\beta$-normal term.
%\end{remark}

\begin{lemma}[$\eta$-long normalization preserves safety]
\label{lem:elnf_preserves_safety}
If $\Gamma \vdash s :A$ then $\Gamma \vdash \elnf{s} :A$.
\end{lemma}
\proof

 First we observe that for any variable or constant $x:A$ we have $x:A \vdash \elnf{x} :A$. We show this by induction on $\ord{x}$.
It is verified for any ground type variable $x$
since $x = \elnf{x}$.
Step case: $x:A$ with $A=(A_1, \ldots, A_n,o)$ and $n>0$. Let $\varphi_i:A_i$ be fresh variables for $1\leq i\leq n$.
Since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i :A_i \vdash \elnf{\varphi_i} : A_i$. Using \rulenamet{wk} we obtain $x:A, \overline{\varphi} : \overline{A}
  \vdash \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \vdash x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \vdash \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} =
  \elnf{x} :A$.


We now prove the lemma by induction on $s$.
The base case is covered by the previous observation.
\emph{Step case:}
\begin{compactitem}
\item $s = x s_1 \ldots s_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $s_i : B_i$ for $1 \leq i \leq
  m$.  Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \vdash \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \vdash \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \vdash x s_1 \ldots s_m : A$ is formed using the \rulenamet{app} rule, each $s_j$ must be safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \vdash \elnf{s_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \vdash \elnf{s_j} : B_j$.  The \rulenamet{app}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \vdash x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the \rulenamet{abs} rule gives $\Gamma \vdash \lambda \overline{\varphi} . x
  \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} = \elnf{s} : A$, the side-condition of \rulenamet{abs} being verified since $\ord{\elnf{s}} = \ord{s}$.


\item $s = t s_0 \ldots s_m$ where $t$ is an abstraction.
For some fresh variables $\varphi_1$, \ldots, $\varphi_n$
we have $\elnf{s} = \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n}$. Again, using the induction hypothesis we can easily derive $\Gamma \vdash
 \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : A$.

\item $s = \lambda \overline{\eta} . t $ where
$\overline{\eta} : \overline{B}$ and $t:C$ is not an abstraction. The induction hypothesis gives $\Gamma,
  \overline{\eta} : \overline{B} \vdash \elnf{t} : C$ and using
\rulenamet{abs} we get $\Gamma \vdash \lambda \overline{\eta} . \elnf{t} = \elnf{s} : A$.  \qed
\end{compactitem}


Note that the converse does not hold in general, for instance $\lambda
x^o . f^{(o,o,o)} x^o$ is unsafe although $\elnf{\lambda x . f x} =
\lambda x^o y^o . f x y$ is safe.


%\notetoself{Check and prove the following lemma}
% For terms with homogeneous types however, the converse does hold:
%\begin{lemma}
%If $\Gamma \vdash \elnf{s} : T$ is homogeneously safe (i.e. it is a
%safe judgement of the safe $\lambda$-calculus and each sequent
%occurring at the nodes of the proof tree is homogeneously typed)
%then $\Gamma \vdash s :T$ is homogeneously safe.
%\end{lemma}
