\newcommand\sentail{\vdash_{\sf s}} % safe entailment
\newcommand\isentail{\vdash_{\sf is}} % intrinsically safe entailment
\newcommand\asentail{\vdash_{\sf as}} % almost safe entailment
\newcommand\stentail{\vdash_{\sf st}} % entailment for simply-typed term

\section*{Introduction}

\subsection*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and
Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars. The
idea, however, goes back some twenty years to Damm \cite{Dam82} who
introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe} grammars
  form an infinite hierarchy as $n$ varies over the natural numbers.
  The hierarchy gives an attractive classification of the
  semi-decidable languages: Levels 0, 1 and 2 of the hierarchy are
  respectively the regular, context-free, and indexed languages (in
  the sense of Aho \cite{Aho68}), although little is known about
  higher orders.

  Remarkably, for generating word languages, order-$n$ \emph{safe}
  grammars are equivalent to order-$n$ pushdown automata \cite{DG86},
  which are in turn equivalent to order-$n$ indexed grammars
  \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have decidable
    MSO theories. More precisely, the MSO theory of trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to Damm
  and Goerdt \cite{DG86} to an equivalence result with respect to
  generating trees: A ranked tree is generated by an order-$n$ \emph{safe}
  grammar if and only if it is generated by an order-$n$ pushdown
  automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a recent preprint \cite{hague-sto07}, however,
  Hague \emph{et al.} have
  shown that the MSO theories of graphs generated by order-$n$
  \emph{unsafe} grammars are undecidable, but deciding their modal
  mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}

\subsection*{Overview}

In this paper, we aim to understand the safety condition in the
setting of the lambda calculus. Our first task is to transpose it to
the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and cleaner
version where terms are no longer required to be homogeneously typed
(see Section~\ref{sec:safe} for a definition). The formation rules of
the calculus are designed to maintain a simple invariant: Variables
that occur free in a safe $\lambda$-term have orders no smaller than
that of the term itself.  We can now explain the sense in which the
safe lambda calculus is safe by establishing its salient property: No
variable capture can ever occur when substituting a safe term into
another. In other words, in the safe lambda calculus, it is
\emph{safe} to use capture-\emph{permitting} substitution when
performing $\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable names
in the input term. Safe lambda calculus is thus cheaper to compute in
this na\"ive sense. Intuitively one would expect the safety constraint
to lower the expressivity of the simply-typed lambda calculus. Our
next contribution is to give a precise measure of the expressivity
deficit of the safe lambda calculus. An old result of Schwichtenberg
\cite{citeulike:622637} says that the numeric functions representable
in the simply-typed lambda calculus are exactly the multivariate
polynomials \emph{extended with the conditional function}.  In the
same vein, we show that the numeric functions representable in the
safe lambda calculus are exactly the multivariate polynomials.

Our last contribution is to give a game-semantic account of the safe
lambda calculus.
% Not much is known about the safe $\lambda$-calculus, and many problems
% remain to be studied concerning its computational power, the
% complexity classes that it characterizes, its interpretation under the
% Curry-Howard isomorphism and its game-semantic characterization. This
% paper is a contribution to the last problem.
%
% The difficulty in giving a game-semantic account of safety lies in the
% fact that it is a syntactic restriction whereas game semantics is
% syntax-independent. The solution consists in finding a particular
% syntactic representation of terms on which the plays of the game
% denotation can be represented.  To achieve this, we use ideas recently
% introduced by the second author \cite{OngLics2006}: a term is
% canonically represented by a certain abstract syntax tree of its
% $\eta$-long normal form referred as the \emph{computation tree}. This
% abstract syntax tree is specially designed to establish a
% correspondence with the game arena of the term. A computation is
% described by a justified sequence of nodes of the computation tree
% respecting some formation rules and called a
% \emph{traversal}. Traversals permit us to model $\beta$-reductions
% without altering the structure of the computation tree via
% substitution. A notable property is that \emph{P-views} (in the
% game-semantic sense) of traversals corresponds to paths in the
% computation tree.  We show that traversals are just representations of
% the uncovering of plays of the game-semantic denotation. We then
% define a \emph{reduction} operation which eliminates traversal nodes
% that are ``internal'' to the computation, this implements the
% counterpart of the hiding operation of game semantics. Thus, we obtain
% an isomorphism between the strategy denotation of a term and the set
% of reductions of traversals of its computation tree.
Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are denoted
by \emph{P-incrementally justified strategies}. In such a strategy,
pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically, a P-question always
points to the last pending O-question (in the P-view) of a greater
order. Consequently pointers in the game semantics of safe
$\lambda$-terms are only necessary from order 4 onwards. Finally we
prove that a $\eta$-long $\beta$-normal $\lambda$-term is \emph{safe}
if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.



% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, one of us obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the forthcoming paper \cite{hague-sto07}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

% \medskip

% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph
% based on Lamping's graphs \cite{lamping} is introduced to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The safe lambda calculus}
\label{sec:safe}
\subsection*{Higher-order safe grammars}
We first present the safety restriction as it was originally defined
\cite{KNU02}. We consider simple types generated by the grammar $A \,
::= \, o \; | \; A \typear A$. By convention, $\rightarrow$ associates
to the right. Thus every type can be written as $A_1 \typear \cdots
\typear A_n \typear o$, which we shall abbreviate to $(A_1, \cdots,
A_n, o)$ (in case $n = 0$, we identify $(o)$ with $o$). The
\emph{order} of a type is given by $\ord{o} = 0$ and $\ord{A \typear
  B} = \max(\ord{A}+1, \ord{B})$. We assume an infinite set of typed
variables. The order of a typed term or symbol is defined to be the
order of its type.

A (higher-order) \defname{grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ has an
arity $\mathit{ar}(f) \geq 0$) of \emph{terminals}\footnote{Each $f \in
  \Sigma$ of arity $r \geq 0$ is assumed to have type $(\underbrace{o,
    \cdots, o}_r, o)$.}; $\mathcal{N}$ is a finite set of typed
\emph{non-terminals}; $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol; $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form $ F z_1 \ldots z_m
\rightarrow e$ where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the typed symbols in $\Sigma \union \mathcal{N} \union \{z_1,
\ldots, z_m \}$. We say that the grammar is \emph{order-$n$} just in
case the order of the highest-order non-terminal is $n$.

The \defname{tree generated by a recursion scheme} $G$ is a possibly
infinite applicative term, but viewed as a $\Sigma$-labelled tree;
it is \emph{constructed from the terminals in $\Sigma$}, and is obtained by
unfolding the rewrite rules of $G$ \emph{ad infinitum}, replacing
formal by actual parameters each time, starting from the start symbol
$S$. See e.g.~\cite{KNU02} for a formal definition.

\pssetcomptree
\parpic[r]{
$\tree[levelsep=3ex,nodesep=1pt,treesep=1cm,linewidth=0.5pt]{g}
{  \TR{a}
    \tree{g}{\TR{a} \tree{h}{\tree{h}{\vdots}}}
}$
}
\begin{example}\rm\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}

A type $(A_1, \cdots, A_n, o)$ is said to be \defname{homogeneous} if
$\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$, and each $A_1$,
\ldots, $A_n$ is homogeneous \cite{KNU02}.  We reproduce the following
definition from \cite{KNU02}.

\begin{definition}[Safe grammar]\rm
  (All types are assumed to be homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
%   A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be
%   \defname{unsafe} if the righthand term $e$ has a subterm $t$ such
%   that
% \begin{enumerate}[(i)]
% \item $t$ occurs in an {\em operand} ({\it i.e.}~second) position of some
%   occurrence of the implicit application operator {\it i.e.}~$e$ has the
%   form $\cdots (s \, t) \cdots $ for some $s$
% \item $t$ contains an occurrence of a parameter $z_i$ (say) whose
%   order is less than that of $t$.
% \end{enumerate}
% A homogeneous grammar is said to be \defname{safe} if none of its
% rewrite rules is unsafe.
\end{definition}

\begin{example}\begin{inparaenum}[(i)] \item Take $H : ((o, o), o)$ and $f : (o, o, o)$; the
    following rewrite rules are unsafe (in each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x
\end{array}\]
\item The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{inparaenum}
% The
% reader is referred to the literature
% \cite{KNU02,demirandathesis,safety-mirlong2004}
% for details about the safety restriction for higher-order grammars.
\end{example}

\subsection*{Safety adapted to the lambda calculus}
We assume a set $\Xi$ of higher-order constants.
We use sequents of the form $\Gamma \vdash^\Xi M : A$ to represent
terms-in-context where $\Gamma$ is the context and $A$ is the type of
$M$. We will write $\Gamma \stentail^\Xi M : A$ to denote a term-in-context generated from the rules of the simply-typed lambda calculus augmented with constants from $\Xi$.
For simplicity
we write $(A_1, \cdots, A_n, B)$ to mean $A_1 \typear \cdots \typear
A_n \typear B$, where $B$ is not necessarily ground.

\begin{definition}\rm
\label{def:safelambda}
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus defined by induction over the
  following Church-style system of rules:
$$ \rulename{var} \ \rulef{}{x : A\sentail^\Xi x : A} \qquad
\rulename{const} \ \rulef{}{\sentail^\Xi f : A}\quad f \in \Xi \qquad
\rulename{wk} \ \rulef{\Gamma \sentail^\Xi s : A}{\Delta \sentail^\Xi s : A}\quad
\Gamma \subset \Delta$$

$$ \rulename{app} \ \rulef{\Gamma \sentail^\Xi s : (A_1,\ldots,A_n,B)
\quad
  \Gamma \sentail^\Xi t_1 : A_1 \quad \ldots \quad \Gamma \sentail^\Xi t_n : A_n
} {\Gamma \sentail^\Xi s t_1 \ldots t_n : B} \quad \ord{B} \sqsubseteq
\ord{\Gamma}$$

$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \sentail^\Xi s : B} {\Gamma \sentail^\Xi \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{A_1, \ldots ,A_n,B} \sqsubseteq
\ord{\Gamma}$$
\smallskip

where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$
and ``$c \sqsubseteq S$'' means that $c$ is a lower-bound of the set
$S$. For convenience, we shall omit the superscript from $\sentail^\Xi$
whenever the generator-set $\Xi$ is clear from the context.

\noindent \item The sub-system that is defined by the same rules in
(i), such that all types that occur in them are homogeneous, is called
the \defname{homogeneous safe lambda calculus}.
\end{inparaenum}
\end{definition}
\notetoself{An equivalent notion of homogeneous safe lambda calculus is given in de Miranda's thesis \cite{demirandathesis}. }


The safe lambda calculus deviates from the standard definition of
the simply-typed lambda calculus in a number of ways. First the
rules $\rulename{app}$ and $\rulename{abs}$ respectively can perform
multiple applications and abstract several variables at once. (Of
course this feature alone does not alter expressivity.) Crucially,
the side conditions in the application rule and abstraction rule
require the variables in the typing context to have orders no
smaller than that of the term being formed.  We do not impose any
constraint on types. In particular, type-homogeneity, which was an
assumption of the original definition of safe grammars \cite{KNU02},
is not required here. Another difference is that we allow
$\Xi$-constants to have
arbitrary higher-order types.  % Thus our formulation
% of the safe lambda calculus is more general than the one proposed in
% the technical report \cite{safety-mirlong2004}. (It is possible to
% reconcile the two definitions by adding the further constraint that
% each type occurring in our rules is homogeneous and by restricting
% constants to at most order 1.)

\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y
))$ and $M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where
$x,y:o$ and $f:((o,o),o)$. The term $M_2$ is not safe because in the
subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{\lambda y . x} = 1$.  On the other hand, $M_1$
is safe.
%On the other hand, $M_1$ is safe as the following proof tree shows:
%$$
% \rulef{
%     \rulef{
%        \rulef{}{f \sentail f} {\sf(var)}
%        \
%        \rulef{
%             \rulef{
%                \rulef{
%                    \rulef{}{f \sentail f} {\sf(var)}
%                }
%                {f , x \sentail f } {\sf(wk)}
%                \
%                \rulef{
%                    \rulef{
%                        \rulef{}{y \sentail y} {\sf(var)}
%                    }
%                    {y \sentail \lambda y . y } \rulenamet{abs}
%                }
%                {f , x \sentail \lambda y .y } {\sf(wk)}
%             }
%             {f , x \sentail f (\lambda y .y )} {\sf(app)}
%        }
%        { f  \sentail \lambda x . f (\lambda y .y )} \rulenamet{abs}
%     }
%     {
%        f  \sentail f (\lambda x . f (\lambda y .y ))} {\sf(app)}
%     }
% { \sentail M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } \rulenamet{abs}
%$$
\end{example}

It is easy to see that valid typing judgements of the safe lambda
calculus satisfy the following simple invariant:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \sentail M : A$ then every variable in $\Gamma$ occurring
free in $M$ has order at least $ord(M)$.
\end{lemma}


When restricted to the homogeneously-typed sub-system, the safe
lambda calculus captures the original notion of safety due to Knapik
\emph{et al.}~in the context of higher-order grammars:

\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe (in the original sense of Knapik \emph{et al.}) if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \sentail^{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} safe lambda calculus.
\end{proposition}

\notetoself{See \cite{demirandathesis} for a proof.}

\emph{In what sense is the safe lambda calculus safe?} It is an
elementary fact that when performing $\beta$-reduction in the lambda
calculus, one must use capture-\emph{avoiding} substitution, which
is standardly implemented by renaming bound variables afresh upon
each substitution. In the safe lambda calculus, however, variable
capture can never happen (as the following lemma shows).
Substitution can therefore be implemented simply by
capture-\emph{permitting} replacement, without any need for variable
renaming. In the following, we write $M\captsubst{N}{x}$ to denote
the capture-\emph{permitting} substitution\footnote{This
substitution is done by textually replacing all free occurrences of
$x$ in $M$ by $N$ without performing variable renaming.  In
particular for the abstraction
  case we have
$(\lambda y_1\ldots y_n . M)\captsubst{N}{x} = \lambda y_1\ldots y_n . M\captsubst{N}{x}$ when $x\not\in
  \{ y_1\ldots y_n \}$.}
%\footnote{This substitution is implemented by textually
%  replacing all free occurrences of $x$ in $M$ by $N$ without
%  performing variable renaming.  In particular for the abstraction
%  case $(\lambda \overline{y} . P)\captsubst{N}{x}$ is defined as
%  $\lambda \overline{y} . P\captsubst{N}{x}$ if $x\not\in
%  \overline{y}$ and $\lambda \overline{y} . P$ elsewhere.}
of $N$ for $x$ in $M$.

\begin{lemma}[No variable capture]\label{lem:nvc}
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x:B \sentail M : A$ and $\Gamma \sentail  N : B$ are valid judgments of the safe lambda calculus.
\end{lemma}

\proof
  We proceed by structural induction. The variable, constant and
  application cases are trivial. For the abstraction case, suppose $M = \lambda \overline{y}. R$ where $\overline{y} = y_1
  \ldots y_p$. If $x \in \overline{y}$ then $M \captsubst{N}{x} = M$ and there is no variable capture.

 If $x \not\in \overline{y}$ then we have $M \captsubst{N}{x} = \lambda \overline{y} . R \captsubst{N}{x}$.  By the induction hypothesis there is no variable capture in $R \captsubst{N}{x}$.  Thus variable capture can only happen if the following two conditions are met: $x$ occurs freely in $R$, and some variable $y_i$ for $1 \leq i \leq p$ occurs freely in $N$. By Lemma \ref{lem:ordfreevar}, the latter condition  implies $\ord{y_i} \geq \ord{N} = \ord{x}$ and  since $x \not \in \overline{y}$, the former condition implies that $x$ occurs freely in the safe term $\lambda \overline{y}. R$
  therefore Lemma \ref{lem:ordfreevar} gives $ \ord{x} \geq
  \ord{\lambda \overline{y} . R} \geq 1+ \ord{y_i} > \ord{y_i}$ which  gives a contradiction.
\qed


\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \stentail (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    x}) : (o,o)\] one should rename the bound variable $x$ with a fresh name to
  prevent the capture of the free occurrence of $x$ in the underlined term during substitution. Consequently, by the previous lemma,
  the term is not safe (because $\ord{x} = 0 < 1
  = \ord{f x}$).
\end{example}

Note that $\lambda$-terms that `satisfy' the No-variable-capture
Lemma are not necessarily safe. For instance the $\beta$-redex in
$\lambda y^o z^o. (\lambda x^o .y) z$ can be contracted using
capture-permitting substitution, even though the term is not safe.

\subsection*{Reductions and transformations preserving safety}

From now on we will use the standard notation $M\subst{N}{x}$ to
denote the substitution of $N$ for $x$ in $M$.  It is understood that,
provided that $M$ and $N$ are safe, this substitution is
capture-permitting.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x :B \sentail M : A$ and $\Gamma \sentail N : B$ then $\Gamma \sentail M[N/x] : A$.
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.


It is desirable to have an appropriate notion of reduction for our
calculus. However the standard $\beta$-reduction rule is not
adequate. Indeed, safety is not preserved by $\beta$-reduction as
the following example shows. Suppose that $w,x,y,z : o$ and $f :
(o,o,o) \in \Sigma$ then the safe term $(\lambda x y . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y . f z y}) w$ which is
unsafe since the underlined order-1 subterm contains a free
occurrence of the ground-type $z$. However if we perform one more
reduction we obtain the safe term $f z w$. This suggests
simultaneous contraction of ``consecutive'' $\beta$-redexes. In
order to define this notion of reduction we first introduce the
corresponding notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:

\begin{definition}\rm
Let $l\geq 1$ and $n\geq 1$. We use the abbreviations $\overline{x}$
and $\overline{x}:\overline{A}$  for $x_1 \ldots x_n$ and $x_1:A_1,
\ldots, x_n : A_n$ respectively. A \defname{safe redex} is a safe
term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such
that the variables $\overline{x}$ are abstracted altogether by one
application of the \rulenamet{abs} rule (possibly followed by
\rulenamet{wk}) and the term $(\lambda \overline{x}.M)$ is applied
to $N_1$, \ldots, $N_l$ by one application of the \rulenamet{app}
rule.
\end{definition}
For instance, in the case $n<l$, a safe redex has a derivation tree of the following  form:
$$   \rulef{
            \rulef{\rulef{\rulef{\ldots}{\Gamma', \overline{x}:\overline{A} \sentail M : (A_{n+1}, \ldots, A_l, B)}}{\Gamma' \sentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)} \rulename{abs}}{\Gamma \sentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)}\rulename{wk}
            \quad
            \rulef{\ldots}{\Gamma \sentail N_1 :A_1}  \ \ldots \  \rulef{\ldots}{\Gamma \sentail N_l :A_l}
    }
    {
       \Gamma \sentail (\lambda \overline{x} . M) N_1 \ldots N_l : B
    } \rulename{app}
$$


We can now define a notion of reduction for safe terms.
\begin{definition}\rm
\label{dfn:safereduction} We use the abbreviations $\overline{x} =
x_1 \ldots x_n$, $\overline{N} = N_1 \ldots N_l$. The relation
$\beta_s$ (when viewed as a function) is defined on the set of safe
redexes as follows:
\begin{eqnarray*}
  \beta_s &=&
  \{  \ (\lambda \overline{x} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1 \ldots x_l} \mbox{, for $n> l$}
  \} \\
  &\cup&
  \{ \ (\lambda \overline{x}  . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}
where $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution in $M$ of $R_1$,\ldots,$R_k$ for $z_1, \ldots, z_k$.  The
\defname{safe $\beta$-reduction}, written $\betasred$, is the
compatible closure of the relation $\beta_s$ with respect to the
formation rules of the safe lambda calculus.
\end{definition}

\noindent \emph{Remark:} The safe $\beta$-reduction is a multi-step
$\beta$-reduction \ie it is a subset of the transitive closure of
$\betared$.


\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:safered_preserve_safety}
If $\Gamma \sentail s :A$ and $s \betasred t$ then $\Gamma \sentail t :A$.
\end{lemma}

\proof
  It suffices to show that the relation $\beta_s$ preserves safety.
Suppose that $s\ \beta_s\ t$ where $s$ is the
safe-redex $(\lambda x_1 \ldots x_n . M) N_1
  \ldots N_l $ with $x_1 : B_1, \ldots, x_n: B_n$
and $M$ of type $C$.  W.l.o.g we can assume that the last rule used
to form the term $s$ is \rulenamet{app} (and not the weakening rule
\rulenamet{wk}, thus  we have $\Gamma = fv(s)$.

Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$. By Lemma \ref{lem:subst_preserve_safety} we can form the safe term %\begin{equation}
$\Gamma, x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\sentail M\subst{\overline{N}}{x_1 \ldots x_l} : C$. %\label{jud:substsafe}\ .
%\end{equation}
By Lemma \ref{lem:ordfreevar}, since $s$ is safe, all the variables
in $\Gamma$ have order $\geq \ord{A}$. This ensures that the
side-condition of the \rulenamet{abs} rule is verified when
abstracting the variables $x_{l+1} \ldots x_n$, which gives us the
judgement $\Gamma \sentail t :A$.

Suppose $n \leq l$. The Substitution Lemma gives $\Gamma \sentail
M\subst{N_1 \ldots N_n}{\overline{x}} : C$ and using \rulenamet{app}
we form $\Gamma \sentail t :A$.
  \qed


In general, safety is not preserved by $\eta$-expansion: for
instance we have
% $f:o,o \sentail f$ but $f:o,o \not \sentail \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\sentail \lambda y^o z^o . y : (o,o,o)$ but
$\not \sentail\lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$.
However safety is preserved by $\eta$-reduction:

\begin{lemma}[$\eta$-reduction of one variable preserves safety]
\label{lem:etared_preserve_safety}
  $\Gamma \sentail \lambda \varphi . s \varphi :A $ with $\varphi$ not
  occurring free in $s$ implies $\Gamma \sentail s :A$.
\end{lemma}
\proof
  Suppose $\Gamma \sentail \lambda \varphi . s \varphi :A$. If $s$ is an  abstraction then by construction of the safe term $\lambda \varphi . s \varphi$, $s$ is necessarily safe.  If $s = N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for any $z\in fv(\lambda \varphi . s \varphi)$, $\ord{z} \geq
  \ord{\lambda \varphi . s \varphi} = \ord{s}$. Since  $\varphi$ does not occur free in $s$ we have $fv(s) = fv(\lambda \varphi . s \varphi)$, thus we can use the application rule to form $fv(s) \sentail N_0 \ldots N_p : A$. The weakening rules permits us to conclude $\Gamma \sentail s :A$. \qed



The $\eta$-long normal form (or simply $\eta$-long form) of a term
% (also called \emph{long reduced form}, \emph{$\eta$-normal form} and
% \emph{extensional form} in the literature
% \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding every subterm occurring
at an operand position (\ie occurring in the second argument of some
occurrence of the binary application operator, that is to say in $v$
for some subterm of the form $\ldots (t~v) \ldots$). Formally the
\defname{$\eta$-long form}, written $\elnf{t}$, of a term $t:
(A_1,\ldots,A_n,o)$ with $n \geq 0$ is defined by cases according to
the syntactic shape of $t$:
\begin{eqnarray*}
  \elnf{\lambda x . s } &=& \lambda x . \elnf{s} \\
  \elnf{x s_1 \ldots s_m } &=& \lambda \overline{\varphi} . x \elnf{s_1}\ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x . s) s_1 \ldots s_p } &=& \lambda \overline{\varphi} . (\lambda x . \elnf{s}) \elnf{s_1} \ldots \elnf{s_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is a  variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.

%\begin{remark}
%  Converting a term to its $\eta$-long normal form does not introduce
%  new redex therefore the $\eta$-long normal form of $\beta$-normal
%  term is a $\beta$-normal term.
%\end{remark}

\begin{lemma}[$\eta$-long normalization preserves safety]
\label{lem:elnf_preserves_safety}
If $\Gamma \sentail s :A$ then $\Gamma \sentail \elnf{s} :A$.
\end{lemma}
\proof

 First we observe that for any variable or constant $x:A$ we have $x:A \sentail \elnf{x} :A$. We show this by induction on $\ord{x}$.
It is verified for any ground type variable $x$
since $x = \elnf{x}$.
Step case: $x:A$ with $A=(A_1, \ldots, A_n,o)$ and $n>0$. Let $\varphi_i:A_i$ be fresh variables for $1\leq i\leq n$.
Since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i :A_i \sentail \elnf{\varphi_i} : A_i$. Using \rulenamet{wk} we obtain $x:A, \overline{\varphi} : \overline{A}
  \sentail \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \sentail x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \sentail \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} =
  \elnf{x} :A$.


We now prove the lemma by induction on $s$.
The base case is covered by the previous observation.
\emph{Step case:}
\begin{compactitem}
\item $s = x s_1 \ldots s_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $s_i : B_i$ for $1 \leq i \leq
  m$.  Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \sentail \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \sentail \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \sentail x s_1 \ldots s_m : A$ is formed using the \rulenamet{app} rule, each $s_j$ must be safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \sentail \elnf{s_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \sentail \elnf{s_j} : B_j$.  The \rulenamet{app}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \sentail x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the \rulenamet{abs} rule gives $\Gamma \sentail \lambda \overline{\varphi} . x
  \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} = \elnf{s} : A$, the side-condition of \rulenamet{abs} being verified since $\ord{\elnf{s}} = \ord{s}$.


\item $s = t s_0 \ldots s_m$ where $t$ is an abstraction.
For some fresh variables $\varphi_1$, \ldots, $\varphi_n$
we have $\elnf{s} = \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n}$. Again, using the induction hypothesis we can easily derive $\Gamma \sentail
 \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : A$.

\item $s = \lambda \overline{\eta} . t $ where
$\overline{\eta} : \overline{B}$ and $t:C$ is not an abstraction. The induction hypothesis gives $\Gamma,
  \overline{\eta} : \overline{B} \sentail \elnf{t} : C$ and using
\rulenamet{abs} we get $\Gamma \sentail \lambda \overline{\eta} . \elnf{t} = \elnf{s} : A$.  \qed
\end{compactitem}

\begin{remark}\hfill
\begin{enumerate}
\item
The converse of this lemma does not hold in general: Performing
$\eta$-reduction over a large abstraction does not in general
preserve safety. This does not contradict Lemma
  \ref{lem:etared_preserve_safety} which states that safety is
  preserved when performing $\eta$-reduction on an abstraction
  of a \emph{single} variable. The simplest counter-example is
  the
 unsafe term $f^{(o,o,o)} \stentail \lambda x^o . f \underline{x}$
whose eta-long normal form $f^{(o,o,o)} \sentail \lambda x^o y^o .
f x y$ is safe. Even for closed terms the converse does not
hold: $\lambda f^{(o,o,o)} g^{((o,o,o),o)} . g(\lambda x^o . f
\underline{x})$ is unsafe but its eta-nf $\lambda f^{(o,o,o)}
g^{((o,o,o),o)} . g(\lambda x^o y^o. f x y)$ is safe. In fact
even the closed $\beta\eta$-normal unsafe term $\lambda
f^{(o,(o,o),o,o)} g^{((o,o),o,o,o),o)} . g(\lambda y^{(o,o)} x^o
. f \underline{x} y)$ has a safe $\eta$-\emph{long} normal form!

  \item After performing $\eta$-long expansion of a term, the ``unsafetyness'' caused by the application rule is
  completely removed. Thus the only potential source of unsafety
  comes from occurrences of variables that are not bound by the
  first following application of the \rulenamet{abs} rule in the
  typing tree.
  \end{enumerate}
\end{remark}


A consequence of this lemma is that the intrinsic safety/unsafety of
a term is not always revealed by its $\beta$-normal form. Instead one
has to study the $\eta$-long $\beta$-normal form.
For this reason, one may argue that the set of rules defining the safe lambda calculus
in Def.~\ref{def:safelambda} do not capture faithfully the semantic notion of safety.
It is in indeed possible to define a type system whose set of judgements is precisely the simply-typed terms
having a safe $\eta$-long normal form. Such term will be called \defname{intrinsically safe}.




\begin{lemma}
  \label{lem:intrinsic_safe}
  The intrinsically safe terms are precisely the set of simply-typed terms that can be typed
  as $\Gamma \isentail M : A$ using the following rules:

$$ \rulename{var_{is}} \ \rulef{}{x : A\isentail x : A} \qquad
\rulename{const_{is}} \ \rulef{}{\isentail f : A}~f \in \Xi \qquad
\rulename{wk_{is}} \ \rulef{\Gamma \isentail s : A}{\Delta \isentail s : A} \quad
\Gamma \subset \Delta$$

$$ \rulename{app_{as}} \ \rulef{\Gamma \asentail s : A\typear B
\quad \Gamma \isentail t : A} {\Gamma \asentail s~t : B}
\qquad
\rulename{\delta} \ \rulef{\Gamma \isentail s : A}{\Gamma \asentail s : A}
$$

$$ \rulename{app_{is}} \ \rulef{\Gamma \asentail s : A\typear B
\quad \Gamma \isentail t : A} {\Gamma \isentail s~t : B} \quad \ord{B} \sqsubseteq
\ord{\Gamma}$$

$$ \rulename{abs_{is}} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asentail s : B} {\Gamma \isentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{A_1, \ldots ,A_n,B} \sqsubseteq
\ord{\Gamma}$$
\smallskip

The subscripts in $\asentail$ and $\isentail$ stand for ``almost intrinsically safe''
and ``intrinsically safe'' respectively.
\end{lemma}
Observe that the system of rules given above is a variation on the one given in Def.~\ref{def:safelambda} where the application is more permissive. Thus clearly, every safe term is intrinsically safe.

\proof
Let $\Gamma \stentail M : T$. We want to show that 
$\Gamma \sentail \elnf{M} : T$ if and only if 
$\Gamma \isentail M : T$.
The `If' part can be proved by a trivial induction on the structure of $\Gamma \isentail M : T$.
For the `Only if' part we proceed by induction on the structure of the simply-typed term $\Gamma \stentail M : T$: The variable, constant and weakening cases are trivial. Suppose that $M$ is an application of the form 
$x s_1 \ldots s_m : A$ for $m\geq 1$. Its $\eta$-long normal form is
of the form $x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_m}: o$ for some fresh variables $\varphi_1$, \ldots $\varphi_m$.
By assumption this term is safe term therefore we have $\ord{A}\sqsubseteq\ord{\Gamma}$ and for $1\leq i \leq m$, $\elnf{s_i}$ is also safe. By the induction hypothesis this implies that
the $s_i$s are all intrinsically safe. We can then form the judgment 
$\Gamma \isentail x s_1 \ldots s_m : A$ using the
rules $\rulename{var_{is}}$ and $\rulename{\delta}$ followed by $m-1$ applications of the rule $\rulename{app_{as}}$ and one application of
$\rulename{app_{is}}$ (allowed since we have $\ord{A}\sqsubseteq\ord{\Gamma}$).
The case $M\cong (\lambda x. s) s_1 \ldots s_m$ for $m\geq 1$ is treated identically.

Suppose that $M \cong \lambda \overline{x} . s : A$.
By assumption, its  $\eta$-long n.f.\ 
$\lambda \overline{x} \overline{\varphi} . \elnf{s} \elnf{\varphi_1} \ldots \elnf{\varphi_m}: A$ (for
some fresh variables $\varphi_1$ \ldots $\varphi_m$) is safe.
Thus we have $\ord{A}\sqsubseteq\ord{\Gamma}$.
Furthermore the safe subterm $\elnf{s} \elnf{\varphi_1} \ldots \elnf{\varphi_m}$ is precisely the eta-long expansion of $s\varphi_1 \ldots \varphi_m : o$ therefore by the induction hypothesis we have that $s \varphi_1 \ldots \varphi_m :o$ is intrinsically safe.
Since the $\varphi_i$'s are all intrinsically safe by rule $\rulename{var_{is}}$, we can ``peal-off'' $m$ applications of the rules
$\rulename{app_{is}}$/$\rulename{app_{as}}$ from $\Gamma, \overline{x}, \overline{\varphi} \isentail s \varphi_1 \ldots \varphi_m :o$ which gives us the judgment $\Gamma, \overline{x}, \overline{\varphi} \asentail s : A$. 
Since the $\overline{\varphi}$ variables are fresh for $s$, we can further peal-off $m$ applications of the weakening rule to obtain the judgment $\Gamma, \overline{x} \asentail s : A$. Finally we conclude
$\Gamma \asentail \lambda \overline{x} . s : A$ using the rule 
$\rulename{abs_{is}}$ (which is permitted since we have $\ord{A}\sqsubseteq\ord{\Gamma}$).
\qed
\smallskip

\notetoself{
Lemma \ref{lem:ordfreevar} clearly holds for intrinsically safe term,
therefore so does the 
``no-variable capture'' lemma.
}
 

\begin{remark}
  Although the notion of intrinsic safety provides a better match between the syntax and the semantics of safety, we feel that the original definition is more succinct and simpler to understand. Moreover it turns out that the semantic account that we give in Sec.~\ref{sec:gamesemaccount} relies precisely on an analysis of the eta-long normal form of the term. This underpins our decision to take Def.~\ref{def:safelambda} as the main definition for the safe lambda calculus.
\end{remark}



In the homogeneous safe lambda calculus, the notion of safe terms and intrinsic safe terms coincide as the following lemma shows:
\begin{lemma}
If $\Gamma \stentail s : T$ is homogeneously typed (\ie each judgment
appearing in the typing tree is homogeneously typed) then
$s$ is safe if and only if $s$ is intrinsically safe. 
\end{lemma}
\proof
The implication holds trivially even in the non-homogeneous case.
For the converse, it is an easy proof by induction on the rules of 
Lemma \ref{lem:intrinsic_safe}. The rules 
$\rulename{var_{is}}$, $\rulename{const_{is}}$, $\rulename{wk_{is}}$ and 
$\rulename{abs_{is}}$ directly translate to their equivalent from
Def.\ \ref{def:safelambda}.
Take the rule $\rulename{app_{is}}$. It is easy to show
(by another induction) that the judgment $\Gamma \asentail s : A \typear B$ in the hypothesis is such that $s = s_1 \ldots s_m$ and for all $1 \leq i\leq m$, $s_i$ is intrinsically safe. Thus by the induction hypothesis, $s_1$, \ldots, $s_m$ and $t$ are all safe. So in particular we have $\ord{A}\sqsubseteq\ord{\Gamma}$.
Finally by the homogeneity constraint we have that $\ord{B} \leq \ord{A}$.
Thus the side-condition of the rule \rulenamet{app} of
Def.\ref{def:safelambda} is met and we can form the judgment $\Gamma \sentail s t : B$.
\qed


When put together with the previous Lemma, this tells us that in the homogeneous safe lambda calculus, safety is preserved by $\eta$-reduction.
%\ie If $\Gamma \sentail \elnf{s} : T$ is homogeneously safe (\ie  it is a
%safe judgement of the safe $\lambda$-calculus and each judgment
% in the nodes of the proof tree is homogeneously typed)
%then $\Gamma \sentail s :T$ is homogeneously safe.
This contrasts with the result of Lemma \ref{lem:elnf_preserves_safety}.


\subsection*{The type inhabitation problem}

It is well known that the simply-typed lambda calculus corresponds
to intuitionistic implicative logic via the Curry-Howard
isomorphism. The tautologies of the logic correspond to inhabited
types, so that any inhabitant of a type is a proof of the
corresponding formula. Similarly, we can consider the fragment of
intuitionistic implicative logic that corresponds to the safe lambda
calculus under the Curry-Howard isomorphism. We call it the
\emph{safe fragment of intuitionistic implicative logic}.

One way to investigate the complexity of the safe lambda calculus is
to compare the power of these two logics, in other words, to
determine which types are inhabited in the lambda calculus but not
in the safe lambda calculus.\footnote{This problem was raised to our
attention by Ugo dal Lago.}

If we restrict the set of type atoms to a single one $o$, then there
is a positive answer: any type with only one atom that is inhabited
in the lambda calculus is also inhabited in the safe lambda
calculus. Indeed, one can transform any unsafe inhabitant $M$ into a
safe one of the same type as follows: Compute the eta-long beta
normal form of $M$. Let $x$ be an occurrence of a ground-type
variable in a subterm of the form $\lambda \overline{x} . C[x]$
where $\lambda \overline{x}$ is the binder of $x$ and for some
context $C[\_~]$ different from the identity $C[R]=R$. We replace
the subterm $\lambda \overline{x} . C[x]$ by $\lambda \overline{x}.
x$ in $M$. This transformation is sound because both $C[x]$ and $x$
are of ground type therefore since there is only one atom they must
be of the same type. We repeat this procedure until the term
stabilizes. This procedure clearly terminates since the size of the
term decreases strictly after each step. The final term obtained is
safe and of the same type as $M$.

This argument cannot be generalized to types with multiple atoms. In fact there are order $3$ types with only $2$ atoms that are inhabited in the simply-typed lambda calculus but not in the safe lambda calculus. Take for instance the order $3$ type
 $( ((b, a), b),  ((a, b), a),  a)$ for some distinct atoms $a$ and $b$. It is only inhabited by the following family of terms which are all unsafe:
 \begin{align*}
& \lambda f g . g (\lambda x_1 . f (\lambda y_1 . x_1)) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . y_1))) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . x_i))) \qquad\mbox{where $i = 1, 2$} \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . g (\lambda x_3 . y_i))) \qquad\mbox{where $i = 1, 2$} \\
&\ldots
\end{align*}

Another example is the type of function composition. For any atom
$a$ and natural number $n\in\nat$, we define the types $n_a$ as
follows: $0_a = a$ and $(n+1)_a = n_a \typear a$. Take three
distinct atoms $a$, $b$ and $c$. For any $i,j,k\in\nat$, we write
$\sigma(i,j,k)$ to denote the type
$$\sigma(i,j,k) \cong (i_a \typear j_b) \typear (j_b \typear k_c) \typear i_a \typear
k_c \ .$$

For all $i$, $j$, $k$, this type is inhabited in the lambda calculus by the function composition term:
$$\lambda x y z w . y (x z) $$
which is safe if and only if $i\geq j$. Suppose that $i<j$ then the type
$\sigma(i,j,k)$ may still be safely inhabited. For instance
$\sigma(1,3,4)$ is inhabited by the safe term
$$ \lambda x^{1_a \typear 3_b} y^{3_b \typear 4_c} z^{1_c} w^{3_c} . y (x (\lambda u^a . u)) \ .$$
The order-$4$ type $\sigma(0,2,0)$, however, is only inhabited by the unsafe term $\lambda x y z w. y (x z) $.


Statman showed in \cite{Statman1979} that the problem of deciding
whether a type \emph{defined over an infinite number of ground
atoms} is inhabited (or equivalently of deciding an intuitionistic
implicative formula) is PSPACE-complete. The previous observations suggest that the safe
fragment of implicative logic may not be PSPACE-hard.
