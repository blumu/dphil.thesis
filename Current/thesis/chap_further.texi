
%%%%%A pressing question concerns the complexity of the safe lambda calculus.

% (note that it is unlikely to obtain the complexity PSPACE because the
% set of complete plays of the safe term $\lambda f^{(o,o),o} . f
% (\lambda x^o . x)$ is not regular \cite{DBLP:journals/apal/Ong04}).

% Murawski showed the undecidability of program equivalence in
% $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations
% into a finitary $IA_4$ term \cite{murawski03program}. The term
% constructed being not safe, the proof cannot be transposed to the
% safe fragments. Hence the question remains of whether observational
% equivalence is decidable for the \emph{safe} fragments of these
% language.

%In \cite{Ong02}, Ong showed that observational equivalence for
% finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is
% undecidable. The proof consists in reducing the Queue-Halting
% problem to the observational equivalence of two $\ialgol_2 + Y_1$
% terms. The same reduction is still valid in the safe fragment of
% $\ialgol_2 + Y_1$.  Consequently, observational equivalence of safe
% $\ialgol_2 + Y_1$ is also undecidable.


\unfinished[Make sure all these questions are answered in the thesis]{
\begin{itemize}
\item Safe $\ialgol_3$ is a PUR language.

\item Murawski \cite{Murawski2003} has shown that observational equivalence for $\ialgol_4$ is undecidable; is observational equivalence for
\emph{safe} $\ialgol_4$ decidable?

\item What is a (categorical) model of the safe lambda
calculus? Does the calculus have interesting models?

\item give a detailed account of
P-incrementally justified strategies that treats the problem of
compositionality;
\item find a categorical interpretation of the safe $\lambda$-calculus;
\item identify a non-trivial fragment of safe \ialgol\ for which observational equivalence is decidable;
\item Is the addition of unsafe contexts to safe ones conservative with respect to observational (or contextual) equivalence?
Can we obtain a fully abstract model of safe PCF by suitably constraining O-moves (\ie, ``O-incremental justification'')?
\end{itemize}
}

\section{Summary of contribution}

In this thesis we have introduced a new calculus and studied it
under different angles. We have given an account of the game
semantics of safe $\lambda$-calculus. \todo{bla bla bla}



\section{Further work and open problems}

The nature of the safe lambda calculus is still not completely
understood. Some questions remain about the safe $\lambda$-calculus pertaining to its computational power, the complexity classes that it characterizes and its interpretation under the Curry-Howard isomorphism.
Here are some interesting open questions:
\begin{enumerate}
    \item Is the game model of safe \pcf\ universal? (\ie, is every recursive incremental strategy denoted by some safe \pcf\ term?)

    \item What kind of reasoning principles does the safe lambda calculus support, via the Curry-Howard Isomorphism?

    \item Does the safe lambda calculus characterize a complexity class, in the same way that the simply typed lambda calculus characterizes the polytime-computable numeric functions \cite{DBLP:conf/tlca/LeivantM93}?

    \item What are the function over \emph{free-algebras} definable in the safe simply typed lambda calculus? \cite{DBLP:journals/tcs/Leivant93,DBLP:journals/apal/Zaionc91}

    \todo{add my conjecture here}
\end{enumerate}


\subsection*{PUR languages}
In this thesis, we have shown that the safety constrained produces
language whose game semantics enjoy the property that pointers in a play are uniquely recoverable from the underlying sequence of moves. We name
this class PUR for ``\emph{Pointer Uniquely Recoverable}''.

With a view to algorithmic game semantics and its applications, it
would be interesting to discover other classes of PUR languages. $\ialgol_2$ is the paradigmatic example of a PUR-language. Because of the simplicity of its game semantics, observational equivalence becomes decidable when the language is restricted to its finitary fragment (finite base types and no recursion). PUR-languages are therefore good candidates of languages with decidable observational equivalence. Identifying classes of PUR languages having this appealing property would have immediate applications in the domain of program verification.

Another example is \emph{Serially Re-entrant Idealized  Algol} \cite{abramsky:mchecking_ia}, a version of \ialgol\ where multiple uses of arguments are allowed only if they do not ``overlap in time''.
In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to safe \ialgol.

Another possible way to generate PUR-languages consists in constraining
types. In \cite{DBLP:conf/tlca/Joly01}, a notion of ``complexity'' is defined for $\lambda$-terms and it is proved that there is a constant bounding the
complexity of every closed normal $\lambda$-term of a given type $T$
if and only if $T$ can be generated from a finite set of combinators.
Consequently, the only inhabited finitely generated types are the
types of order $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$. We already know that imposing the
first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?
