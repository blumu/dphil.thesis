\torework[Make sure all these questions are answered in the thesis]{
\begin{itemize}
\item Safe $\ialgol_3$ is a PUR language.

\item Murawski \cite{Murawski2003} has shown that observational equivalence for $\ialgol_4$ is undecidable; is observational equivalence for
\emph{safe} $\ialgol_4$ decidable?

\item What is a (categorical) model of the safe lambda
calculus? Does the calculus have interesting models?

\item give a detailed account of
P-incrementally justified strategies that treats the problem of
compositionality;
\item find a categorical interpretation of the safe $\lambda$-calculus;
\item identify a non-trivial fragment of safe \ialgol\ for which observational equivalence is decidable;
\item Is the addition of unsafe contexts to safe ones conservative with respect to observational (or contextual) equivalence?
Can we obtain a fully abstract model of safe PCF by suitably constraining O-moves (\ie ``O-incremental justification'')?
\end{itemize}
}

\section{Summary of Contribution}

In this thesis we have introduced a new calculus and studied it
under different angles. We have given an account of the game
semantics of safe $\lambda$-calculus. \notetoself{bla bla bla}



\section{Further work and open problems}

The nature of the safe lambda calculus is still not completely
understood. Here are some interesting open questions:
\begin{enumerate}
    \item Is the game model of safe \pcf\ universal \ie every recursive incremental strategy is denoted by some safe \pcf\ term?

    \item What kind of reasoning principles does the safe lambda calculus support, via the Curry-Howard Isomorphism?

    \item Does the safe lambda calculus characterize a complexity class, in the same way that the simply-typed lambda calculus characterizes the polytime-computable numeric functions \cite{DBLP:conf/tlca/LeivantM93}?

    \item What are the function over \emph{free-algebras} definable in the safe simply-typed lambda calculus? \cite{DBLP:journals/tcs/Leivant93,DBLP:journals/apal/Zaionc91}

    \notetoself{add my conjecture here}
\end{enumerate}


\subsection*{PUR languages}
In this thesis, we have shown that the safety constrained produces
language whose game semantics enjoy the property that pointers in a play are uniquely recoverable from the underlying sequence of moves. We name
this class PUR for ``\emph{Pointer Uniquely Recoverable}''.

With a view to algorithmic game semantics and its applications, it
would be interesting to discover other classes of PUR languages. $\ialgol_2$ is the paradigmatic example of a PUR-language. Because of the simplicity of its game semantics, observational equivalence becomes decidable when the language is restricted to its finitary fragment (finite base types and no recursion). PUR-languages are therefore good candidates of languages with decidable observational equivalence. Identifying classes of PUR languages having this appealing property would have immediate applications in the domain of program verification.

Another example is \emph{Serially Re-entrant Idealized  Algol} \cite{abramsky:mchecking_ia}, a version of \ialgol\ where multiple uses of arguments are allowed only if they do not ``overlap in time''.
In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to safe \ialgol.

Another possible way to generate PUR-languages consists in constraining
types. In \cite{DBLP:conf/tlca/Joly01}, a notion of ``complexity'' is defined for $\lambda$-terms and it is proved that there is a constant bounding the
complexity of every closed normal $\lambda$-term of a given type $T$
if and only if $T$ can be generated from a finite set of combinators.
Consequently, the only inhabited finitely generated types are the
types of order $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$. We already know that imposing the
first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?
