
\section{Summary of contribution}

In this thesis we have introduced a new calculus and studied it
under many angles.
Motivated by the appealing algorithmic properties of the \emph{safety constraint} in the setting of higher-order grammars, we derived a new typing system, the \emph{safe lambda calculus}, by imposing the safety condition on the simply typed lambda calculus. We observed an intriguing property: it is not necessary to rename variables when performing substitution. Thus in some sense, safe terms are ``easier'' to compute than unsafe ones.

To measure the effect of the constraint on the expressivity,
We gave a clear account of the loss of expressivity caused by this constraint: the expressible numeric functions are the multivariate polynomials; the conditional operator is not expressible.

We also looked at the complexity of the calculus by considering the beta-equivalence problem: we hinted it is probably in ELEMENTARY by showing how Statman's encoding as well as Mairson's encoding of finite type theory in the simply typed lambda calculus both fail in the safe fragment. We showed however that the problem is PSPACE-hard.

\unfinished{
Our second main contribution is our new presentation of Game semantics based on the theory of traversals, extending a work by Ong. We show that the game sem

We have given an account of the game
semantics of safe $\lambda$-calculus.
}


\subsection{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik et~al.\ \cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig et~al.\
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, Luke Ong obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the paper \cite{hmos-lics08}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

\section{Further works}


The nature of the safe lambda calculus is still not completely
understood. Some questions remain about the safe $\lambda$-calculus pertaining to its computational power, the complexity classes that it characterizes and its interpretation under the Curry-Howard isomorphism.
Here are some interesting open questions:
\begin{enumerate}
    \item Is the game model of safe \pcf\ universal? (\ie, is every recursive incremental strategy denoted by some safe \pcf\ term?)

    \item What kind of reasoning principles does the safe lambda calculus support, via the Curry-Howard Isomorphism?

    \item Does the safe lambda calculus characterize a complexity class, in the same way that the simply typed lambda calculus characterizes the polytime-computable numeric functions \cite{DBLP:conf/tlca/LeivantM93}?

    \item What are the function over \emph{free-algebras} definable in the safe simply typed lambda calculus? \cite{DBLP:journals/tcs/Leivant93,DBLP:journals/apal/Zaionc91}
\end{enumerate}


\subsection{Complexity}
%%%%%A pressing question concerns the complexity of the safe lambda calculus.

% (note that it is unlikely to obtain the complexity PSPACE because the
% set of complete plays of the safe term $\lambda f^{(o,o),o} . f
% (\lambda x^o . x)$ is not regular \cite{DBLP:journals/apal/Ong04}).


\subsection{Representability of functions over free algebras}

There is an isomorphism between binary trees and closed simply typed terms of
type $\tau =(o\typear o\typear o) \typear o \typear o$. Thus any
closed term of type $\tau\typear\tau \typear \ldots \typear \tau $
represents an $n$-ary function over trees. Zaionc gave a
characterization of the set of tree functions representable in the
simply typed lambda calculus \cite{DBLP:conf/aluacs/Zaionc88}: it is
precisely the minimal set containing constant functions, projections
and closed under composition and limited primitive recursion. Zaionc
showed that the same characterization holds for the general case of
functions expressed over free algebras
\cite{DBLP:journals/apal/Zaionc91}: they are given by the
minimal set containing constant functions, projections and closed
under composition and limited primitive recursion. This result subsumes
Schwichtenberg's result on definable numeric functions as well as
Zaionc's own results on definable word and tree functions.

All these basic operations are safe except limited primitive recursion.
This suggests that one needs to restrict further the primitive recursion in order to obtain a characterization of free-algebra functions representable in the
safe lambda calculus. Such result would generalized our expressivity result for numeric and word functions from Sec.\ \ref{sec:expressivity}.

\subsection{Expressibility}
Murawski introduced a notion of language expressibility by game semantics \cite{Murawski2003}. He showed that the $4th$ order finitary fragment of \ialgol\ is expressive enough to give the full class of recursively enumerable languages. Does the safe fragment have the same expressive power? Another line of research would be to investigate whether the class of word languages recognizable by higher-order pushdown automata can be characterized in Murawski's sense by some higher-order fragment of safe \ialgol.


\subsection{Algorithmic game semantics}
We have seen that up to order $3$, the problem of observational equivalence has the same complexity in the safe finitary fragments as in the unrestricted finitary fragments.  An obvious direction would be to investigate this problem at order $4$: Murawski \cite{Murawski2003} has shown that observational equivalence is undecidable for $\ialgol_4$, is it the case for safe $\ialgol_4$?


% Murawski showed the undecidability of program equivalence in
% $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations
% into a finitary $IA_4$ term \cite{murawski03program}. The term
% constructed being not safe, the proof cannot be transposed to the
% safe fragments. Hence the question remains of whether observational
% equivalence is decidable for the \emph{safe} fragments of these
% language.

% Ong showed that observational equivalence for
% finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is
% undecidable \cite{Ong02}. The proof consists in reducing the Queue-Halting
% problem to the observational equivalence of two $\ialgol_2 + Y_1$
% terms. The same reduction is still valid in the safe fragment of
% $\ialgol_2 + Y_1$.  Consequently, observational equivalence of safe
% $\ialgol_2 + Y_1$ is also undecidable.


\unfinished[Make sure all these questions are answered in the thesis]{
\begin{itemize}
\item Safe $\ialgol_3$ is a PUR language.

\item Murawski \cite{Murawski2003} has shown that observational equivalence for $\ialgol_4$ is undecidable; is observational equivalence for \emph{safe} $\ialgol_4$ decidable?

\item What is a (categorical) model of the safe lambda
calculus? Does the calculus have interesting models?

\item give a detailed account of
P-incrementally justified strategies that treats the problem of
compositionality;
\item find a categorical interpretation of the safe $\lambda$-calculus;
\item identify a non-trivial fragment of safe \ialgol\ for which observational equivalence is decidable;
\item Is the addition of unsafe contexts to safe ones conservative with respect to observational (or contextual) equivalence?
Can we obtain a fully abstract model of safe PCF by suitably constraining O-moves (\ie, ``O-incremental justification'')?
\end{itemize}
}


\subsection{PUR languages}
In this thesis, we have shown that the safety constrained produces
languages whose game semantics enjoy the property that pointers in a play are uniquely recoverable from the underlying sequence of moves. We name
this class PUR for ``\emph{Pointer Uniquely Recoverable}''.

With a view to algorithmic game semantics and its applications, it
would be interesting to discover other classes of PUR languages. $\ialgol_2$ is the paradigmatic example of a PUR-language. Because of the simplicity of its game semantics, observational equivalence becomes decidable when the language is restricted to its finitary fragment (finite base types and no recursion). PUR-languages are therefore good candidates of languages with decidable observational equivalence. Identifying classes of PUR languages having this appealing property would have immediate applications in the domain of program verification.

Another example is \emph{Serially Re-entrant Idealized  Algol} \cite{abramsky:mchecking_ia}, a version of \ialgol\ where multiple uses of arguments are allowed only if they do not ``overlap in time''.
In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to safe \ialgol.

Another possible way to generate PUR-languages consists in constraining
types. Joly introduced a notion of ``complexity'' for $\lambda$-terms and proved that there is a constant bounding the
complexity of every closed normal $\lambda$-term of a given type $T$
if and only if $T$ can be generated from a finite set of combinators;
Consequently, the only inhabited finitely generated types are the
types of order $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$ \cite{DBLP:conf/tlca/Joly01}.
We already know that imposing the first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?


%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.

