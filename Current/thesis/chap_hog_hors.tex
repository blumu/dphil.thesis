
\begin{proposition}
Higher-order recursion schemes are equivalent to the simply-typed lambda calculus extended with mutual recursion and $\Sigma$-constants.
\end{proposition}
This is shown straightforwardly by showing that every higher-order recursion scheme can be converted into an equivalent lambda-term and conversely.
% Proof
\newcommand\lcalculrec{\Lambda^{\rightarrow}_\Sigma+Y}
Let $\lcalculrec$ denotes the simply-typed lambda calculus extended with the typed-constants $\Sigma$ and mutual recursion.


\begin{itemize}
\item The first direction is trivial. Take a recursion scheme $\mathcal{R} = \langle \Sigma, \mathcal{N}, \mathcal{R}, F_0 \rangle$.
where $\mathcal{R} = \{ F_0, \ldots, F_q \}$ for some $q\geq 0$.
For each rule $F_i\ x_1 \ldots x_n \rightarrow e$ in $\mathcal{R}$ we can construct the term $\widetilde{F_i} \equiv \lambda x_1 \ldots x_n . e$. The recursion scheme is then equivalent to the term $\pi_0 (Y (\langle \widetilde{F_0}, \ldots \widetilde{F_q}\rangle)) $
We can construct an equivalent lambda term over the constant $\Sigma$ by induction on the rewriting rules as follows: we define a function $\Pi : \mathcal{A}(\Sigma,\mathcal{N}) \funto $

\end{itemize} 