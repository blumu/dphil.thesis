% -*- TeX -*- -*- Soft -*-

We present the safety restriction in the context of higher-order grammars as it was originally defined
\cite{KNU02}. We briefly introduce the concept of higher-order grammars, the reader is referred to \cite{KNU02,demirandathesis,safety-mirlong2004} for an in-depth account of this subject.
\bigskip

Notations: Notations: We consider simple types generated by the grammar $A \, ::= \, o \; | \; A \typear A$. Given a set of typed symbols $S$, the set of \defname{applicative terms} generated from $S$ is defined as the
closure of $S$ under the application rule \ie if it contains both $s: A\rightarrow B$ and $t:A$ then it also contains $s t :B$.


\subsection{Type ranking and type homogeneity}
Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \typear A$. Any type different from the base
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \typear \cdots \typear A_n \typear o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the \defname{arity} of $T$, written $\arity(T)$, is
defined to be $n$, the arity of the base type is $0$.

We call \defname{type-ranking function}, or just ranking function, any function
in types ${\sf rank} : Types \funto (L, \leq)$ for some set $L$ and preorder $\leq$ verifying the following condition:
 $${\sf rank}(B) \leq {\sf rank}(A\typear B)$$

\begin{example}
The followings are type-ranking functions:
\begin{itemize}
\item ${\sf ord} : Types \funto (\nat,\leq)$ with $\ord{o} = 0$
and $\ord{A \typear B} = \max(\ord{A}+1, \ord{B})$;
\item ${\sf height} : Types \funto (\nat,\leq)$ with
$\slheight{A \typear B} = 1 + \max(\slheight{A}, \slheight{B})$ and
$\slheight{o} = 0$ ;
\item ${\sf arity} : Types \funto (\nat,\leq)$ with $\arity{o} = 0$
and $\arity{A_1, \cdots, A_n} = n$;
\item ${\sf size} : Types \funto (\nat,\leq)$ with ${\sf size}(o) = 0$
and ${\sf size}(A \typear B) = {\sf size}(A) + {\sf size}(B)$.
\end{itemize}
The product of two type-ranking function is also a type-ranking function with respect to the lexicographic ordering. For instance ${\sf order} \times {\sf arity} : Types \funto (\nat \times \nat,\leq)$ is a type-ranking function.
\end{example}

We say that a type is {\sf rank}-homogeneous
if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition
that $\rank{A_1} \geq \rank{A_2}\geq \cdots \geq \rank{A_n}$ and
each $A_1$, \ldots, $A_n$ is {\sf rank}-homogeneous.
If the ranking function is {\sf ord} then we obtain
the original definition of type homogeneity
from \cite{KNU02}.

Suppose that $\overline{A_1}$, $\overline{A_2}$, \ldots,
$\overline{A_n}$ are $n$ lists of types, where $A_{ij}$ denotes the
$j$th type in the list $\overline{A_i}$ and $l_i$ the size of
$\overline{A_i}$, then we use the notation:
$$A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)_{\sf rank}$$
 to mean that
\begin{itemize}
  \item $A$ is the type $(A_{11},A_{12},\cdots, A_{1l_1}, A_{21}, \cdots,A_{2l_2}, \cdots A_{n1},\cdots, A_{nl_n},o)$
  \item $\forall i: \forall u,v \in A_i : \rank u = \rank v $
  \item $\forall i,j . \forall u \in A_i . \forall v \in A_j . i<j \implies \rank u >
   \rank v $
\end{itemize}
which implies that $A$ is {\sf rank}-homogenous. In other words, this notation
partitions the $A_{ij}$s according to their ranks. Suppose $B =
(\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)_{\sf rank}$,
we write $(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, |
\, {B})_{\sf rank}$ to mean
\[(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, | \,
\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)_{\sf rank}\ .\]

When the ranking function is not specified it is assumed by default that
it is the order function {\sf ord}. We use the term ``homogeneous'' to refer to {\sf ord}-homogeneity
and the notation $A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)$ to mean
$A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)_{\sf ord}$.


\subsection{Higher-order grammars}

\begin{definition}
A (higher-order) \defname{grammar}\index{higher-order grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where
\begin{enumerate}[-]
\item $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ has an arity $\mathit{ar}(f) \geq 0$) of \emph{terminals};
\item $\mathcal{N}$ is a finite set of typed
\emph{non-terminals};
\item $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol;
\item $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form:
$$ F z_1 \ldots z_m \rightarrow e$$
where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the typed symbols in $\Sigma \union \mathcal{N} \union \{z_1:A_1, \ldots, z_m:A_m \}$.
\end{enumerate}
We say that the grammar is \emph{order-$n$} just in case the order of the highest-order non-terminal is $n$.
\end{definition}

We call \defname{value term} any applicative term generated from the terminals in $\Sigma$ only (without non-terminals), and viewed as a $\Sigma$-labelled tree.

A higher-order grammar $G$ defines a tree language denoted $L(G)$. It is a set of \emph{finite} value terms
which can be seen as applicative terms over $\mathcal{N} \union \Sigma$. It is formally defined as the set consisting of all the finite value terms that can be obtained by normalizing the start symbol $S$ using the the reduction relation induced by the rewriting rules of $G$.
This normalization can be done using different reduction strategies also called \emph{derivation modes}. The three main ones are: outside-in (OI), inside-out (IO), and unrestricted.
As the names suggest, in the OI derivation mode the outermost redex is reduced first; in IO mode the innermost redex is reduced first; and in unrestricted mode, no particular choice of redex is imposed.
It can be shown that the OI derivation is sufficient in the sense that every value term obtained from an IO derivation can also be obtained from an OI derivation. The converse however does not hold \cite{Dam82}.


\begin{remark}
In the literature \cite{Dam82,demirandathesis,KNU02},
the ranked-alphabet $\Sigma$ is usually restricted to terminals of order $1$ at most so that each $f \in\Sigma$ of arity $r \geq 0$ is assumed to have type $(\underbrace{o, \ldots, o}_r, o)$. The idea
is that order-$0$ terminals correspond to leaves of the value tree and order-$1$ terminals correspond to nodes. Such restriction is however not necessary as one can just regard higher-order terminals as special nodes that constrain the type of their children.
\notetoself{Check the above statement with Luke.}
\end{remark}






\subsection{Higher-order recursion schemes}
In order to generate infinite trees, higher-order grammars are specialized into a device called \emph{recursion scheme}. A \defname{higher-order recursion scheme} is a higher-order grammar where the set of rewrite rules is deterministic \ie for each non-terminal $F \in \mathcal{N}$ there is exactly one production rule with $F$ on the left-hand side.

A recursion scheme $R$ defines a (potentially infinite) value tree denoted $\sem{R}$ obtained by unfolding the rewrite rules of $G$ \emph{ad infinitum}, replacing formal by actual parameters each time, starting from the start symbol $S$. See e.g.~\cite{KNU02,demirandathesis} for a formal definition.

\parpic[r]{
\raisebox{-15pt}
{\begin{tikzpicture}[baseline=(root.base),level distance=3ex,inner ysep=0.5mm,sibling distance=13mm]
\node (root) {$g$}
child {node {$a$}}
child {node {$g$}
    child {node {$a$}}
    child {node {$h$}
           child {node {$h$}
                  child {node {$\ldots$}}
            }
    }
};
\end{tikzpicture}
}
}
\begin{example}\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}


\subsection{The safety restriction}
\label{sec:safetygrammar}

\emph{Safety} is a syntactic restriction for on higher-order grammars. We reproduce the original definition from \cite{KNU02}.
A type $(A_1, \cdots, A_n, o)$ is said to be \defname{homogeneous} if $\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$, and each $A_1$, \ldots, $A_n$ is homogeneous \cite{KNU02}.

\begin{definition}[Safe grammar]
\label{def:safegrammar}
  (All types are assumed to be homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
\end{definition}

This definition is a bit opaque and does not seem to make a lot of sense at first. One can reformulate this definition in a slightly clearer way:
A higher-order grammar $G$ whose non-terminals are of homogeneous type is \emph{unsafe} if and only if there is a rewrite rule $F z_1 \ldots z_m \rightarrow e$ where $e$ contains a subterm that:
\begin{enumerate}
\item occurs in {\em operand} position in $e$,
\item contains a parameter of order strictly less than its order.
\end{enumerate}
A grammar is safe if it is not unsafe.
By ``operand position'' we mean ``in the second position of some
occurrence of the implicit application operator of the lambda calculus''.



Let us illustrate the definition with some examples:
\begin{example}[taken from \cite{KNU02}] Let $f:(o,o,o)$, $g,h:(o,o)$ and $a,b:o$ be $\Sigma$ constants.
 The grammar of level 3 with non-terminals $S:o$ and $F: ((o,o),o,o,o)$ and production rules:
\begin{eqnarray*}
    S &\rightarrow&  F g a b \\
    F \varphi x y &\rightarrow& f ( F ( F \varphi x ) y (h y)) (f (\varphi x) y)
\end{eqnarray*}
is not safe because the term $F \varphi x : (o,o)$ containing a variable of order $0$
occurs at an operand position in the right-hand side expression of the second rule.

On the other hand, the grammar with the following production rules is safe:
\begin{eqnarray*}
    S &\rightarrow&  G (g a) b \\
    G z y &\rightarrow& f ( G ( G z y) (h y)) (f z y)
\end{eqnarray*}
Moreover it can be shown that these two recursion schemes are equivalent in the sense that they generate the same
infinite tree.
\end{example}

\begin{example}
Take $H : ((o, o), o)$ and $f : (o, o, o)$; the
    following rewrite rules are unsafe (in each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x
\end{array}\]
\end{example}

\begin{example}
The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{example}


\notetoself{Add examples and some results:MSO decidability and stuff}



\subsection*{Higher-order recursion schemes and the lambda calculus}
\newcommand\ymut{Y_{\sf mut}}
We extend the syntax of the simply-typed lambda calculus with a mutual recursion operator $\ymut$ as follows:
 $$ (\ymut) \rulef{\Gamma \vdash M_1 : A \typear A_1 \qquad \Gamma \vdash M_q : A \typear A_q}{\Gamma \vdash \ymut (M_1, \ldots, M_q):A_1}\ A = A_1 \times \ldots \times A_q, q \geq 0$$
The semantics of this operator is given by the rule
$ \ymut (M_1 \ldots M_q) \rightarrow \pi_1 (Y \langle M_1 \ldots M_q \rangle)$
where $\pi_1$ denotes the projection of a $q$-tuple to its first component and $Y$ denotes the extension of the usual $Y$-combinator to product types with a semantics given by the rule:
$$ Y \langle M_1, \ldots, M_q \rangle \rightarrow
\langle M_1 (Y \langle M_1, \ldots, M_q \rangle),
\ldots, M_q (Y \langle M_1, \ldots, M_q \rangle) \rangle \ .$$


It is easy to see that higher-order recursion schemes have the same computational power as the simply-typed lambda calculus extended with mutual recursion and $\Sigma$-constants.
The first direction is trivial: Take a recursion scheme $\langle \Sigma, \mathcal{N}, \mathcal{R}, F_0 \rangle$
where $\mathcal{R} = \{ F_0, \ldots, F_q \}$ for some $q\geq 0$.
We convert each rule $F_i\ x_1 \ldots x_n \rightarrow e$ into a lambda term $\widetilde{F_i} \equiv \lambda F_0 \ldots F_q x_1 \ldots x_n . e$. The recursion scheme can then be equivalently formulated as the term $\ymut ( \widetilde{F_0},\ \ldots,\  \widetilde{F_q})$.

Conversely, any lambda term using mutual recursion and $\Sigma$-constants can be turned into an equivalent higher-order recursion schemes. This is done by proceeding inductively over the syntax of the $\eta$-long normal form of the term.
The algorithm {\sf LmdToRS} that performs this conversion is given in table \ref{tab:LmdToRS}. We describe the algorithm in an ML-like syntax, using lists to encode the set of rules $\mathcal{R}$ and non-terminals $\mathcal{N}$. (Observe that since we work on the $\eta$-long normal form, the right-hand side of each generated rule is indeed of ground type, as required by the definition of recursion schemes.)


\begin{table}[htbp]

{\bf Input}: a closed term $\vdash_\Sigma M : T$ using mutual recursion and  $\Sigma$-constants.

{\bf Output}: an equivalent higher-order recursion scheme $\langle \Sigma, \mathcal{N}, \mathcal{R}, S \rangle$.
$$\begin{array}{ll}
{\sf let\ LmdToRS}(\vdash_\Sigma M : T) =  \\
\qquad {\sf let\ createRules} = {\sf fun} \\
\qquad \qquad
    \begin{array}{lcl}
     |\ \Gamma \vdash x : T &\rightarrow& x \\
     |\ \Gamma \vdash M_0 \ldots M_q : o
      &\rightarrow&
        \mbox{``}{\sf createRules} (\Gamma \vdash M_0) \ldots {\sf createRules} (\Gamma \vdash M_q)\mbox{''}
      \\
     |\ \overline{x} : \overline{A} \vdash \lambda \overline{y}:\overline{B}. M : (\overline{B},o)
       &\rightarrow&
        {\sf let\ } t = {\sf createRules} (\overline{x}: \overline{A}, \overline{y}: \overline{B}\vdash M : o) \\
         && {\sf and \ } F \mbox{ be a fresh non-terminal name } {\sf in}\\
         &&\mathcal{R} \leftarrow \mbox{``}F\ \overline{x}\ \overline{y} \rightarrow t\mbox{''}::\mathcal{R} \\
         &&\mathcal{N} \leftarrow \mbox{``}F : (\overline{A},\overline{B},o)\mbox{''}::\mathcal{N} \\
         && \mbox{``}F\ \overline{x}\mbox{''}
     \\
      |\ \overline{x} : \overline{A} \vdash \ymut (M_1, \ldots, M_q):B_1 &\multicolumn{2}{l}{\mbox{ where } \forall i \in 1..q: M_i:B_i \mbox{ and } B=B_1 \times \ldots \times B_q \rightarrow} \\
     &&
     {\sf for\ i = 1\ ..\ q\ do} \\
     &&\qquad     {\sf createRules} (\overline{x}: \overline{A} \vdash M_i : B_i) \\
     &&\qquad     rule[i] \leftarrow hd\ \mathcal{R} \\
     &&{\sf done} \\
     &&{\sf let\ for\ all\ i\in\{1..q\}, } \mbox{``}F_i\ \overline{x}\ f_1 \ldots f_q\ \overline{y}_i \rightarrow t_i \mbox{''} = rule[i] {\sf\ in}\\
     &&{\sf for\ i = 1\ ..\ q\ do} \\
     &&\qquad \mathcal{R} \leftarrow \mbox{``}\widehat{F_i}\ \overline{x} \ \overline{y}_i \rightarrow t[\widehat{F_1} \overline{x}/f_1] \ldots [\widehat{F_q} \overline{x}/ f_q]\mbox{''} \\
     &&\qquad\qquad ::(tail\ \mathcal{R}[\widehat{F_1} \overline{x}/f_1] \ldots [\widehat{F_q} \overline{x}/ f_q]) \\
     &&\qquad\mathcal{N} \leftarrow \mbox{``}F_i : (\overline{A},B_i)\mbox{''}::(tail\ \mathcal{N}) \\
     &&{\sf done} \\
     &&\mbox{``}F_1\ \overline{x}\mbox{''}
   \end{array} \\
\qquad {\sf in}\\
\qquad \mathcal{N},\mathcal{R} \leftarrow [],[]  \\
\qquad appterm \leftarrow {\sf createRules}(\vdash M : T) \\
\qquad \langle \Sigma, \mbox{``}S\ \rightarrow appterm\mbox{''}::\mathcal{N}, \mbox{``}S:o\mbox{''}::\mathcal{R}, S \rangle
\end{array}$$

\caption{Algorithm {\sf LmdToRS} converting a mutually recursive lambda term into a recursion scheme.}
\label{tab:LmdToRS}
\end{table}


