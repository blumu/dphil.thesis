% -*- TeX -*- -*- Soft -*-

%This section introduces the concepts of higher-order grammars, higher-order recursion schemes.

\subsection{Type ranking and type homogeneity}
Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \typear A$. Any type different from the base
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \typear \cdots \typear A_n \typear o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the \defname{arity} of $T$, written $\arity(T)$, is
defined to be $n$, the arity of the base type is $0$.

We call \defname{type-ranking function}, or just ranking function, any function
in types ${\sf rank} : Types \funto (L, \leq)$ for some set $L$ and preorder $\leq$ verifying the following condition:
 $${\sf rank}(B) \leq {\sf rank}(A\typear B)$$

\begin{example}
The followings are type-ranking functions:
\begin{itemize}
\item ${\sf ord} : Types \funto (\nat,\leq)$ with $\ord{o} = 0$
and $\ord{A \typear B} = \max(\ord{A}+1, \ord{B})$;
\item ${\sf height} : Types \funto (\nat,\leq)$ with
$\slheight{A \typear B} = 1 + \max(\slheight{A}, \slheight{B})$ and
$\slheight{o} = 0$ ;
\item ${\sf arity} : Types \funto (\nat,\leq)$ with $\arity{o} = 0$
and $\arity{A_1, \cdots, A_n} = n$;
\item ${\sf size} : Types \funto (\nat,\leq)$ with ${\sf size}(o) = 0$
and ${\sf size}(A \typear B) = {\sf size}(A) + {\sf size}(B)$.
\end{itemize}
The product of two type-ranking function is also a type-ranking function with respect to the lexicographic ordering. For instance ${\sf order} \times {\sf arity} : Types \funto (\nat \times \nat,\leq)$ is a type-ranking function.
\end{example}

We say that a type is {\sf rank}-homogeneous
if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition
that $\rank{A_1} \geq \rank{A_2}\geq \cdots \geq \rank{A_n}$ and
each $A_1$, \ldots, $A_n$ is {\sf rank}-homogeneous.
If the ranking function is {\sf ord} then we obtain
the original definition of type homogeneity
from \cite{KNU02}.

Suppose that $\overline{A_1}$, $\overline{A_2}$, \ldots,
$\overline{A_n}$ are $n$ lists of types, where $A_{ij}$ denotes the
$j$th type in the list $\overline{A_i}$ and $l_i$ the size of
$\overline{A_i}$, then we use the notation:
$$A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)_{\sf rank}$$
 to mean that
\begin{itemize}
  \item $A$ is the type $(A_{11},A_{12},\cdots, A_{1l_1}, A_{21}, \cdots,A_{2l_2}, \cdots A_{n1},\cdots, A_{nl_n},o)$
  \item $\forall i: \forall u,v \in A_i : \rank u = \rank v $
  \item $\forall i,j . \forall u \in A_i . \forall v \in A_j . i<j \implies \rank u >
   \rank v $
\end{itemize}
which implies that $A$ is {\sf rank}-homogenous. In other words, this notation
partitions the $A_{ij}$s according to their ranks. Suppose $B =
(\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)_{\sf rank}$,
we write $(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, |
\, {B})_{\sf rank}$ to mean
\[(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, | \,
\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)_{\sf rank}\ .\]

When the ranking function is not specified it is assumed by default that
it is the order function {\sf ord}. We use the term ``homogeneous'' to refer to {\sf ord}-homogeneity
and the notation $A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)$ to mean
$A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)_{\sf ord}$.


\subsection{Higher-Order Grammars and the Safety Restriction}
The original notion of safety was introduced in \cite{KNU02} as a restriction for higher-order grammars. This section present briefly the notion of higher-order grammar in order to introduce the safety restriction in its original setting. The reader is referred to \cite{KNU02,demirandathesis,safety-mirlong2004} for more details on the subject.

{\emph Notations:} Suppose that $\Gamma$ is a set of typed symbols then the set of \emph{applicative terms} written $\mathcal{T}(\Gamma)$ is the
closure of $\Gamma$ under the application rule \ie if $s: A\rightarrow B$ and $t:A$ are in $\mathcal{T}(\Gamma)$ then so is $st :B$.

\begin{definition}[Higher-order grammar]
A \emph{higher-order grammar} is a tuple $\langle \Sigma,
\mathcal{N}, V, \mathcal{R}, S \rangle$, where
\begin{itemize}
\item $\Sigma$ is a ranked alphabet of terminals of order at most 1,
\item $V$ is a finite set of typed variables,
\item $\mathcal{N}$ is a finite set of homogeneously-typed non-terminals,
\item $S$ a distinguished symbol of $\mathcal{N}$ of ground type, called the start symbol,
\item $\mathcal{R}$ is a finite set of production rules, one for each $F : (A_1, \ldots, A_n, o) \in \mathcal{N}$, of the form
    $$ F z_1 \ldots z_m \rightarrow e$$
where $z_i$ is a variable of type $A_i$ and $e$ is an applicative
term of type $o$ in $\mathcal{T}(\Sigma \union \mathcal{N} \union
\{z_1 \ldots z_m \} )$. The $z_i$s are called the \emph{parameters}
of the rule.
\end{itemize}
\end{definition}
A higher-order recursion scheme is a \emph{deterministic} higher-order grammar \ie for each non-terminal $F \in \mathcal{N}$ there is exactly one production rule with $F$ on the left hand side.
Higher-order recursion schemes are used as generators
of infinite trees.

\notetoself{Add examples and some results:MSO decidability and stuff}

The order of a rewrite rule is the order of the non-terminal symbol
appearing on the left hand side of the rule. The order of a grammar
is the highest order of its non-terminals.

Safety is a syntactic restriction on higher-order grammars. It can be formulated as
follows:
\begin{definition}[Safe higher-order grammar]
  Let $G$ be a higher-order grammar $G$ of order $n$
    whose non-terminals are of homogeneous type.
    $G$ is \emph{unsafe} if and only if there is a rewrite rule $F z_1 \ldots z_m \rightarrow e$ where
   $e$ contains a subterm $t$ such that:
  \begin{enumerate}
    \item $t$ occurs in an operand position in $e$,
    \item $t$ is of order $k>0$,
    \item $t$ contains a parameter of order strictly less than $k$.
  \end{enumerate}
  $G$ is \emph{safe} if it is not unsafe.
\end{definition}

Let us illustrate the definition with an example taken from \cite{KNU02}:
\begin{example} Let $f:(o,o,o)$, $g,h:(o,o)$ and $a,b:o$ be $\Sigma$ constants.
 The grammar of level 3 with non-terminals $S:o$ and $F: ((o,o),o,o,o)$ and production rules:
\begin{eqnarray*}
    S &\rightarrow&  F g a b \\
    F \varphi x y &\rightarrow& f ( F ( F \varphi x ) y (h y)) (f (\varphi x) y)
\end{eqnarray*}
is not safe because the term $F \varphi x : (o,o)$ containing a variable of order $0$
occurs at an operand position in the right-hand side expression of the second rule.

On the other hand, the grammar with the following production rules is safe:
\begin{eqnarray*}
    S &\rightarrow&  G (g a) b \\
    G z y &\rightarrow& f ( G ( G z y) (h y)) (f z y)
\end{eqnarray*}
Moreover it can be shown that these two grammars are equivalent in the sense that they generate the same
infinite tree.
\end{example}





\subsection{Higher-order recursion schemes and the lambda calculus}
\newcommand\ymut{Y_{\sf mut}}
We extend the syntax of the simply-typed lambda calculus with a mutual recursion operator $\ymut$ as follows:
 $$ (\ymut) \rulef{\Gamma \vdash M_1 : A \typear A_1 \qquad \Gamma \vdash M_q : A \typear A_q}{\Gamma \vdash \ymut (M_1, \ldots, M_q):A_1}\ A = A_1 \times \ldots \times A_q, q \geq 0$$
The semantics of this operator is given by the rule
$ \ymut (M_1 \ldots M_q) \rightarrow \pi_1 (Y \langle M_1 \ldots M_q \rangle)$
where $\pi_1$ denotes the projection of a $q$-tuple to its first component and $Y$ denotes the extension of the usual $Y$-combinator to product types with a semantics given by the rule:
$$ Y \langle M_1, \ldots, M_q \rangle \rightarrow
\langle M_1 (Y \langle M_1, \ldots, M_q \rangle),
\ldots, M_q (Y \langle M_1, \ldots, M_q \rangle) \rangle \ .$$


It is easy to see that higher-order recursion schemes have the same computational power as the simply-typed lambda calculus extended with mutual recursion and $\Sigma$-constants.
The first direction is trivial: Take a recursion scheme $\langle \Sigma, \mathcal{N}, \mathcal{R}, F_0 \rangle$
where $\mathcal{R} = \{ F_0, \ldots, F_q \}$ for some $q\geq 0$.
We convert each rule $F_i\ x_1 \ldots x_n \rightarrow e$ into a lambda term $\widetilde{F_i} \equiv \lambda F_0 \ldots F_q x_1 \ldots x_n . e$. The recursion scheme can then be equivalently formulated as the term $\ymut ( \widetilde{F_0},\ \ldots,\  \widetilde{F_q})$.

Conversely, any lambda term using mutual recursion and $\Sigma$-constants can be turned into an equivalent higher-order recursion schemes. This is done by proceeding inductively over the syntax of the $\eta$-long normal form of the term.
The algorithm {\sf LmdToRS} that performs this conversion is given in table \ref{tab:LmdToRS}. We describe the algorithm in an ML-like syntax, using lists to encode the set of rules $\mathcal{R}$ and non-terminals $\mathcal{N}$. (Observe that since we work on the $\eta$-long normal form, the right-hand side of each generated rule is indeed of ground type, as required by the definition of recursion schemes.)


\begin{table}[htbp]

{\bf Input}: a closed term $\vdash_\Sigma M : T$ using mutual recursion and  $\Sigma$-constants.

{\bf Output}: an equivalent higher-order recursion scheme $\langle \Sigma, \mathcal{N}, \mathcal{R}, S \rangle$.
$$\begin{array}{ll}
{\sf let\ LmdToRS}(\vdash_\Sigma M : T) =  \\
\qquad {\sf let\ createRules} = {\sf fun} \\
\qquad \qquad
    \begin{array}{lcl}
     |\ \Gamma \vdash x : T &\rightarrow& x \\
     |\ \Gamma \vdash M_0 \ldots M_q : o
      &\rightarrow&
        \mbox{``}{\sf createRules} (\Gamma \vdash M_0) \ldots {\sf createRules} (\Gamma \vdash M_q)\mbox{''}
      \\
     |\ \overline{x} : \overline{A} \vdash \lambda \overline{y}:\overline{B}. M : (\overline{B},o)
       &\rightarrow&
        {\sf let\ } t = {\sf createRules} (\overline{x}: \overline{A}, \overline{y}: \overline{B}\vdash M : o) \\
         && {\sf and \ } F \mbox{ be a fresh non-terminal name } {\sf in}\\
         &&\mathcal{R} \leftarrow \mbox{``}F\ \overline{x}\ \overline{y} \rightarrow t\mbox{''}::\mathcal{R} \\
         &&\mathcal{N} \leftarrow \mbox{``}F : (\overline{A},\overline{B},o)\mbox{''}::\mathcal{N} \\
         && \mbox{``}F\ \overline{x}\mbox{''}
     \\
      |\ \overline{x} : \overline{A} \vdash \ymut (M_1, \ldots, M_q):B_1 &\multicolumn{2}{l}{\mbox{ where } \forall i \in 1..q: M_i:B_i \mbox{ and } B=B_1 \times \ldots \times B_q \rightarrow} \\
     &&
     {\sf for\ i = 1\ ..\ q\ do} \\
     &&\qquad     {\sf createRules} (\overline{x}: \overline{A} \vdash M_i : B_i) \\
     &&\qquad     rule[i] \leftarrow hd\ \mathcal{R} \\
     &&{\sf done} \\
     &&{\sf let\ for\ all\ i\in\{1..q\}, } \mbox{``}F_i\ \overline{x}\ f_1 \ldots f_q\ \overline{y}_i \rightarrow t_i \mbox{''} = rule[i] {\sf\ in}\\
     &&{\sf for\ i = 1\ ..\ q\ do} \\
     &&\qquad \mathcal{R} \leftarrow \mbox{``}\widehat{F_i}\ \overline{x} \ \overline{y}_i \rightarrow t[\widehat{F_1} \overline{x}/f_1] \ldots [\widehat{F_q} \overline{x}/ f_q]\mbox{''} \\
     &&\qquad\qquad ::(tail\ \mathcal{R}[\widehat{F_1} \overline{x}/f_1] \ldots [\widehat{F_q} \overline{x}/ f_q]) \\
     &&\qquad\mathcal{N} \leftarrow \mbox{``}F_i : (\overline{A},B_i)\mbox{''}::(tail\ \mathcal{N}) \\
     &&{\sf done} \\
     &&\mbox{``}F_1\ \overline{x}\mbox{''}
   \end{array} \\
\qquad {\sf in}\\
\qquad \mathcal{N},\mathcal{R} \leftarrow [],[]  \\
\qquad appterm \leftarrow {\sf createRules}(\vdash M : T) \\
\qquad \langle \Sigma, \mbox{``}S\ \rightarrow appterm\mbox{''}::\mathcal{N}, \mbox{``}S:o\mbox{''}::\mathcal{R}, S \rangle
\end{array}$$

\caption{Algorithm {\sf LmdToRS} converting a mutually recursive lambda term into a recursion scheme.}
\label{tab:LmdToRS}
\end{table}


