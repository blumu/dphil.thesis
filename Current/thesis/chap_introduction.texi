% -*- TeX -*- -*- Soft -*-

\section*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski
and Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars.
The idea, however, goes back some twenty years to Damm \cite{Dam82}
who introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe}
  grammars form an infinite hierarchy as $n$ varies over the
  natural numbers. The hierarchy gives an attractive
  classification of the semi-decidable languages: Levels 0, 1
  and 2 of the hierarchy are respectively the regular,
  context-free, and indexed languages (in the sense of Aho
  \cite{Aho68}), although little is known about higher orders.

  Remarkably, for generating word languages, order-$n$
  \emph{safe} grammars are equivalent to order-$n$ pushdown
  automata \cite{DG86}, which are in turn equivalent to
  order-$n$ indexed grammars \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have
    decidable MSO theories. More precisely, the MSO theory of
    trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to
  Damm and Goerdt \cite{DG86} to an equivalence result with
  respect to generating trees: A ranked tree is generated by an
  order-$n$ \emph{safe} grammar if and only if it is generated
  by an order-$n$ pushdown automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a
  recent paper \cite{hmos-lics08}, however, Hague \emph{et
  al.} have shown that the MSO theories of graphs generated by
  order-$n$ \emph{unsafe} grammars are undecidable, but deciding
  their modal mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}



\section*{Overview}

The aim of this thesis is to understand the safety condition in the setting of the typed lambda calculus. Our first task is to transpose it to the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and
cleaner version where terms are no longer required to be
homogeneously typed (see Section~\ref{sec:safe} for a definition).
The formation rules of the calculus are designed to maintain a
simple invariant: Variables that occur free in a safe $\lambda$-term
have orders no smaller than that of the term itself.  We can now
explain the sense in which the safe lambda calculus is safe by
establishing its salient property: No variable capture can ever
occur when substituting a safe term into another. In other words, in
the safe lambda calculus, it is \emph{safe} to use
capture-\emph{permitting} substitution when performing
$\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable
names in the input term. Safe lambda calculus is thus cheaper to
compute in this na\"ive sense. Intuitively one would expect the
safety constraint to lower the expressivity of the simply typed
lambda calculus. Our next contribution is to give a precise measure
of the expressivity deficit of the safe lambda calculus. An old
result of Schwichtenberg \cite{citeulike:622637} says that the
numeric functions representable in the simply typed lambda calculus
are exactly the multivariate polynomials \emph{extended with the
conditional function}.  In the same vein, we show that the numeric
functions representable in the safe lambda calculus are exactly the
multivariate polynomials. We further obtain a similar characterization concerning representable word-functions.

In order to get a better understanding of our calculus, it is interesting to recast common problems studied in the literature on the simply typed lambda calculus in the setting of the safe lambda calculus.
We show for instance that the type-checking and typability problems remain decidable. We also consider the type-inhabitation problem (``Is there a term inhabiting a given type?''). This problem is already relatively complex in the simply-typed lambda calculus: Statman showed that it is PSPACE-complete.
Because of the somewhat intricate way in which safety constrains the occurrences of the variables, the inhabitation problem becomes even more
complex in the safe lambda calculus. We do not know whether the problem is decidable.

Another famous result by Statman is that deciding beta-equality of two simply typed terms is non-elementary. There are several proofs of this results in the literature. All of them proceed by reduction of a non-elementary problem - such as quantifier elimination in finite type theory - into the simply typed lambda calculus. Interestingly, all these encodings make use of unsafe terms in some place. This suggests that such encoding is impossible in the safe lambda calculus and that the beta-equivalence problem may be simpler when restricted to safe terms. Unfortunately, we have not been able to establish an upper-bound on the complexity of this problem. On the other hand, a lower-bound can be obtained: we can easily encode the True Quantifier Boolean Formula (TQBF) problem in the safe lambda-calculus, thus showing that deciding beta-equivalence is PSPACE-hard.
A particularity of this encoding is that it relies on the entire type hierarchy and thus we only have PSPACE-hardness for the safe lambda calculus in its entirety. This contrasts with another result by Statman which shows that there exists a finite set of types such that the beta-eta equivalence problems in the simply type lambda calculus restricted to terms of these types is PSPACE-hard.

\subsection*{Concrete game semantics}
Game semantics has emerged as a powerful paradigm for the study of higher-order functional programming languages in general, and the lambda calculus in particular - the mother of all functional languages.
Game model were for instance the first to give rise to a full abstract model of PCF \cite{abramsky94full,hylandong_pcf}. A major part of this thesis is concerned with the study of the game semantics of safe terms.

In the traditional presentation of game semantics, a lot of attention is taken to abstract away completely the syntax of the language from the definition of the semantics. This syntax-independent aspect of game models constitutes their salient feature. But when it comes to analyze the safety restriction it appears more like a complication rather than a benefit because safety is precisely a \emph{syntactic} constraint.

A substantial part of the thesis is therefore devoted to give a presentation of game semantics that is more concrete than the traditional one in the sense that the syntax of the term is carried over in its semantic denotation.
This presentation is based on ideas recently introduced in \cite{OngLics2006}: a term is canonically represented by a certain abstract syntax tree of its
 $\eta$-long normal form referred as the \emph{computation tree}. 
A computation is then described by a justified sequence of nodes of the computation tree  respecting some formation rules and called a
 \emph{traversal}. Traversals permit us to model $\beta$-reductions
 without altering the structure of the computation tree via
 substitution. A notable property is that \emph{P-views} (in the
 game-semantic sense) of traversals corresponds to paths in the
 computation tree.  We show that traversals are just representations of
 the \emph{revealed game semantic} denotation: the set of uncovering of plays of the game-semantic denotation with respect to the syntax of the eta-long normal form of the term. The standard game denotation can then be recovered by mean of a \emph{reduction} operation which eliminates traversal nodes that are ``internal'' to the computation, thus implementing the
 counterpart of the hiding operation of game semantics. This leads to 
 an isomorphism between the standard strategy denotation of a term and the set  of reductions of traversals of its computation tree.
 
\subsection*{Game semantics of safety}
 
 This contribution constitutes a significant detour from the main topic of this thesis, but it turns out to be extremely useful. Using the correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} over its \emph{computation tree}, we are able to show that safe terms are denoted by \emph{P-incrementally justified strategies}. In such a
strategy, pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the
pointers associated to the O-moves therein: Specifically, a
P-question always points to the last pending O-question (in the
P-view) of a greater order. Consequently pointers in the game
semantics of safe $\lambda$-terms are only necessary from order 4
onwards. More precisely, we show that a $\beta$-normal $\lambda$-term is
\emph{safe} if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.


\subsection*{Model of safe lambda calculi}
Our last contribution is to establish a game model of the safe lambda calculus. A fundamental result in theoretical computer science is the connection between Cartesian Closed Categories (CCC) and models of typed lambda calculi: it was observed by Lambek \cite{lambek1986ccc} that any extensional model of the simply typed lambda calculus is a CCC, and converserly, any typed lambda calculus induces a CCC.

A similar categorical connection can be made for models of the safe lambda calculus. The categorical counterparts of safe lambda calculi are the \emph{Incremental Closed Categories} (ICC). These categories are subcategories of CCC in which \emph{Currying} is restrained. By showing that P-incrementally justified strategies compose, we can construct an ICC of games with morphisms given by P-incrementally justified strategies. This gives rise to a categorical game model of the safe lambda calculus.

% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, Luke Ong obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the paper \cite{hmos-lics08}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.


%\section{The game-semantic correspondence}
% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph
% based on Lamping's graphs \cite{lamping} is introduced to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda calculus.


\section*{Prerequisite}
The reader is assumed to be familiar with the simply-typed lambda calculus. A brief account is given in the background chapter; a more detailed introduction can be found in \cite{Barendregt:92}. Familiarity with game semantics would be very helpful, in particular for Chapter \ref{chap:syntactic_gamesem} and \ref{chap:model}, although it is not a requirement since the background chapter contains an introduction on the topic. A very good tutorial is \cite{abramsky:game-semantics-tutorial}.


\section*{Organization of the thesis}
The first chapter lays down the background for the rest of the thesis. It introduces \emph{higher-order grammars},
the original setting in which the safety restriction firstly
appeared, and presents the safety restriction with some related
results. It then presents briefly the simply-type lambda calculus and
 two of its extension that will be studied throughout the thesis, namely PCF and Idealized Algol. Finally, the last section is devoted to the presentation of the basics and main results of game semantics. It also fixes notation that will be use in other chapters when we study the game semantics of the safety restriction.

Chapter \ref{chap:safelambda} introduces the definition of the \emph{safe lambda calculus}. It establishes basic properties of the calculus and gives an account of its expressivity and complexity.
The chapter concludes with a generalization of the safety restriction to other applied lambda calculi such as PCF and Idealized Algol.

Chapter \ref{chap:concrete_gamesem} takes a detour from the safety restriction. It presents and extends the theory of traversals originally introduced in \cite{OngLics2006}, introducing the notions of computation tree of a simply-typed term and traversals over the computation tree. The ultimate goal of this chapter is to prove an important result called the Correspondence Theorem which establishes a correspondence between traversals of the computation tree and the game semantics of a term.

This correspondence theorem allows us to give an account
of the game semantics of safety using a very simple syntactic argument. This is presented in Chapter \ref{chap:syntactic_gamesem}.

Chapter \ref{chap:model} presents a categorical model of the safe lambda calculus, safe \pcf and safe Idealized Algol. A complete fully abstract game model is established. The chapter concludes with application to Algorithmic Game Semantics.




\unfinished[stuff from TLCA paper]
{\pcf\ is the simply typed lambda calculus augmented with basic
arithmetic operators, if-then-else branching and a family of
recursion combinator $Y_A : ((A,A),A)$ for any type $A$.  We define
\emph{safe} \pcf\ to be \pcf\ where the application and abstraction
rules are constrained in the same way as the safe lambda calculus.
This language inherits the good properties of the safe lambda
calculus: No variable capture occurs when performing substitution
and safety is preserved by the reduction rules of the small-step
semantics of \pcf. Similarly, we define safe \ialgol\ as safe \pcf\ augmented
with the imperative features of Idealized Algol (\ialgol\ for short)
\cite{Reynolds81}.


The computation tree of a \pcf\ term is defined as the least
upper-bound of the chain of computation trees of its \emph{syntactic
approximants} \cite{abramsky:game-semantics-tutorial}.  It is
obtained by infinitely expanding the $Y$ combinator, for instance
$\tau(Y (\lambda f x. f x))$ is the tree representation of the
$\eta$-long form of the infinite term $(\lambda f x. f x)
 ((\lambda f x. f x) ((\lambda f x. f x) ( \ldots$

It is straightforward to define the traversal rules modeling the
arithmetic constants of \pcf. Just as in the safe lambda calculus we
had to remove @-nodes in order to reveal the game-semantic
correspondence, in safe \pcf\ it is necessary to filter out the
constant nodes from the traversals. The Correspondence Theorem for
\pcf\ says that the interaction game semantics is isomorphic to the
set of traversals disposed of these superfluous nodes. This can
easily be shown for term approximants. It is then lifted to full
\pcf\ using a continuity argument. Finally computation trees of
safe \pcf\ terms are incrementally-bound thus we obtain the theorem that
safe PCF terms are denoted by P-incrementally justified strategies.

It is possible to adapt the game-semantic correspondence and
safety characterization to \ialgol\ although the
presence of the base type \iavar, whose game arena $\iacom^{\nat}
\times \iaexp$ has infinitely many initial moves, causes a mismatch
between the tree representation of the term and its game
arena. To overcome this problem we introduce the
notion of computation hyper-trees.

The possibility of representing plays \emph{without some or all of
  their pointers} under the safety assumption suggests potential
applications in algorithmic game semantics. Ghica and McCusker
\cite{ghicamccusker00} were the first to observe that pointers are
unnecessary for representing plays in the game semantics of the
second-order finitary fragment of Idealized Algol ($\ialgol_2$ for
short). Consequently observational equivalence for this fragment can
be reduced to the problem of equivalence of regular expressions.  At
order $3$, although pointers are necessary, deciding observational
equivalence of $\ialgol_3$ is EXPTIME-complete
\cite{DBLP:journals/apal/Ong04,DBLP:conf/fossacs/MurawskiW05}.
Restricting the problem to the safe fragment of $\ialgol_3$ may lead
to a lower complexity.

% (note that it is unlikely to obtain the complexity PSPACE because the
% set of complete plays of the safe term $\lambda f^{(o,o),o} . f
% (\lambda x^o . x)$ is not regular \cite{DBLP:journals/apal/Ong04}).

% Murawski showed the undecidability of program equivalence in
% $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations
% into a finitary $IA_4$ term \cite{murawski03program}. The term
% constructed being not safe, the proof cannot be transposed to the
% safe fragments. Hence the question remains of whether observational
% equivalence is decidable for the \emph{safe} fragments of these
% language.

%In \cite{Ong02}, Ong showed that observational equivalence for
% finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is
% undecidable. The proof consists in reducing the Queue-Halting
% problem to the observational equivalence of two $\ialgol_2 + Y_1$
% terms. The same reduction is still valid in the safe fragment of
% $\ialgol_2 + Y_1$.  Consequently, observational equivalence of safe
% $\ialgol_2 + Y_1$ is also undecidable.
} 