% -*- TeX -*- -*- Soft -*-

\section*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski
and Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars.
The idea, however, goes back some twenty years to Damm \cite{Dam82}
who introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe}
  grammars form an infinite hierarchy as $n$ varies over the
  natural numbers. The hierarchy gives an attractive
  classification of the semi-decidable languages: Levels 0, 1
  and 2 of the hierarchy are respectively the regular,
  context-free, and indexed languages (in the sense of Aho
  \cite{Aho68}), although little is known about higher orders.

  Remarkably, for generating word languages, order-$n$
  \emph{safe} grammars are equivalent to order-$n$ pushdown
  automata \cite{DG86}, which are in turn equivalent to
  order-$n$ indexed grammars \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have
    decidable MSO theories. More precisely, the MSO theory of
    trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to
  Damm and Goerdt \cite{DG86} to an equivalence result with
  respect to generating trees: A ranked tree is generated by an
  order-$n$ \emph{safe} grammar if and only if it is generated
  by an order-$n$ pushdown automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a
  recent preprint \cite{hague-sto07}, however, Hague \emph{et
  al.} have shown that the MSO theories of graphs generated by
  order-$n$ \emph{unsafe} grammars are undecidable, but deciding
  their modal mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}

\subsection*{Overview}

The aim of this thesis is to understand the safety condition in the
setting of the lambda calculus. Our first task is to transpose it to
the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and
cleaner version where terms are no longer required to be
homogeneously typed (see Section~\ref{sec:safe} for a definition).
The formation rules of the calculus are designed to maintain a
simple invariant: Variables that occur free in a safe $\lambda$-term
have orders no smaller than that of the term itself.  We can now
explain the sense in which the safe lambda calculus is safe by
establishing its salient property: No variable capture can ever
occur when substituting a safe term into another. In other words, in
the safe lambda calculus, it is \emph{safe} to use
capture-\emph{permitting} substitution when performing
$\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable
names in the input term. Safe lambda calculus is thus cheaper to
compute in this na\"ive sense. Intuitively one would expect the
safety constraint to lower the expressivity of the simply-typed
lambda calculus. Our next contribution is to give a precise measure
of the expressivity deficit of the safe lambda calculus. An old
result of Schwichtenberg \cite{citeulike:622637} says that the
numeric functions representable in the simply-typed lambda calculus
are exactly the multivariate polynomials \emph{extended with the
conditional function}.  In the same vein, we show that the numeric
functions representable in the safe lambda calculus are exactly the
multivariate polynomials.

Our last contribution is to give a game-semantic account of the safe
lambda calculus.
% Not much is known about the safe $\lambda$-calculus, and many problems
% remain to be studied concerning its computational power, the
% complexity classes that it characterizes, its interpretation under the
% Curry-Howard isomorphism and its game-semantic characterization. This
% paper is a contribution to the last problem.
%
% The difficulty in giving a game-semantic account of safety lies in the
% fact that it is a syntactic restriction whereas game semantics is
% syntax-independent. The solution consists in finding a particular
% syntactic representation of terms on which the plays of the game
% denotation can be represented.  To achieve this, we use ideas recently
% introduced by the second author \cite{OngLics2006}: a term is
% canonically represented by a certain abstract syntax tree of its
% $\eta$-long normal form referred as the \emph{computation tree}. This
% abstract syntax tree is specially designed to establish a
% correspondence with the game arena of the term. A computation is
% described by a justified sequence of nodes of the computation tree
% respecting some formation rules and called a
% \emph{traversal}. Traversals permit us to model $\beta$-reductions
% without altering the structure of the computation tree via
% substitution. A notable property is that \emph{P-views} (in the
% game-semantic sense) of traversals corresponds to paths in the
% computation tree.  We show that traversals are just representations of
% the uncovering of plays of the game-semantic denotation. We then
% define a \emph{reduction} operation which eliminates traversal nodes
% that are ``internal'' to the computation, this implements the
% counterpart of the hiding operation of game semantics. Thus, we obtain
% an isomorphism between the strategy denotation of a term and the set
% of reductions of traversals of its computation tree.
Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are
denoted by \emph{P-incrementally justified strategies}. In such a
strategy, pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the
pointers associated to the O-moves therein: Specifically, a
P-question always points to the last pending O-question (in the
P-view) of a greater order. Consequently pointers in the game
semantics of safe $\lambda$-terms are only necessary from order 4
onwards. Finally we prove that a $\beta$-normal $\lambda$-term is
\emph{safe} if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.



% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, Luke Ong obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the forthcoming paper \cite{hague-sto07}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

% \medskip

% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph
% based on Lamping's graphs \cite{lamping} is introduced to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The safety restriction for higher-order grammars}

\section{The game-semantic correspondence}


\section{Organisation of the thesis}
The present thesis is divided in two parts. The first part lay down
the background for the rest of the thesis. It is divided in three
chapters. The first chapter presents \emph{higher-order grammars},
the original setting in which the safety restriction firstly
appeared. It presents the safety restriction with some related
results. The next chapter introduces the languages that will be
considered throughout the thesis: the simply-typed lambda calculus
and two of its extension: PCF and Idealized Algol. Chapter
\ref{{chap:gamesem}} is devoted to the presentation of the basics
and main results of game semantics. It also fixes notation that will
be use in the second part of the thesis when we analyse the game
semantics of the safety restriction.

The second part of the thesis presents the contribution. Chapter \ref{safelambda} introduces the definition of the \emph{safe lambda calculus}. It establishes basic properties of the calculus and studies its expressivity and complexity.
Various extensions of the safety restriction to languages like PCF and Idealzied Algol are also considered.
\notetoself{organisation of the rest of the chapters of the second part.}

Chapter \ref{chap:localbeta} takes a detour from the safety restriction. It presents and extends the theory of traversals originally introduced in \cite{OngLics2006}. We present the notions of computation tree of a simply-typed term and traversals over the computation tree. We then give the first proof of an important theorem in the theory of traversals that establishes a correspondence between traversals of the
computation tree and the game semantics of a term. 

The correspondence established in Chapter \ref{chap:localbeta} allows us to study in a very simple manner the game semantics of safety. This is presented in Chapter \ref{chap:syntactic_gamesem}.

