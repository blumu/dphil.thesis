% -*- TeX -*- -*- Soft -*-

\section{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski
and Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars.
The idea, however, goes back some twenty years to Damm \cite{Dam82}
who introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars---namely the safe complete grammars---and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe}
  grammars form an infinite hierarchy as $n$ varies over the
  natural numbers. The hierarchy gives an attractive
  classification of the semi-decidable languages: Levels 0, 1
  and 2 of the hierarchy are respectively the regular,
  context-free, and indexed languages (in the sense of Aho
  \cite{Aho68}), although little is known about higher orders.

  Remarkably, for generating word languages, order-$n$
  \emph{safe} grammars are equivalent to order-$n$ pushdown
  automata \cite{DG86}, which are in turn equivalent to
  order-$n$ indexed grammars \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik et~al.\ have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have
    decidable MSO theories. More precisely, the MSO theory of
    trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to
  Damm and Goerdt \cite{DG86} to an equivalence result with
  respect to generating trees: A ranked tree is generated by an
  order-$n$ \emph{safe} grammar if and only if it is generated
  by an order-$n$ pushdown automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a
  recent paper \cite{hmos-lics08}, however, Hague et~al. have shown that the MSO theories of graphs generated by
  order-$n$ \emph{unsafe} grammars are undecidable, but deciding
  their modal mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}



\section{Overview}

The aim of this thesis is to understand the safety condition in the setting of the typed lambda calculus. Our first task is to transpose it to the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and
cleaner version where terms are no longer required to be
homogeneously typed.
The formation rules of the calculus are designed to maintain a
simple invariant: Variables that occur free in a safe lambda-term
have orders no smaller than that of the term itself.  We can now
explain the sense in which the safe lambda calculus is safe by
establishing its salient property: No variable capture can ever
occur when substituting a safe term into another. In other words, in
the safe lambda calculus, it is \emph{safe} to use
capture-\emph{permitting} substitution when performing
$\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe lambda-terms, because one can safely ``reuse'' variable
names in the input term. Safe lambda calculus is thus cheaper to
compute in this na\"ive sense. Intuitively one would expect the
safety constraint to lower the expressivity of the simply typed
lambda calculus. Our next contribution is to give a precise measure
of the expressivity deficit of the safe lambda calculus. An old
result of Schwichtenberg \cite{citeulike:622637} says that the
numeric functions representable in the simply typed lambda calculus
are exactly the multivariate polynomials \emph{extended with the
conditional function}.  In the same vein, we show that the numeric
functions representable in the safe lambda calculus are exactly the
multivariate polynomials.
\begin{citeresult}{Theorem \ref{thm:polychar}}
The numeric functions (Church-)representable in the safe lambda-calculus are exactly the multivariate polynomials.
\end{citeresult}
We further obtain a similar characterization concerning representable word-functions.
\begin{citeresult}{Theorem \ref{thm:wordfunctions_safely_definable}}
The word-functions definable in the safe lambda calculus is given by
the minimal set containing (a) concatenation, (b) substitution, (c) the projections, (d) the constant functions; and closed by composition.
\end{citeresult}

In order to get a better understanding of our calculus, it is interesting to recast common problems studied in the literature on the simply typed lambda calculus in the setting of the safe lambda calculus.
We show for instance that the type-checking and typability problems remain decidable. We also consider the type-inhabitation problem: ``Is there a term inhabiting a given type?''. This problem is already relatively complex in the simply typed lambda calculus---Statman showed that it is PSPACE-complete.
Because of the somewhat intricate way in which safety constrains the occurrences of the variables, the inhabitation problem becomes even more
complex in the safe lambda calculus. We do not know whether the problem is decidable.

Another famous result by Statman is that deciding beta-equality of two simply typed terms is non-elementary. There are several proofs of this result in the literature. All of them proceed by reduction of a non-elementary problem---such as quantifier elimination in finite type theory---into the simply typed lambda calculus. Interestingly, all these encodings make use of unsafe terms in some place. This suggests that such encoding is impossible in the safe lambda calculus and that the beta-equivalence problem may be simpler when restricted to safe terms. We have not been able to establish an upper-bound on the complexity of this problem but we provide a lower-bound: the True Quantifier Boolean Formula (TQBF) problem (\ie, deciding whether a quantified boolean formula is true) can be encoded in the safe lambda-calculus. Since the latter problem is PSPACE-complete, this implies:
 \begin{citeresult}{Theorem \ref{thm:pspacehardness}}
 The beta-equivalence problem for safe lambda-terms is PSPACE-hard.
 \end{citeresult}
A particularity of this encoding is that it relies on the entire type hierarchy and thus we only have PSPACE-hardness for the safe lambda calculus in its entirety. This contrasts with another result by Statman which says that there exists a finite set of types such that the beta-eta equivalence problem restricted to simply typed terms of these types is PSPACE-hard.


\subsection*{Extensions}

\pcf\ is the simply typed lambda calculus augmented with basic
arithmetic operators, if-then-else branching and a family of
recursion combinator $Y_A$ of type $(A\typear A)\typear A$ for every type $A$.  We define
\emph{safe} \pcf\ to be the fragment of \pcf\ obtained by constraining the application and abstraction rules in the same way as the safe lambda calculus.
This language inherits the good properties of the safe lambda
calculus: No variable capture occurs when performing substitution
and safety is preserved by the reduction rules of the small-step
semantics of \pcf. Similarly, we define safe \ialgol\ as safe \pcf\ augmented
with the imperative features of Idealized Algol (\ialgol\ for short)
\cite{Reynolds81}. A version of the no variable capture lemma also holds in safe \ialgol.


\subsection*{A concrete game semantics}
Game semantics has emerged as a powerful paradigm for the study of higher-order functional programming languages in general, and in particular for the mother of all functional languages: the lambda calculus.
The game approach was for instance the first to give rise to a full abstract model of PCF \cite{abramsky94full,hylandong_pcf}.

A question inevitably arising is: Does the safety constraint noticeably impact on the game denotation of a term? Answering this question can help us gain a better understanding of the 
fundamental nature of the safety restriction.

In the traditional presentation of game semantics, attention is taken to abstract away entirely the syntax of the language from the definition of the semantics. This syntax-independent aspect of game models constitutes their salient feature. But when it comes to analyzing the game semantics of the safety restriction, this turns out to be a complication rather than a benefit because safety is precisely a \emph{syntactic} constraint.

A substantial part of the thesis is therefore devoted to giving a presentation of game semantics that is more concrete than the traditional one in the sense that the semantic denotation of a term carries some information about its syntax.
This presentation is based on ideas recently introduced by Ong \cite{OngLics2006}: a term is canonically represented by a certain abstract syntax tree of its
 $\eta$-long normal form referred as the \emph{computation tree}.
A computation is then described by a justified sequence of nodes of the computation tree  respecting some formation rules and called a
 \emph{traversal}. Essentially, traversals allow us to model $\beta$-reductions
 without altering the structure of the computation tree via
 substitution. A notable property is that \emph{P-views} (in the
 game-semantic sense) of traversals corresponds to paths in the
 computation tree.  We show that traversals are just representations of
 the \emph{revealed game semantic} denotation (\ie, the set of uncoverings of plays of the game-semantic denotation with respect to the syntax of the eta-long normal form). The standard game denotation can then be recovered by extracting the \emph{cores} of the traversals, an operation that eliminates nodes that are ``internal'' to the computation---the counterpart of the hiding operation of game semantics. This leads to
 an isomorphism between the standard strategy denotation of a term and the set of traversal cores of its computation tree:
\begin{citeresult}{Theorem \ref{thm:correspondence}}
{\ \rm(The Correspondence Theorem)}
 The set of traversals of the computation tree of a simply typed term-in-context $\Gamma \entail M :T$ is isomorphic to its revealed denotation $\syntrevsem{\Gamma \entail M :T}$; the set of traversal cores is isomorphic to the standard game denotation $\sem{\Gamma \entail M : T}$.
\end{citeresult}

We then extend our presentation of game semantics to PCF and Idealized Algol (PCF extended with block-allocated variables). We accommodate the notion of computation tree to recursively defined terms as follows: the computation tree of a \pcf\ term is defined as the least upper-bound of the chain of computation trees of its \emph{syntactic approximants} \cite{abramsky:game-semantics-tutorial}.
Think of it as the tree obtained by expanding Y-combinators {\it ad infinitum}. For instance the computation tree of $Y (\lambda f x. f x)$ is given by the abstract syntax tree of the $\eta$-long normal form of the infinite lambda-term $(\lambda f x. f x)  ((\lambda f x. f x) ((\lambda f x. f x) ( \ldots $. It is possible to define traversal rules modeling the
arithmetic constants of \pcf\ so that a version of the Correspondence Theorem holds for \pcf.

The extension to \ialgol\ is complicated by the presence of the base type $\iavar$ used for reference variables. Indeed, the game denotation of $\iavar$ has infinitely many initial moves, therefore there is a mismatch between the tree representation of a term of type $\iavar$ and the arena underlying the game induced by the type $\iavar$. It is possible, however, to adapt the game-semantic correspondence to \ialgol\ by generalizing the notion of computation tree to computation hyper-trees. These are trees in which sibling nodes can be grouped together into a single \emph{hyper-node}.
\smallskip

On a more applied side, I have implemented a tool to illustrate the theory of traversals and its correspondence with game semantics \cite{Blum2008}. 

This contribution in game semantics is a significant detour from the main topic of this thesis, but it provides the keys to a simple analysis of the game semantics of the safety constraint.

\subsection*{Game semantics of safety}

Based on the correspondence between the game semantics of a
lambda-term $M$ and the set of traversals over its computation tree, we are able to give a game-semantic characterization of safety. We show that the safety syntactic restriction is semantically captured by the \emph{P-incrementally justified strategies}:
 \begin{citeresult}{Theorem \ref{thm:safeincrejust_lmd}}
 Let $\stentail M : A$ be a closed simply typed term. Then
$$ M \mbox{ has a safe $\beta$-normal form} \iff \sem{\entail M : A} \mbox{ is P-incrementally justified strategies.}$$
 \end{citeresult}
In a \emph{P-incrementally justified strategy}, pointers emanating from the P-moves of a play are uniquely reconstructible from the underlying sequence of moves and the
pointers associated to the O-moves therein. More precisely, a strategy is \emph{P-incrementally justified} just if each P-question in a play points to the last pending O-question of greater order in the P-view at that point. Thus up to order 3, pointers are superfluous in the game semantics of safe lambda-terms; from order 4 onwards, they are only necessary for O-questions.

\subsection*{A model of safe lambda calculi}
Our last contribution is to establish a game model of the safe lambda calculus. A fundamental result in theoretical computer science is the connection between Cartesian Closed Categories (CCC) and models of typed lambda calculi: it was observed by Lambek \cite{lambek1986ccc} that any extensional model of the simply typed lambda calculus is a CCC, and conversely, any typed lambda calculus induces a CCC.

A similar categorical connection can be made for models of the safe lambda calculus. The categorical counterparts of safe lambda calculi are the \emph{Incremental Closed Categories} (ICC). These categories are subcategories of CCC in which \emph{currying} is restrained. By showing that P-incrementally justified strategies compose, we can construct an ICC of games with morphisms given by P-incrementally justified strategies. This gives rise to a categorical game model of the safe lambda calculus:
\begin{citeresult}{Proposition \ref{prop:game_ICC}}
There is a Incremental Closed Category with games as objects and (closed) P-incrementally justified strategies as morphisms that soundly models the safe lambda calculus.
\end{citeresult}

\subsection*{Full abstraction}

A common concept in game semantics is that the pure functional core of a programming language can be modeled by strategies verifying the properties of \emph{visibility}, \emph{innocence} and \emph{well-bracketing}. Adding features to the language corresponds to relaxing one of these properties in the game model. For instance adding imperative features breaks innocence, adding exceptions-handling breaks well-bracketing and adding general references breaks visibility. Furthermore in each of these cases, the game model gives rise to a fully abstract model of the considered language.
For instance the well-bracketed and visible strategies give rise to a fully abstract game model of the language Idealized Algol (IA).

Conversely, restricting the language corresponds to imposing more constraints on the strategy. As mentioned before, the strategy counterpart of the safety restriction is P-incremental justification (P-i.j.\ for short). As expected, this restriction gives rise to a fully-abstract model for the safe fragment of \pcf\ and \ialgol:
\begin{citeresult}{Theorem \ref{thm:fullabstraction_safeia}}{\ \rm(Full abstraction)}
Two safe (PCF or \ialgol) terms are observationally equivalent \emph{with respect to safe contexts} if and only if their denotations are equivalent with respect to the intrinsic preorder of the ICC games model.
\end{citeresult}
%Let $\siaentail M : T$ and $\siaentail N : T$ be two safe closed \ialgol\ terms. Then:
%\begin{align*}
%M \obspre_s  N \ &\iff\  \sem{M}_{\mathcal{I}} \intrpre_{\mathcal{I}_b} \sem{N}_{\mathcal{I}} \\
%&\iff\  \mathcal{O}(\sem{M}_{\mathcal{I}}) \intrpre_{\mathcal{I}_{b}} \mathcal{O}(\sem{N}_{\mathcal{I}})\enspace .
%\end{align*}
%where the preorder $\obspre_s$ is defined similarly as for safe \pcf.
%\end{theorem}


These results are summarized in the following table:
\smallskip

\begin{tabular}{l|l}
Language & Strategy constraints\\ \hline\hline
Safe IA & deterministic + visible + w.b.\ + P-i.j.\\
Safe PCF & deterministic + visible + w.b.\ + innocent + P-i.j.\\
PCF & deterministic + visible + w.b.\ + innocent \\
IA & deterministic + visible + w.b.\  \\
IA + exceptions & deterministic + visible  \\
IA + exceptions + general references & deterministic
\end{tabular}

\subsection*{Algorithmic game semantics}

The game semantic approach has become a very successful paradigm after the resolution of the long-standing full abstraction problem of PCF; its success story did not stop here however. Game semantics turned out to be useful to the study of the observational equivalence problem: Given two terms, can they be used interchangeably? The research activity consisting in studying the observational equivalence problem via game semantics is known as \emph{Algorithmic game semantics}. A major breakthrough was the observation that the game model of Idealized Algol is effectively presentable \cite{AM97a} (a property that is not enjoyed by any model of PCF \cite{loader2001fpn}). This result paved the way to interesting characterizations of the game denotation of lower-order IA terms.
Ghica and McCusker observed \cite{ghicamccusker00} that pointers are
unnecessary for representing plays in the game semantics of the second-order finitary fragment of Idealized Algol ($\ialgol_2$ for short). Consequently observational equivalence for this fragment can
be reduced to the problem of equivalence of regular expressions. Similar characterizations were later obtain for other finitary fragments. For instance at order $3$, although pointers are necessary, deciding observational
equivalence of $\ialgol_3$ is EXPTIME-complete \cite{DBLP:journals/apal/Ong04,DBLP:conf/fossacs/MurawskiW05}. These results are all based on the same observation: at lower orders, the justification pointers present in the game denotation are either not required (\eg, at order $2$) or can be encoded succinctly (\eg, at order $3$). The possibility of representing plays \emph{without some or all of their pointers} under the safety assumption strongly suggests that similar result can be obtained for the safe fragment of \ialgol.


Our last contribution consists in studying the safety from the point of view of algorithmic game semantics.
We introduce a new notion of observational equivalence for IA: A \emph{safe context} is a safe IA term-in-context with a hole (a distinguished variable occurring exactly once in the term); two terms are considered equivalent if no safe context can distinguish them.
We show that up to order $3$ this notion of observational equivalence coincides with the usual one.
A basic result in Algorithmic game semantics is the Characterization Theorem: observational equivalence of two IA terms is characterized by the equality of their set of complete plays. We show a version of this theorem for our notion of observational equivalence:
\begin{citeresult}{Theorem \ref{thm:charac_theorem_oij}}{ \rm(Characterization Theorem)}
Two terms are observationally equivalent with respect to \emph{safe contexts} if and only if they have the same set of P-incremental justified complete plays.
\end{citeresult}
Finally, based on these results, we show that all the known results \cite{ghicamccusker00,Ong02,DBLP:conf/fossacs/MurawskiW05,DBLP:conf/icalp/MurawskiOW05,Murawski2003}
about the complexity of observational equivalence up to order $3$ are also valid for our new notion of observational equivalence:
\begin{citeresult}{Theorem} (Sec.\ \ref{sec:algogamesem_safety})
The observational equivalence problem (with respect to safe contexts) for the safe finitary fragment of
\begin{enumerate}[(a)]
\item order-$2$ \ialgol\ + iteration is in PSPACE;
\item order-$2$ \ialgol\ + order-$1$ recursion is undecidable;
\item order-$3$ + iteration is EXPTIME-complete;
\item order-$3$ + ground type recursion is reducible to the equivalence problem for deterministic pushdown automata (DPDA), and is thus decidable.
\end{enumerate}
\end{citeresult}
This suggests that the restriction imposed on contexts kicks in at order-$4$.
Murawksi has shown that the problem for (not necessarily safe) terms is undecidable at order-$4$ \cite{Murawski2003}. His proof can be reused to show that the observational equivalence problem for safe order-$4$ terms and unrestricted (\ie, not necessarily safe) contexts remains undecidable. We further make the following conjecture:
\begin{citeresult}{Conjecture \ref{conj:order4obseeq_decidable}}
The observational equivalence problem for \emph{safe terms} with respect to \emph{safe contexts} reduces to the DPDA-equivalence problem and thus is decidable.
\end{citeresult}

\ifforexaminers
\else
\section{Prerequisite}
The reader is assumed to be familiar with the simply typed lambda calculus. A brief account is given in the background chapter;
For more details, we refer the reader to introductions on the subject by Barendregt \cite{Barendregt:92} and Hindley \cite{Hindley1997}. Familiarity with game semantics, in particular for Chapter \ref{chap:syntactic_gamesem} and \ref{chap:model}, is also helpful although it is not a requirement since the topic is introduced in the background chapter.
For another introduction we recommend Abramsky and McCusker's tutorial \cite{abramsky:game-semantics-tutorial}.
\fi

\section{Organization of the thesis}
The next chapter lays down the background for the rest of the thesis. It introduces briefly the simply typed lambda calculus and  two of its extensions that will be studied throughout the thesis, namely PCF and Idealized Algol.
 It then presents \emph{higher-order grammars}, the original setting in which the safety restriction firstly
appeared, and presents the safety restriction with some related
results.
Finally, the last section is devoted to the presentation of the basics and main results of game semantics. It also fixes notations that will be used in other chapters.

{\bf Chapter \ref{chap:safelambda}} introduces the definition of the \emph{safe lambda calculus}. It establishes basic properties of the calculus and gives an account of its expressivity and complexity.
The chapter concludes with a generalization of the safety restriction to other applied lambda calculi such as PCF and Idealized Algol.

{\bf Chapter \ref{chap:concrete_gamesem}} takes a detour from the safety restriction. It presents and extends the theory of traversals
originally introduced by Ong \cite{OngLics2006}. It defines the notions of \emph{computation tree} of a simply typed term and \emph{traversals} over this tree. The ultimate goal is to prove the \emph{Correspondence Theorem}, an important result that establishes a correspondence between traversals of the computation tree and the game semantic denotation of a term.

This correspondence theorem allows us to give in {\bf Chapter \ref{chap:syntactic_gamesem}} an account
of the game semantics of safety using a very simple syntactic argument.

In {\bf Chapter \ref{chap:model}} we look at categorical models for the safe lambda calculus, safe \pcf\ and safe Idealized Algol. A complete fully abstract game model is established. The chapter concludes with application to Algorithmic Game Semantics.
