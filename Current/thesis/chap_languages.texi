
\section{Idealized Algol}

Idealized Algol, \ialgol\ for short, is \pcf extended with imperative features.
It was introduced by J.C.~Reynold in \cite{Reynolds81}. It adds imperative features such as local
variables and sequential composition. On top of the base type \iaexp, it has
two new types: \iacom\ for commands and \iavar\ for
variables. There is a constant \iaskip\ of type \iacom\ 
which corresponds to the command that does nothing.

Commands can be composed using the sequential composition operator
$\iaseq_A$: suppose that $M$ and $N$ are of type \iacom\
and $A$ respectively then they can be composed to form the term $S =
\iaseq_A M N : \iacom$. $S$ denotes program that
executes $M$ until it terminates and then behaves like $N:A$. If $A
= \iaexp$ then the expression is allowed to have a side-effect
and $S$ returns the expression computed by $N$, if $A =
\iacom$ then the command $N$ is executed after $M$. We say
that the language has \emph{active expressions} to indicate the
presence of the sequential operator $\iaseq_{\iaexp}$ in the
language.


Local variables are
declared using the \ianew\ operator, variable content is altered
using \iaassign\ and retrieved using \iaderef.

In addition IA has the constant \iamkvar\ that can be used to
create a particular kind of variables. The \iamkvar\ operator
works in an object oriented fashion: it takes two arguments, the
first one is a function (called the acceptor) that affects a value
to the variable and the second argument is an expression that
returns a value from the variable. This mechanism is similar to
the ``set/get'' object programming paradigm used by C++ programmers.

Variables created with \iamkvar\ are less constrained than the
variables created with \ianew. Indeed, variables created with
\ianew\ act like memory cells, they obey the following rule:
the value read from the variable is always the last value that has
been assigned to it. This rule does not apply to variables created
with \iamkvar. For instance the variable:
$$\iamkvar\  (\lambda v.\iaskip)\ 0$$
will always return $0$ even if another number has been assigned it.


One may think that this addition to the language is artificial, however the full abstraction result of the game model of IA relies upon this addition.\footnote{McCusker showed in \cite{mccusker2001} that the game model of IA with \iamkvar\ which is fully abstract with respect to the observational preorder is also fully abstract for the language without \iamkvar\, but for observational equivalence only. Hence the model is equationally but not inequationally fully abstract for IA without \iamkvar .}


\subsection{The syntax of \ialgol}

The set of formation rules for the constructs of \ialgol are given
in table \ref{tab:ia_formrules}. (They are defined on top of the formations rules of \pcf.)
Judgements are of the form $\Gamma \vdash M : A$. If $\Gamma = \emptyset$ then we say that $M$
is a closed term.

\begin{table}[htbp]
$$ \rulef{\Gamma \vdash M : \iacom \quad \Gamma \vdash N :A}
    {\Gamma \vdash \iaseq_A \ M\ N\ : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulef{\Gamma \vdash M : \iavar\ \quad \Gamma \vdash N : \iaexp}
    {\Gamma \vdash \iaassign\ M\ N\ : \iacom}
\qquad
 \rulef{\Gamma \vdash M : \iavar}
    {\Gamma \vdash \iaderef\ M\ : \iaexp}$$

$$ \rulef{\Gamma, x : \iavar\ \vdash M : A}
    {\Gamma \vdash \texttt{new } x \texttt{ in } M} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulef{\Gamma \vdash M_1 : \iaexp \rightarrow \iacom \quad \Gamma \vdash M_2 : \iaexp}
    {\Gamma \vdash \iamkvar\  M_1\ M_2\ : \iavar}$$

\caption{Formation rules for IA terms}
\label{tab:ia_formrules}
\end{table}


\subsection{Finitary fragments of Idealized algol}
\label{subsec:iafragments}
We introduce some commonly used fragments of the language \ialgol. Firstly, \defname{Finitary
Idealized Algol} denotes the recursion-free sub-fragment of \ialgol\
over finite ground types (\ie  $\nat$ is replaced by the set $0..max$ for some
fixed value $max$).

\begin{definition}[$i$th order \ialgol\ term]
A term $\Gamma \vdash M:T$ of finitary Idealized algol is an $i$th-order term if any sequent $\Gamma' \vdash N:A$ appearing in the typing derivation of $M$ is such that $\ord{A} \leq i$ and all the variables in $\Gamma'$ are of order strictly less than $i$.
\end{definition}

The fragment of finitary Idealized Algol
consisting of the collection of $i$th-order terms is denoted $\ialgol_i$.
If we add the iteration construct defined as
$$  \rulef{\Gamma \vdash M : \iabool \qquad \Gamma \vdash N : \iacom}{\Gamma \vdash \iawhile\ M \iado\ N : \iacom } \quad \mbox{where } \forall x \in \Gamma : \ord{x} < i $$
we obtain the fragments $\ialgol_i + \textsf{while}$ for $i\in\nat$.
Finally $\ialgol_i + \textsf{Y}_j$ for $j< i$ denotes the fragment $\ialgol_i$ augmented with a set of fixed-point iterators $\textsf{Y}_A : (A\typear A ) \typear A$ for any type $A$ of order $j$ at most, whose syntax is defined by the rule:
$$  \rulef{\Gamma \vdash \lambda x . M : A\rightarrow A}{\Gamma \vdash Y_A M : A} \quad \mbox{where } \forall x \in \Gamma : \ord{x} < i \mbox{ and } \ord{A} \leq j $$


\subsection{Operational semantics of \ialgol}

To define the operational semantics of IA we proceed slightly differently than for \pcf. Instead of giving the semantics for closed terms, we consider terms whose free variables are all of type
\iavar. Terms are ``closed'' by means of stores. A store is a
function mapping free variables of type \iavar\ to natural
numbers. Suppose $\Gamma$ is a context containing only variables of
type \iavar, then we say that $\Gamma$ is a
\iavar-context. A store with domain $\Gamma$ is called a
$\Gamma$-store. The notation $s\ |\ x \mapsto n$ refers to the store
that maps $x$ to $n$ and acts according to the store $s$ otherwise.

%%%% The following is poorly written:
%
%In \pcf, the evaluation rules were given for closed terms only.
%Suppose that we proceed the same way for IA and consider the
%evaluation rule for the $\ianew$ construct: the conclusion is
%$\texttt{new } x:=0 \texttt{ in } M$ and the premise is an
%evaluation for a certain term constructed from $M$, more precisely
%the term $M$ where \emph{some} occurrences of $x$ are replaced by
%the value $0$. Because of the presence of the \iaassign
%operator, we cannot simply replace all the occurrences of $x$ in $M$
%(the required substitution is  more complicated than the
%substitution used for beta-reduction).


The canonical forms for IA are given by the grammar:
$$ V ::= \iaskip\ |\ n\ |\ \lambda x. M\ |\ x\ |\  \iamkvar\  M\ N$$

where $n \in \nat$ and $x: \iavar$.


In \ialgol, a program is a term together with a $\Gamma$-store such
that $\Gamma \vdash M : A$. The evaluation semantics is expressed by
the judgment form:
$$s,M \eval s', V$$
where $s$ and $s'$ are $\Gamma$-stores, $V$ is a canonical form and $\Gamma \vdash V : A$.

The operational semantics for IA is given by the rule of \pcf\ (table \ref{tab:bigstep_pcf})
together with the rules of table \ref{tab:bigstep_ia} where the following abbreviation is used:
$$ \rulef{M_1 \eval V_1 \quad M_2 \eval V_2}{M \eval V} \qquad \mbox{for} \qquad
  \rulef{s,M_1 \eval s',V_1 \quad s', M_2 \eval s'',V_2 }{s,M \eval s'',V}
$$


\begin{table}[htbp]
$$\mbox{\textbf{Sequencing }}
    \rulef{M \eval \iaskip \quad N \eval V}{\texttt{seq } M\ N \eval V}
$$

$$\mbox{\textbf{Variables }}
    \rulef{s,N \eval s',n \quad s',M \eval s'',x}{s, \iaassign\ M\ N \eval (s''\ |\ x \mapsto n),\iaskip}
\qquad
    \rulef{s,M \eval s',x }{s, \iaderef\ M \eval s',s'(x)}$$

$$\mbox{\texttt{\textbf{mkvar}}}
    \rulef{N \eval n \quad M \eval \iamkvar\  M_1\ M_2 \quad M_1\ n \eval \iaskip}
    {\iaassign\ M\ N \eval \iaskip}
\qquad
    \rulef{N \eval \iamkvar\  M_1\ M_2 \quad M_2\ \eval n}
    {\iaderef\ M \eval n}
$$

$$\mbox{\textbf{Block}}
    \rulef{(s\ |\ x \mapsto 0),M \eval (s'\ |\ x \mapsto n),V }
    {s, \texttt{new } x \texttt{ in } M \eval s',V}
$$

\label{tab:bigstep_ia}
\caption{Big-step operational semantics of IA}
\end{table}

\subsection{Small-step semantics of \ialgol}
\label{subsec:smallstep_ia}
The previous section defined the operational semantics of
\ialgol\ using a big step semantics. Equivalently, we can define it using a small-step semantics.
The reduction rules of the small-step semantics are of the form $s,e
\rightarrow s',e'$ where $s$ and $s'$ denotes the stores and $e$ and
$e'$ denotes \ialgol\ expressions.

The reduction rules are the following:
\begin{itemize}
\item the $\beta$-reduction;
\item reduction rules for \pcf\ constants:
\begin{eqnarray*}
\pcfsucc\ n &\rightarrow& n+1 \\
\pcfpred\ n+1 &\rightarrow& n \\
\pcfpred\ 0 &\rightarrow& 0 \\
\pcfcond\ 0\ N_1 N_2 &\rightarrow& N_1 \\
\pcfcond\ n+1\ N_1 N_2 &\rightarrow& N_2 \\
Y\ M &\rightarrow& M (Y M)
\end{eqnarray*}
\item reduction rules for \ialgol\ constants:
\begin{eqnarray*}
\iaseq\ \iaskip\  M &\rightarrow& M \\
s, \ianewin{x}\ M &\rightarrow& (s|x\mapsto 0), M \\
s, \iaassign\ x\ n &\rightarrow& (s|x\mapsto n), \iaskip \\
s, \iaderef\ x &\rightarrow& s, s(x) \\
\iaassign\ (\iamkvar M N)\ n &\rightarrow& M n \\
\iaderef\ (\iamkvar M N) &\rightarrow& N
\end{eqnarray*}
\end{itemize}

Redex can also be reduced when they occur as subexpressions within a
larger expression. We make use of evaluation contexts to indicate
when such reduction can happen. Evaluation contexts are given by the
following grammar:
\begin{eqnarray*}
E[-] &::=& - |\ E N\ |\ \pcfsucc\ E\ |\ \pcfpred\ E\ |\ \pcfcond\ E\ N_1\ N_2\ |\ \\
&&    \iaseq\ E\ N\ |\ \iaderef\ E\ |\ \iaassign\ E\ n\ |\ \iaassign\ M\ E \ |\ \\
&&    \iamkvar\ M\ E\ |\ \iamkvar\ E\ M\ |\ \ianewin{x}\ E  .
\end{eqnarray*}

The small-step semantics is completed with following rule:
$$ \rulef{M \rightarrow N}{E[M] \rightarrow E[N]} $$