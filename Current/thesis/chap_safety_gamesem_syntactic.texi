Our aim is to characterize safety by game semantics. This chapter
assumes that the reader is familiar with the basics of game
semantics introduced in Chapter \ref{chap:background}.  Recall that a
\emph{justified sequence} over an arena is an alternating sequence
of O-moves and P-moves such that every move $m$, except the opening
move, has a pointer to some earlier occurrence of the move $m_0$
such that $m_0$ enables $m$ in the arena. A \emph{play} is just a
justified sequence that satisfies Visibility and Well-Bracketing. A
basic result in game semantics is that lambda-terms are denoted
by \emph{innocent strategies}, which are strategies that depend only
on the \emph{P-view} of a play. The main result
(Theorem~\ref{thm:safeincrejust_lmd}) of this section is that if a
lambda-term is safe, then its game semantics (is an innocent
strategy that) is, what we call, \emph{P-incrementally justified}.
In such a strategy, pointers emanating from the P-moves of a play
are uniquely reconstructible from the underlying sequence of moves
and pointers from the O-moves therein: Specifically a P-question
always points to the last pending O-question (in the P-view) of a
greater order.

The proof of Theorem~\ref{thm:safeincrejust_lmd} relies on the
Correspondence Theorem from Chapter \ref{chap:concrete_gamesem} that
relates the strategy denotation of a lambda-term $M$ to the set
of \emph{traversals} over a souped-up abstract syntax tree of the
$\eta$-long normal form of $M$. In the language of game semantics, this theorem says that
traversals are just (concrete representations of) the
\emph{uncovering} (in the sense of Hyland and Ong
\cite{hylandong_pcf}) of plays in the strategy denotation.



Since the safety condition is a syntactic constraint, it seems difficult to give a characterization in term of game semantics, as game models are by essence syntax-independent. This is where the Correspondence Theorem comes to the rescue by helping us to reason syntactically about the game denotation of a term. This ultimately permits us to give a precise game-semantic characterization of the safety restriction.

One of the main results of this chapter (Proposition
\ref{prop:safe_Pptr_recoverable}) states that pointers in a play of
a strategy denoting  a safe term can be uniquely recovered
from O-questions' justification pointers and from the underlying sequence of
moves. In the first section we introduce the
notion of \emph{P-incrementally justified strategies}, a particular kind of strategy in which justification pointers emanating from P-moves can be
reconstructed uniquely from the underlying sequences of moves and
from O-moves' pointers. We then introduce the notion of
\emph{incrementally-bound computation trees} and establish a relationship between
incremental-binding and P-incremental justification (Proposition \ref{prop:Nher_incrbound_iff_incrjustified}). Finally, we show that safe simply-typed terms have incrementally\--bound computation trees, consequently their game denotation is P-incrementally justified.

The third section of this chapter is concerned with the safe lambda calculus without interpreted constants. In the following sections we extend the result by taking into account the interpreted constants of \pcf\ and \ialgol: We show that safe \pcf\ and safe \ialgol\ terms are denoted by P-incrementally justified strategies.

Some of the results presented in this chapter were first published in TLCA \cite{blumong:safelambdacalculus}. They are reproduced here with complete proofs and generalized to the languages \pcf\ and \ialgol.

\section{P-incrementally justified strategies}

In the game semantics literature, some authors use the term ``order of a question move'' to refer to the length of the path in the arena to the initial move that hereditarily enables it. For the purpose of studying the safety restriction, however, it will be convenient instead to call it the \defname{level} of the node, and reserve the term ``order'' to refer to another quantity: The \defname[order!move]{order of a question move} $q$, written $\ord{q}$, is defined as the length of the path from $q$ to its furthest leaf in the arena minus~1 (See Def~\ref{def:move_order}). Thus the order of an arena can be defined in term of move-order: It is precisely the greatest order of its initial moves.


\begin{definition}
  A strategy $\sigma$ is said to be \defname{P-incrementally
    justified} if for every play $s \, q \in \sigma$ where $q$ is a
  P-question, $q$ points to the last unanswered O-question in $\pview{s}$ with
  order strictly greater than $\ord{q}$.
\end{definition}



Note that although the pointer of $q$ is determined by the P-view, the
choice of the move $q$ itself can be based on the whole history of the
play. Thus P-incremental justification does not imply innocence.

The definition suggests an algorithm that, given a play of a
P-incrementally justified denotation, uniquely recovers the pointers
from the underlying sequence of moves and from the pointers
associated to the O-moves therein. Hence:
\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} In P-incrementally
justified strategies, pointers emanating from P-moves are
superfluous.
\end{lemma}
\begin{proof}
Suppose $\sigma$ is a P-incrementally justified strategy. We prove
that pointers attached to P-moves in a play $s\in \sigma$ are
uniquely recoverable by induction on the length of $s$. \noindent
\emph{Base case}: If $|s| \leq 1$ then there is no pointer to
recover. \noindent \emph{Step case}: Suppose $s m \in \sigma$. If
$m$ is an answer move then by the well-bracketing condition $m$
points to the last unanswered question in $s$. If $m$ is a
P-question then by  P-incremental justification of $\sigma$, $m$
points to the last O-move in $\pview{s}$ with order strictly greater
than $\ord{q}$. Since we have access to O-moves' pointers, we can
compute the P-view $\pview{s}$. Hence $m$'s pointer is uniquely
recoverable.
\end{proof}

\begin{example}
Copycat strategies, such as the identity strategy $id_A$ on game $A$
or the evaluation map $ev_{A,B}$ of type $(A \typear B) \times A
\typear B$, are all P-incrementally justified.\footnote{In such
strategies, a P-move $m$ is justified as follows: Either $m$ points
to the immediately preceding move in the P-view or the preceding move is of
smaller order and $m$ is justified by the second last O-move in the
P-view.}
\end{example}



\section{Dead code elimination}

We recall that the $\beta$-normal form of a term of an applied lambda calculus is the (possibly infinite) term obtained by reducing all the $\beta$-redexes. Because of the presence of interpreted constants, a $\beta$-normal form is not necessarily normal with respect to the small-step semantics. For instance in \pcf, the term $\pcfcond\, 0\, M\, N$ is $\beta$-normal but it reduces in one step to $M$.
\smallskip

We say that a coloured subterm $N$ of $M : (A_1, \ldots, A_n,o)$ is \defname{dead code} if for every context $C[-]$ such that $C[M]$ is of ground type, any reduction sequence starting from $C[M]$ does not involve a reduction of the subterm $N$; Formally, there is no reduction sequence of the form $C[M] \redar \ldots \redar E[\sigma(N)] \redar E[N']$ for some evaluation context $E[-]$, term $N'$, and substitution $\sigma$ of free variables of $N$.

\begin{example}
  The subterm $N$ in $\pcfcond\, 0\, M\, N$ is dead-code, whereas in $\lambda x . (\pcfcond\, 0\, x\, N)\, M$ the subterm $x$ is not dead-code.
\end{example}

The dead code elimination problem is the converse of the \defname{reachability problem}: Given a term $M$ containing a coloured subterm $N$ of $M$, is there a context $C[-]$ such that $C[M]$ is of ground type, and a reduction sequence $C[M] \redar \ldots \redar E[\sigma(N)]$ for some evaluation context $E[-]$ and substitution $\sigma$ of free variables of $N$?
The reachability problem is clearly not trivial. In fact for \pcf\ it is not decidable since the halting problem for \pcf---which is a Turing-complete language---can be encoded into a reachability problem.


Let $M$ be a term in eta-long normal form. Occurrences of variables that are in the dead code of $M$ are called \defname{dead occurrences}.  Given a term $M$, we define $M^*$ as the term obtained from the (possibly infinite) $\eta$-long normal form of $M$ by substituting all subterms of the form  $x N_1 \dots N_k$ where $x:(B_1,\ldots, B_k, o)$ is a dead variable occurrence, by the constant $\bot$ of type $o$. This process is called \defname{dead variable elimination}. We write $\tau(M)^*$ to denote the equivalent transformation on the computation tree of $M$.

Clearly we have:
\begin{equation}
\travset(M^*) \subseteq \travset(M) \label{eqn:reachable_in_deadcodefree_imp_reachable} \enspace .
\end{equation}

\subsection*{Reachability by traversals}

A node of a computation tree is said to be \defname{reachable} if
there exists a traversal that visits it. By the Correspondence Theorem, it is easy to show that if a node is not \emphind{reachable} then the corresponding variable occurrence is a dead occurrence. In particular:
\begin{lemma}
  If $x$ is a variable node in $\tau(M)^*$ then the corresponding node in $\tau(M)$ is reachable by some traversal.
\end{lemma}
However the converse does not hold. This is because the Correspondence Theorem concerns the \emph{intentional} innocent game model where the Opponent is not restricted to play deterministically, let alone innocently. Thus in this model, the strategy denotation accounts for contexts $C[-]$ that are not part of the language considered, whereas in the definition of dead-code elimination, the context ranges over term of the language only. Hence a variable node may be reachable by a traversal (as defined in Chapter \ref{chap:concrete_gamesem}) but not reachable in the sense defined above (with respect to the operational semantics of the language).

\begin{example}
Take the following simply-typed lambda-term:
$$M \equiv \lambda \varphi^{(o,o)}\,x^o\, y^o\, z^o. \varphi x (\varphi y z) \enspace .$$
The node of its computation tree corresponding to the occurrence $y$ is reachable by the traversal $\lambda \varphi x y z \cdot \varphi \cdot \lambda \cdot \varphi \cdot \lambda \cdot y$ but there is no simply-typed context $C[-]$ such that the evaluation of $C[M]$ leads to the evaluation of $y$.
\end{example}

The two notions of reachability can be reconciled by enforcing O-innocence in the rules of Table \ref{tab:trav_rules}, so that whenever a lambda node is visited, it is uniquely determined by the O-view of the traversal at that point.

\section{Incremental binding}
In this section, we work in the general setting of an applied simply-typed lambda calculus extended with a stock of interpreted constants $\Sigma$ (but without recursion), whose terms are of the form $\Gamma \entail M : T$. We consider its safe fragment, as defined in Sec\ \ref{sec:safe_appliedlambda}, whose terms are written $\Gamma \entail M : T$.

We fix a term $\Gamma \entail M : T$ of this unspecified language for the rest of this section. We assume that the language has a fully-abstract game-semantic model. We write $\sem{\Gamma \entail M : T}$ to denote the strategy denotation in the intensional model. We further assume that there are \emph{well-behaved} (see Def.\ \ref{def:wellbehaved_traversal}) traversal rules modeling the behaviour of the constants in such a way that the game-semantic correspondence (Theorem \ref{thm:correspondence}) holds for that language.


\bigskip

\begin{notations}
We call \defname{path} any sequence of nodes such
that for every two consecutive nodes $a \cdot b$ in the sequence, $a$
is the parent of $b$. We write $[n_1,n_2]$ to denote, if it exists,
the unique path going from node $n_1$ to node $n_2$ equipped with
the justification pointers induced by the enabling relation $\enable$
(A node has a unique enabler in the path to the root
thus for each occurrence in $[n_1,n_2]$ there is at most one
occurrence of its enabler in $[n_1,n_2]$). We write $]n_1,n_2]$ for
the sub-sequence of $[n_1,n_2]$ obtained by removing $n_1$ together with
all the associated pointers.
\indexnotation{$[n_1,n_2]$}{Path in a tree from node $n_1$ to node $n_2$}%

The symbol $\theroot$ denotes the root of the computation tree
$\tau(M)$, $N^{\theroot\enable}$ denotes the subset of $N$
consisting of nodes that are hereditarily enabled by $\theroot$,
and $N^{\Sigma\enable}$ denotes the nodes that are hereditarily enabled by some constant in $\Sigma$.
\end{notations}

\subsection*{Definition}

Recall from the definition of computation trees (Chapter
\ref{chap:concrete_gamesem}) that a variable node $n$ labelled $x$ is said
to be \index{bound!node}\emph{bound} by a node $m$ if $m$ is the closest node in the
path from $n$ to the root such that $m$ is labelled $\lambda
\overline{\xi}$ with $x\in \overline{\xi}$. Thus the binder node
always occurs in the path from the variable node that it binds to the root. We now introduce a class of computation trees in which the binder node is
uniquely determined by the nodes' orders.



\begin{definition}[Incrementally-bound computation tree]
Let $A$ be a subset of nodes of the computation tree.
\begin{enumerate}[(i)]
\item A variable node $x$ of a computation tree is said to be
\defname[incremental!node binding]{$A$-incrementally-bound} if its enabler is the first
$\lambda$-node from $A$ in the path to the root that has order
strictly greater than $\ord{x}$. Formally:
\begin{align*}
x \mbox{ is $A$-incrementally-bound} \  \iff \  \left\{
                                                  \begin{array}{ll}
                                                    x \hbox{ is enabled by } b \in [\theroot,x]\inter A \ ; \\
                                                    \ord{b} > \ord{x} \;\\
                                                    \forall \lambda\mbox{-node } n' \in ]n,x]\inter A  . \ord{n'} \leq \ord{x} \enspace .
                                                  \end{array}
                                                \right.
\end{align*}
\noindent This definition can be split into two cases:
\begin{enumerate}
\item $x$ is \emph{bound} by the first $\lambda$-node from $A$ occurring in the path to the root that has
order strictly greater than $\ord{x}$.
\item or $x$ is a \emph{free variable} and all the $\lambda$-nodes from $A$ occurring in the path to the root except the root have order
 smaller or equal to $\ord{x}$.
\end{enumerate}

\item A computation tree is said to be
\defname[incremental!tree binding]{$A$-incrementally-bound}, also abbreviated $A$-i.b., if all
the variable nodes from $A$ are $A$-incrementally-bound

\item  A node (resp.\ a tree) is
\defname[incremental!node binding]{incrementally-bound} if it is
\defname[incremental!node binding]{$(N\setminus N^{\Sigma\enable})$-incrementally-bound} where $N$ is the entire set of nodes of the computation tree and $N^{\Sigma\enable}$ is the set of nodes hereditarily justified by some constant node.
\end{enumerate}
\end{definition}

\begin{lemma} \hfill
\begin{enumerate}[(i)]
\item  For every two sets of nodes $A$ and $B$ satisfying $A\subseteq
B$, $B$-incremental-binding implies $A$-incremental-binding.

\item $\tau(M)$ is $A$-incrementally bound if and only if $\tau(\closure{M})$ is.
\end{enumerate}
where $\closure{M}$ denotes the closed term obtained by abstracting the free variables in $M$ (see Sec.\ \ref{sec:lambdacalculus}).
\end{lemma}
\begin{proof}
(i) follows immediately from the definition. (ii) This is because the computation trees $\tau(M)$ and $\tau(\closure{M})$ are isomorphic and the enabling relation $\enable$ is defined identically on these two trees (since free variable nodes are enabled by the root).
\end{proof}

\subsection*{Safety and incremental binding}
We recall that a term is \emphind{almost safe} if it can be written $\lambda x_1 \ldots x_n . N_0 \ldots N_p$ for some $n,p \geq 0$ where $N_i$ is safe for all $0\leq i \leq p$. It is an \index{almost safe!application}\emph{almost safe application} if further $n=0$ (\ie, no abstraction).

\begin{proposition}[Safe terms have incrementally-bound computation trees]
\label{prop:incrbound_iff_etanf_safe} Let $\Gamma \entail M
:T$ be a term of some applied typed lambda calculus (without recursion).
\begin{itemize}
\item[(i)] If $M$ is almost safe then $\tau(M)$ is incrementally-bound ;
\item[(ii)] conversely, if $\tau(M)$ is incrementally-bound then the $\eta$-long normal form of $M$ is almost safe, and safe if further $M$ is closed.
\end{itemize}
\end{proposition}
\begin{proof}
(i) Suppose that $M$ is almost safe. Computation trees are defined modulo eta-long normal expansion thus since
this transformation preserves almost safety (Lemma \ref{lem:almostsafe_iff_etalnf_almostsafe}) we can assume that
$M$ is in eta-long nf. By the previous lemma, to show that $\tau(M)$ is incrementally-bound we just have to show that
$\tau(\closure{M})$ is incrementally-bound. We now consider $\tau(\closure{M})$.

In an applied safe lambda calculus, the $\Gamma$-variables with
the lowest order must be all abstracted at once when applying the
abstraction rule. Since the computation tree merges consecutive
abstractions into a single node, any $\Gamma$-variable $x$ occurring free in
the subtree rooted at a $\lambda$-node $\lambda \overline{\xi} \not\in N^{\Sigma\enable}$
different from the root must have order greater or equal to
$\ord{\lambda \overline{\xi}}$. Conversely, if a lambda node
$\lambda \overline{\xi}$ binds a variable node $x$ then
its order is $1+\max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Let $x$ be a $\Gamma$-variable node in $\tau(\closure{M})$.
Its enabler necessarily occurs in the path to the root, therefore, according to the previous observation,
$x$ must be bound by the first $\lambda$-node occurring in $[\theroot,x]\setminus N^{\Sigma\enable}$
with order strictly greater than $\ord{x}$. Hence $\tau$ is incrementally-bound.

(ii) We first show the result for closed term. Let $\entail M :T$ be a closed term such that $\tau(M)$ is incrementally-bound. We assume that $M$ is already in $\eta$-long normal form. We prove by induction that $M$ is safe. The
base case $M \equiv \lambda \overline{\xi} . \alpha$ for some variable or
constant $\alpha$ is trivial. \emph{Step case:} $M \equiv \lambda
\overline{\xi} . N_1 \ldots N_p$. Let $1\leq i\leq p$. Each $N_i$
can be written $\lambda \overline{\eta_i} . N'_i$ where $N'_i$ is
not an abstraction. By the induction hypothesis, $\lambda
\overline{\xi} . N_i \equiv \lambda\overline\xi\overline{\eta_i} .
N'_i$ is safe which means that the term $N'_i$ is also safe: We have
$\overline\xi, \overline{\eta_i} \sentail N'_i :A_i$ for some type $A_i$.
Let $z$ be a variable occurring free in $N'_i$. Since $M$ is
closed, $z$ is either bound by $\lambda \overline{\eta_1}$ or
$\lambda \overline{\xi}$. In the latter case, since $\tau(M)$ is
i.b. we have that $\ord{z}$ is smaller than $\ord{\lambda
\overline{\eta_1}}=\ord{N_i}$, thus in both case we are allowed to
abstract the variables $\overline{\eta_1}$ using the rule
\rulenamet{abs}, which shows that $N_i$ is safe.
Since all the $N_i$s are safe and the term $N_1 \ldots N_p : o$ is of order $0$, by the rule \rulenamet{app} we have that $N_1 \ldots N_p$ is safe: $\overline{\xi} \sentail N_1 \ldots N_p :o$. The rule \rulenamet{abs} then gives us the sequent $\sentail \lambda \overline{\xi} . N_1 \ldots N_p$.

Now if $M$ is open, by the preceding case we have that $\closure{M}$ is safe. But by ``pealing-off'' abstractions from a safe term we obtain an almost safe term, thus $M$ is almost safe.
\end{proof}

Note that the hypothesis that $M$ is closed in (ii) is necessary.
Take for instance the two terms $\lambda x y .x$ and $\lambda y . x$,
where $x,y:o$. Their have isomorphic incrementally-bound computation
trees. But $\lambda x y .x$ is safe and $\lambda y . x$ is
only almost safe.
\smallskip

For the second part of this proposition a slightly stronger result holds if the term is $\beta$-normal and does not contain any interpreted constant:
\begin{corollary}
\label{cor:incrbind_imp_safe_betanf}
Let $M$ be a $\beta$-normal term containing no interpreted constant.
If all the \emph{input variables} are incrementally-bound then
 the $\eta$-long normal form of $M$ is almost safe, and safe if further $M$ is closed.
\end{corollary}
This is simply because in the computation tree of such terms all the variable nodes are \emph{input}-variable nodes. This stronger result does not hold for terms containing redexes: For every unsafe closed term $U$, the term $(\lambda u .u)~U$ is unsafe but the only input-variable is $u$ and it is incrementally-bound. It does not hold either for terms with interpreted constants: For every closed unsafe term $U$ of type \iaexp, the \pcf\ term $\pcfsucc\ U$ has no input variable but it is unsafe.



\begin{corollary}
\label{cor:betasred_preserve_incrbound} If $\tau(M)$ is incrementally-bound and $M \betasred N$ then $\tau(N)$ is incrementally-bound.
\end{corollary}
\begin{proof} Suppose that $\tau(M)$ is i.b. Then by Proposition
\ref{prop:incrbound_iff_etanf_safe}(ii) the eta-long normal form of $M$ is almost safe, therefore so is $M$ by Lemma \ref{lem:almostsafe_iff_etalnf_almostsafe}.
But almost safety is preserved by $\beta_s$-reduction (Lemma \ref{lem:betasred_preserves_almostsafety}) therefore $N$ is almost safe, and by Proposition \ref{prop:incrbound_iff_etanf_safe}(i), $\tau(N)$ is
incrementally-bound.
\end{proof}

Note that this corollary  cannot be generalized to
$A$-incremental-binding for every set of node $A$. Take for instance
the term $M \equiv \lambda u^{o} v^{((o,o),o)} . (\lambda x^o
. v (\lambda z^o . x)) u$ which beta-reduces to $N \equiv \lambda u v . v
(\lambda z . u)$. The computation trees are:
\begin{center}
\begin{tikzpicture}[level distance=7mm,inner ysep=0.5mm,inner xsep=0.5mm,sibling distance=10mm]
\path
node{$\tau(M) = $}
+(2,0)
node{$\underline{\lambda u v}$}
child{
      node{$@$}
            child{
              node {$\lambda x$}
              child{
                  node {$\underline{v}$}
                  child{
                        node {$\underline{\lambda z}$}
                        child{
                          node {$x$}
                        }
                  }
                }
            }
            child{
                node {$\lambda$}
                child{
                        node{$\underline{u}$}
                }
            }
        }
+(5,0)
 node {$\tau(N)=$ }
 +(6,0)
 node {$\underline{\lambda u v}$}
    child{
      node{$\underline{v}$}
          child{
            node {$\underline{\lambda z}$}
            child{
                node {$\underline{u}$}
            }
          }
      }
;
\end{tikzpicture}
\end{center}
If we take $A$ to be the set of nodes that are hereditarily enabled by
the root (underlined in the figure above) then $\tau(M)$
is $A$-incrementally-bound but $\tau(N)$ is not.


\subsection*{Incremental justification and incremental binding}


\begin{proposition}[Incremental-binding and P-incremental justification]
\label{prop:Nher_incrbound_iff_incrjustified}
Let $\Gamma \entail M : T$ be a term-in-context of some applied typed lambda calculus.

\begin{enumerate}[(i)]
\item Suppose $M$ is $\beta$-normal. If all the \emph{reachable} input-variable nodes of the computation tree
$\tau(\Gamma \entail M : T)$ are
incrementally bound then $\sem{\Gamma
\entail M : T}$ is P-incrementally justified.

\item If $\sem{\Gamma \entail M : T}$ is
P-incrementally justified then all the \emph{reachable}
input-variable nodes of the computation tree $\tau(\Gamma \entail
M : T)$ are $N^{\theroot\enable}$-incrementally bound.
\end{enumerate}
\end{proposition}
\begin{proof}
\noindent (i) Suppose $M$ is a $\beta$-nf.
W.l.o.g\ we can assume that $M$ is a closed term since the incremental-binding property is conserved when taking the closure of a term and since the denotation of the closure is isomorphic to the denotation of the term.

Suppose that all the reachable input-variable nodes of $\tau(M)$ are incrementally bound. We want to show
that $\sem{M}$ is P-incrementally justified. Take a play $s \in \sem{M}$ ending with a question
P-move $q$. By the Correspondence Theorem \ref{thm:correspondence},
there is a traversal $t$ of $\tau(M)$ starting with an occurrence
$r$ of the root $\theroot$ such that $\psi_M (t\filter r) = s$. We
assume $t$ to be the shortest such traversal, so that the last
occurrence of $t$---name it $n$---is hereditarily justified
by $r$, and is by definition an occurrence of a reachable node.
Since $\psi_M$ maps $n$ to the P-question $q$, $n$ is necessarily an
occurrence of a variable node $x$.
By Lemma \ref{lem:psi_properties} (iv), the P-views of
$s$ and $t \filter r$ are computed identically
and have the same underlying sequence of justification pointers so in particular the node $n$ and the move $q$ both
point to the same position in the justified sequence
$\pview{t\filter r}$ and $\pview{s}$ respectively.
Further by Lemma \ref{lem:psi_properties}(iii), $\psi_M$ maps nodes of a given order to moves of the same order. Hence showing that $s$ is P-incrementally justified amounts to showing that $n$'s justifier in $t$ is the latest lambda-node in $\pview{t\filter r}$ with order strictly greater than $\ord{n}$.

Let $m$ denote $n$'s justifier in $t$. The term $M$ is closed therefore $x$ is necessarily a bound variable and $n$ is an occurrence of $x$'s binder in $\tau(M)$. The traversal $t$ is incrementally-bound by assumption
and $n$ belongs to $N\setminus N^{\Sigma\enable} = N^{\theroot\enable}$ therefore by definition of incremental binding the occurrence $m$ is the last $\lambda$-node in $[\theroot,n]\ \inter
N^{\theroot\enable}$ with order strictly greater than $\ord{n}$.
The Path--P-view correspondence (Prop.~\ref{prop:pviewtrav_is_path}) gives  $[\theroot,n] \inter
N^{\theroot\enable} = \pview{t} \filter r$ which in turn equals
 $\pview{t\filter r}$ by Lemma \ref{lem:betanf_wellbehavedconst_trav_pview_red} (it is applicable because $M$ is a $\beta$-nf and we have assumed that the constant traversals are well-behaved).
\smallskip

\noindent (ii) Suppose $\sem{M}$ is P-incrementally justified. Let
$x$ be a reachable input-variable node of $\tau(M)$: There exists a
traversal of the form $t \cdot x$ in $\travset(M)$ such that $x$ is
hereditarily justified in $t$ by the first occurrence $r$ of $\tau(M)$'s
root.

The correspondence theorem shows that $\varphi((t \cdot x)
\filter r) = \varphi(t \filter r) \cdot \varphi(x)$ belongs to $\sem{M}$.
Since $\sem{M}$ is P-incrementally justified, $\varphi(x)$ points to
the last O-move in $\pview{\varphi(t \filter r)}$ with order
strictly greater than $\ord{\varphi(x)}$. Consequently $x$ points to
the last $\lambda$-node in $\pview{t \filter r}$ with order strictly
greater than $\ord{x}$.

But by Lemma \ref{lem:pviewproj_wrt_theroot}, $\pview{t \filter r}$
contains $\pview{t} \filter r$ as a subsequence, and by
P-visibility $m$ occurs in this subsequence, thus $m$ is
also the last $\lambda$-node in $\pview{t} \filter r$ with order
strictly greater than $\ord{x}$. By the Path-P-view correspondence
(Prop.~\ref{prop:pviewtrav_is_path}) this means that $m$ is the last $\lambda$-node in $[\theroot,x[\  \inter\
N^{\theroot \enable}$ with order strictly greater than $\ord{x}$.
Hence $\tau(M)$ is $N^{\theroot\enable}$-incrementally-bound.
\end{proof}

\begin{corollary}
\label{cor:Nher_incrbound_iff_incrjustified} Let  $\Gamma \entail
M : A$ be a term-in-context of some applied typed lambda calculus.
\begin{enumerate}[(i)]
\item  If $\tau(\Gamma \entail M : A)$ is incrementally-bound then $\sem{\Gamma \entail M : A}$ is P-incrementally justified;
\item  if $M$ is $\beta$-normal and $\sem{\Gamma \entail M : A}$ is P-incrementally justified
then $\tau(\Gamma \entail M : A)^*$ is incrementally-bound.
\end{enumerate}
\end{corollary}
\begin{proof}
(i) Let $M'$ denote the beta-normal form of $M$. If $\tau(M)$ is incrementally bound then by Corollary \ref{cor:betasred_preserve_incrbound} so is $\tau(M')$. So in particular all the \emph{reachable} input-variable node of $\tau(M')$ are incrementally bound. Thus by Proposition \ref{prop:Nher_incrbound_iff_incrjustified}(i), $\sem{M} = \sem{M'}$ is P-incrementally justified.

\noindent (ii) Suppose that $\sem{M}$ is P-incrementally justified.
Consider $\tau(M)^*$.  By definition, a tree is incrementally bound just if it is $N \setminus N^{\Sigma\enable}$-incrementally bound.
Since $M$ is $\beta$-normal, variable nodes cannot be hereditarily enabled by an @-node thus $N^{\enable \theroot} = N \setminus N^{\Sigma\enable}$. Thus to show that $\tau(M)^*$ is incrementally-bound we just need to show that its variables are $N^{\enable \theroot}$-incrementally bound.
But by definition its variable nodes are precisely those of $\tau(M)$ that are reachable. Hence we just need to show that the reachable input variables of
$\tau(M)$ are $N^{\enable \theroot}$-incrementally bound. This is precisely
what Proposition \ref{prop:Nher_incrbound_iff_incrjustified}(ii) says.
\end{proof}


\section{Safe lambda calculus}

We now consider the special case of the pure (\ie, without interpreted constants) safe lambda calculus. For every simply-typed term $\Gamma \stentail M : T$ we write $\sem{\Gamma \stentail M : T}$  to refer to the innocent game denotation of $\Gamma \stentail M : T$.
\begin{lemma}
  \label{lem:st_allnodes_reachable}
  For simply-typed lambda-term in $\beta$-normal form,
  all the nodes of the computation tree are \emph{reachable} by some traversal obtained using the rules of Table \ref{tab:trav_rules}.
\end{lemma}
\begin{proof} Since $M$ is in $\beta$-normal form, its computation tree has no application node and therefore all the variable nodes are hereditarily justified by the root. Hence each variable node can be reached by the traversal consisting of the path from the root to that node: The rule \rulenamet{Lam} and \rulenamet{InputVar} permit us to visit the variable nodes and lambda nodes respectively.
\end{proof}


\begin{proposition}
\label{prop:Nher_incrbound_iff_incrjustified_lmd}
  Let $\Gamma \stentail M : T$ be a pure
   (\ie, with no interpreted constants) simply-typed term in $\beta$-normal form.
   Then $\sem{\Gamma \stentail M : T}$ is P-incrementally justified
   if and only if the computation tree $\tau(M)$ is incrementally-bound.
\end{proposition}
\begin{proof}
By Lemma \ref{lem:st_allnodes_reachable}, all the variable nodes are reachable
in a $\beta$-normal term thus $\tau(M) = \tau(M)^*$ and the result follows from Corollary \ref{cor:Nher_incrbound_iff_incrjustified}.
\end{proof}

\begin{example} \hfill
\begin{enumerate}[(i)]
\item For every higher-order variable $x:A$ the computation tree
$\tau(x)$ is incrementally-bound. Consequently the projection
strategies are all P-incrementally justified.

\item
\parpic[r]{
\raisebox{-12pt} {\begin{tikzpicture}[level distance=4.4ex,inner
ysep=0.5mm] \node {$\lambda^3$} child {node {$f^2$}
       child {node {$\lambda y^1$} child {node {$x^0$}}}};
\end{tikzpicture}
} } Consider the $\beta$-normal term $\Gamma\stentail f (\lambda
y .x) : o$ where $y:o$ and $\Gamma=f:2,~x:o$. The
figure on the right represents its computation tree with the
node orders given as superscripts.  The node $x$ is not
incrementally-bound because the node $x$ of order $0$ is not
bound by the order 1 node $\lambda y$. Therefore $\tau(f
(\lambda y .x))$ is not incrementally-bound and by Proposition
\ref{prop:Nher_incrbound_iff_incrjustified_lmd}, $\sem{\Gamma
\stentail f (\lambda y .x) : o}$ is not P-incrementally
justified. Similarly we can check that $\sem{\lambda y. x}$ is
P-i.j.\ while $\sem{f (\lambda y .x)}$ is not.

\item By the previous examples we have that $\sem{\Gamma \stentail f : 2}$ and $\sem{\Gamma \stentail \lambda
  y. x : 1}$ are both P-i.j.\ whereas
$\sem{\Gamma \stentail f (\lambda y .x) : o}$ is not. Hence application does not preserve
P-incremental justification. This suggests that P-incremental justification is not a
compositional property. In Chapter \ref{chap:model} we will identify a sufficient condition enabling compositionality of P-incrementally justified strategies.
\end{enumerate}
\end{example}
\smallskip



Putting Proposition \ref{prop:Nher_incrbound_iff_incrjustified_lmd} and
Proposition \ref{prop:incrbound_iff_etanf_safe} together gives us a
game-semantic characterization of safety. This result was first presented in TLCA2007, \cite[Theorem 3(ii)]{blumong:safelambdacalculus}:
\begin{theorem}[Characterization Theorem for the safe lambda calculus]
\label{thm:safeincrejust_lmd} Let $\Gamma \stentail M : A$ be a pure
simply-typed term (with no interpreted constants).
\begin{enumerate}[(i)]
\item If $M$ is \emph{almost safe} (and in particular if it is safe) then $\sem{\Gamma \stentail M : A}$
is P-incrementally justified.
\item If $\sem{\Gamma \stentail M : A}$ is
  P-incrementally justified then the beta-normal form of $M$ is
almost safe, and safe if further $M$ is closed.
\end{enumerate}
\end{theorem}
\begin{proof}
(i) Since $M$ is almost safe, by Proposition \ref{prop:incrbound_iff_etanf_safe}(i),
its computation tree is incrementally-bound. Hence by Corollary \ref{cor:Nher_incrbound_iff_incrjustified}(i) its denotation is incrementally justified.

(ii) Since a term has the same denotation as its beta-normal form we can assume that
$M$ is beta-normal.
By Proposition \ref{prop:Nher_incrbound_iff_incrjustified_lmd} its computation tree is incrementally bound,
and by Proposition \ref{prop:incrbound_iff_etanf_safe}(ii), the eta-long normal form of $M$ is safe if it is a closed term and almost safe otherwise. The same holds for $M$ itself since both safety and unsafety are preserved by
eta-long normal expansion (Lemma \ref{lem:almostsafe_iff_etalnf_almostsafe} and \ref{prop:safe_iff_elnfsafe}).
\end{proof}

In particular, a term has a P-incrementally justified denotation if and only its beta-normal form is almost safe.

\begin{remark} \hfill
\begin{enumerate}[(i)]
\item Observe that the use of the Correspondence theorem makes the proof of the above theorem almost trivial: Just by making some observations about the computation trees of safe terms, we are able to deduce properties in the denotational game model. We do not claim here that it is the unique way to prove the result; However any proof would require at some point to make a connection between the binding information found in the syntax of the term, and the justification pointers of game semantics. In our argument, this connection is provided by the concrete presentation of game semantics from the previous chapter.

\item In game semantics, the Opponent's strategy is dictated by the denotation of a term---the context---representing the environment so that if the language considered is a pure functional language such as \pcf\ then the Opponent necessarily plays innocently. In the intentional game denotation, however, all possible O-moves are accounted for at every position, including those moves that would break ``O-innocence''. In the extensional denotation, non O-innocent plays do not have any effect since the test strategy from the intrinsic preorder ranges over P-innocent strategies.

The second part of the previous theorem crucially relies on the presence of those non O-innocent plays: It is true that an unsafe beta normal term is denoted by a non P-i.j.\ strategy, but the failure to satisfy P-incremental justification may only be due to some play that does not affect the extensional denotation of the term. For instance the beta-normal term
$\lambda \varphi^{((o,o),o,o)}\, y^o .\ \varphi (\lambda x^o. x) (\varphi (\lambda x^o .\underline{y})\, y)$
is clearly unsafe and, as is implied by (ii), its denotation in the intentional game model is not P-i.j.\ since for instance the last node in the traversal $t = \lambda \varphi y \cdot \varphi^1 \cdot\lambda\cdot\varphi^2\cdot \lambda x \cdot y$ is not incrementally justified.
But the traversal $t$ corresponds to a play that does not respect O-innocence since we have $\oview{t_{\prefixof \varphi^1}} = \oview{t_{\prefixof \varphi^2}}$ and the node visited after $\varphi^1$ and $\varphi^2$ differ.
\end{enumerate}
\end{remark}


Putting Theorem \ref{thm:safeincrejust_lmd}(i) and Lemma
\ref{lem:incrjustified_pointers_uniqu_recover} together gives:
\begin{proposition}[P's pointers are superfluous for safe terms]
\label{prop:safe_Pptr_recoverable}
   In the game semantics of safe lambda-terms, pointers emanating from P-moves are unnecessary: They are uniquely recoverable from the underlying sequences of moves and from O-moves' pointers.
\end{proposition}

 \begin{example} If justification pointers are omitted then the denotations of the two Kierstead terms $M_1 \equiv \lambda f . f (\lambda x . f (\lambda y .y ))$ and $M_2 \equiv \lambda f . f (\lambda x . f (\lambda y .x ))$ from Example~\ref{ex:kierstead} are not distinguishable.
   In the safe lambda calculus this ambiguity disappears
   since $M_1$ is safe whereas $M_2$ is not (The free variable $x$ in the subterm $f (\lambda y . x)$, has the same order as $y$ but it is not abstracted together with $y$).
\end{example}

In fact, as the last example highlights, pointers are superfluous at
order $3$ for safe terms whether from P-moves or O-moves. This is
because for question moves in the first two levels of an arena
(initial moves being at level $0$), the associated pointers are
uniquely recoverable thanks to the visibility condition. At the
third level, the question moves are all P-moves therefore their
associated pointers are uniquely recoverable by P-incremental
justification. This is not true anymore at order $4$: Take the safe
term $\psi:(((o^4,o^3),o^2),o^1) \sentail \psi (\lambda \varphi .
\varphi a) : o^0$ for some constant $a:o$, where $\varphi:(o,o)$.
Its strategy denotation contains plays whose underlying sequence of
moves is $q_0 \, q_1 \, q_2 \, q_3 \, q_2 \, q_3 \, q_4$. Since
$q_4$ is an O-move, it is not constrained by P-incremental
justification and thus it can point to any of the two occurrences of
$q_3$.\footnote{More generally, a P-incrementally justified strategy
can contain plays that are not ``O-incrementally justified'' since
it must take into account any possible strategy incarnating its
context, including those that are not P-incrementally justified. For
instance in the given example, there is one version of the play that
is not O-incrementally justified (the one where $q_4$ points to the
first occurrence of $q_3$). This play is involved in the strategy
composition $\sem{ \stentail M_2 : (((o,o),o),o)} ; \sem{
\psi:(((o,o),o),o) \stentail \psi (\lambda \varphi . \varphi a):o}$
where $M_2$ denotes the unsafe Kierstead term.}


\section{Safe PCF}
We now extend the game-semantic characterization to safe \pcf.

We have already established the correspondence between almost safety and incremental binding in the general setting of an applied simply-typed lambda calculus without recursion (Proposition \ref{prop:incrbound_iff_etanf_safe}). \pcf$_1$ can be cast into this setting by considering $\bot_A$ as ordinary constants: In the computation tree of a \pcf$_1$ term,  subterms of the form $\Omega_A$ are represented by the single constant node $\bot_A$. In full \pcf, however, a difficulty arises as computation trees are potentially infinite due to the presence of the Y combinator. Nevertheless the result still holds:
\begin{proposition}[Almost safety and incrementally-binding]
\label{prop:incrbound_iff_etanf_safe_pcf} Let $\Gamma \entail M : A$
be a PCF term.
\begin{itemize}
\item[(i)] If $\Gamma \entail M : A$ is almost safe then $\tau(\Gamma \entail M : A)$ is incrementally-bound ;
\item[(ii)] conversely, if $\tau(\Gamma \entail M : A)$ is incrementally-bound then the $\eta$-long normal form of $\Gamma \entail M : A$ is almost safe if $M$ is open and safe if $M$ is closed.
\end{itemize}
\end{proposition}
\begin{proof}
(i) Let $M$ be an almost safe \pcf\ term and  $i$ denote the number of occurrences of the Y combinator in $M$.
We first prove by induction on $i$ that for every $k\in \omega$, the $k$th approximants to $M$, denoted $M_k$, is almost safe. The base case $i=0$ is trivial: $M_k = M$. Step case: $i>0$. Let $Y_A N$ be a subterm of $M$. Since $M$ is almost safe, $N$ is
also safe. The number of occurrences of the Y combinator in $N$ is
smaller than $i$ therefore by the induction hypothesis $N_k$ is
safe. Consequently the term $Y_A^k N_k = \underbrace{N_k ( \ldots (
N_k}_{k \mbox{ times}} \Omega ) \ldots )$ is also safe and by
compositionality so is $M_k$.

The result holds for \pcf$_1$ terms, thus since $M_k$ is a safe \pcf$_1$ term, $\tau(M_k)$ is
incrementally-bound. Now let $z$ be a variable node in $\tau(M) =
\Union_{k\in\omega} \tau(M_k)$. There exists $k\in \omega$ such that
$z$ belongs to $\tau(M_k) \treeapprox \tau(M)$. If we write $r_k$ to
denote the root of the tree $\tau(M_k)$ then the path $[r_k,z]$ in
$\tau(M_k)$ is equal to the path $[r,z]$ in $\tau(M)$. Hence, since $z$ is incrementally-bound in $\tau(M_k)$, it is also
incrementally-bound in $\tau(M)$.

(ii)
Suppose that the term is not almost safe then necessarily one of its approximant is not almost safe either.
Since the result holds for every \pcf$_1$ term, the computation tree of the approximant is not incrementally-bound.  But the computation tree of $M$ contains the computation tree of its approximant, therefore it is not incrementally-bound.
\end{proof}


Hence we obtain the following characterization of almost safety by P-incrementally justified strategies:
\begin{theorem}[Characterization Theorem for safe \pcf]
\label{thm:almostsafeincrejust_pcf} Let $\Gamma \entail M : A$ be a PCF term. Then:
\begin{enumerate}[(i)]
\item If $M$ is almost safe then $\sem{\Gamma \entail M : A}$ is P-incrementally justified.
\item If $\sem{\Gamma \entail M : A}$ is
  P-incrementally justified then $\etalnf{\betanf{M}}^*$ is
  almost safe  if $M$ is open, and safe if $M$ is closed.
\end{enumerate}
\end{theorem}
\begin{proof}
\noindent(i)
Let $M$ be an almost safe term and $M^{\infty}$ be the $\beta$-normal form of $M$. Since almost-safety is preserved by the small-step reduction of PCF, $M^\infty$ is also almost-safe
and by Proposition \ref{prop:incrbound_iff_etanf_safe_pcf}, $\tau(M^{\infty})$ is incrementally-bound.
By Corollary \ref{cor:Nher_incrbound_iff_incrjustified}(i),
$\sem{M^{\infty}}$ is P-incrementally justified and by soundness of the game denotation, $\sem{M^{\infty}} = \sem{M}$, thus $\sem{M}$ is P-incrementally justified.

\noindent(ii) Let $M$ be \pcf\ term with a P-incrementally
justified denotation. By Corollary
\ref{cor:Nher_incrbound_iff_incrjustified}(ii),
$\tau(\betanf{M})^* = \tau(\etalnf{\betanf{M}}^*)$ is
incrementally-bound. Hence by Proposition
\ref{prop:incrbound_iff_etanf_safe_pcf}(ii),
if $M$ is closed then $\etalnf{\betanf{M}}^*$ is safe and almost safe otherwise.
\end{proof}

Consequently, P-pointers are superfluous (\ie,~uniquely recoverable) in the game denotation of safe \pcf\ terms.

\begin{example}[Counter-example]
The use of dead-code elimination in the second part of the theorem is crucial.
Take for instance the closed \pcf\ term:
$$M \equiv \lambda f^{((\pcfexp,\pcfexp),\pcfexp)}\, x^\pcfexp\, y^\pcfexp. f (\lambda z^\pcfexp. \pcfcond (\pcfsucc\ x) y z ) \enspace .$$ This term is in $\beta$-normal form (the conditional operator cannot be reduced since the value of $x$ is undetermined). The $\eta$-long $\beta$-normal form of $M$ is therefore $M$ itself which is unsafe. But since $\pcfsucc\ x$ will always evaluate to a positive integer, the first branch of the conditional  operator will never be evaluated. Hence $M$ is observationally equivalent to the safe term $N \equiv \lambda f x y. f (\lambda z. z)$ which by the Full Abstraction theorem implies that they have the same denotation. But since $N$ is safe, by the first part of the theorem, we have that $\sem{M}$ is P-incrementally justified.

Such counter-example arises because the conditional operator of
\pcf\ permits us to construct beta-normal terms containing
``dead code'' (\ie, some subterm that will never be evaluated
for every value of M's parameters). In the example above, the dead code
consists of the subterm $y$. In general, if the dead code part of
the computation tree contains a variable that is not incrementally
bound then the resulting term will be unsafe even if the rest of the
tree is incrementally bound. In our example, it is possible
to turn $M$ into the equivalent safe term $N$ by eliminating the dead code from $M$.
\end{example}


\section{Safe Idealized Algol}

The argument used in the previous section for safe \pcf\ can be reused identically for safe \ialgol\ (as defined in Sec.\ \ref{subsec:safeia_rules}). Hence we have:
\begin{theorem}[Characterization Theorem for Safe \ialgol]
\label{thm:almostsafeincrejust_ia} Let $\Gamma \entail M : A$ be a \ialgol\ term. Then:
\begin{enumerate}[(i)]
\item If $M$ is almost safe then $\sem{\Gamma \entail M : A}$ is P-incrementally justified.
\item If $\sem{\Gamma \entail M : A}$ is
  P-incrementally justified then $\etalnf{\betanf{M}}^*$ is
  almost safe  if $M$ is open, and safe if $M$ is closed.
\end{enumerate}
\end{theorem}

This shows that P-pointers are superfluous for safe \ialgol\ terms. Since unsafety only appears at order $3$, this theorem implies the well-known result that pointers are uniquely recoverable for \ialgol$_2$ terms. This suggests potential applications in Algorithmic Game Semantics: Ghica and McCusker were able to show that the game denotation of \ialgol$_2$ terms can be characterized by (extended) regular expressions, thus giving a decision procedure for observational equivalence in this fragment \cite{ghicamccusker00}. Can we achieve a result for higher-order fragment of safe \ialgol? We will investigate this question in the next chapter.


\section{Towards a game model of safe \pcf}

\subsection{Definability}
Recall (Sec.\ \ref{sec:pcfdefinability}) that \pcf$_c$ denotes the language obtained by extending \pcf\ with the $\pcfcase_k$ construct.
The $\pcfcase_k$ construct is the obvious generalization of the
conditional operator \pcfcond\ to $k\in\nat$ branches instead of $2$. We call safe \pcf$_c$ the corresponding extension of safe \pcf. Clearly, all the results obtained so far concerning safe \pcf\ also hold in safe \pcf$_c$.

The characterization theorem allows us to show the following definability result for safe \pcf$_c$:
\begin{proposition}[Definability for safe \pcf$_c$ terms]
\label{prop:safetydefinability} Let $\overline{A}=(A_1,\ldots, A_i)$
and $B$ be two PCF types for some $i,l\geq 0$
and $\sigma$ be a well-bracketed innocent P-i.j.\ strategy with
finite view function defined on the game $A_1 \times \ldots
\times A_i \gamear B$. There exists an \emph{almost safe} \pcf$_c$ term
$\overline{x} : \overline{A} \asentail M : B$ in $\eta$-long normal
form such that:
$$ \sem{\overline{x} : \overline{A} \asentail M_\sigma : B} = \sigma $$
and a safe closed \pcf$_c$ term $\sentail M'_\sigma : (\overline{A},B)$ in $\eta$-long normal form such that:
$$ \sem{\sentail M'_\sigma : (\overline{A},B)} \cong \sigma \enspace .$$
\end{proposition}
\begin{proof}
By the standard definability result for \pcf$_c$, there is a \emph{finite} term
$\overline{x} : \overline{A} \entail N : B$ such that
$\sem{\overline{x} :\overline{A} \entail N : B} = \sigma$. Take
$M_\sigma$ to be $\etalnf{\betanf{N}}^*$.  We have
$\sem{\overline{x} : \overline{A} \entail M_\sigma : B} =
\sem{\overline{x} :\overline{A} \entail N : B} = \sigma$ and by
Theorem  \ref{thm:almostsafeincrejust_pcf}(ii), $M_\sigma$ is
almost safe. For the second part, take $M'_\sigma$ to be the closure $\lambda \overline{x}. M_\sigma$ of $M_\sigma$.
\end{proof}

Note that because the argument relies on dead code-elimination, which is undecidable, it does not constitutes a constructive proof: We know that the term $M_\sigma$ exists but we do not have an algorithm to compute it.

This result shows that the game model of safe \pcf\ is \defname{intentionally fully-abstract}: Every \emphind{compact} strategy (\ie, with finite view function) is definable \cite{abramsky94full}).
The property that all denotations in the model are definable, including the recursive ones, is called \defname{universality}. Universality was shown for the game model of \pcf\ \cite{abramsky94full}.
In order to show universality for safe \pcf, the ``trick'' used in the previous proof does not suffice: It is possible to perform dead-code elimination on the infinite term obtained by unfolding the Y-recursion, but the resulting term is a potentially infinite term, and it is not necessarily the unfolding of a ``finite'' \pcf\ term (with Y combinators). Thus one has  to be slightly more subtle to handle recursion. One way around this problem could consists in using a version of the Correspondence Theorem expressed over a finite syntax representation of the term (as described in remark \ref{rem:finite_pcftree}) and to perform dead-code elimination on this representation rather than on its unwinding. We will not investigate this question further as it is not essential to our understanding of the game semantics of safe lambda-calculi.



\subsection{Compositionality}

In the next chapter we will give an in depth account of P-i.j.\ strategies. In particular we will give a semantic argument showing that when suitably restricted, P-i.j.\ strategies compose. We show here essentially the same result using a syntactic argument that relies on the definability result from the previous section. The advantage is that the proof is much simpler that the one given in the next chapter. The disadvantage is that it is slightly less general as it only works for strategies that are denotations of compact \pcf\ terms (\ie, the compact innocent ones) whereas the proof in the next chapter works in the general case.

Let $\overline{A} = (A_1, \ldots, A_i)$, $B = (B_1, \ldots,
B_l,o)$ and $C=(C_1,\ldots,C_k,o)$ be three PCF types for some
$i\geq 1,l,k\geq 0$.

\emph{Problem:} Given two compact (with finite view function) innocent well-bracketed and P-incrementally justified strategies $f:\ A_1 \times \ldots \times A_i \gamear B$ and $g:\ B\gamear C$. What is a sufficient condition for the composite $f;g$ to be P-incrementally justified?

We tackle the problem syntactically by appealing to the definability result: Since $f$ and $g$ are compact innocent, there are two closed safe terms $M_f :(\overline{A},B)$ and $M_g :B \typear C$ in $\eta$-long nf denoted by $f$ and $g$ respectively.
Composition is syntactically formulated by the term
 $$ M_{f; g} \equiv \lambda \overline{x} . M_g (M_f \overline{x})$$ for some fresh variables $\overline{x} : \overline{A}$,
 whose denotation is clearly given by $\sem{M_f} ; \sem{M_g} = f; g$.

Observe that the safety of $M_f$ and $M_g$ does not imply that of $M_{f; g}$ as the following examples illustrate:
\begin{example}
\begin{enumerate}[(i)]
\item Take $A=o$, $B=(o,o)$, $C=(((o,o),o),o)$, the variables $x,u,v:o$,
$y:B$ and $\varphi:((o,o),o)$ and the $\Sigma$-constant $a:o$.
Take the two closed safe terms $M_f \equiv \lambda xv.x : A\typear
B$ and  $M_g \equiv \lambda y \varphi. \varphi (\lambda u . y a)
: B\typear C$. The eta-long beta-nf of $M_{f; g}$ is $
\lambda x \varphi. \varphi (\underline{\lambda u . x})$ which is
unsafe because of the underlined term.

Consequently by Theorem \ref{thm:safeincrejust_lmd}(ii), the strategy $\sem{M_{f; g}}=\sem{M_f}
; \sem{M_g}$ is not P-i.j. This shows that P-i.j.\ strategies do not generally compose. The following diagram illustrates a play that is not P-i.j.:
\begin{center}
\begin{tikzpicture}[style={anchor=base}]
\matrix (m) [matrix of math nodes]
{
    \ &   & \ & \ & \ & \ &  & &\  &  & & & \\
    o & \stackrel{\sigcol{\sem{M_f}}}\longrightarrow & (o, & o) & \stackrel{\mucol{\sem{M_g}}}\longrightarrow & (((o, &o),& o),& o) \\ \\
    &&&&&&&&\node(n0){\lambda x \varphi \omove  \mucol {\lambda y \varphi}};\\[3mm]
    &&&&&&&\node(n1){\varphi  \pmove \mucol \varphi};\\[3mm]
    &&&&&&\node(n2){\lambda u \omove  \mucol {\lambda u}}; \\[3mm]
    &&&  \node(n3){ \sigcol {\lambda x v} \opmove \mucol y}; \\[3mm]
    \node(n4){x \pmove \sigcol x}; \\
};
\draw [-,thick] (m-1-1.south west) -- (m-1-1.south east) node [above,midway] {A};
\draw [-,thick] (m-1-3.south west) -- (m-1-4.south east) node [above,midway] {B};
\draw [-,thick] (m-1-6.south west) -- (m-1-9.south east) node [above,midway] {C};
\path (n4) edge[tableptr] (n0);
\path (n2) edge[tableptr,\mucolor] (n1);
\path (n1) edge[tableptr,\mucolor] (n0);
\path (n3) edge[tableptr,\mucolor] (n0);
\path (n4) edge[tableptr,\sigcolor] (n3);
\end{tikzpicture}
\end{center}

\item A counter-example with $\ord{B} = \ord{C}$:
 Let $A=o$, $B=C=(((o,o),o),o)$ and let $x:A$, $y:B$, $u:o$, $v,\varphi:((o,o),o)$
and $g:(o,o)$ be variables and  $a:o$ be a $\Sigma$-constant. Take the two closed safe terms $M_f \equiv \lambda x v.x$ and $M_g \equiv \lambda y \varphi. \varphi (\lambda u . y (\lambda g. a))$.
The $\eta\beta$-nf of $M_{f; g}$ is $\lambda x \varphi. \varphi (\underline{\lambda u . x})$ which is unsafe because of the underlined term, so
$f; g$ is not P-i.j.
\end{enumerate}
\end{example}


Since $M_f$ and $M_g$ are in $\eta$-nf, they can be written:
\begin{eqnarray*}
\sentail M_f &\equiv& \lambda x_1^{A_1} \ldots x_i^{A_i}\ \varphi_1^{B_1} \ldots \varphi_l^{B_l} . N_f \\
\sentail M_g &\equiv& \lambda y^{(B_1, \ldots, B_l,o)}\ \phi_1^{C_1} \ldots \phi_k^{C_k} . N_g
\end{eqnarray*}
for some safe ground-type terms $N_f$ and $N_g$ in $\eta$-nf.
Substituting these two equations in $M_{f;g}$ gives:
\begin{align}
f; g &= \sem{\lambda \overline{x} . (\lambda \phi_1\ldots \phi_k . N_g) [(M_f \overline{x}) / y]} \nonumber \\
&= \sem{\lambda \overline{x} \phi_1 \dots \phi_k. N_g [(M_f  \overline{x}) / y]}
& \mbox{(the $x_j$'s and $\phi_j$'s can be chosen to be disjoint).} \label{eq_fcompg}
\end{align}

Thus by Theorem \ref{thm:almostsafeincrejust_pcf},
$f;g$ is P-incrementally justified just when
$\etalnf{\betanf{N_g [(M_f  \overline{x}) / y]}}^*$ is safe.


\paragraph{A sufficient and necessary condition}
\begin{lemma}
Let $\Gamma,y:B \sentail M$ be a safe term in $\eta$-nf and $\Gamma \entail R : B$ be an almost safe application. Let $N$ denote the set of nodes of the computation tree of $M$ and $\theroot$ be the root. Then:
\begin{align*}
\Gamma \sentail M[R/y] :A
\iff&  \forall x \in \freevarset(R) .  \forall y \in N_{\sf fv} .
      \forall m \in N_{\lambda} \inter ]\theroot,y] : \ord{m} \leq \ord{x} \enspace .
\end{align*}
\end{lemma}
\begin{proof}
The only cause of unsafety that can be introduced when substituting the almost safe term $R$ for $y$ in $M$ is when some variable free in $R$ becomes not incrementally bound in $\tau(M)$. The right-hand side of the equivalence expresses just this.
\end{proof}

Applying this lemma with $R \equiv M_f \overline{x}$ and $M \equiv M_g$ gives us a necessary and sufficient condition for $M_g [(M_f \overline{x}) / y]$ to be safe, and hence for $f;g$ to be P-i.j. The problem is that this condition is expressed on both $M_g$ and $M_f$ at the same time rather than independently. This is unsatisfactory because it does not give rise to a categorical notion of compositionality: Two morphisms should be composable as soon as the domain of one matches with the codomain of the other.

\paragraph{A sufficient condition}
The solution consists in restricting the P-i.j.\ strategies to a smaller class of composable strategies.

\begin{lemma}
\label{lem:suffic_compos}
If $\ord{A_i}\geq\ord{B} \mbox{ for all } 1 \leq i \leq n$ then $f;g$ is P-incrementally justified.
\end{lemma}
\begin{proof}
For all $1 \leq i \leq n$ we have
$\ord{x_i} = \ord{A_i} \geq \ord{B} = \ord{(M_f \overline x)}$
thus we can use the application rule of the safe lambda calculus to form the safe term $\overline{x}:\overline{A} \sentail M_f \overline{x}$.
The substitution lemma then shows that $M_g[(M_f \overline{x})/y]$ is safe which by Eq.\ \ref{eq_fcompg} implies that $f;g$ is
P-i.j.
\end{proof}

Strategies satisfying this condition are the \index{strategy!closed P-incrementally justified}\emph{closed P-incrementally justified strategies}. This property will be studied in depth in Sec.\ \ref{sec:closedpij}.

\begin{remark}\hfill
\begin{enumerate}
  \item The condition is not necessary: Take $A=o$, $B=(o,o)$,
$C=(o,o)$ and consider the two safe terms $M_f \equiv \lambda x^A\, u^o.u$
and $M_g \equiv \lambda y^B . y\, a$ for  some constant $a:o$. Then we have $M_{f; g} =_\beta \lambda x . a$ which is safe hence $f;g$ is P-i.j.\ although $\ord{A} < \ord{B}$.

\item In general type homogeneity is not preserved after composition. For instance the
types $o \typear (o \typear o)$ and $(o \typear o) \typear \left((o
\typear o) \typear o \right)$ are homogeneous but $o \typear \left((o \typear o) \typear o\right)$ is not.
Incidentally, the condition of Lemma \ref{lem:suffic_compos} turns out to be a sufficient condition for type-homogeneity to compose: For instance
if $A\typear B$ and $B \typear C$ are homogeneous simple types and $\ord{A} \geq \ord{B}$ then $A\typear C$ is homogeneous.

\end{enumerate}
\end{remark}

\subsection{Full abstraction}
In Chapter \ref{chap:background} we have presented the well-known result that the standard game models of PCF is fully abstract \cite{abramsky94full,hylandong_pcf,Nickau:lfcs94}: Two \pcf\ terms are observationally equivalent if and only they have the same denotations. Since safe \pcf\ is a fragment of \pcf\, this statement also holds for safe \pcf\ terms: Two safe \pcf\ terms are observationally equivalent \emph{with respect to \pcf\ contexts} (not necessarily safe) if and only if they have the same game denotation.

A natural question is whether there exists a fully abstract model with \emph{respect to safe contexts} only. Since safe \pcf\ terms are denoted by
P-incrementally justified strategies, it is reasonable to think
that O-moves also need to be constrained by a symmetrical
notion of ``O-incremental justification'' corresponding to the requirement
that contexts are safe.

The definability result shown for safe \pcf\ is a first step towards full-abstraction. This problem will be studied in Chapter \ref{chap:model}.

