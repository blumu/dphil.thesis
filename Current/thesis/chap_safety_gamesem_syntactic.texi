Our aim is to characterize safety by game semantics. This chapter
assumes that the reader is familiar with the basics of game
semantics introduced in Chapter \ref{chap:gamesem}.  Recall that a
\emph{justified sequence} over an arena is an alternating sequence
of O-moves and P-moves such that every move $m$, except the opening
move, has a pointer to some earlier occurrence of the move $m_0$
such that $m_0$ enables $m$ in the arena. A \emph{play} is just a
justified sequence that satisfies Visibility and Well-Bracketing. A
basic result in game semantics is that $\lambda$-terms are denoted
by \emph{innocent strategies}, which are strategies that depend only
on the \emph{P-view} of a play. The main result
(Theorem~\ref{thm:safeincrejust_lmd}) of this section is that if a
$\lambda$-term is safe, then its game semantics (is an innocent
strategy that) is, what we call, \emph{P-incrementally justified}.
In such a strategy, pointers emanating from the P-moves of a play
are uniquely reconstructible from the underlying sequence of moves
and pointers from the O-moves therein: specifically a P-question
always points to the last pending O-question (in the P-view) of a
greater order.

The proof of Theorem~\ref{thm:safeincrejust_lmd} relies on the
Correspondence Theorem from Chapter \ref{chap:concrete_gamesem} that
relates the strategy denotation of a $\lambda$-term $M$ to the set
of \emph{traversals} over a souped-up abstract syntax tree of the
$\eta$-long form of $M$. In the language of game semantics, this theorem says that
traversals are just (concrete representations of) the
\emph{uncovering} (in the sense of Hyland and Ong
\cite{hylandong_pcf}) of plays in the strategy denotation.



Since the safety condition is a syntactic constraint, it can seem
difficult to give a characterization in term of game
semantics, as game models are by essence syntax-independent. This is where the the Correspondence Theorem comes to the rescue and help us to reason syntactically about the game denotation of a term. This ultimately permits us to give a precise game-semantic characterization of the safety restriction.

The main result of this chapter (Proposition
\ref{prop:safe_Pptr_recoverable}) states that pointers in a play of
a strategy denoting  a safe term can be uniquely recovered
from O-questions' justification pointers and from the underlying sequence of
moves. We introduce the
notion of \emph{P-incrementally justified strategies}, a particular kind of strategy in which justification pointers emanating from P-moves can be
reconstructed uniquely from the underlying sequences of moves and
from O-moves' pointers. We then introduce the notion of
\emph{incrementally-bound computation trees} and establish a relationship betwwen
incremental-binding and P-incremental justification (proposition \ref{prop:Nher_incrbound_iff_incrjustified}). Finally, we show that safe simply-typed terms have incrementally\--bound computation trees, consequently their game denotation is P-incrementally justified.


The first section of this chapter is concerned only with the safe $\lambda$-calculus without interpreted constants. In the following sections we extend the result by taking into account the interpreted
constants of \pcf\ and \ialgol. We define the language safe \ialgol\
(resp. safe \pcf) to be the fragment of \ialgol\ (resp. \pcf) where
the application and abstraction rules are constrained the same way
as in the safe $\lambda$-calculus. We show that safe \pcf\ terms are
denoted by P-incrementally justified strategies and we give the key
elements for a possible extension of the result to Safe Idealized
Algol.

Some of the results presented in this chapter were first published in TLCA \cite{blumong:safelambdacalculus}. The present chapter reproduced those results here with complete proof and generalized them to the languages \pcf\ and \ialgol.

\section{P-incrementally justified strategies}

In the game-semantic literature, some authors use the term ``order of a question move'' to refer to the length of the path in the arena to the initial move that hereditarily enables it. For the purpose of studying the safety restriction, however, it will be convenient instead to call it the \defname{level} of the node, and reserve the term ``order'' to refer to another quantity: The \defname{order of a move} $m$, written $\ord{m}$, is defined as the length of the path from $m$ to its furthest leaf in the arena minus 1. Thus the order of an arena can be defined in term of move-order: it is precisely the greatest order of its initial moves.


\begin{definition}
  A strategy $\sigma$ is said to be \defname{P-incrementally
    justified} if for any play $s \, q \in \sigma$ where $q$ is a
  P-question, $q$ points to the last unanswered O-question in $\pview{s}$ with
  order strictly greater than $\ord{q}$.
\end{definition}



Note that although the pointer is determined by the P-view, the
choice of the move itself can be based on the whole history of the
play. Thus P-incremental justification does not imply innocence.

The definition suggests an algorithm that, given a play of a
P-incrementally justified denotation, uniquely recovers the pointers
from the underlying sequence of moves and from the pointers
associated to the O-moves therein. Hence:
\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} In P-incrementally
justified strategies, pointers emanating from P-moves are
superfluous.
\end{lemma}
\begin{proof}
Suppose $\sigma$ is a P-incrementally justified strategy. We prove
that pointers attached to P-moves in a play $s\in \sigma$ are
uniquely recoverable by induction on the length of $s$. \noindent
\emph{Base case}: if $|s| \leq 1$ then there is no pointer to
recover. \noindent \emph{Step case}: suppose $s m \in \sigma$. If
$m$ is an answer move then by the well-bracketing condition $m$
points to the last unanswered question in $s$. If $m$ is a
P-question then by  P-incremental justification of $\sigma$, $m$
points to the last O-move in $\pview{s}$ with order strictly greater
than $\ord{q}$. Since we have access to O-moves' pointers, we can
compute the P-view $\pview{s}$. Hence $m$'s pointer is uniquely
recoverable.
\end{proof}

\begin{example}
Copycat strategies, such as the identity strategy $id_A$ on game $A$
or the evaluation map $ev_{A,B}$ of type $(A \Rightarrow B) \times A
\typear B$, are all P-incrementally justified.\footnote{In such
strategies, a P-move $m$ is justified as follows: either $m$ points
to the preceding move in the P-view or the preceding move is of
smaller order and $m$ is justified by the second last O-move in the
P-view.}
\end{example}



\section{Incremental binding}

In this section, we assume that we work in the general setting of an applied simply-typed lambda calculus extended with new
interpreted constants (but not recursion) and verifying the following prerequisites:
\begin{asparaitem}[-]
\item Terms of the language are denoted by sequents of the form
$\Gamma \entail M : T$.
\item The language has a properly defined fully-abstract game-semantic model where each term-in-context $\Gamma \entail M : T$ is denoted by a strategy $\sem{\Gamma \entail M : T}$;

\item A notion of safety is defined for the language by way of a system of rules producing sequents of the form $\Gamma \sentail M : T$ such that the restriction of the language to the safe pure simply-typed
fragment coincides with the definition of the safe lambda calculus;

\item A safe term-in-context $\Gamma \sentail M : T$ verifies the basic property $\forall z \in \Gamma . \ord{z} \geq \ord{T}$;

\item The small-step reduction semantics of the language preserves safety;

\item Well-behaved (see Def.\
\ref{def:wellbehaved_traversal}) traversal rules are defined to take into account the constants of the language;

\item These constant traversal rules model the behaviour of the constants in such a way that the game-semantic correspondence (Theorem \ref{thm:correspondence}) holds for that language.
\end{asparaitem}
\smallskip

The result of the two previous chapters shows that the recursion-free fragments of \pcf\ and \ialgol\ fit in this setting. For the rest of this section we fix a term $\Gamma \entail M : T$
of this unspecified language.


\subsection*{Definition}


Recall from the definition of computation trees (Chapter
\ref{chap:concrete_gamesem}) that a variable node $n$ labelled $x$ is said
to be \emph{bound} by a node $m$ if $m$ is the closest node in the
path from $n$ to the root such that $m$ is labelled $\lambda
\overline{\xi}$ with $x\in \overline{\xi}$. Thus a binder node
always occurs in the path from the bound node to the root. We now
introduce a class of computation trees in which the binder node is
uniquely determined by the nodes' orders.

\emph{Notations:} We call \defname{path} any sequence of nodes such
that for any two consecutive nodes $a \cdot b$ in the sequence, $a$
is the parent of $b$. We write $[n_1,n_2]$ to denote, if it exists,
the unique path going from node $n_1$ to node $n_2$ equipped with
the justification pointers induced by the enabling relation $\vdash$
(each node of the tree has a unique enabler in the path to the root
thus for each occurrence in $[n_1,n_2]$ there is at most one
occurrence of its enabler in $[n_1,n_2]$). We write $]n_1,n_2]$ for
the sub-sequence of $[n_1,n_2]$ obtained by removing $n_1$ as welle
as all the associated pointers.

We recall that $\theroot$ denotes the root of the computation tree
$\tau(M)$ and $N^{\theroot\vdash}$ denotes the subset of $N$
consisting of nodes that are hereditarily enabled by $\theroot$.



\begin{definition}[Incrementally-bound computation tree]
Let $A$ be a subset of nodes of the computation tree.
\begin{enumerate}[(i)]
\item A variable node $x$ of a computation tree is said to be
\defname{$A$-incrementally-bound} if its enabler is the first
$\lambda$-node from $A$ in the path to the root that has order
strictly greater than $\ord{x}$. Formally:
\begin{align*}
x \mbox{ is $A$-incrementally-bound} \  \iff \  \left\{
                                                  \begin{array}{ll}
                                                    x \hbox{ is enabled by } b \in [\theroot,x]\inter A \ ; \\
                                                    \ord{b} > \ord{x} \;\\
                                                    \forall \lambda\mbox{-node } n' \in ]n,x]\inter A  . \ord{n'} \leq \ord{x} \ .
                                                  \end{array}
                                                \right.
\end{align*}
\noindent This definition can be split into two cases:
\begin{enumerate}
\item $x$ is \emph{bound} by the first $\lambda$-node from $A$ occurring in the path to the root that has
order strictly greater than $\ord{x}$.
\item or $x$ is a \emph{free variable} and all the $\lambda$-nodes from from $A$ occurring in the path to the root except the root have order
 smaller or equal to $\ord{x}$.
\end{enumerate}

\item A computation tree is said to be
\defname{$A$-incrementally-bound}, also abbreviated $A$-i.b., if all
the variable nodes from $A$ are $A$-incrementally-bound, and we say
that a node (resp.\ a tree) is
\defname{incrementally-bound} if it is
\defname{$N$-incrementally-bound} where $N$ is the entire set of nodes of the computation tree.
\end{enumerate}
\end{definition}

Clearly for any two sets of nodes $A$ and $B$ verifying $A\subseteq
B$, $B$-incremental-binding implies
$A$-incremental-binding.


\smallskip

Let $\closure{M}$ denote the function that converts $M$ into the
closed term obtained from $M$ by abstracting all its free variables
(in order of appearance in the term).
Clearly, $\tau(M)$ and $\tau(\closure{M})$ are isomorphic and the enabling relation $\vdash$ is defined identically
on these two trees (since free variable nodes are enabled by the root), therefore $\tau(M)$ is $A$-i.b.\ if and only if $\tau(\closure{M})$ is.
\smallskip

\subsection*{Safety and incremental binding}
We recall that a term is \emphind{almost safe} if it can be written $\lambda x_1 \ldots x_n . N_0 \ldots N_p$ for some $n,p \geq 0$ where $N_i$ is safe for all $0\leq i \leq p$.

\begin{proposition}[Safe terms have incrementally-bound computation trees]
\label{prop:incrbound_iff_etanf_safe} Let $\Gamma \sentail M
:T$ be a safe term of some applied simply-typed calculus without recursion.
\begin{itemize}
\item[(i)] If $M$ is almost safe then $\tau(M)$ is incrementally-bound ;
\item[(ii)] conversely, if $\tau(M)$ is i.b.\ then the $\eta$-long normal form of $M$ is almost safe, and safe if further $M$ is closed.
\end{itemize}
\end{proposition}
\proof
(i) Suppose that $M$ is almost safe. By the previous remark,
to show that $\tau(M)$ is i.b., it is equivalent to show that
$\tau(\closure{M})$ is incrementally-bound.

By definition, the computation tree $\tau(\closure{M})$ is
an abstract syntax representation of the $\eta$-long normal form of the closure of $M$.
Since $M$ is almost safe, by Lemma \ref{lem:almostsafe_iff_etalnf_almostsafe} the
$\eta$-long normal form of the closure of $M$ is safe.
Hence the underlying term represented by the abstract syntax tree $\tau(\closure{M})$ is a safe term.

In a safe applied $\lambda$-calculus, the variables in the context with
the the lowest order must be all abstracted at once when using the
abstraction rule. Since the computation tree merges consecutive
abstractions into a single node, any variable $x$ occurring free in
the subtree rooted at a $\lambda$-node $\lambda \overline{\xi}$
different from the root must have order greater or equal to
$\ord{\lambda \overline{\xi}}$. Conversely, if a lambda node
$\lambda \overline{\xi}$ binds a variable node $x$ then
its order is $1+\max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Let $x$ be a variable node in $\tau(\closure{M})$.
Its enabler necessarily occurs in the path to the root, therefore, according to the previous observation,
$x$ must be bound by the first $\lambda$-node occurring in $[\theroot,x]$
with order strictly greater than $\ord{x}$. Hence $\tau$ is incrementally-bound.

(ii) We first show the result for closed term. Let $\entail M :T$ be a closed term such that $\tau(M)$ is incrementally-bound. We assume that $M$ is already in $\eta$-long normal form. We prove by induction that $M$ is safe. The
base case $M \equiv \lambda \overline{\xi} . \alpha$ for some variable or
constant $\alpha$ is trivial. \emph{Step case:} $M \equiv \lambda
\overline{\xi} . N_1 \ldots N_p$. Let $1\leq i\leq p$. Each $N_i$
can be written $\lambda \overline{\eta_i} . N'_i$ where $N'_i$ is
not an abstraction. By the induction hypothesis, $\lambda
\overline{\xi} . N_i \equiv \lambda\overline\xi\overline{\eta_i} .
N'_i$ is safe which means that the term $N'_i$ is also safe \ie
$\overline\xi, \overline{\eta_i} \sentail N'_i :A_i$ for some type $A_i$.
Let $z$ be a variable occurring free in $N'_i$. Since $M$ is
closed, $z$ is either bound by $\lambda \overline{\eta_1}$ or
$\lambda \overline{\xi}$. In the latter case, since $\tau(M)$ is
i.b. we have that $\ord{z}$ is smaller than $\ord{\lambda
\overline{\eta_1}}=\ord{N_i}$, thus in both case we are allowed to
abstract the variables $\overline{\eta_1}$ using the rule
\rulenamet{abs}, which shows that $N_i$ is safe.
Since all the $N_i$s are safe and the term $N_1 \ldots N_p : o$ is of order $0$, by the rule \rulenamet{app} we have that $N_1 \ldots N_p$ is safe \ie $\overline{\xi} \sentail N_1 \ldots N_p :o$. The rule \rulenamet{abs} then gives us $\sentail \lambda \overline{\xi} . N_1 \ldots N_p$.

Now if $M$ is open, by the preceding case we have that $\closure{M}$ is safe. But clearly by ``pealing-off'' abstractions from a safe term we obtain an almost safe term, thus $M$ is almost safe.
\qed
% end of proof
\smallskip

Note that the hypothesis that $M$ is closed in (ii) is necessary.
Take for instance the two terms $\lambda x y .x$ and $\lambda y . x$,
where $x,y:o$. Their have isomorphic incrementally-bound computation
trees. But $\lambda x y .x$ is safe and $\lambda y . x$ is
only almost safe.
\smallskip

In the second part of this proposition a slightly stronger result holds if the term is $\beta$-normal and does not contain any interpreted constant:
\begin{corollary}
\label{cor:incrbind_imp_safe_betanf}
Let $M$ be a $\beta$-normal term containing no interpreted constant.
If all the input variables are incrementally-bound then 
 the $\eta$-long normal form of $M$ is almost safe, and safe if further $M$ is closed.
\end{corollary}
This is simply because in the computation tree of such terms all the variable nodes are input-variables.
This stronger result does not hold for term containing a redex: For any unsafe closed term $U$, the term $(\lambda u .u)~U$ is unsafe but the only input-variable is $u$ and it is incrementally-bound. It does not hold either for terms with interpreted constants: for instance the \pcf\ term $\pcfsucc\ U$ for any closed unsafe term $U$ of type \iaexp, has no input variable but it is unsafe.



\begin{corollary}
\label{cor:betasred_preserve_incrbound} If $\tau(M)$ is incrementally-bound and $M \betasred N$ then $\tau(N)$ is incrementally-bound.
\end{corollary}
\proof Suppose that $\tau(M)$ is i.b. Then by Proposition
\ref{prop:incrbound_iff_etanf_safe}(ii) the eta-long normal form of $M$ is almost safe, therefore so is $M$ by Lemma \ref{lem:almostsafe_iff_etalnf_almostsafe}.
But almost safety is preserved by $\beta_s$-reduction (Lemma \ref{lem:betasred_preserves_almostsafety}) therefore $N$ is almost safe. Finally by Proposition \ref{prop:incrbound_iff_etanf_safe}(i), $\tau(N)$ is
incrementally-bound. \qed
\smallskip

Note that this corollary  cannot be generalized to
$A$-incremental-binding for any set of node $A$. Take for instance
the eta-normal term $M = \lambda u^{o} v^{((o,o),o)} . (\lambda x^o
. v (\lambda z^o . x)) u$ which beta-reduces to $N = \lambda u v . v
(\lambda z . u)$. The computation trees are:
\begin{center}
\begin{tikzpicture}[level distance=7mm,inner ysep=0.5mm,inner xsep=0.5mm,sibling distance=10mm]
\path
node{$\tau(M) = $}
+(2,0)
node{$\underline{\lambda u v}$}
child{
      node{$@$}
            child{
              node {$\lambda x$}
              child{
                  node {$\underline{v}$}
                  child{
                        node {$\underline{\lambda z}$}
                        child{
                          node {$x$}
                        }
                  }
                }
            }
            child{
                node {$\lambda$}
                child{
                        node{$\underline{u}$}
                }
            }
        }
+(5,0)
 node {$\tau(N)=$ }
 +(6,0)
 node {$\underline{\lambda u v}$}
    child{
      node{$\underline{v}$}
          child{
            node {$\underline{\lambda z}$}
            child{
                node {$\underline{u}$}
            }
          }
      }
;
\end{tikzpicture}
\end{center}
and if we take $A$ to be the set of nodes that are hereditarily enabled by
the root (underlined in the above figure) then $\tau(M)$
is $A$-incrementally-bound but $\tau(N)$ is not.
\bigskip

\subsection*{Incremental justification and incremental binding}

A node of the computation tree is said to be \defname{reachable} if
there is some traversal of the computation tree that visits it.

\begin{proposition}[Incremental-binding and P-incremental justification]
\hfill

 \label{prop:Nher_incrbound_iff_incrjustified}

\begin{enumerate}[(i)]
\item Suppose $M$ is $\beta$-normal. If all the \emph{reachable} input-variable nodes of the computation tree
$\tau(\Gamma \vdash M : T)$ are
$N^{\theroot\vdash}$-incrementally-bound then $\sem{\Gamma
\vdash M : T}$ is P-incrementally justified.

\item If $\sem{\Gamma \vdash M : T}$ is
P-incrementally justified then all the \emph{reachable}
input-variable nodes of the computation tree $\tau(\Gamma \vdash
M : T)$ are $N^{\theroot\vdash}$-incrementally-bound.
\end{enumerate}
\end{proposition}

\begin{proof}
\noindent (i) Take a term $M$ in $\beta$-nf.
W.l.o.g\ we can assume that $M$ is a closed term since the incremental-binding property is conserved when taking the closure of a term and since the denotation of the closure is isomorphic to the denotation of the term.

Suppose that all the reachable input-variable nodes of $\tau(M)$ are $N^{\theroot\vdash}$-incrementally bound. We want to show
that $\sem{M}$ is P-incrementally justified. Take a play $s \in \sem{M}$ ending with a question
P-move $q$. By the Correspondence Theorem \ref{thm:correspondence},
there is a traversal $t$ of $\tau(M)$ starting with an occurrence
$r$ of the root $\theroot$ such that $\psi_M (t\filter r) = s$. We
assume $t$ to be the shortest such traversal, so that the last
occurrence of $t$, let us name it $n$, is hereditarily justified
by $r$, and is by definition an occurrence of a reachable node.
Since $\psi_M$ maps $n$ to $q$, $n$ is necessarily an
occurrence of a variable node $x$.

Since $M$ is closed, $x$ is necessarily a bound variable. Let $m$ denote its justifier
in $t$ (which is an occurrence of $x$'s binder in $\tau(M)$). By
assumption $\tau(M)$ is $N^{\theroot\vdash}$-incrementally-bound
therefore since $n$ belongs to $N^{\theroot\vdash}$, $m$ must be
the last $\lambda$-node in $[\theroot,n]\ \inter
N^{\theroot\vdash}$ of order strictly greater than $\ord{n}$.
By the Path--P-view correspondence (Prop.\
\ref{prop:pviewtrav_is_path}) we have $[\theroot,n] \inter
N^{\theroot\vdash} = \pview{t} \filter r$. This in turn is equal to $\pview{?(t \filter r)}$ by Lemma
\ref{lem:betanf_wellbehavedconst_trav_pview_red}
because $M$ is in $\beta$-normal form and because we assumed that the traversal constant for the language considered are well-behaved.


By Lemma \ref{lem:psi_properties} (iv), the P-view of
$?(s)$ and the P-view of $?(t \filter r)$ are computed similarly
and have the same pointers, therefore node $n$ and move $q$ both
point to the same position in the justified sequence
$\pview{?(t\filter r)}$ and $\pview{?(s)}$ respectively.
Moreover by Lemma \ref{lem:psi_properties}, $\psi_M$ maps nodes of a given order to moves of
the same order. Hence $q$ points to the last O-move in $\pview{?(s)}$ with order $>\ord{q}$. Finally Lemma \ref{lem:views_and_questionmarkfilter} gives us
$?(\pview{s}) = \pview{?(s)}$, and since $s$'s last move is a
question, $\pview{s}$ contains only question moves and therefore
$\pview{?(s)} = \pview{s}$. Thus $q$ points to the last O-move
in $\pview{s}$ with order strictly greater than $\ord{q}$.
\smallskip

\noindent (ii) Suppose $\sem{M}$ is P-incrementally justified. Let
$x$ be a reachable input-variable node of $\tau(M)$: there exists a
traversal of the form $t \cdot x$ in $\travset(M)$ such that $x$ is
hereditarily justified by the first occurrence $r$ of $\tau(M)$'s
root in $t$.

The correspondence theorem tells us that $\varphi((t \cdot x)
\filter r) = \varphi(t \filter r) \cdot \varphi(x)$ belongs to $\sem{M}$.
Since $\sem{M}$ is P-incrementally justified, $\varphi(x)$ points to
the last O-move in $\pview{\varphi(t \filter r)}$ with order
strictly greater than $\ord{\varphi(x)}$. Consequently $x$ points to
the last $\lambda$-node in $\pview{t \filter r}$ with order strictly
greater than $\ord{x}$.

But by Lemma \ref{lem:pviewproj_wrt_theroot}, $\pview{t \filter r}$
contains $\pview{t} \filter r$ as a subsequence. Thus since by
P-visibility $m$ occurs in this subsequence, we have that $m$ is
also the last $\lambda$-node in $\pview{t} \filter r$ with order
strictly greater than $\ord{x}$. By the path-P-view correspondence
(Prop.\ \ref{prop:pviewtrav_is_path}) this can in turn be restated
as: $m$ is the last $\lambda$-node in $[\theroot,x[\  \inter\
N^{\theroot \vdash}$ with order strictly greater than $\ord{x}$.
Hence $\tau(M)$ is $N^{\vdash \theroot}$-incrementally-bound.
\end{proof}

\section{Safe lambda calculus}

We now consider the special case of the pure (\ie without interpreted constants) safe $\lambda$-calculus. For any simply-type term $\Gamma \stentail M : T$ we write $\sem{\Gamma \stentail M : T}$  to refer to the game denotation of $\Gamma \stentail M : T$ in which the Opponent is not restricted to play deterministically (let alone innocently). In other words, the game denotation accounts for contexts that are not simply-typed terms. This allows us to make use of the Correspondence Theorem with respect to the traversal rules defined in Table \ref{tab:trav_rules}.
With this definition of traversals, the notion of \emph{reachability} for simply-typed terms gets simplified:
\begin{lemma}
  \label{lem:st_allnodes_reachable}
  For simply-typed lambda term in $\beta$-normal form,
  all the nodes of the computation tree are \emph{reachable} by some traversal obtained using the rules of Table \ref{tab:trav_rules}.
\end{lemma}
\proof Since $M$ is in $\beta$-normal form, its computation tree has no application node and therefore all the variable nodes are hereditarily justified by the root. Hence each variable node can be reached by the traversal consisting of the path from the root to that node: the rule \rulenamet{Lam} and \rulenamet{InputVar} permit us to visit the variable nodes and lambda nodes respectively.\qed
\smallskip

Observe that if we restrict the rules of Table \ref{tab:trav_rules} to make it correspond to the ``standard'' game model where the Opponent is required to play innocently then this result does not hold anymore. For instance in the term $\lambda \varphi x y z. \varphi x (\varphi y z)$ the node corresponding to the occurrence $y$ would not be reachable.

\begin{corollary}[of Proposition \ref{prop:Nher_incrbound_iff_incrjustified}]
\label{cor:Nher_incrbound_iff_incrjustified_lmd}
  Let $\Gamma \stentail M : T$ be a pure
   (\ie with no interpreted constants) simply-typed term in $\beta$-normal form.
   Then $\sem{\Gamma \stentail M : T}$ is P-incrementally justified
   if and only if the computation tree $\tau(M)$ is incrementally-bound.
\end{corollary}
\proof We first observe that all the variable nodes are
input-variable nodes. Indeed, let $x$ be a variable node of
$\tau(M)$. Since $M$ is $\beta$-normal, by lemma
\ref{lem:betanorm_enabling}, $x$ is either hereditarily enabled by
the root or by a constant in $N_\Sigma$. But the pure simply-typed
$\lambda$-calculus does not have constants thus $N_\Sigma =
\emptyset$ and $x$ is hereditarily enabled by the root, \ie it is an
input-variable node. Consequently, incremental-binding coincides
with $N^{\vdash \theroot}$-incremental-binding.
Finally, by Lemma \ref{lem:st_allnodes_reachable}, all the variable nodes are reachable. Hence the result follows from Proposition \ref{prop:Nher_incrbound_iff_incrjustified}.
\qed
\smallskip


\begin{example}
\begin{enumerate}[(i)]
\item For any higher-order variable $x:A$ the computation tree
$\tau(x)$ is incrementally-bound therefore the projection
strategies are P-incrementally justified.

\item
\parpic[r]{
\raisebox{-12pt} {\begin{tikzpicture}[level distance=4.4ex,inner
ysep=0.5mm] \node {$\lambda^3$} child {node {$f^2$}
       child {node {$\lambda y^1$} child {node {$x^0$}}}};
\end{tikzpicture}
} } Consider the $\beta$-normal term $\Gamma\stentail f (\lambda
y .x) : o$ where $y:o$ and $\Gamma =f:((o,o),o),~x:o$. The
figure on the right represents its computation tree with the
node orders given as superscripts.  The node $x$ is not
incrementally-bound because the node $x$ of order $0$ is not
bound by the order 1 node $\lambda y$. Therefore $\tau(f
(\lambda y .x))$ is not incrementally-bound and by Corollary
\ref{cor:Nher_incrbound_iff_incrjustified_lmd}, $\sem{\Gamma
\stentail f (\lambda y .x) : o}$ is not P-incrementally
justified. Similarly we can check that $\sem{\lambda y. x}$ is
P-i.j.\ while $\sem{f (\lambda y .x)}$ is not.

\item The previous examples show that $\sem{\Gamma \stentail f : ((o,o),o)}$ and $\sem{\Gamma \stentail \lambda
  y. x : (o,o)}$ are P-incrementally justified whereas
$\sem{\Gamma \stentail f (\lambda y .x) : o}$ is not. This
implies that application does not preserve
P-incremental justification.
\end{enumerate}
\end{example}
\smallskip

The third example suggests that P-incremental justification is not a
compositional property. In Chapter \ref{chap:model} we will identify a sufficient condition enabling compositionality of
P-incrementally justified strategies. \smallskip


Putting Corollary \ref{cor:Nher_incrbound_iff_incrjustified_lmd} and
Proposition \ref{prop:incrbound_iff_etanf_safe} together gives us a
game-semantic characterization of safety:
\begin{theorem}[Characterization Theorem for the Safe Lambda Calculus]
\label{thm:safeincrejust_lmd} Let $\Gamma \stentail M : A$ be a pure
simply-typed term (with no interpreted constants).
\begin{enumerate}[(i)]
\item If $\Gamma \stentail M : A$ is \emph{almost safe} (and in particular if it is safe) then $\sem{\Gamma \stentail M : A}$
is P-incrementally justified.
\item If $\sem{\Gamma \stentail M : A}$ is
  P-incrementally justified then the eta-long normal form of the beta-normal form of $M$ is
almost safe, and safe if further $M$ is closed.
\end{enumerate}
\end{theorem}
\proof (i) Let $M$ be a safe simply-typed term. By Lemma
\ref{lem:safered_preserve_safety}, its $\beta$-normal form $M'$ is
also safe, by Proposition \ref{prop:incrbound_iff_etanf_safe}(i),
$\tau(M')$ is incrementally-bound and by Proposition
\ref{cor:Nher_incrbound_iff_incrjustified_lmd}, $\sem{M'}$ is
incrementally justified. The soundness of the game model
gives $\sem{M} = \sem{M'}$.  (ii) is a consequence of Lemma
\ref{lem:safered_preserve_safety}, Corollary
\ref{cor:Nher_incrbound_iff_incrjustified_lmd} and
Proposition \ref{prop:incrbound_iff_etanf_safe}(ii) and soundness of the game model.
\qed
\smallskip

In particular, a term has a P-incrementally justified denotation if and only its eta-long beta-normal form is almost safe.
This result was first presented in TLCA2007, \cite[Theorem 3(ii)]{blumong:safelambdacalculus}.
\smallskip

\begin{remark}
  It is important here to underline the fact that the game denotation used here is not the standard one in the sense that the context is not constrained to play deterministically, let alone innocently. In the standard model, the second part of the theorem does not hold. Take for instance the eta-long beta-normal term $M \equiv \lambda \varphi:(o,o)~ y:o . \varphi (\lambda x:o. x) (\varphi (\lambda x:o .\underline{y}) (\lambda x.x))$. It is clearly unsafe but its denotation is P-i.j. Indeed, there is only two \emph{simply-typed terms} inhabiting the type $(o,o)$: $\pi_1 \equiv \lambda x_1 x_2 . x_1$ and $\pi_i \equiv \lambda x_1 x_2 . x_2$. But since we have $M~\pi_1 =_\beta \pi_2$ and $M~\pi_2 =_\beta \pi_2$, the term $M$ is in fact observationally equivalent to $\pi_2$ which is clearly P-i.j.
  
  Using ``dead-code elimination'', it is possible to obtain a version of the theorem that holds for the standard game denotation. This will be illustrated in the next section when dealing with Safe \pcf.
\end{remark}


Putting Theorem \ref{thm:safeincrejust_lmd}(i) and Lemma
\ref{lem:incrjustified_pointers_uniqu_recover} together gives:
\begin{proposition}[P's pointers are superfluous for safe terms]
\label{prop:safe_Pptr_recoverable}
   In the game semantics of safe $\lambda$-terms, pointers emanating from P-moves are unnecessary
  \ie~they are uniquely recoverable from the underlying sequences of
  moves and from O-moves' pointers.
\end{proposition}

 \begin{example} If justification pointers are omitted then the denotations of the two Kierstead terms $M_1 = \lambda f . f (\lambda x . f (\lambda y .y ))$ and $M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ from Example~\ref{ex:kierstead} are not distinguishable.
   In the safe lambda calculus this ambiguity disappears
   since $M_1$ is safe whereas $M_2$ is not (The free variable $x$ in the subterm $f (\lambda y . x)$, has the same order as $y$ but it is not abstracted together with $y$).
\end{example}

In fact, as the last example highlights, pointers are superfluous at
order $3$ for safe terms whether from P-moves or O-moves. This is
because for question moves in the first two levels of an arena
(initial moves being at level $0$), the associated pointers are
uniquely recoverable thanks to the visibility condition. At the
third level, the question moves are all P-moves therefore their
associated pointers are uniquely recoverable by P-incremental
justification. This is not true anymore at order $4$: Take the safe
term $\psi:(((o^4,o^3),o^2),o^1) \sentail \psi (\lambda \varphi .
\varphi a) : o^0$ for some constant $a:o$, where $\varphi:(o,o)$.
Its strategy denotation contains plays whose underlying sequence of
moves is $q_0 \, q_1 \, q_2 \, q_3 \, q_2 \, q_3 \, q_4$. Since
$q_4$ is an O-move, it is not constrained by P-incremental
justification and thus it can point to any of the two occurrences of
$q_3$.\footnote{More generally, a P-incrementally justified strategy
can contain plays that are not ``O-incrementally justified'' since
it must take into account any possible strategy incarnating its
context, including those that are not P-incrementally justified. For
instance in the given example, there is one version of the play that
is not O-incrementally justified (the one where $q_4$ points to the
first occurrence of $q_3$). This play is involved in the strategy
composition $\sem{ \stentail M_2 : (((o,o),o),o)} ; \sem{
\psi:(((o,o),o),o) \stentail \psi (\lambda \varphi . \varphi a):o}$
where $M_2$ denotes the unsafe Kierstead term.}


\section{Safe PCF}
We now extend the game-semantic characterization to Safe
\pcf.

\emph{Conventions:} We recall that the $\beta$-normal form of a \pcf\ term is the possibly infinite term obtained by reducing all the $\beta$-redexes. A $\beta$-normal form is therefore not necessarily normal with respect to the full system of rules of \pcf\ (\eg the term $\pcfcond\, 0\, M\, N$ is $\beta$-normal although it reduces in one step to $M$).


\subsection{Dead code elimination}

In the context of the simply-typed lambda calculus, we have shown
the correspondence between safety and P-incremental justification
(Theorem \ref{thm:safeincrejust_lmd}). It is easy to see that
that the first part of this theorem still holds for Safe \pcf.
The second part, however, does not hold anymore: Indeed, take the
closed \pcf\ term $M = \lambda f x y. f (\lambda z. \pcfcond
(\pcfsucc\ x) y z )$ where $x,y,z:o$ and $f:((o,o),o)$. $M$ is in
normal form (the conditional operator cannot be reduced since the value of $x$ is
undetermined). The $\eta$-long form $\beta$-normal form of
$M$ is therefore $M$ itself which is unsafe. But clearly we have
$M$ has the same denotation as the safe term $\lambda f x y. f (\lambda z. z)$, which is is P-incrementally justified by (i).

Such counter-example arises because the conditional operator of
\pcf\ permits us to construct terms in normal form that contain
``dead code'' \ie some subterm that will never be evaluated
for any value of M's parameters. In the example above, the dead code
consists of the subterm $y$. In general, if the dead code part of
the computation tree contains a variable that is not incrementally
bound then the resulting term will be unsafe even if the rest of the
tree is incrementally bound. In our example, it was possible
to turn $M$ into the equivalent safe term $\lambda f x y. f (\lambda
z. z)$ by eliminating the dead code from $M$. We now show how this process can be generalized to any \pcf\ term that has a P-incrementally
justified denotation.
\smallskip

We say that a subterm $N$ of $M : (A_1, \ldots, A_n,o)$ is \defname{dead code} if for any context $C[-]$ such that $C[M]$ is of ground type, any reduction sequence starting from $C[M]$ does not involve a reduction of the subterm $N$ \ie for any reduction sequence $C[M] \equiv T_0 \redar T_1 \redar \ldots \redar T_k$, there is no $j\in \{0.. k-1\}$ such that $T_j = C'[N]$ and $T_{j+1} = C'[N']$ for some evaluation context $C'[-]$ and term $N'$.

The dead code elimination problem is the converse of the \defname{reachability problem}: given a term $M$ containing a subterm $N$ of $M$, is there a context $C[-]$ such that $C[M]$ is of ground type, and a reduction sequence $C[M] \equiv T_0 \redar T_1 \redar \ldots \redar T_j \equiv E[N]$ for some evaluation context $E[-]$.
The reachibility problem is clearly not trivial. In fact is not decidable since \pcf\ is Turing-complete and the halting problem for \pcf\ can be encoded into a reachability problem.\footnote{When restricted to the finitary fragment, however, reachibility is decidable. Luke Ong recently announced a proof of this result based on the theory of traversals.}


Let $M$ be a \pcf\ term in eta-long normal form. Occurrences of a variables that are in the dead code of $M$ are called \defname{dead occurrences}. By a game semantic argument, it is easy to show that an occurrence of $x$ is dead just if if the corresponding node in the computation tree is not \emphind{reachable} by any traversal.

Given a term \pcf\ $M$, we define $M^*$ as the term obtained from the (possibly infinite) $\eta$-long normal form of $M$ by substituting all
subterms of the form  $x N_1 \dots N_k$ for some dead variable
occurrence $x:(B_1,\ldots, B_k, o)$ by the constant $\bot$ of type $o$. This process is called \defname{dead variable elimination}. We write $\tau(M)^*$ to denote the equivalent transformation on the computation tree of $M$.
Clearly we have:
\begin{equation}
\travset(M^*) \subseteq \travset(M) \label{eqn:reachable_in_deadcodefree_imp_reachable}
\end{equation}

\subsection{Game characterization}

In \pcf, the correspondence between incremental binding and P-incremental justification showed in Prop.\ \ref{prop:Nher_incrbound_iff_incrjustified} becomes:
\begin{corollary}[Corollary of Prop.\ \ref{prop:Nher_incrbound_iff_incrjustified}] \
\label{cor:Nher_incrbound_iff_incrjustified_pcf} Let $\Gamma \vdash
M : A$ be a PCF term in $\beta$-normal form.
\begin{enumerate}[(i)]
\item  If $\tau(\Gamma \vdash M : A)$ is incrementally-bound then $\sem{\Gamma \vdash M : A}$ is P-incrementally justified;
\item  if $\sem{\Gamma \vdash M : A}$ is P-incrementally justified
then $\tau(\Gamma \vdash M : A)^*$ is incrementally-bound.
\end{enumerate}
\end{corollary}
\begin{proof}
(i) If $\tau(M)$ is incrementally bound then in particular it is $N^{\vdash \theroot}$-incrementally bound therefore by Proposition \ref{prop:Nher_incrbound_iff_incrjustified}(i), the denotation of $M$ is P-incrementally justified.

\noindent (ii) Suppose that $\sem{M}$ is P-incrementally justified.
Let $x$ be a variable node in $\tau(M)^*$. By definition of $\tau(M)^*$, $x$ is reachable in $\tau(M)^*$.
Hence there exists a traversal of $\tau(M)^*$ of the form $t \cdot x$.
By Eq.\ \ref{eqn:reachable_in_deadcodefree_imp_reachable}, $t \cdot x$ is also a traversal of $\tau(M)$ therefore
$x$ is also reachable in $\tau(M)$.

We observe that all the variable nodes are input-variable nodes. Indeed, since $M$ is $\beta$-normal, by lemma
\ref{lem:betanorm_enabling}, variable node are either hereditarily enabled by
the root or by a constant in $N_\Sigma$. But since the constants of \pcf\ are of order $1$ at most, they cannot hereditarily justify any variable node, thus variable nodes are necessarily hereditarily enabled by the root.


Thus $x$ is a reachable input-variable node of $\tau(M)$ and by Prop.\ \ref{prop:Nher_incrbound_iff_incrjustified}(ii)
it is $N^{\vdash \theroot}$-incrementally bound in $\tau(M)$:
$x$ points to the last lambda node in $\pview{t} \filter N^{\theroot\vdash}$ with order greater than $\ord{x}$.
By the Path-View correspondence (Prop.\ \ref{prop:pviewtrav_is_path}) we have:
\begin{align*}
\pview{t} \filter N^{\theroot\vdash} & = [\theroot,x[ \ \filter N^{\theroot\vdash} & (\mbox{by Prop.\ \ref{prop:pviewtrav_is_path}})
\end{align*}
Since $M$ is in $\beta$-nf, the nodes that are \emph{not} hereditarily
enabled by the root are precisely the nodes hereditarily enabled by
$N_\Sigma$ thus $[\theroot,x[ \ \filter N^{\theroot \vdash} = [\theroot,x[\ \setminus\
N^{\filter \Sigma}$. Since \pcf\ constants are of order $1$ at
most we have $N^{\filter \Sigma} = N_{\Sigma} \union N^c_{\Sigma}$
where $N^c_{\Sigma}$ is the set of children nodes of $N_{\Sigma}$.
Hence $x$ points to the last lambda node of greater order in $[\theroot,x[\ \setminus\
N_\Sigma \setminus N^c_\Sigma$
But $N_\Sigma$ does not contain any lambda node, and
$N^c_\Sigma$ is constituted of order-$0$ lambda-nodes only therefore
$x$ points to the last lambda node in $[\theroot,x[$ with order strictly greater than $\ord{x}$.
This shows that $\tau(M)^*$ is incrementally-bound.
\end{proof}


We have already established the correspondence between almost safety and incremental binding in the general setting of an applied simply-typed lambda calculus without recursion (Proposition \ref{prop:incrbound_iff_etanf_safe}). $\pcf_1$ can be cast into this setting by considering $\bot_A$ as ordinary constants: in the computation tree of a $\pcf_1$ term,  ubterms of the form $\Omega_A$ are represented by the single constant node $\bot_A$. In full \pcf, however, a difficulty arises as computation trees are potentially infinite due to the presence of the Y combinator. Nevertheless the result still holds:
\begin{proposition}[Almost safety and incrementally-binding]
\label{prop:incrbound_iff_etanf_safe_pcf} Let $\Gamma \vdash M : A$
be a PCF term.
\begin{itemize}
\item[(i)] If $\Gamma \vdash M : A$ is almost safe then $\tau(\Gamma \vdash M : A)$ is incrementally-bound ;
\item[(ii)] conversely, if $\tau(\Gamma \vdash M : A)$ is incrementally-bound then the $\eta$-normal form of $\Gamma \vdash M : A$ is almost safe if $M$ is open and safe if $M$ is closed.
\end{itemize}
\end{proposition}
\proof
(i) Let $M$ be an almost safe \pcf\ term and  $i$ denote the number of occurrences of the Y combinator in $M$.
We first prove by induction on $i$ that for any $k\in \omega$, the $k$th approximants to $M$, denoted $M_k$, is almost safe. The base case $i=0$ is trivial: $M_k = M$. Step case: $i>0$. Let $Y_A N$ be a subterm of $M$. Since $M$ is almost safe, $N$ is
also safe. The number of occurrences of the Y combinator in $N$ is
smaller than $i$ therefore by the induction hypothesis $N_k$ is
safe. Consequently the term $Y_A^k N_k = \underbrace{N_k ( \ldots (
N_k}_{k \mbox{ times}} \Omega ) \ldots )$ is also safe and by
compositionality so is $M_k$.

The result holds for $\pcf_1$ terms, thus since $M_k$ is a safe $\pcf_1$ term, $\tau(M_k)$ is
incrementally-bound. Now let $z$ be a variable node in $\tau(M) =
\Union_{k\in\omega} \tau(M_k)$. There exists $k\in \omega$ such that
$z$ belongs to $\tau(M_k) \sqsubseteq \tau(M)$. If we write $r_k$ to
denote the root of the tree $\tau(M_k)$ then the path $[r_k,z]$ in
$\tau(M_k)$ is equal to the path $[r,z]$ in $\tau(M)$. Hence, since $z$ is incrementally-bound in $\tau(M_k)$, it is also
incrementally-bound in $\tau(M)$.

(ii)
Suppose that the term is not almost safe then necessarily one of its approximant is not almost safe either.
Since the result holds for any $\pcf_1$ term, the computation tree of the approximant is not incrementally-bound.  But the computation tree of $M$ contains the computation tree of its approximant, therefore it is not incrementally-bound.
\qed
\smallskip


Hence we obtain the following characterization of almost safety by P-incrementally justified strategies:
\begin{theorem}[Characterization Theorem for Safe \pcf]
\label{thm:almostsafeincrejust_pcf} Let $\Gamma \entail M : A$ be a PCF term. Then:
\begin{enumerate}[(i)]
\item If $M$ is almost safe then $\sem{\Gamma \entail M : A}$ is P-incrementally justified.
\item If $\sem{\Gamma \entail M : A}$ is
  P-incrementally justified then $\etalnf{\betanf{M}}^*$ is
  almost safe  if $M$ is open, and safe if $M$ is closed.
\end{enumerate}
\end{theorem}
\proof
\noindent(i)
Let $M$ be an almost safe term and $M^{\infty}$ be the $\beta$-normal form of $M$. Since almost-safety is preserved by the small-step reduction of PCF, $M^\infty$ is also almost-safe
and by Proposition \ref{prop:incrbound_iff_etanf_safe_pcf}, $\tau(M^{\infty})$ is incrementally-bound.
By Corollary \ref{cor:Nher_incrbound_iff_incrjustified_pcf}(i),
$\sem{M^{\infty}}$ is P-incrementally justified and by soundness of the game denotation, $\sem{M^{\infty}} = \sem{M}$, thus $\sem{M}$ is P-incrementally justified.

\noindent(ii)
\notetoself{review that proof to account for almost safe terms}
Suppose $M$ is a \pcf\ term with a P-incrementally
justified strategy denotation. By Corollary
\ref{cor:Nher_incrbound_iff_incrjustified_pcf}(ii),
$\tau(\betanf{M})^* = \tau(\etalnf{\betanf{M}}^*)$ is
incrementally-bound. If $M$ is closed then so is
$\etalnf{\betanf{M}}^*$ therefore by Proposition
\ref{prop:incrbound_iff_etanf_safe_pcf},
$\etalnf{\etalnf{\betanf{M}}^*} = \etalnf{\betanf{M}}^*$ is safe. If
$M$ is open then so is $\etalnf{\betanf{M}}^*$ and by Proposition
\ref{prop:incrbound_iff_etanf_safe_pcf},
$\etalnf{\etalnf{\betanf{M}}^*} = \etalnf{\betanf{M}}^*$ is
almost safe.
\qed
%end of proof
\smallskip

Consequently, P-pointers are superfluous in the game denotation of safe \pcf\ terms \ie pointers emanating from P-moves are uniquely recoverable.

We write \pcf' to denote the language obtained by extending \pcf\
with the $\pcfcase_k$ construct (see \cite{Abr02}).
The $\pcfcase_k$ construct is the obvious generalisation of the
conditional operator \pcfcond\ to $k$ branches instead of $2$. Clearly, all the results obtained so far concerning Safe \pcf\ also hold for \pcf'.

\subsection{Definability}

The previous theorem leads to the following definability result for safe \pcf':
\begin{proposition}[Definability for safe \pcf' terms]
\label{prop:safetydefinability} Let $\overline{A}=(A_1,\ldots, A_i)$
and $B =(B_1, \ldots, B_l,o)$ be two PCF types for some $i,l\geq 0$
and $\sigma$ be a well-bracketed innocent P-i.j.\ strategy with
finite view function defined on the game $!A_1 \otimes \ldots
\otimes !A_i \lingamear (!B_1 \lingamear \ldots \lingamear !B_l
\lingamear o) $. There exists an \emph{almost safe} PCF' term
$\overline{x} : \overline{A} \asentail M : B$ in $\eta$-long normal
form such that:
$$ \sem{\overline{x} : \overline{A} \vdash M_\sigma : B} = \sigma $$
and a safe closed PCF' term $\sentail M'_\sigma : (\overline{A},B)$ in $\eta$-long normal form such that:
$$ \sem{\vdash M'_\sigma : (\overline{A},B)} \cong \sigma \ .$$
\end{proposition}
\begin{proof}
By the standard definability result for PCF', there is a \emph{finite} term
$\overline{x} : \overline{A} \vdash N : B$ such that
$\sem{\overline{x} :\overline{A} \vdash N : B} = \sigma$. Take
$M_\sigma$ to be $\etalnf{\betanf{N}}^*$.  We have
$\sem{\overline{x} : \overline{A} \vdash M_\sigma : B} =
\sem{\overline{x} :\overline{A} \vdash N : B} = \sigma$ and by
Theorem  \ref{thm:almostsafeincrejust_pcf}(ii), $M_\sigma$ is
almost safe. For the second part we just need to take $M'_\sigma$ to be the closure $\lambda \overline{x}. M_\sigma$ of $M_\sigma$.
\end{proof}

This result shows that the game model of Safe \pcf\ is \defname{intentionally fully-abstract} (every compact strategy is definable \cite{abramsky94full}). Note however that the proof of this result is not constructive: we know that the term $M_\sigma$ exists but we do not have an algorithm to compute it.
This is because we rely on dead code-elimination which is undecidable.


\subsection{Compositionality of P-i.j.\ strategies}

In the next chapter we will give an in depth account of P-i.j.\ strategies. In particular we will give a semantic argument showing that when suitably restricted, P-i.j.\ strategies compose. We show here essentially the safe result using a syntactic argument that relies on the definability result from the previous section. The advantage is that the proof is much simpler that the one given in the next chapter. The disadvantage is that it is slightly less general as it only works for strategies that are denotations of compact \pcf\ terms (\ie the compact innocent ones) whereas the proof in the next chapter works in the general case.
 
Let $\overline{A} = (A_1, \ldots, A_i)$, $B = (B_1, \ldots,
B_l,o)$ and $C=(C_1,\ldots,C_k,o)$ be three PCF types for some
$i\geq 1,l,k\geq 0$. 

\emph{Problem:} Given two compact (with finite view function) innocent well-bracketed and P-incrementally justified strategies $f:\ A_1 \times \ldots \times A_i \gamear B$ and $g:\ B\gamear C$. What is a sufficient condition for the composite $f;g$ to be P-incrementally justified?

We tackle the problem syntactically by appealing to the definability result: since $f$ and $g$ are compact innocent, there are two closed safe terms $M_f :(\overline{A},B)$ and $M_g :B \typear C$ in $\eta$-long nf denoted by $f$ and $g$ respectively.
Composition can be syntactically formulated using the term
 $$ M_{f\fatcompos g} \equiv \lambda \overline{x} . M_g (M_f \overline{x})$$ for some fresh variables $\overline{x} : \overline{A}$,
 whose denotation is clearly given by $\sem{M_f} ; \sem{M_g} = f; g$.
 
Observe that the safety of $M_f$ and $M_g$ does not imply that of $M_{f\fatcompos g}$ as the following examples illustrates:

\begin{example}
\begin{enumerate}[(i)]
\item Take $A=o$, $B=(o,o)$, $C=(((o,o),o),o)$, the variables $x,u,v:o$,
$y:B$ and $\varphi:((o,o),o)$ and the $\Sigma$-constant $a:o$.
Take the two closed safe terms $M_f \equiv \lambda xv.x : A\typear
B$ and  $M_g \equiv \lambda y \varphi. \varphi (\lambda u . y a)
: B\typear C$. The eta-long beta-nf of $M_{f\fatcompos g}$ is $
\lambda x \varphi. \varphi (\underline{\lambda u . x})$ which is
unsafe because of the underlined term.

Consequently by Theorem \ref{thm:safeincrejust_lmd}(ii), the strategy $\sem{M_{f\fatcompos g}}=\sem{M_f}
; \sem{M_g}$ is not P-i.j. This shows that P-i.j.\ strategies do not generally compose. The following diagram illustrates a play that is not P-i.j.:
\begin{center}
\begin{tikzpicture}[style={anchor=base}]
\matrix (m) [matrix of math nodes]
{
    \ &   & \ & \ & \ & \ &  & &\  &  & & & \\
    o & \stackrel{\sigcol{\sem{M_f}}}\longrightarrow & (o, & o) & \stackrel{\mucol{\sem{M_g}}}\longrightarrow & (((o, &o),& o),& o) \\ \\
    &&&&&&&&\node(n0){\lambda x \varphi \omove  \mucol {\lambda y \varphi}};\\[3mm]
    &&&&&&&\node(n1){\varphi  \pmove \mucol \varphi};\\[3mm]
    &&&&&&\node(n2){\lambda u \omove  \mucol {\lambda u}}; \\[3mm]
    &&&  \node(n3){ \sigcol {\lambda x v} \opmove \mucol y}; \\[3mm]
    \node(n4){x \pmove \sigcol x}; \\
};
\draw [-,thick] (m-1-1.south west) -- (m-1-1.south east) node [above,midway] {A};
\draw [-,thick] (m-1-3.south west) -- (m-1-4.south east) node [above,midway] {B};
\draw [-,thick] (m-1-6.south west) -- (m-1-9.south east) node [above,midway] {C};
\path (n4) edge[tableptr] (n0);
\path (n2) edge[tableptr,\mucolor] (n1);
\path (n1) edge[tableptr,\mucolor] (n0);
\path (n3) edge[tableptr,\mucolor] (n0);
\path (n4) edge[tableptr,\sigcolor] (n3);
\end{tikzpicture}
\end{center}

\item Another counter-example with $\ord{B} = \ord{C}$:
 Let $A=o$, $B=C=(((o,o),o),o)$ and let $x:A$, $y:B$, $u:o$, $v,\varphi:((o,o),o)$
and $g:(o,o)$ be variables and  $a:o$ be a $\Sigma$-constant. Take the two closed safe terms $M_f \equiv \lambda x v.x$ and $M_g \equiv \lambda y \varphi. \varphi (\lambda u . y (\lambda g. a))$.
The $\eta\beta$-nf of $M_{f\fatcompos g}$ is $\lambda x \varphi. \varphi (\underline{\lambda u . x})$ which is unsafe because of the underlined term, so
$f; g$ is not P-i.j.
\end{enumerate}
\end{example}


The term $M_f$ and $M_g$, being in $\eta$-nf, are of the following forms:
\begin{eqnarray}
\sentail M_f &\equiv& \lambda x_1^{A_1} \ldots x_i^{A_i} \varphi_1^{B_1} \ldots \varphi_l^{B_l} . N_f^o \label{eq_Mf}\\
\sentail M_g &\equiv& \lambda y^{ (B_1, \ldots, B_l,o)} \phi_1^{C_1} \ldots \phi_k^{C_k} . N_g^o \label{eq_Mg}
\end{eqnarray}
for some distinct variables $x_1, \ldots, x_i$, $y$, $\varphi_1, \dots \varphi_l$, $\phi_1, \dots \phi_k$ and $\eta$-normal terms $N_f$ and $N_g$:
\begin{eqnarray*}
x_1:A, \ldots, x_i:A_i, \varphi_1:B_1, \dots, \varphi_l:B_l &\sentail& N_f :o \\
y: (B_1, \ldots, B_l,o), \phi_1:C_1, \dots, \phi_l:C_l &\sentail& N_g :o
\end{eqnarray*}

Substituting Eq.\ \ref{eq_Mf} and \ref{eq_Mg} in $M_{f;g}$ gives:
\begin{align}
f; g &= \sem{\lambda \overline{x} . (\lambda \phi_1\ldots \phi_k . N_g) [(M_f \overline{x}) / y]} \nonumber \\
&= \sem{\lambda \overline{x} \phi_1 \dots \phi_k. N_g [(M_f  \overline{x}) / y]}
& \mbox{(the $x_j$'s and $\phi_j$'s are disjoint).} \label{eq_fcompg}
\end{align}

Thus by Theorem \ref{thm:almostsafeincrejust_pcf}, 
$f;g$ is P-incrementally justified just when
$\etalnf{\betanf{N_g [(M_f  \overline{x}) / y]}}^*$ is safe.


\paragraph{A sufficient and necessary condition}
\begin{lemma}
Let $\Gamma,y:B \sentail M$ be a safe term in $\eta$-nf and $\Gamma \vdash R : B$ be an almost safe application. Let $N$ denote the set of nodes of the computation tree of $M$ and $\theroot$ be the root. Then:
\begin{align*}
\Gamma \sentail M[R/y] :A 
\iff&  \forall x \in fv(R) .  \forall y \in N_{\sf fv} .
      \forall m \in N_{\lambda} \inter ]\theroot,y] : \ord{m} \leq \ord{x}
\end{align*}
\end{lemma}
\proof
The only cause of unsafety that can be introduced when substituting the almost safe term $R$ for $y$ in $M$ is when some variable free in $R$ becomes not incrementally bound in $\tau(M)$. The right-hand side of the equivalence expresses just this.
\qed
% end of proof
\smallskip

Applying this lemma with $R \equiv M_f \overline{x}$ and $M \equiv M_g$ gives us a necessary and sufficient condition for $M_g [(M_f \overline{x}) / y]$ to be safe, and hence for $f;g$ to be P-i.j. The problem is that this condition is expressed on both $M_g$ and $M_f$ at the same time rather than independently. This is unsatisfactory because it does not give rise to a categorical notion of compositionality: two morphisms should be composable as soon as the domain of one matches with the codomain of the other.

\paragraph{A sufficient condition}
The solution consists in restricting the P-i.j.\ strategies to a smaller class of composable strategies. 

\begin{lemma}
If the following condition holds:
$$
  \ord{A_i}\geq\ord{B} \mbox{ for all } 1 \leq i \leq n
$$
then $f;g$ is P-incrementally justified.
\end{lemma}
\proof
For all $1 \leq i \leq n$ we have
$\ord{x_i} = \ord{A_i} \geq \ord{B} = \ord{(M_f \overline x)}$
thus we can use the application rule of the safe lambda calculus to form the safe term $\overline{x}:\overline{A} \sentail M_f \overline{x}$.
The substitution lemma then shows that $M_g[(M_f \overline{x})/y]$ is safe which by Eq.\ \ref{eq_fcompg} implies that $f;g$ is
P-i.j.
\qed
\smallskip

Note that this condition is not necessary: Take $A=o$, $B=(o,o)$,
$C=(o,o)$ and consider the two safe terms $M_f \equiv \lambda x^A u^o.u$
and $M_g \equiv \lambda y^B . y a$ for  some constant $a:o$. Then we have $M_{f\fatcompos g} =_\beta \lambda x . a$ which is safe hence $f;g$ is P-i.j.\ although $\ord{A} < \ord{B}$.

\begin{remark}
The strategy from this restricted class are called \emphind{closed P-incremental strategies}. They will be studied in depth in Sec.\ \ref{sec:closedpij}.
\end{remark}






\subsection{Towards a fully abstract game model}

The standard game models which have been shown to be fully abstract
for PCF \cite{abramsky94full,hylandong_pcf} are of course also fully
abstract for the restricted language safe PCF. One may ask, however,
whether there exists a fully abstract model with respect to safe
context only. Such model may be obtain by considering
P-incrementally justified strategies. Its is reasonable to think
that O-moves also needs to be constrained by a symmetrical
notion of ``O-incremental justification'' corresponding to the requirement
that contexts are safe. This question will be addressed in Chapter
\ref{chap:model}.




\section{Safe Idealized Algol}

We now consider Safe \ialgol\ as defined in Sec.\  \ref{subsec:safeia_rules}. We observe that the only particularity of \pcf\ that was used in the argument of the previous section is the fact that the constants of the language are of order $1$ at most. This is not the case anymore in \ialgol\ because of the presence of the bad-variable construct \iamkvar. But if we consider safe \ialgol-$\{\iamkvar\}$, the fragment of safe Idealized Algol obtained by removing the bad-variable construct, then all the argument can be carried on. In particular the Characterization Theorem \ref{thm:almostsafeincrejust_pcf} holds as well as the definability result (Proposition \ref{prop:safetydefinability}).


In safe \ialgol, the presence of the \iamkvar\ construct makes things slightly more complicated. Since $\iamkvar$ is an order-2 constant, the proof of the second part of Corollary \ref{cor:Nher_incrbound_iff_incrjustified_pcf}(ii) cannot be used, and indeed it does not hold. Here is a counter-example: Take the term beta-normal term
$$\iamkvar\ (\lambda x. f(\lambda y . \underline{x}))\ 0 \ .$$
There is clearly no dead-code in this term. Moreover the variable $x$ is not incrementally-bound. Nevertheless it is easy to see that its denotation is P-i.j.

The same example shows that the second part of the Characterization Theorem does not hold in safe \ialgol, so we only have:
\begin{theorem}
\label{thm:almostsafeincrejust_ia} If $\Gamma \entail M : A$ is an almost safe \ialgol\ term then $\sem{\Gamma \entail M : A}$ is P-incrementally justified.
\end{theorem}

This shows that P-pointers are superfluous for safe \ialgol\ terms. Since unsafety only appears at order $3$, this theorem implies the well-known result that pointers are uniquely recoverable for $\ialgol_2$ terms. This suggests potential applications in Algorithmic Game Semantics: In \cite{ghicamccusker00}, Ghica and McCusker were able to show that the game denotation of $\ialgol_2$ terms can be characterized by (extended) regular expressions which subsequently lead them to derive a decision procedure for observational equivalence in the considered fragment. Can a similar thing been achieved for higher-order fragment of safe \ialgol? We will investigate this question in the next chapter.
\smallskip

It is not known whether the the definability result holds for safe \ialgol.

  
\torework[Overview of the argument]{
Clearly, the computation hypertree of a safe term is incrementally-bound. By using the correspondence between traversals and plays, it is easy
to prove that incrementally-bound computation trees are denoted by
P-incrementally justified strategies. Consequently, by lemma
\ref{lem:incrjustified_pointers_uniqu_recover}, P's pointers are superfluous in the game semantics of safe \ialgol\ terms.
}
