\section*{Introduction}

\subsection*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and
Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars. The
idea, however, goes back some twenty years to Damm \cite{Dam82} who
introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterizations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe} grammars
  form an infinite hierarchy as $n$ varies over the natural numbers.
  The hierarchy gives an attractive classification of the
  semi-decidable languages: Levels 0, 1 and 2 of the hierarchy are
  respectively the regular, context-free, and indexed languages (in
  the sense of Aho \cite{Aho68}), although little is known about
  higher orders.

  Remarkably, for generating word languages, order-$n$ \emph{safe}
  grammars are equivalent to order-$n$ pushdown automata \cite{DG86},
  which are in turn equivalent to order-$n$ indexed grammars
  \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have decidable
    MSO theories. More precisely, the MSO theory of trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.}.

  They have also generalized the equi-expressivity result due to Damm
  and Goerdt \cite{DG86} to an equivalence result with respect to
  generating trees: A ranked tree is generated by an order-$n$ \emph{safe}
  grammar if and only if it is generated by an order-$n$ pushdown
  automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. In a recent preprint \cite{hague-sto07}, however,
  Hague \emph{et al.} have
  shown that the MSO theories of graphs generated by order-$n$
  \emph{unsafe} grammars are undecidable, but deciding their modal
  mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}

\subsection*{Overview}

In this paper, we aim to understand the safety condition in the
setting of the lambda calculus. Our first task is to transpose it to
the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and cleaner
version where terms are no longer required to be homogeneously typed
(see Section~\ref{sec:safe} for a definition). The formation rules of
the calculus are designed to maintain a simple invariant: Variables
that occur free in a safe $\lambda$-term have orders no smaller than
that of the term itself.  We can now explain the sense in which the
safe lambda calculus is safe by establishing its salient property: No
variable capture can ever occur when substituting a safe term into
another. In other words, in the safe lambda calculus, it is
\emph{safe} to use capture-\emph{permitting} substitution when
performing $\beta$-reduction.


There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable names
in the input term. Safe lambda calculus is thus cheaper to compute in
this na\"ive sense. Intuitively one would expect the safety constraint
to lower the expressivity of the simply-typed lambda calculus. Our
next contribution is to give a precise measure of the expressivity
deficit of the safe lambda calculus. An old result of Schwichtenberg
\cite{citeulike:622637} says that the numeric functions representable
in the simply-typed lambda calculus are exactly the multivariate
polynomials \emph{extended with the conditional function}.  In the
same vein, we show that the numeric functions representable in the
safe lambda calculus are exactly the multivariate polynomials.

Our last contribution is to give a game-semantic account of the safe
lambda calculus.
% Not much is known about the safe $\lambda$-calculus, and many problems
% remain to be studied concerning its computational power, the
% complexity classes that it characterizes, its interpretation under the
% Curry-Howard isomorphism and its game-semantic characterization. This
% paper is a contribution to the last problem.
%
% The difficulty in giving a game-semantic account of safety lies in the
% fact that it is a syntactic restriction whereas game semantics is
% syntax-independent. The solution consists in finding a particular
% syntactic representation of terms on which the plays of the game
% denotation can be represented.  To achieve this, we use ideas recently
% introduced by the second author \cite{OngLics2006}: a term is
% canonically represented by a certain abstract syntax tree of its
% $\eta$-long normal form referred as the \emph{computation tree}. This
% abstract syntax tree is specially designed to establish a
% correspondence with the game arena of the term. A computation is
% described by a justified sequence of nodes of the computation tree
% respecting some formation rules and called a
% \emph{traversal}. Traversals permit us to model $\beta$-reductions
% without altering the structure of the computation tree via
% substitution. A notable property is that \emph{P-views} (in the
% game-semantic sense) of traversals corresponds to paths in the
% computation tree.  We show that traversals are just representations of
% the uncovering of plays of the game-semantic denotation. We then
% define a \emph{reduction} operation which eliminates traversal nodes
% that are ``internal'' to the computation, this implements the
% counterpart of the hiding operation of game semantics. Thus, we obtain
% an isomorphism between the strategy denotation of a term and the set
% of reductions of traversals of its computation tree.
Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are denoted
by \emph{P-incrementally justified strategies}. In such a strategy,
pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically, a P-question always
points to the last pending O-question (in the P-view) of a greater
order. Consequently pointers in the game semantics of safe
$\lambda$-terms are only necessary from order 4 onwards. Finally we
prove that a $\beta$-normal $\lambda$-term is \emph{safe}
if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.



% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, one of us obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the forthcoming paper \cite{hague-sto07}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

% \medskip

% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph
% based on Lamping's graphs \cite{lamping} is introduced to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The safe lambda calculus}
\label{sec:safe}
\subsection*{Higher-order safe grammars}
We first present the safety restriction as it was originally defined
\cite{KNU02}. We consider simple types generated by the grammar $A \,
::= \, o \; | \; A \typear A$. By convention, $\rightarrow$ associates
to the right. Thus every type can be written as $A_1 \typear \cdots
\typear A_n \typear o$, which we shall abbreviate to $(A_1, \cdots,
A_n, o)$ (in case $n = 0$, we identify $(o)$ with $o$). The
\emph{order} of a type is given by $\ord{o} = 0$ and $\ord{A \typear
  B} = \max(\ord{A}+1, \ord{B})$. We assume an infinite set of typed
variables. The order of a typed term or symbol is defined to be the
order of its type.

A (higher-order) \defname{grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ has an
arity $\mathit{ar}(f) \geq 0$) of \emph{terminals}\footnote{Each $f \in
  \Sigma$ of arity $r \geq 0$ is assumed to have type $(\underbrace{o,
    \cdots, o}_r, o)$.}; $\mathcal{N}$ is a finite set of typed
\emph{non-terminals}; $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol; $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form $ F z_1 \ldots z_m
\rightarrow e$ where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the typed symbols in $\Sigma \union \mathcal{N} \union \{z_1,
\ldots, z_m \}$. We say that the grammar is \emph{order-$n$} just in
case the order of the highest-order non-terminal is $n$.

The \defname{tree generated by a recursion scheme} $G$ is a possibly
infinite applicative term, but viewed as a $\Sigma$-labelled tree;
it is \emph{constructed from the terminals in $\Sigma$}, and is obtained by
unfolding the rewrite rules of $G$ \emph{ad infinitum}, replacing
formal by actual parameters each time, starting from the start symbol
$S$. See e.g.~\cite{KNU02} for a formal definition.

\parpic[r]{
\raisebox{-15pt}
{\begin{tikzpicture}[baseline=(root.base),level distance=3ex,inner ysep=0.5mm,sibling distance=13mm]
\node (root) {$g$}
child {node {$a$}}
child {node {$g$} 
    child {node {$a$}}
    child {node {$h$}
           child {node {$h$}
                  child {node {$\ldots$}}
            }
    }
};
\end{tikzpicture}
}
}
\begin{example}\rm\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}

A type $(A_1, \cdots, A_n, o)$ is said to be \defname{homogeneous} if
$\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$, and each $A_1$,
\ldots, $A_n$ is homogeneous \cite{KNU02}.  We reproduce the following
definition from \cite{KNU02}.

\begin{definition}[Safe grammar]\rm
  (All types are assumed to be homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
%   A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be
%   \defname{unsafe} if the righthand term $e$ has a subterm $t$ such
%   that
% \begin{enumerate}[(i)]
% \item $t$ occurs in an {\em operand} ({\it i.e.}~second) position of some
%   occurrence of the implicit application operator {\it i.e.}~$e$ has the
%   form $\cdots (s \, t) \cdots $ for some $s$
% \item $t$ contains an occurrence of a parameter $z_i$ (say) whose
%   order is less than that of $t$.
% \end{enumerate}
% A homogeneous grammar is said to be \defname{safe} if none of its
% rewrite rules is unsafe.
\end{definition}

\begin{example}\begin{inparaenum}[(i)] \item Take $H : ((o, o), o)$ and $f : (o, o, o)$; the
    following rewrite rules are unsafe (in each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x
\end{array}\]
\item The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{inparaenum}
% The
% reader is referred to the literature
% \cite{KNU02,demirandathesis,safety-mirlong2004}
% for details about the safety restriction for higher-order grammars.
\end{example}

\subsection*{Safety adapted to the lambda calculus}
We assume a set $\Xi$ of higher-order constants. We use sequents of
the form $\Gamma \vdash_\$^\Xi M : A$ to represent term-in-context
where $\Gamma$ is the context and $A$ is the type of $M$. For
convenience, we shall omit the superscript from $\sentail^\Xi$
whenever the set of constants $\Xi$ is clear from the context. The
subscript in $\vdash_\$^\Xi$ specifies which type system we are
using to form the judgment: we use the subscript `st' to refer to
the traditional system of rules of the Church-style simply-typed
lambda calculus augmented with constants from $\Xi$. In the
following we will use new subscripts for each type system that we
introduce. For simplicity we write $(A_1, \cdots, A_n, B)$ to mean
$A_1 \typear \cdots \typear A_n \typear B$, where $B$ is not
necessarily ground.

\begin{definition}\rm
\label{def:safelambda}
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus. It is defined as the set of judgments of the form $\Gamma \sentail M : A$ that are derivable from the following Church-style system of rules:
$$ \rulename{var} \ \rulef{}{x : A\sentail x : A} \qquad
%\rulename{const} \ \rulef{}{\sentail f : A}~f \in \Xi \qquad
\rulename{wk} \ \rulef{\Gamma \sentail s : A}{\Delta \sentail s : A} \quad
\Gamma \subset \Delta$$

$$ \rulename{app_{as}} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \asappentail s~t_1 \ldots t_n : B} $$

$$ \rulename{app} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \sentail s~t_1 \ldots t_n : B} \quad \ord{B} \leq
\ord{\Gamma}$$

$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail s : B} {\Gamma \sentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{A_1, \ldots ,A_n,B} \leq
\ord{\Gamma}$$
\smallskip

\noindent where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in
\Gamma \}$ and ``$c \leq S$'' means that $c$ is a lower-bound of the
set $S$. Terms typed with the entailment ``$\sentail$'' are the safe terms and those typed with $\asentail$ are the ``almost safe'' terms.

\noindent \item The sub-system that is defined by the same rules in
(i), such that all types that occur in them are homogeneous, is called
the \defname{homogeneous safe lambda calculus}.
\end{inparaenum}
\end{definition}
An equivalent notion of homogeneous safe lambda calculus is given in
de Miranda's thesis \cite{demirandathesis}.


The safe lambda calculus deviates from the standard definition of
the simply-typed lambda calculus in a number of ways. %First the
%rules $\rulename{app}$ and $\rulename{abs}$ respectively can perform
%multiple applications and abstract several variables at once.
First the rule $\rulename{abs}$ can abstract several variables at once. (Of course this feature alone does not alter expressivity.) Crucially,
the side conditions in the application rule and abstraction rule
require the variables in the typing context to have orders no
smaller than that of the term being formed.  We do not impose any
constraint on types. In particular, type-homogeneity, which was an
assumption of the original definition of safe grammars \cite{KNU02},
is not required here. Another difference is that we allow
$\Xi$-constants to have
arbitrary higher-order types.  % Thus our formulation
% of the safe lambda calculus is more general than the one proposed in
% the technical report \cite{safety-mirlong2004}. (It is possible to
% reconcile the two definitions by adding the further constraint that
% each type occurring in our rules is homogeneous and by restricting
% constants to at most order 1.)


\subsection{Almost safety}
We now give an alternative presentation of the safe lambda calculus.
Consider the following system of rules:
$$ \rulename{var_{as}} \ \rulef{}{x : A\asappentail x : A}
%\rulename{const_{as}} \ \rulef{}{\asappentail f : A}~f \in \Xi \qquad
\qquad
\rulename{app_{as}} \ \rulef{\Gamma \asappentail s : A\typear B
\quad \Gamma \sentail t : A} {\Gamma \asappentail s~t : B}
\qquad
\rulename{abs_{as}}\  \rulef{\dps  \Gamma, x : A \asentail s : B} {\Gamma \asentail \lambda x  . s : A\typear B}
$$

$$
\rulename{wk_{as}} \ \rulef{\Gamma \asappentail s : A}{\Delta \asappentail s : A} \quad
\Gamma \subset \Delta
\qquad
\rulename{wk} \ \rulef{\Gamma \sentail s : A}{\Delta \sentail s : A} \quad
\Gamma \subset \Delta
$$

$$
\rulename{\delta} \ \rulef{\Gamma \sentail s : A}{\Gamma \asentail s : A}
\qquad
\rulename{\delta'} \ \rulef{\Gamma \asappentail s : A}{\Gamma \asentail s : A}
\qquad
\rulename{\rho}\
\rulef{\Gamma \asentail s : A}{\Gamma \sentail s : A}\
\ord{A} \leq \ord{\Gamma} \ .
$$


It is easy to see that this system of rules is equivalent to the one from
Def.\ \ref{def:safelambda} in the sense that both systems generate the same set of judgments of the form $\Gamma \sentail M : T$. The above system of rules, however, has the advantage of decomposing the application and abstraction rules into atomic steps where only one variable is abstracted at a time and only two terms are applied together at a time.

\begin{definition}
Terms typed with the entailment operator $\asentail$  are called \defname{almost safe} terms. Terms typed with the entailment operator $\asappentail$ are distinguished almost safe terms called \defname{almost safe applications}.
\end{definition}


The intuition behind these rules is as follows: almost safe terms represent terms that are not safe but which can become safe if sufficiently many safe terms are applied to them or if sufficiently many variables are abstracted. The rule \rulenamet{app_{as}} is used to form applications in which each applied term is safe:
\begin{lemma}
\label{lem:almostsafe_is_appplicative_safe}
If $\Gamma \asappentail M : T$ then $M$ is of the form $N_0
\ldots N_k : T$ for some $k\geq 0$ where $N_0$ is not an application and
for every $0 \leq i\leq m$, $N_i$ is safe.
\end{lemma}
This results follows immediately from the definition of the rules.
The rule \rulenamet{abs_{as}} is the standard abstraction rule of the lambda calculus. As soon as the context and the type of the term being formed respect the safety condition (\ie all the context variables have order greater that the order of the type), the term can be marked as safe. This is done using the rule \rulenamet{\rho}. Together with the rule \rulenamet{\delta'} this implies that the closure of an almost safe term is always safe:
\begin{lemma}
  \label{lem:closealmostsafe_is_safe}
  If $fv(M) \asappentail M : T$ then $\sentail \closure{M} : T$.
\end{lemma}


The two weakening rules \rulenamet{wk} and \rulenamet{wk_{as}} permit one to extend the context of a safe term or an almost safe application.
We could have added a third rule to allow weakening for almost safe terms $\Gamma \asentail M : T$ as well. This is however not necessary because this kind of weakening can always be eliminated. (In particular if the term is an abstraction then we can instead apply the rule \rulenamet{wk_{as}} just before the abstraction rule).

A term is almost safe if and only if its eta-long normal form is safe:
\begin{lemma}
\label{lem:almostsafe_iff_etalnf_almostsafe}
  $\Gamma \asentail M : T$ if and only if $\Gamma \asentail \etalnf{M} : T$.
\end{lemma}
\begin{proof}
\emph{Only if:} Let $\Gamma \asentail M :T$ be an almost safe term.
We proceed by induction on $M$.
Suppose that the last rule used is \rulenamet{\delta'}.
Then by Lemma \ref{lem:almostsafe_is_appplicative_safe}
$M$ is an application $N_0 N_1 \ldots N_k : (A_1,\ldots,A_n)$ with $k\geq 0$. Let $\varphi_i:A_i$ for $i\in\{1..n\}$ be fresh variables, using the
rules \rulenamet{var_{as}}, \rulenamet{wk_{as}}, \rulenamet{app_{as}} and \rulenamet{abs_{as}} we can build the almost safe term $\Gamma \asentail \lambda \varphi_1 \ldots \varphi_n . N_0 N_1 \ldots N_k \varphi_1 \ldots \varphi_n :T$.

If the last rule used is \rulenamet{\delta} then
$M$ is safe therefore by Proposition \ref{prop:safe_iff_elnfsafe}, its eta-long normal form is safe and therefore by \rulenamet{\delta} it is also almost safe.

If the last rule used is \rulenamet{abs_{as}} then by the induction hypothesis the eta-long nf of the premise is almost safe so we can conclude using \rulenamet{abs_{as}}.

\emph{If:} It is again a proof by structural induction on the eta-long normal form. The basic idea is that the rule \rulenamet{abs_{as}} (resp.\ \rulenamet{app_{app}}) allows us to ``peal-off'' the lambda-abstraction (resp.\ extra operands) introduced during the eta-expansion.
\end{proof}
The two preceding lemmas show that the closure of the eta-long expansion of an almost safe term is safe. This explains the expression ``almost safe'': an almost safe is semantically safe in the sense that it is (extensionally) equivalent to a safe term; on the other hand it is syntactically unsafe since it cannot appear as an operand of an application inside a larger safe term.


\notetoself{
\begin{lemma}
\label{lem:betasred_preserves_almostsafety}
Safe beta reduction preserves almost safety.
\end{lemma}
}


\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y
))$ and $M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where
$x,y:o$ and $f:((o,o),o)$. The term $M_2$ is not safe because in the
subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{\lambda y . x} = 1$.  On the other hand, $M_1$
is safe.
%On the other hand, $M_1$ is safe as the following proof tree shows:
%$$
% \rulef{
%     \rulef{
%        \rulef{}{f \sentail f} {\sf(var)}
%        \
%        \rulef{
%             \rulef{
%                \rulef{
%                    \rulef{}{f \sentail f} {\sf(var)}
%                }
%                {f , x \sentail f } {\sf(wk)}
%                \
%                \rulef{
%                    \rulef{
%                        \rulef{}{y \sentail y} {\sf(var)}
%                    }
%                    {y \sentail \lambda y . y } \rulenamet{abs}
%                }
%                {f , x \sentail \lambda y .y } {\sf(wk)}
%             }
%             {f , x \sentail f (\lambda y .y )} {\sf(app)}
%        }
%        { f  \sentail \lambda x . f (\lambda y .y )} \rulenamet{abs}
%     }
%     {
%        f  \sentail f (\lambda x . f (\lambda y .y ))} {\sf(app)}
%     }
% { \sentail M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } \rulenamet{abs}
%$$
\end{example}

It is easy to see that valid typing judgements of the safe lambda
calculus satisfy the following simple invariant:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \sentail M : A$ then every variable in $\Gamma$ occurring
free in $M$ has order at least $ord(M)$.
\end{lemma}



When restricted to the homogeneously-typed sub-system, the safe
lambda calculus captures the original notion of safety due to Knapik
\emph{et al.}~in the context of higher-order grammars:

\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe (in the original sense of Knapik \emph{et al.}) if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \sentail^{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} safe lambda calculus.
\end{proposition}
See \cite{demirandathesis} for a proof.

\emph{In what sense is the safe lambda calculus safe?} It is an
elementary fact that when performing $\beta$-reduction in the lambda
calculus, one must use capture-\emph{avoiding} substitution, which
is standardly implemented by renaming bound variables afresh upon
each substitution. In the safe lambda calculus, however, variable
capture can never happen (as the following lemma shows).
Substitution can therefore be implemented simply by
capture-\emph{permitting} replacement, without any need for variable
renaming. In the following, we write $M\captsubst{N}{x}$ to denote
the capture-\emph{permitting} substitution\footnote{This
substitution is done by textually replacing all free occurrences of
$x$ in $M$ by $N$ without performing variable renaming.  In
particular for the abstraction
  case we have
$(\lambda y_1\ldots y_n . M)\captsubst{N}{x} = \lambda y_1\ldots y_n . M\captsubst{N}{x}$ when $x\not\in
  \{ y_1\ldots y_n \}$.}
%\footnote{This substitution is implemented by textually
%  replacing all free occurrences of $x$ in $M$ by $N$ without
%  performing variable renaming.  In particular for the abstraction
%  case $(\lambda \overline{y} . P)\captsubst{N}{x}$ is defined as
%  $\lambda \overline{y} . P\captsubst{N}{x}$ if $x\not\in
%  \overline{y}$ and $\lambda \overline{y} . P$ elsewhere.}
of $N$ for $x$ in $M$.

\begin{lemma}[No variable capture]\label{lem:nvc}
\label{lem:nocapture} There is no variable capture when performing
capture-permitting substitution of $N$ for $x$ in $M$ provided that
$\Gamma, x:B \sentail M : A$ and $\Gamma \sentail  N : B$ are valid
judgments of the safe lambda calculus.
\end{lemma}

\proof
  We proceed by structural induction on $M$. The variable, constant, weakening and
  application cases are trivial. For the abstraction case, suppose $M = \lambda \overline{y}. R$ where $\overline{y} = y_1 \ldots y_p$. If $x \in \overline{y}$ then $M \captsubst{N}{x} = M$ and there is no variable capture.

 Otherwise, $x \not\in \overline{y}$. By Lemma \ref{lem:almostsafe_is_appplicative_safe} $R$ is of the
  form $M_1 \ldots M_m$ for some $m\geq 1$ where $M_1$ is not an application and for every $1 \leq i\leq m$, $M_i$ is safe.
 Thus we have $M \captsubst{N}{x} = \lambda \overline{y} . M_1 \captsubst{N}{x} \ldots M_m \captsubst{N}{x}$.  Let $i\in\{1..m\}$. By the induction hypothesis there is no variable capture in $M_i \captsubst{N}{x}$.  Thus variable capture can only happen if the following two conditions are met: $x$ occurs freely in $M_i$, and some variable $y_i$ for $1 \leq i \leq p$ occurs freely in $N$. By Lemma \ref{lem:ordfreevar}, the latter condition implies $\ord{y_i} \geq \ord{N} = \ord{x}$ and  since $x \not \in \overline{y}$, the former condition implies that $x$ occurs freely in the safe term $\lambda \overline{y}. R$
  thus by Lemma \ref{lem:ordfreevar} we have $ \ord{x} \geq
  \ord{\lambda \overline{y} . R} \geq 1+ \ord{y_i} > \ord{y_i}$ which  gives a contradiction.
\qed


\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \stentail (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    x}) : (o,o)\] one should rename the bound variable $x$ to a fresh name to
  prevent the capture of the free occurrence of $x$ in the underlined term during substitution. Consequently, by the previous lemma,
  the term is not safe (because $\ord{x} = 0 < 1
  = \ord{f x}$).
\end{example}

Note that $\lambda$-terms that `satisfy' the No-variable-capture
Lemma are not necessarily safe. For instance the $\beta$-redex in
$\lambda y^o z^o. (\lambda x^o .y) z$ can be contracted using
capture-permitting substitution, even though the term is not safe.

\subsection*{Safe beta reduction}

From now on we will use the standard notation $M\subst{N}{x}$ to
denote the substitution of $N$ for $x$ in $M$.  It is understood that,
provided that $M$ and $N$ are safe, this substitution is
capture-permitting.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x :B \sentail M : A$ and $\Gamma \sentail N : B$ then $\Gamma \sentail M[N/x] : A$.
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.
\smallskip

It is desirable to have an appropriate notion of reduction for our
calculus. However the standard $\beta$-reduction rule is not
adequate. Indeed, safety is not preserved by $\beta$-reduction as
the following example shows. Suppose that $w,x,y,z : o$ and $f :
(o,o,o) \in \Sigma$ then the safe term $(\lambda x y . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y . f z y}) w$, which is
unsafe since the underlined order-1 subterm contains a free
occurrence of the ground-type $z$. However if we perform one more
reduction we obtain the safe term $f z w$. This suggests
simultaneous contraction of ``consecutive'' $\beta$-redexes. In
order to define this notion of reduction we first introduce the
corresponding notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:

\begin{definition}\rm
Let $l\geq 1$ and $n\geq 1$. We use the abbreviations $\overline{x}$
and $\overline{x}:\overline{A}$  for $x_1 \ldots x_n$ and $x_1:A_1,
\ldots, x_n : A_n$ respectively. A \defname{safe redex} is a safe
term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such
that $M$ is safe and $N_i$ is safe for $1\leq i\leq n$.
\end{definition}
For instance, in the case $n<l$, a safe redex has a derivation tree of the following form:
\def\defaultHypSeparation{}
\begin{prooftree}
    \AxiomC{\ldots}
  \UnaryInfC{$\Gamma', \overline{x}:\overline{A} \sentail M : (A_{n+1}, \ldots, A_l, B)$}
  \RightLabel{\rulenamet{abs}}
  \UnaryInfC{$\Gamma' \sentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)$}
  \RightLabel{\rulenamet{wk}}
  \UnaryInfC{$\Gamma \sentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)$}
  \RightLabel{\rulenamet{\delta}}
  \UnaryInfC{$\Gamma \asentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)$}
  \AxiomC{\ldots}
  \UnaryInfC{$\Gamma \sentail N_1 :A_1$}
  \RightLabel{\rulenamet{app_{as}}}
   \BinaryInfC{$\Gamma \asentail (\lambda \overline{x} . M) N_1 : (A_2, \ldots A_l, B)$}
%  \AxiomC{\ldots}
%  \RightLabel{\rulenamet{app_{as}}}
%  \BinaryInfC{\vdots\raisebox{0.5cm}{}}
  \noLine\UnaryInfC{\vdots\raisebox{0.5cm}{}}
  \RightLabel{\rulenamet{app_{as}}}
  \UnaryInfC{$\Gamma \asentail (\lambda \overline{x} . M) N_1 \ldots N_{l-1} : (A_l, B)$}
  \AxiomC{\ldots}
  \UnaryInfC{$\Gamma \sentail N_l :A_l$}
  \RightLabel{\rulenamet{app}}
  \BinaryInfC{$\Gamma \sentail (\lambda \overline{x} . M) N_1 \ldots N_l : B$}
\end{prooftree}
\smallskip

We can now define a notion of reduction for safe terms.
\begin{definition}\rm
\label{dfn:safereduction} We use the abbreviations $\overline{x} =
x_1 \ldots x_n$, $\overline{N} = N_1 \ldots N_l$. The relation
$\beta_s$ (when viewed as a function) is defined on the set of safe
redexes as follows:
\begin{eqnarray*}
  \beta_s &=&
  \{  \ (\lambda \overline{x} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1 \ldots x_l} \mbox{, for $n> l$}
  \} \\
  &\cup&
  \{ \ (\lambda \overline{x}  . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}
where $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution in $M$ of $R_1$,\ldots,$R_k$ for $z_1, \ldots, z_k$.  The
\defname{safe $\beta$-reduction}, written $\betasred$, is the
compatible closure of the relation $\beta_s$ with respect to the
formation rules of the safe lambda calculus.
\end{definition}

\noindent \emph{Remark:} The safe $\beta$-reduction is a multi-step
$\beta$-reduction \ie it is a subset of the transitive closure of
$\betared$.


\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:safered_preserve_safety}
If $\Gamma \sentail s :A$ and $s \betasred t$ then $\Gamma \sentail t :A$.
\end{lemma}

\proof
  It suffices to show that the relation $\beta_s$ preserves safety.
Suppose that $s\ \beta_s\ t$ where $s$ is the
safe-redex $(\lambda x_1 \ldots x_n . M) N_1
  \ldots N_l $ with $x_1 : B_1, \ldots, x_n: B_n$
and $M$ of type $C$.  W.l.o.g we can assume that the last rule used
to form the term $s$ is \rulenamet{app} (and not the weakening rule
\rulenamet{wk}, thus  we have $\Gamma = fv(s)$, and since $s$ is
safe, Lemma \ref{lem:ordfreevar} gives us $\ord{A} \leq
\ord{\Gamma}$.

Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$. By Lemma
\ref{lem:subst_preserve_safety} we can form the safe term $\Gamma,
x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\sentail M\subst{\overline{N}}{x_1
\ldots x_l} : C$. And since we have $\ord{A} \leq \ord{\Gamma}$, we
can use the \rulenamet{abs} rule to form the safe term $\Gamma
\sentail \lambda x_{l+1} \ldots x_n . M\subst{\overline{N}}{x_1
\ldots x_l} \equiv t : A$.

Suppose $n \leq l$. The Substitution Lemma gives $\Gamma \sentail
M\subst{N_1 \ldots N_n}{\overline{x}} : C$. If $n<l$ then we further apply the rule \rulenamet{app_{as}} $l-n-1$ times followed by one application of
\rulenamet{app}. This gives us the sequent $\Gamma \sentail t :A$.
  \qed

\subsection*{Eta-long expansion}

The $\eta$-long normal form (or simply $\eta$-long form) of a term
% (also called \emph{long reduced form}, \emph{$\eta$-normal form} and
% \emph{extensional form} in the literature
% \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding the body of every
lambda abstraction as well as every subterm occurring in an
\emph{operand position} (\ie occurring as the second argument of
some occurrence of the binary application operator). Formally the
\defname{$\eta$-long form}, written $\elnf{t}$, of a term $t:
(A_1,\ldots,A_n,o)$ with $n \geq 0$ is defined by cases according to
the syntactic shape of $t$:
\begin{eqnarray*}
  \elnf{\lambda x . s } &=& \lambda x . \elnf{s} \\
  \elnf{x s_1 \ldots s_m } &=& \lambda \overline{\varphi} . x \elnf{s_1}\ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x . s) s_1 \ldots s_p } &=& \lambda \overline{\varphi} . (\lambda x . \elnf{s}) \elnf{s_1} \ldots \elnf{s_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is either a variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.

\begin{remark}
  This transformation does not introduce
  new redexes therefore the $\eta$-long normal form of a $\beta$-normal
  term is also $\beta$-normal.
\end{remark}

Let us introduce a new typing system:
\begin{definition}
\label{dfn:longsafe}
We define the set of \defname{long-safe terms}
by induction over the following system of rules:
  $$ \rulename{var_l} \ \rulef{}{x : A\lsentail x : A} \qquad
\rulename{const_l} \ \rulef{}{\lsentail f : A}\quad f \in \Xi \qquad
\rulename{wk_l} \ \rulef{\Gamma \lsentail s : A}{\Delta \lsentail s : A}\quad
\Gamma \subset \Delta$$

$$ \rulename{app_l} \ \rulef{\Gamma \lsentail s : (A_1,\ldots,A_n,B)
\quad
  \Gamma \lsentail t_1 : A_1 \quad \ldots \quad \Gamma \lsentail t_n : A_n
} {\Gamma \lsentail s t_1 \ldots t_n : B} \quad \ord{B} \leq
\ord{\Gamma}$$

$$ \rulename{abs_l} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \lsentail s : B} {\Gamma \lsentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{A_1, \ldots ,A_n,B} \leq
\ord{\Gamma}$$
\smallskip

The subscript in $\lsentail$ stands for ``long''.
\end{definition}
The terminology ``long-safe'' is deliberately suggestive of a forthcoming lemma. Note that long-safe terms are not necessarily in $\eta$-long normal form.

Observe that the system of rules from Def.~\ref{dfn:longsafe} is a sub-system of the typing system of Def.~\ref{def:safelambda} where the application rule is  restricted the same way as the abstraction rule \ie it can perform multiple applications at once provided that all the variables in the context of the resulting term have order greater than the order of the term itself. Thus we clearly have:
\begin{lemma}
\label{lem:longsafe_imp_safe}
If a term is long-safe then it is safe.
\end{lemma}
\smallskip

In general, long-safety is not preserved by $\eta$-expansion: for
instance we have
% $f:o,o \lsentail f$ but $f:o,o \not \lsentail \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\lsentail \lambda y^o z^o . y : (o,o,o)$ but
$\not \lsentail\lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$.
On the other hand,  $\eta$-reduction preserves long-safety:

\begin{lemma}[$\eta$-reduction of one variable preserves long-safety]
\label{lem:etared_preserve_longsafety}
  $\Gamma \lsentail \lambda \varphi . s \varphi :A $ with $\varphi$ not
  occurring free in $s$ implies $\Gamma \lsentail s :A$.
\end{lemma}
\proof
  Suppose $\Gamma \lsentail \lambda \varphi . s \varphi :A$. If $s$ is an  abstraction then by construction of the safe term $\lambda \varphi . s \varphi$, $s$ is necessarily safe.  If $s = N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for any $z\in fv(\lambda \varphi . s \varphi)$, $\ord{z} \geq
  \ord{\lambda \varphi . s \varphi} = \ord{s}$. Since  $\varphi$ does not occur free in $s$ we have $fv(s) = fv(\lambda \varphi . s \varphi)$, thus we can use the application rule to form $fv(s) \lsentail N_0 \ldots N_p : A$. The weakening rules permits us to conclude $\Gamma \lsentail s :A$. \qed
\smallskip

\begin{lemma}[Long-safety is preserved by $\eta$-long expansion]
\label{lem:longsafe_imp_elnf_longsafe}
$\Gamma \lsentail s :A$ then $\Gamma \lsentail \elnf{s} :A$.
\end{lemma}
\proof
 First we observe that for any variable or constant $x:A$ we have $x:A \lsentail \elnf{x} :A$. We show this by induction on $\ord{x}$.
It is verified for any ground type variable $x$
since $x = \elnf{x}$.
Step case: $x:A$ with $A=(A_1, \ldots, A_n,o)$ and $n>0$. Let $\varphi_i:A_i$ be fresh variables for $1\leq i\leq n$.
Since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i :A_i \lsentail \elnf{\varphi_i} : A_i$. Using \rulenamet{wk_l} we obtain $x:A, \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \lsentail x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \lsentail \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} =
  \elnf{x} :A$.


We now prove the lemma by induction on $s$.
The base case is covered by the previous observation.
\emph{Step case:}
\begin{compactitem}
\item $s = x s_1 \ldots s_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $s_i : B_i$ for $1 \leq i \leq
  m$.  Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \lsentail \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \lsentail x s_1 \ldots s_m : A$ is formed using the \rulenamet{app_l} rule, each $s_j$ must be long-safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \lsentail \elnf{s_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \lsentail \elnf{s_j} : B_j$.  The \rulenamet{app_l}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \lsentail x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the \rulenamet{abs_l} rule gives $\Gamma \lsentail \lambda \overline{\varphi} . x
  \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} = \elnf{s} : A$, the side-condition of \rulenamet{abs_l} being verified since $\ord{\elnf{s}} = \ord{s}$.


\item $s = t s_0 \ldots s_m$ where $t$ is an abstraction.
For some fresh variables $\varphi_1$, \ldots, $\varphi_n$
we have $\elnf{s} = \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n}$. Again, using the induction hypothesis we can easily derive $\Gamma \lsentail
 \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : A$.

\item $s = \lambda \overline{\eta} . t $ where
$\overline{\eta} : \overline{B}$ and $t:C$ is not an abstraction. The induction hypothesis gives $\Gamma,
  \overline{\eta} : \overline{B} \lsentail \elnf{t} : C$ and using
\rulenamet{abs_l} we get $\Gamma \lsentail \lambda \overline{\eta} . \elnf{t} = \elnf{s} : A$.  \qed
\end{compactitem}

\begin{remark}\hfill
\begin{enumerate}
\item
The converse of this lemma does not hold in general: Performing
$\eta$-reduction over a large abstraction does not in general
preserve long-safety. This does not contradict Lemma
  \ref{lem:etared_preserve_longsafety} which states that safety is
  preserved when performing $\eta$-reduction on an abstraction
  of a \emph{single} variable. The simplest counter-example is
  the
 term $f^{(o,o,o)} \stentail \lambda x^o . f \underline{x}$ which is not long-safe and
whose eta-long normal form $f^{(o,o,o)} \lsentail \lambda x^o y^o .
f x y$ is long-safe. Even for closed terms the converse does not
hold: $\lambda f^{(o,o,o)} g^{((o,o,o),o)} . g(\lambda x^o . f
\underline{x})$ is not long-safe but its eta-normal form $\lambda f^{(o,o,o)}
g^{((o,o,o),o)} . g(\lambda x^o y^o. f x y)$ is long-safe. In fact
even the closed $\beta\eta$-normal term $\lambda
f^{(o,(o,o),o,o)} g^{((o,o),o,o,o),o)} . g(\lambda y^{(o,o)} x^o
. f \underline{x} y)$ which is not long-safe has a long-safe $\eta$-long normal form!

  \item After performing $\eta$-long expansion of a term, all the occurrences of the application rule are made long-safe. Thus if a term remains not long-safe after $\eta$-long expansion, this means that
  some variable occurrence is not bound by the
  first following application of the \rulenamet{abs} rule in the
  typing tree.
  \end{enumerate}
\end{remark}

\begin{lemma}
  \label{lem:safe_iff_etalong_lsafe}
  A simply-typed term is safe if and only if its $\eta$-long normal form is long-safe.
\end{lemma}
\proof Let $\Gamma \stentail M : T$. We want to show that $\Gamma
\lsentail \elnf{M} : T$ if and only if $\Gamma \sentail M : T$. The
`If' part can be proved by a trivial induction on the structure of
$\Gamma \sentail M : T$. For the `Only if' part we proceed by
induction on the structure of the simply-typed term $\Gamma
\stentail M : T$: The variable, constant and weakening cases are
trivial. Suppose that $M$ is an application of the form $x s_1
\ldots s_m : A$ for $m\geq 1$. Its $\eta$-long normal form is of the
form $x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
\elnf{\varphi_m}: o$ for some fresh variables $\varphi_1$, \ldots
$\varphi_m$. By assumption this term is long-safe term therefore we
have $\ord{A}\leq\ord{\Gamma}$ and for $1\leq i \leq m$,
$\elnf{s_i}$ is also long-safe. By the induction hypothesis this
implies that the $s_i$s are all safe. We can then form the judgment
$\Gamma \sentail x s_1 \ldots s_m : A$ using the rules
$\rulename{var}$ and $\rulename{\delta}$ followed by $m-1$
applications of the rule $\rulename{app_{as}}$ and one application
of $\rulename{app}$ (this is allowed since we have
$\ord{A}\leq\ord{\Gamma}$). The case $M\cong (\lambda x. s) s_1
\ldots s_m$ for $m\geq 1$ is treated identically.

Suppose that $M \cong \lambda \overline{x} . s : A$. By assumption,
its  $\eta$-long n.f.\ $\lambda \overline{x} \overline{\varphi} .
\elnf{s} \elnf{\varphi_1} \ldots \elnf{\varphi_m}: A$ (for some
fresh variables $\varphi_1$ \ldots $\varphi_m$) is long-safe. Thus
we have $\ord{A}\leq\ord{\Gamma}$. Furthermore the long-safe subterm
$\elnf{s} \elnf{\varphi_1} \ldots \elnf{\varphi_m}$ is precisely the
eta-long expansion of $s\varphi_1 \ldots \varphi_m : o$ therefore by
the induction hypothesis we have that $s \varphi_1 \ldots \varphi_m
:o$ is safe. Since the $\varphi_i$'s are all safe (by rule
$\rulename{var}$), we can ``peal-off'' $m$ applications of the rules
$\rulename{app_{as}}$/$\rulename{app}$ from the sequent $\Gamma,
\overline{x}, \overline{\varphi} \sentail s \varphi_1 \ldots
\varphi_m :o$ which gives us the sequent $\Gamma, \overline{x},
\overline{\varphi} \asentail s : A$. Since the $\overline{\varphi}$
variables are fresh for $s$, we can further peal-off $m$
applications of the weakening rule to obtain the judgment $\Gamma,
\overline{x} \sentail s : A$. Finally we obtain $\Gamma \sentail
\lambda \overline{x} . s : A$ using the rule $\rulename{abs}$ (which
is permitted since we have $\ord{A}\leq\ord{\Gamma}$). \qed
\smallskip






\begin{proposition}
\label{prop:safe_iff_elnfsafe}
A term is safe if and only if its $\eta$-long normal form is safe.
\end{proposition}
\proof
`If':
\begin{align*}
  \Gamma \sentail \elnf{M}:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies   \Gamma \sentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (if).}
\end{align*}
`Only if':
\begin{align*}
  \Gamma \sentail M:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies \Gamma \sentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:longsafe_imp_safe}\qquad }
\end{align*}
\qed

% The following statement is wrong:
%``In the homogeneous safe lambda calculus, the notion of safe terms and long-safe terms coincide''
% Because of the example given earlier (which is homogeneously typed)

\subsection*{The type inhabitation problem}

It is well known that the simply-typed lambda calculus corresponds
to intuitionistic implicative logic via the Curry-Howard
isomorphism. The theorems of the logic correspond to inhabited
types; further every inhabitant of a type represents a proof of the
corresponding formula. Similarly, we can consider the fragment of
intuitionistic implicative logic that corresponds to the safe lambda
calculus under the Curry-Howard isomorphism. We call it the
\emph{safe fragment of intuitionistic implicative logic}.

An obvious first question is to compare the reasoning power of these
two logics, in other words, to determine which types are inhabited
in the lambda calculus but not in the safe lambda
calculus.\footnote{This problem was raised to our attention by Ugo
dal Lago.}

If types are generated from a single atom $o$, then there is a
positive answer: every type generated from one atom that is
inhabited in the lambda calculus is also inhabited in the safe
lambda calculus. Indeed, one can transform any unsafe inhabitant $M$
into a safe one of the same type as follows: Compute the eta-long
beta normal form of $M$. Let $x$ be an occurrence of a ground-type
variable in a subterm of the form $\lambda \overline{x} . C[x]$
where $\lambda \overline{x}$ is the binder of $x$ and for some
context $C[\_~]$ different from the identity $C[R]=R$. We replace
the subterm $\lambda \overline{x} . C[x]$ by $\lambda \overline{x}.
x$ in $M$. This transformation is sound because both $C[x]$ and $x$
are of the same ground type. We repeat this procedure until the term
stabilizes. This procedure clearly terminates since the size of the
term decreases strictly after each step. The final term obtained is
safe and of the same type as $M$.

This argument cannot be generalized to types generated from multiple
atoms. In fact there are order-$3$ types with only $2$ atoms that
are inhabited in the simply-typed lambda calculus but not in the
safe lambda calculus. Take for instance the order-$3$ type
 $( ((b, a), b),  ((a, b), a),  a)$ for some distinct atoms $a$ and $b$. It is only inhabited by the following family of terms which are all unsafe:
 \begin{align*}
& \lambda f g . g (\lambda x_1 . f (\lambda y_1 . x_1)) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . y_1))) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . x_i))) \qquad\mbox{where $i = 1, 2$} \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . g (\lambda x_3 . y_i))) \qquad\mbox{where $i = 1, 2$} \\
&\ldots
\end{align*}

Another example is the type of function composition. For any atom
$a$ and natural number $n\in\nat$, we define the types $n_a$ as
follows: $0_a = a$ and $(n+1)_a = n_a \typear a$. Take three
distinct atoms $a$, $b$ and $c$. For any $i,j,k\in\nat$, we write
$\sigma(i,j,k)$ to denote the type
$$\sigma(i,j,k) \cong (i_a \typear j_b) \typear (j_b \typear k_c) \typear i_a \typear
k_c \ .$$

For all $i$, $j$, $k$, this type is inhabited in the lambda calculus
by the ``function composition term'':
$$\lambda x y z w . y (x z) $$
which is safe if and only if $i\geq j$. Suppose that $i<j$ then the type
$\sigma(i,j,k)$ may still be safely inhabited. For instance
$\sigma(1,3,4)$ is inhabited by the safe term
$$ \lambda x^{1_a \typear 3_b} y^{3_b \typear 4_c} z^{1_c} w^{3_c} . y (x (\lambda u^a . u)) \ .$$
The order-$4$ type $\sigma(0,2,0)$, however, is only inhabited by the unsafe term $\lambda x y z w. y (x z) $.


Statman showed in \cite{Statman1979} that the problem of deciding
whether a type \emph{defined over an infinite number of ground
atoms} is inhabited (or equivalently of deciding validity of an
intuitionistic implicative formula) is PSPACE-complete. The previous
observations suggest that the validity problem for the safe fragment
of implicative logic may not be PSPACE-hard.
