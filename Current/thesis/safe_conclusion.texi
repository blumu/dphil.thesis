
\section{Conclusion and future works}

\todo{Conclusion of Chapter \ref{chap:safelambda} (on the safe lambda calculus)}


\emph{Related work:} A first attempt to adapt the safety restriction to the lambda calculus was made  by Aehlig, de Miranda and Ong \cite{DBLP:conf/fossacs/AehligMO05}. The calculus presented here is more general (no condition is imposed on types and use of $\Sigma$-constants of any order is allowed) and simpler (the typing system is a slight variation of that of the simply typed lambda calculus).


% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik et al.\ \cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig et al.\
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, Luke Ong obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the paper \cite{hmos-lics08}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.


\subsection{Representability of functions over free algebras}

There is an isomorphism between binary trees and closed simply typed terms of
type $\tau =(o\typear o\typear o) \typear o \typear o$. Thus any
closed term of type $\tau\typear\tau \typear \ldots \typear \tau $
represents an $n$-ary function over trees. Zaionc gave a
characterization of the set of tree functions representable in the
simply typed lambda calculus \cite{DBLP:conf/aluacs/Zaionc88}: it is
precisely the minimal set containing constant functions, projections
and closed under composition and limited primitive recursion. Zaionc
showed that the same characterization holds for the general case of
functions expressed over free algebras
\cite{DBLP:journals/apal/Zaionc91}: they are given by the
minimal set containing constant functions, projections and closed
under composition and limited primitive recursion. This result subsumes
Schwichtenberg's result on definable numeric functions as well as
Zaionc's own results on definable word and tree functions.

All these basic operations are safe except limited primitive recursion.
This suggests that one needs to restrict further the primitive recursion in order to obtain a characterization of free-algebra functions representable in the
safe lambda calculus. Such result would generalized our expressivity result for numeric and word functions from Sec.\ \ref{sec:expressivity}.

