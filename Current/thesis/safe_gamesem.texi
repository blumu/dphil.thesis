Our aim is to characterize safety by game semantics. This chapter
assumes that the reader is familiar with the basics of game
semantics introduced in Chapter \ref{chap:gamesem}.  Recall that a
\emph{justified sequence} over an arena is an alternating sequence
of O-moves and P-moves such that every move $m$, except the opening
move, has a pointer to some earlier occurrence of the move $m_0$
such that $m_0$ enables $m$ in the arena. A \emph{play} is just a
justified sequence that satisfies Visibility and Well-Bracketing. A
basic result in game semantics is that $\lambda$-terms are denoted
by \emph{innocent strategies}, which are strategies that depend only
on the \emph{P-view} of a play. The main result
(Theorem~\ref{thm:safeincrejust_lmd}) of this section is that if a
$\lambda$-term is safe, then its game semantics (is an innocent
strategy that) is, what we call, \emph{P-incrementally justified}.
In such a strategy, pointers emanating from the P-moves of a play
are uniquely reconstructible from the underlying sequence of moves
and pointers from the O-moves therein: specifically a P-question
always points to the last pending O-question (in the P-view) of a
greater order.

The proof of Theorem~\ref{thm:safeincrejust_lmd} relies on the
Correspondence Theorem from Chapter \ref{chap:localbeta} that
relates the strategy denotation of a $\lambda$-term $M$ to the set
of \emph{traversals} over a souped-up abstract syntax tree of the
$\eta$-long form of $M$: In the language of game semantics,
traversals are just (concrete representations of) the
\emph{uncovering} (in the sense of Hyland and Ong
\cite{hylandong_pcf}) of plays in the strategy denotation.


\subsection*{Safe PCF and safe Idealised Algol}

\pcf\ is the simply-typed lambda calculus augmented with basic
arithmetic operators, if-then-else branching and a family of
recursion combinator $Y_A : ((A,A),A)$ for any type $A$.  We define
\emph{safe} \pcf\ to be \pcf\ where the application and abstraction
rules are constrained in the same way as the safe lambda calculus.
This language inherits the good properties of the safe lambda
calculus: No variable capture occurs when performing substitution
and safety is preserved by the reduction rules of the small-step
semantics of \pcf.

\subsubsection{Correspondence}
The useful transference technique between plays and traversals was
originally introduced by Ong in \cite{OngLics2006} for studying
the decidability of monadic second-order theories of infinite structures generated by
higher-order grammars (in which the $\Sigma$-constants or terminal symbols are at most
order 1, and \emph{uninterpreted}).
% In this setting, free variables are interpreted
% as constructors and therefore they do not have the ``full power'' of
% true free variables and are limited to order $1$ at most. Also,
% although the grammar can perform higher-order computations, the
% structure being studied is itself of ground type.
Here we present an extension of this framework to the
general case of the simply-typed lambda calculus with free variables
of any order. A new traversal rule is introduced to handle nodes
labelled with free variables. Also new nodes are added to the
computation tree to account for the answer moves of the game
semantics, thus enabling the framework to model languages with
interpreted constants such as \pcf~(by adding traversal rules to
handle constant nodes).


The computation tree of a \pcf\ term is defined as the least
upper-bound of the chain of computation trees of its \emph{syntactic
approximants} \cite{abramsky:game-semantics-tutorial}.  It is
obtained by infinitely expanding the $Y$ combinator, for instance
$\tau(Y (\lambda f x. f x))$ is the tree representation of the
$\eta$-long form of the infinite term $(\lambda f x. f x)
 ((\lambda f x. f x) ((\lambda f x. f x) ( \ldots$

It is straightforward to define the traversal rules modeling the
arithmetic constants of \pcf. Just as in the safe lambda calculus we
had to remove @-nodes in order to reveal the game-semantic
correspondence, in safe \pcf\ it is necessary to filter out the
constant nodes from the traversals. The Correspondence Theorem for
\pcf\ says that the interaction game semantics is isomorphic to the
set of traversals disposed of these superfluous nodes. This can
easily be shown for term approximants. It is then lifted to full
\pcf\ using the continuity of the function $\travset(\_)^{\filter
\theroot}$ from the set of computation trees (ordered by the
approximation ordering) to the set of sets of justified sequences of
nodes (ordered by subset inclusion). Finally computation trees of
safe \pcf\ terms are incrementally-bound thus we have
%Computation trees of safe \pcf\ terms are incrementally-bound.
%Moreover since \pcf\ constant are of order $1$ at most, the constant
%traversal rules are all \emph{well-behaved} (Lemma
%\ref{lem:sigma_order1_are_wellbehaved}) hence Lemma
%\ref{lem:betanf_wellbehavedconst_trav_pview_red} (from the Appendix)
%still holds and the game-semantic analysis of safety remains valid
%for \pcf. Hence we have:
\begin{theorem}
Safe PCF terms have P-incrementally justified denotations. \qed
\end{theorem}


Similarly, we can define safe \ialgol\ to be safe \pcf\ augmented
with the imperative features of Idealized Algol (\ialgol\ for short)
\cite{Reynolds81}.  Adapting the game-semantic correspondence and
safety characterization to \ialgol\ seems feasible although the
presence of the base type \iavar, whose game arena $\iacom^{\nat}
\times \iaexp$ has infinitely many initial moves, causes a mismatch
between the simple tree representation of the term and its game
arena. It may be possible to overcome this problem by replacing the
notion of computation tree by a ``computation directed acyclic
graph''.

The possibility of representing plays \emph{without some or all of
  their pointers} under the safety assumption suggests potential
applications in algorithmic game semantics. Ghica and McCusker
\cite{ghicamccusker00} were the first to observe that pointers are
unnecessary for representing plays in the game semantics of the
second-order finitary fragment of Idealized Algol ($\ialgol_2$ for
short). Consequently observational equivalence for this fragment can
be reduced to the problem of equivalence of regular expressions.  At
order $3$, although pointers are necessary, deciding observational
equivalence of $\ialgol_3$ is EXPTIME-complete
\cite{DBLP:journals/apal/Ong04,DBLP:conf/fossacs/MurawskiW05}.
Restricting the problem to the safe fragment of $\ialgol_3$ may lead
to a lower complexity.

% (note that it is unlikely to obtain the complexity PSPACE because the
% set of complete plays of the safe term $\lambda f^{(o,o),o} . f
% (\lambda x^o . x)$ is not regular \cite{DBLP:journals/apal/Ong04}).

% Murawski showed the undecidability of program equivalence in
% $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations
% into a finitary $IA_4$ term \cite{murawski03program}. The term
% constructed being not safe, the proof cannot be transposed to the
% safe fragments. Hence the question remains of whether observational
% equivalence is decidable for the \emph{safe} fragments of these
% language.

%In \cite{Ong02}, Ong showed that observational equivalence for
% finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is
% undecidable. The proof consists in reducing the Queue-Halting
% problem to the observational equivalence of two $\ialgol_2 + Y_1$
% terms. The same reduction is still valid in the safe fragment of
% $\ialgol_2 + Y_1$.  Consequently, observational equivalence of safe
% $\ialgol_2 + Y_1$ is also undecidable.
