\subsection*{Safe PCF and safe Idealised Algol}

\pcf\ is the simply-typed lambda calculus augmented with basic
arithmetic operators, if-then-else branching and a family of
recursion combinator $Y_A : ((A,A),A)$ for any type $A$.  We define
\emph{safe} \pcf\ to be \pcf\ where the application and abstraction
rules are constrained in the same way as the safe lambda calculus.
This language inherits the good properties of the safe lambda
calculus: No variable capture occurs when performing substitution
and safety is preserved by the reduction rules of the small-step
semantics of \pcf.


The computation tree of a \pcf\ term is defined as the least
upper-bound of the chain of computation trees of its \emph{syntactic
approximants} \cite{abramsky:game-semantics-tutorial}.  It is
obtained by infinitely expanding the $Y$ combinator, for instance
$\tau(Y (\lambda f x. f x))$ is the tree representation of the
$\eta$-long form of the infinite term $(\lambda f x. f x)
 ((\lambda f x. f x) ((\lambda f x. f x) ( \ldots$

It is straightforward to define the traversal rules modeling the
arithmetic constants of \pcf. Just as in the safe lambda calculus we
had to remove @-nodes in order to reveal the game-semantic
correspondence, in safe \pcf\ it is necessary to filter out the
constant nodes from the traversals. The Correspondence Theorem for
\pcf\ says that the interaction game semantics is isomorphic to the
set of traversals disposed of these superfluous nodes. This can
easily be shown for term approximants. It is then lifted to full
\pcf\ using the continuity of the function $\travset(\_)^{\filter
\theroot}$ from the set of computation trees (ordered by the
approximation ordering) to the set of sets of justified sequences of
nodes (ordered by subset inclusion). Finally computation trees of
safe \pcf\ terms are incrementally-bound thus we have
%Computation trees of safe \pcf\ terms are incrementally-bound.
%Moreover since \pcf\ constant are of order $1$ at most, the constant
%traversal rules are all \emph{well-behaved} (Lemma
%\ref{lem:sigma_order1_are_wellbehaved}) hence Lemma
%\ref{lem:betanf_wellbehavedconst_trav_pview_red} (from the Appendix)
%still holds and the game-semantic analysis of safety remains valid
%for \pcf. Hence we have:
\begin{theorem}
Safe PCF terms have P-incrementally justified denotations. \qed
\end{theorem}


Similarly, we can define safe \ialgol\ to be safe \pcf\ augmented
with the imperative features of Idealized Algol (\ialgol\ for short)
\cite{Reynolds81}.  Adapting the game-semantic correspondence and
safety characterization to \ialgol\ seems feasible although the
presence of the base type \iavar, whose game arena $\iacom^{\nat}
\times \iaexp$ has infinitely many initial moves, causes a mismatch
between the simple tree representation of the term and its game
arena. It may be possible to overcome this problem by replacing the
notion of computation tree by a ``computation directed acyclic
graph''.

The possibility of representing plays \emph{without some or all of
  their pointers} under the safety assumption suggests potential
applications in algorithmic game semantics. Ghica and McCusker
\cite{ghicamccusker00} were the first to observe that pointers are
unnecessary for representing plays in the game semantics of the
second-order finitary fragment of Idealized Algol ($\ialgol_2$ for
short). Consequently observational equivalence for this fragment can
be reduced to the problem of equivalence of regular expressions.  At
order $3$, although pointers are necessary, deciding observational
equivalence of $\ialgol_3$ is EXPTIME-complete
\cite{DBLP:journals/apal/Ong04,DBLP:conf/fossacs/MurawskiW05}.
Restricting the problem to the safe fragment of $\ialgol_3$ may lead
to a lower complexity.

% (note that it is unlikely to obtain the complexity PSPACE because the
% set of complete plays of the safe term $\lambda f^{(o,o),o} . f
% (\lambda x^o . x)$ is not regular \cite{DBLP:journals/apal/Ong04}).

% Murawski showed the undecidability of program equivalence in
% $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations
% into a finitary $IA_4$ term \cite{murawski03program}. The term
% constructed being not safe, the proof cannot be transposed to the
% safe fragments. Hence the question remains of whether observational
% equivalence is decidable for the \emph{safe} fragments of these
% language.

%In \cite{Ong02}, Ong showed that observational equivalence for
% finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is
% undecidable. The proof consists in reducing the Queue-Halting
% problem to the observational equivalence of two $\ialgol_2 + Y_1$
% terms. The same reduction is still valid in the safe fragment of
% $\ialgol_2 + Y_1$.  Consequently, observational equivalence of safe
% $\ialgol_2 + Y_1$ is also undecidable.
