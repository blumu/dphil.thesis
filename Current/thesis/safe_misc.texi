% -*- TeX -*- -*- Soft -*-

\section{Typing problems}

In this section we consider the problems of type checking, typability and type inhabitation as defined in Sec.\ \ref{sec:lambdacalculus} but recast in the safe lambda calculus:
\begin{itemize}
\item \textsc{Type checking}: Given a term $M$, context $\Gamma$ and type $A$, do we have $\Gamma \sentail M : A$?
\item \textsc{Typability}: Given a term $M$ and context $\Gamma$, is there a type $A$ such that $\Gamma \sentail M : A$?
\item \textsc{Inhabitation}: Given a type $A$, is there a term $M$  such that $\sentail M : A$?
\end{itemize}
We will restrict our attention to the Church-like safe lambda calculus. The results presented here straightforwardly extend to the Curry version.

\subsection{Relating $\cusystem$ and safe $\cusystem$}
In this section we relate the safe lambda calculus with the simply typed lambda calculus. The typing-system from Def.\ \ref{def:lambdacalculus_alacurry} does not have a weakening rule and does not allow simultaneous application and abstraction at once.
In order to ease the comparison, we use an alternative presentation of the simply typed lambda calculus given in Table \ref{tab:alt_currylambda}:
\begin{table}[htnp]
$$ \rulef{}{x:A\cuentail x : A} \qquad
\rulef{\Gamma \cuentail M : A}{\Delta \cuentail M : A} \quad
\Gamma \subset \Delta$$

$$ \rulef{\Gamma \cuentail M : (A_1, \ldots , A_n,B)
\quad \Gamma \cuentail N_1 : A_1 \quad \ldots
\quad \Gamma \cuentail N_n : A_n} {\Gamma \cuentail M\, N_1 \ldots N_n : B} $$

$$ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \cuentail M : B} {\Gamma \cuentail \lambda x_1 \ldots x_n . M :
  (A_1, \ldots ,A_n,B)}
$$
\caption{Alternative definition of the Curry-style lambda calculus}
\label{tab:alt_currylambda}
\end{table}
The two presentations are clearly equivalent: $\Gamma\cuentail M : T$ is derivable in the above system iff it is derivable with the rules of Def.\ \ref{def:lambdacalculus_alacurry}.

\begin{convention}
In order to make our derivations canonical, we adopt the following convention:
\begin{itemize}
\item a derivation cannot contain two consecutive applications of the weakening rule;
\item when using the weakening rule, the context $\Delta$ is chosen as small as possible so that for every judgement $\Gamma \cuentail M: A$ appearing in the derivation that is not deduced from the weakening rule we have $\freevarset(M) = \dom(\Gamma)$.
\end{itemize}
\end{convention}

We are interested in those derivations verifying the following property: a deduction $\Delta$ of $\Gamma \cuentail M : T$ is \defname[compact!typing deduction]{compact} if the set of terms appearing in the nodes of the deduction tree $\Delta$ is precisely $\maxsubterm(M)$. In other words, in a compact deduction, each use of the application and abstraction rule in the deduction is as ``large'' as possible so that each path in the deduction tree is constituted of an axiom followed by an alternation of application/abstraction rules. Compact derivations are sufficient:
if there is derivation in $\cusystem$ then there is a compact derivation with the same conclusion. We will write ${\sf Der}_{cu}(\Gamma, M, T)$ for the set of compact derivations of $\Gamma \cuentail M : T$.

Similarly, we define the notion of compact derivation in the safe lambda calculus. It is easy to check that, despite the side-conditions imposed by the abstraction rule,
the compact deductions are sufficient. We write ${\sf Der}_{s}(\Gamma, M, T)$ for the set of compact deduction of $\Gamma \sentail M : T$ in safe $\cusystem$.

We say that a deduction $\Delta \in {\sf Der}_{cu}(\Gamma, M, T)$ is \defname[safe!deduction]{safe} if $\ord \Gamma \geq \ord T$ and for 
all term-in-context $\Gamma'\stentail M : T'$ deduced in $\Delta$
from the abstraction rule we have: $\ord \Gamma' \geq \ord T'$.


For any deduction tree $\Delta$ in ${\sf Der}_{s}(\Gamma, M, T)$
we write $\epsilon(\Delta)$ to denote the deduction tree obtained by replacing judgements $\Gamma \sentail M : T$ by $\Gamma \cuentail M : T$ and rules of the safe lambda calculus by their counterpart in the simply type lambda calculus (identifying \rulenamet{app} and \rulenamet{app_{as}}).

\begin{lemma}[Relating derivations from $\cusystem$ and safe $\cusystem$]
\label{lem:rel_cu_safe} \hfill
\begin{enumerate}[(i)]
\item $\Delta \in {\sf Der}_{s}(\Gamma, M, T) \implies 
  \epsilon(\Delta) \in {\sf Der}_{cu}(\Gamma, M, T) \zand \epsilon(\Delta)$ is safe,
  \item $\Delta' \in {\sf Der}_{cu}(\Gamma, M, T) \zand \Delta' \mbox{ is safe.} \implies \exists \Delta \in {\sf Der}_{s}(\Gamma, M, T) : \Delta' = \epsilon(\Delta)$.
  \end{enumerate}
\end{lemma}
\proof
This follows immediately from the definition of safe $\cusystem$.
\qed
\smallskip

\subsection{Type checking and typability}

By the PT Theorem \ref{thm:pt}, \textsc{Typability} is decidable in $\cusystem$ and
if a term is typable then it has a computable principal derivation \ie every other derivation is an instance of that derivation.
The same result holds for compact derivations:
\begin{lemma}[Principal compact derivation]
  If $M$ is typable in $\cusystem$ then is has a \emph{compact} principal derivation $\Delta$ \ie any derivation $\Delta' \in {\sf Der}_{cu}(\Gamma, M, T)$ is an instance of $\Delta$.
\end{lemma}
\proof 
This follows immediately from Theorem \ref{thm:pt}: compact derivations are just ``reorganized'' derivations: for any standard derivation there exists a corresponding compact derivation containing the same typing assumptions.
\qed
\smallskip

\begin{proposition}
  Type checking is decidable in safe $\cusystem$.
\end{proposition}
\proof
Let $M \in \Lambda$, $T\in\mathbb{T}$ and $\Gamma$ be a typing-context.
We have $\Gamma \sentail M : T$ iff ${\sf Der}_{s}(\Gamma, M, T) \neq \emptyset$.
By Lemma \ref{lem:rel_cu_safe}, there is a derivation in ${\sf Der}_{s}(\Gamma, M, T)$
if and only if there is a safe derivation in ${\sf Der}_{cu}(\Gamma, M, T)$.

By the \emph{Principal compact derivation} lemma, the problem ``${\sf Der}_{cu}(\Gamma, M, T) = \emptyset?$'' is decidable. If it is empty then we can answer `No' to the type-checking problem. Otherwise we can compute a compact principal derivation $\Delta_p$ of
$\Gamma \sentail M : T$ and we know that there exists a safe derivation 
iff there exists a type-substitution $s$ for $\Delta_p$ such that $s(\Delta_p)$ is safe.

This property turns out to be decidable. Indeed, the deduction $\Delta_p$ contains finitely many atoms $a_1 \ldots a_n \in \mathbb{A}$, $n\geq 1$. Therefore the safety of $s(\Delta_p)$ can be expressed in terms of a system of inequations over the order of the atoms occurring in $\Delta_p$. This system can be reexpressed into a system of inequations $\mathcal{S}$ of the form $x_i > x_j$ for $i,j\in \{1,.., q\}$ and variables $x_1, \ldots, x_q \in\mathbb{Z}$ and such that for every atom $a_k$, $\ord a_k = x_{i_k}$ for some $i_k \in \{1, .., q\}$.

A substitution $s$ verifying the required property exists if and only if $\mathcal{S}$ has a solution: If the solution to $\mathcal{S}$ is $(x_1,\ldots, x_q)$
then we just need to take the substitution $s = [(x_{k_1})_o/a_1, \ldots (x_{k_n})_o/a_n]$ for some fresh atom $o\in\mathbb{A}$. (Observe that if $(x_1,\ldots, x_q)$ is a solution then so is $(x_1+k,\ldots, x_q+k)$ for $k\geq 0$, therefore the $x_i$s can be assume to be positive.)

The problem therefore reduces to solving a system of linear inequalities over $\mathbb{Z}^q$. This is clearly decidable: 
 We can construct a directed graph $G$ whose set of vertices is given by $\{1,..,q\}$ and with an edge from $i$ to $j$ for each equation $x_i>x_j$ in $\mathcal{S}$.
Solving $\mathcal{S}$ then reduces to deciding whether $G$ contains a cycle, which is decidable. If $G$ has no cycle then a solution can be found by performing a breadth-first search algorithm.
\qed


\todo{Typability: same thing...}
\subsection{The type inhabitation problem}

It is well known that the simply typed lambda calculus corresponds
to intuitionistic implicative logic via the Curry-Howard
isomorphism. The theorems of the logic correspond to inhabited
types; further every inhabitant of a type represents a proof of the
corresponding formula. Similarly, we can consider the fragment of
intuitionistic implicative logic that corresponds to the safe lambda
calculus under the Curry-Howard isomorphism. We call it the
\emph{safe fragment of intuitionistic implicative logic}.

An obvious first question is to compare the reasoning power of these
two logics, in other words, to determine which types are inhabited
in the lambda calculus but not in the safe lambda
calculus.\footnote{This problem was raised to our attention by Ugo
dal Lago.}

If types are generated from a single atom $o$, then there is a
positive answer: every type generated from one atom that is
inhabited in the lambda calculus is also inhabited in the safe
lambda calculus. Indeed, one can transform any unsafe inhabitant $M$
into a safe one of the same type as follows: Compute the eta-long
beta normal form of $M$. Let $x$ be an occurrence of a ground-type
variable in a subterm of the form $\lambda \overline{x} . C[x]$
where $\lambda \overline{x}$ is the binder of $x$ and for some
context $C[\_~]$ different from the identity $C[R]=R$. We replace
the subterm $\lambda \overline{x} . C[x]$ by $\lambda \overline{x}.
x$ in $M$. This transformation is sound because both $C[x]$ and $x$
are of the same ground type. We repeat this procedure until the term
stabilizes. This procedure clearly terminates since the size of the
term decreases strictly after each step. The final term obtained is
safe and of the same type as $M$.

This argument cannot be generalized to types generated from multiple
atoms. In fact there are order-$3$ types with only $2$ atoms that
are inhabited in the simply typed lambda calculus but not in the
safe lambda calculus. Take for instance the order-$3$ type
 $( ((b, a), b),  ((a, b), a),  a)$ for some distinct atoms $a$ and $b$. It is only inhabited by the following family of terms which are all unsafe:
 \begin{align*}
& \lambda f g . g (\lambda x_1 . f (\lambda y_1 . x_1)) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . y_1))) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . x_i))) \qquad\mbox{where $i = 1, 2$} \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . g (\lambda x_3 . y_i))) \qquad\mbox{where $i = 1, 2$} \\
&\ldots
\end{align*}

Another example is the type of function composition. Take three
distinct atoms $a$, $b$ and $c$. For any $i,j,k\in\nat$, we write
$\sigma(i,j,k)$ to denote the type
$$\sigma(i,j,k) \equiv (i_a \typear j_b) \typear (j_b \typear k_c) \typear i_a \typear
k_c \ .$$
where $(n+1)_a$ denotes the type $ (\ldots ((a\typear a)\typear a) \ldots) \typear a$ containing $n$ occurrence of $a$ as defined in Sec.\ \ref{sec:simpletype}.

For all $i$, $j$, $k$, this type is inhabited in the lambda calculus
by the ``function composition term'':
$$\lambda x y z w . y (x z) $$
which is safe if and only if $i\geq j$. Suppose that $i<j$ then the type
$\sigma(i,j,k)$ may still be safely inhabited. For instance
$\sigma(1,3,4)$ is inhabited by the safe term
$$ \lambda x^{1_a \typear 3_b} y^{3_b \typear 4_c} z^{1_c} w^{3_c} . y (x (\lambda u^a . u)) \ .$$
The order-$4$ type $\sigma(0,2,0)$, however, is only inhabited by the unsafe term $\lambda x y z w. y (x z) $.


Statman showed in \cite{Statman1979} that the problem of deciding
whether a type \emph{defined over an infinite number of ground
atoms} is inhabited (or equivalently of deciding validity of an
intuitionistic implicative formula) is PSPACE-complete. The previous
observations suggest that the validity problem for the safe fragment
of implicative logic may not be PSPACE-hard.


\section{Safe combinators}

\todo{typset my notes on safe combinators}
