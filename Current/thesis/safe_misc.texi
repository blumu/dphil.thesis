% -*- TeX -*- -*- Soft -*-

\section{Typing problems}

In this section we consider the problems of type checking, typability and type inhabitation as defined in Sec.\ \ref{sec:lambdacalculus}. These problems are recast in the context of the safe lambda calculus as follows:
\begin{itemize}
\item \textsc{Type checking} Given a term $M$, context $\Gamma$ and type $A$, do we have $\Gamma \sentail M : A$?
\item \textsc{Typability} Given a term $M$ and context $\Gamma$, is there a type $A$ such that $\Gamma \sentail M : A$?
\item \textsc{Inhabitation} Given a type $A$, is there a term $M$  such that $\sentail M : A$?
\end{itemize}

Before attacking these problems let us make some observations about the safe lambda calculus.
In the safe lambda calculus, the abstraction rule ensures that when binding variables, all the free variables that are not abstracted have order greater than the order of the subterm formed with the rule. Given a safe term-in-context, by collecting the conditions induced by all the rules applied in the typing tree, we obtain a system of inequations whose variables are the order of the term-variables.

We call \defname{atomic base} of a term-in-context $\Gamma \stentail M : T$, written $\langle \alpha, \beta, \ldots \rangle$, the sequence of type atoms occurring in the types of $\Gamma$ and in $T$ given by order of appearance.

\begin{definition}
    Let $\Gamma \stentail M : T$ be a simply typed term-in-context.
    We define the set $Ineq'(\Gamma \stentail M : T)$ of inequations over types inductively as follows:

    If $M\equiv M_0 \ldots M_q$ where $M_0$ is not an application then
$$Ineq'(\Gamma \stentail M : T) =
\Union_{0\leq i\leq q} Ineq'(\Gamma \stentail M_i : T_i)$$

    If $M\equiv \lambda\overline{x} . N$ then
$$Ineq'(\Gamma \stentail M : T) =
Ineq'(\Gamma \stentail N : T)
\union \Union_{z:A \in \Gamma \zand z\in fv(M)} \{\ord A > \ord \ord T \}$$

$$Ineq'(\Gamma \stentail x : T) = \emptyset$$

We defined the \defname[induced system of inequations]{system of inequations $S$ induced by $\Gamma \stentail M : T$} inductively as follows:
\begin{align*}
   Ineq(\Gamma \stentail M : T) = Ineq'(\Gamma \stentail M : T) & \mbox{if $M$ is an abstraction}\\
   Ineq(\Gamma \stentail M : T) = Ineq'(\Gamma \stentail x : T)
\union \Union_{z:A \in \Gamma \zand z\in fv(M)} \{\ord A \geq \ord T \}
& \mbox{if $M$ is an applciation}
\end{align*}

\end{definition}

\begin{definition} We call \defname{System of inequation induced}
\end{definition}

\begin{proposition}
Let $M \in \Lambda$ be an untyped term. Then
$\Gamma \sentail M : T$ iff $\Gamma \stentail M : T$
\end{proposition}

\subsection{Type checking}



\subsection{The type inhabitation problem}

It is well known that the simply typed lambda calculus corresponds
to intuitionistic implicative logic via the Curry-Howard
isomorphism. The theorems of the logic correspond to inhabited
types; further every inhabitant of a type represents a proof of the
corresponding formula. Similarly, we can consider the fragment of
intuitionistic implicative logic that corresponds to the safe lambda
calculus under the Curry-Howard isomorphism. We call it the
\emph{safe fragment of intuitionistic implicative logic}.

An obvious first question is to compare the reasoning power of these
two logics, in other words, to determine which types are inhabited
in the lambda calculus but not in the safe lambda
calculus.\footnote{This problem was raised to our attention by Ugo
dal Lago.}

If types are generated from a single atom $o$, then there is a
positive answer: every type generated from one atom that is
inhabited in the lambda calculus is also inhabited in the safe
lambda calculus. Indeed, one can transform any unsafe inhabitant $M$
into a safe one of the same type as follows: Compute the eta-long
beta normal form of $M$. Let $x$ be an occurrence of a ground-type
variable in a subterm of the form $\lambda \overline{x} . C[x]$
where $\lambda \overline{x}$ is the binder of $x$ and for some
context $C[\_~]$ different from the identity $C[R]=R$. We replace
the subterm $\lambda \overline{x} . C[x]$ by $\lambda \overline{x}.
x$ in $M$. This transformation is sound because both $C[x]$ and $x$
are of the same ground type. We repeat this procedure until the term
stabilizes. This procedure clearly terminates since the size of the
term decreases strictly after each step. The final term obtained is
safe and of the same type as $M$.

This argument cannot be generalized to types generated from multiple
atoms. In fact there are order-$3$ types with only $2$ atoms that
are inhabited in the simply typed lambda calculus but not in the
safe lambda calculus. Take for instance the order-$3$ type
 $( ((b, a), b),  ((a, b), a),  a)$ for some distinct atoms $a$ and $b$. It is only inhabited by the following family of terms which are all unsafe:
 \begin{align*}
& \lambda f g . g (\lambda x_1 . f (\lambda y_1 . x_1)) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . y_1))) \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . x_i))) \qquad\mbox{where $i = 1, 2$} \\
&\lambda f g . g (\lambda x_1 . f (\lambda y_1 . g (\lambda x_2 . f (\lambda y_2 . g (\lambda x_3 . y_i))) \qquad\mbox{where $i = 1, 2$} \\
&\ldots
\end{align*}

Another example is the type of function composition. Take three
distinct atoms $a$, $b$ and $c$. For any $i,j,k\in\nat$, we write
$\sigma(i,j,k)$ to denote the type
$$\sigma(i,j,k) \equiv (i_a \typear j_b) \typear (j_b \typear k_c) \typear i_a \typear
k_c \ .$$
where $(n+1)_a$ denotes the type $ (\ldots ((a\typear a)\typear a) \ldots) \typear a$ containing $n$ occurrence of $a$ as defined in Sec.\ \ref{sec:simpletype}.

For all $i$, $j$, $k$, this type is inhabited in the lambda calculus
by the ``function composition term'':
$$\lambda x y z w . y (x z) $$
which is safe if and only if $i\geq j$. Suppose that $i<j$ then the type
$\sigma(i,j,k)$ may still be safely inhabited. For instance
$\sigma(1,3,4)$ is inhabited by the safe term
$$ \lambda x^{1_a \typear 3_b} y^{3_b \typear 4_c} z^{1_c} w^{3_c} . y (x (\lambda u^a . u)) \ .$$
The order-$4$ type $\sigma(0,2,0)$, however, is only inhabited by the unsafe term $\lambda x y z w. y (x z) $.


Statman showed in \cite{Statman1979} that the problem of deciding
whether a type \emph{defined over an infinite number of ground
atoms} is inhabited (or equivalently of deciding validity of an
intuitionistic implicative formula) is PSPACE-complete. The previous
observations suggest that the validity problem for the safe fragment
of implicative logic may not be PSPACE-hard.


\section{Safe combinators}

\todo{typset my notes on safe combinators}
