% -*- TeX -*- -*- Soft -*-
As it was mentioned in the background chapter, \emph{safety} was origially introduced in \citep{KNU02} as a syntactical restriction for higher-order grammars in order to study
decidability of Monadic Second Order theory over infinite trees generated by this kind of device. This chapter presents an adaptation and generalization of this syntactic restriction to the lambda calculus, giving rise to what we call the ``\emph{safe lambda calculus}''. We then extend this generalization to the languages \pcf\ and \ialgol.


\emph{Related work:} A first attempt to adapt the safety restriction to the lambda calculus was made in \cite{DBLP:conf/fossacs/AehligMO05} by Aehlig, de Miranda and Ong. The calculus presented here is more general (no condition is imposed on types and use of $\Sigma$-constants of
any order is allowed) and much easier to understand.


\section{Definition and properties}
\label{sec:safe}


\subsection{Safety adapted to the lambda calculus}
We assume a set $\Xi$ of higher-order constants. We use sequents of
the form $\Gamma \vdash_\$^\Xi M : A$ to represent term-in-context
where $\Gamma$ is the context and $A$ is the type of $M$. For
convenience, we shall omit the superscript from $\sentail^\Xi$
whenever the set of constants $\Xi$ is clear from the context. The
subscript in $\vdash_\$^\Xi$ specifies which type system we are
using to form the judgment: we use the subscript `st' to refer to
the traditional system of rules of the Church-style simply-typed
lambda calculus augmented with constants from $\Xi$. In the
following we will use new subscripts for each type system that we
introduce. For simplicity we write $(A_1, \cdots, A_n, B)$ to mean
$A_1 \typear \cdots \typear A_n \typear B$, where $B$ is not
necessarily ground. It will be convenient to use the following abbreviation for types: $0$ for the base type $o$, and
for $k\geq 0$: $(k+1) = k \typear o$.

\begin{definition}
\label{def:safelambda}
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus. It is defined as the set of judgments of the form $\Gamma \sentail M : A$ that are derivable from the following Church-style system of rules:
$$ \rulename{var} \ \rulef{}{x : A\sentail x : A} \qquad
\rulename{const} \ \rulef{}{\sentail f : A}~f \in \Xi \qquad
\rulename{wk} \ \rulef{\Gamma \sentail s : A}{\Delta \sentail s : A} \quad
\Gamma \subset \Delta$$

$$ \rulename{app_{as}} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \asappentail s~t_1 \ldots t_n : B} $$

$$ \rulename{app} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \sentail s~t_1 \ldots t_n : B} \quad \ord\Gamma \geq \ord B$$

$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail s : B} {\Gamma \sentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord\Gamma \geq \ord{(A_1, \ldots ,A_n,B)}
$$
\smallskip

\noindent where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$ and for $S\subseteq \nat$, $u\in\nat$, ``$S \geq u$'' means that $u$ is a lower-bound of $S$. Terms typed with the entailment ``$\sentail$'' are the safe terms and those typed with $\asentail$ are the ``almost safe'' terms.

\noindent \item The sub-system that is defined by the same rules in
(i), such that all types that occur in them are homogeneous (Sec.\ \ref{sec:safetygrammar}), is called
the \defname{homogeneous safe lambda calculus}.
\end{inparaenum}
\end{definition}
We give a brief account of the homogeneous safe lambda calculus in Sec.\ \ref{sec:safe_homog}.
\smallskip

The safe lambda calculus deviates from the standard definition of
the simply-typed lambda calculus in a number of ways. First the rules $\rulename{app}$ and $\rulename{abs}$ respectively can perform multiple applications and abstract several variables at once. (Of course this feature alone does not alter expressivity.) Crucially,
the side conditions in the application rule and abstraction rule require the variables in the typing context to have orders no smaller than that of the term being formed.
Safe terms can be applied together using the rule $\rulename{app_{as}}$, but the resulting term is only ``almost-safe'', it can then be turned into  a safe term using the abstraction rule. We do not impose any constraint on types. In particular, type-homogeneity, which was an
assumption of the original definition of safe grammars \cite{KNU02}, is not required here. Another difference is that we allow $\Xi$-constants to have
arbitrary higher-order types.

\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 \equiv \lambda f . f (\lambda x . f (\lambda y . y
))$ and $M_2 \equiv \lambda f . f (\lambda x . f (\lambda y .x ))$ where
$x,y:o$, $f:\tau$ and $\tau=((o,o),o)$. The term $M_2$ is not safe because in the
subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{(\lambda y . x)} = 1$.  On the other hand, $M_1$
is safe as the following proof tree shows:
\begin{mathpar}
\inferrule* [Left=\rulenamet{abs}]
    {\inferrule* [Left=\rulenamet{app}]
        {\inferrule* [Left=\rulenamet{var}]{ }{f:\tau \sentail f:\tau}
         \qquad
         \inferrule* [Right=\rulenamet{abs}]
             {\inferrule* [Right=\rulenamet{app}]
                {\inferrule* [Left=\rulenamet{wk}]
                    {\inferrule*[Left=\rulenamet{var}]{ }{f:\tau \sentail f:\tau}}
                    {f:\tau, x:o \sentail f:\tau}
                 \qquad
                 \inferrule* [Right=\rulenamet{wk}]
                    {\inferrule* [Right=\rulenamet{abs}]
                            {\inferrule* [Right=\rulenamet{var}]{ }{y:o \sentail y:o}}
                            {y:o \sentail \lambda y . y :(o,o)}}
                    {f:\tau , x:o \sentail \lambda y .y:(o,o) }
                }
                {f:\tau, x:o \sentail f (\lambda y .y ) :o}
            }
            { f:\tau  \sentail \lambda x . f (\lambda y .y ):(o,o)}
       }
       { f:\tau \sentail f (\lambda x . f (\lambda y .y )) :o}
  }
  {\sentail M_1 \equiv \lambda f . f (\lambda x . f (\lambda y .y )) :\tau\typear o}
\end{mathpar}
\end{example}

\begin{example}
The term
$ f:(1,1,o) \asappentail (\lambda \varphi \theta . \varphi (\lambda x . x)) (f (\lambda x .x)) \equiv M : 3$
is almost safe but $ \sentail \lambda f. M :((1,1,o),3) $ is safe.
\end{example}


It is easy to see that valid typing judgements of the safe lambda
calculus satisfy the following simple invariant:
\begin{lemma}[Basic property]
\label{lem:ordfreevar}
If $\Gamma \sentail M : A$ then every variable in $\Gamma$ occurring
free in $M$ has order at least $\ord(M)$.
\end{lemma}
When a term is unsafe, we may highlight the source of its unsafety by underlining one of its subterm and some free occurrence of a variable in that subterm that does not verify the condition of the previous Lemma. (Sometimes we only underline the variable.) For instance the term $\lambda f . f (\lambda x . f (\underline{\lambda y .\underline{x}}))$ is unsafe because the subterm $\lambda y .x$ has order greater that the order of the variable $x$ occurring free in it.
\smallskip


Observe that the converse of the previous lemma does not hold: take the simply-typed term $\lambda y z. (\lambda x . y ) z$ with $x,y,z:o$. This term is closed therefore it trivially satisfies the condition in the conclusion of the previous lemma, but it is not safe because the variable $y$ is not abstracted by the ``$\lambda x$'' abstraction.
Even for applicative term the converse does not hold: for instance the unsafe term $f:2, g:1, y:o \stentail f (\underline{g \underline{y}}) : o$ verifies the condition of the lemma.
\smallskip




When restricted to the homogeneously-typed sub-system, the safe lambda calculus captures the original notion of safety due to Knapik \emph{et al.}~in the context of higher-order grammars (Def.\ \ref{def:safegrammar}):

\begin{proposition}
\label{prop:safegram_safelmd}
Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe (in the original sense of Knapik \emph{et al.}) if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \sentail^{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} safe lambda calculus.
\end{proposition}
\proof
We show by induction that \begin{asparaenum}
\item  $z_1,\ldots, z_m \asappentail t:A$ is a valid judgment of the homogeneous safe lambda calculus containing no abstraction if and only if in the Knapik sense, all the occurrences of unsafe subterms of $t$ are safe occurrences.
\item $z_1,\ldots, z_m \sentail t:A$ is a valid judgment of the homogeneous safe lambda calculus containing no abstraction if and only if in the Knapik sense, all the occurrences of unsafe subterms of $t$ are safe occurrences, and all parameters occurring in $t$ have order greater than $\ord{t}$. \end{asparaenum}
The constant and variable rule are trivial. For the application case: by definition, a term $t_0 \ldots t_n$ is Knapik-safe iff for all $0\leq i \leq n$, all the occurrences of unsafe subterms of $t_i$ are safe occurrences (in the Knapik sense), and for all $1\leq j \leq n$, the operands occurring in $t_j$ have order greater than $\ord{t_j}$. The \rulenamet{app_{as}} rule and the induction hypothesis permit us to conclude.

Now since $e$ is an applicative term of \emph{ground type}, the previous result gives:
$z_1,\ldots, z_m \sentail e:o$ is a valid judgment of the homogeneous safe lambda calculus iff
all the occurrences of unsafe subterms of $e$ are safe occurrences, which is in turn equivalent to ``$F z_1 \ldots z_m \rightarrow e$ is safe'' by definition of Knapik-safety for grammar rules. \qed
\bigskip

\emph{In what sense is the safe lambda calculus safe?} It is an
elementary fact that when performing $\beta$-reduction in the lambda
calculus, one must use capture-\emph{avoiding} substitution, which
is standardly implemented by renaming bound variables afresh upon
each substitution. In the safe lambda calculus, however, variable
capture can never happen (as the following lemma shows).
Substitution can therefore be implemented simply by
capture-\emph{permitting} replacement, without any need for variable
renaming.

In the following, we write $M\captsubst{N}{x}$ to denote
the capture-\emph{permitting} substitution as defined in Def.\ \ref{def:captpermsubst}. We recall that this substitution is done by textually replacing all free occurrences of
$x$ in $M$ by $N$ without performing variable renaming.  In
particular for the abstraction
case, $(\lambda y_1\ldots y_n . M)\captsubst{N}{x}$ is equal to $\lambda y_1\ldots y_n . M\captsubst{N}{x}$ when $x\not\in \{ y_1\ldots y_n \}$, and $\lambda y_1\ldots y_n . M$ otherwise. We use the notation $M\captsubstl N_1/x_1, \ldots, N_p/x_p\captsubstr$ to refer to simultaneous capture-permitting substitution as defined in Def.\ \ref{def:captpermsimultsubst}.

%In the context of the safe lambda calculus, it is formulated as follows:
%\begin{definition}[Simultaneous capture-permitting substitution]
%\label{dfn:safe_simsubst} Let $\Gamma, x_1:A_1, \ldots, x_n:A_n \sentail M :B$, $\Gamma \sentail N_1 :A_1$, \ldots, $\Gamma \sentail N_n :A_n$ be safe terms.
%The \defname{simultaneous capture-permitting substitution} of $N_1$, \ldots, $N_n$ for the variables $x_1$, \ldots, $x_n$ in $M$, written
%$M\captsubstl N_1/x_1, \ldots, N_n/x_n\captsubstr$, abbreviated here $M\captsubst{\overline{N}}{\overline{x}}$, is defined by induction as follows:
%\begin{eqnarray*}
%c \captsubst{\overline{N}}{\overline{x}} &=& c \quad \mbox{ where $c$ is a $\Sigma$-constant}\\
%x_i \captsubst{\overline{N}}{\overline{x}} &=& N_i\\
% y \captsubst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
%(M N_1 \ldots N_l) \captsubst{\overline{N}}{\overline{x}} &=& (M \captsubst{\overline{N}}{\overline{x}}) (N_1 \captsubst{\overline{N}}{\overline{x}}) \ldots  (N_l \captsubst{\overline{N}}{\overline{x}})\\
%(\lambda y_1 \ldots y_p . M)
%\captsubst{\overline{N}}{\overline{x}} &=& \lambda y_1 \ldots y_p . M
%\captsubst{\overline{N} \filter I}{\overline{x} \filter I} \\
%&& \mbox{where } I  = \{ i \in 1..n \ | \ x_i \not \in \{ y_1, \ldots, y_p \} \}
%\end{eqnarray*}
%where for any sequence $s$ is and set of indices $I$, $s \filter I$ denotes the
%subsequence of $s$ obtained by keeping only elements in $s$ whose position index is in $I$.
%\end{definition}

\begin{lemma}[No variable capture lemma]
\label{lem:nocapture} In the safe $\lambda$-calculus, there is
no variable capture when performing the following simultaneous capture-permitting
substitution:
$$ M\{N_1 / x_1 , \cdots, N_n / x_n\} $$
provided that $\Gamma, \overline{x}:\overline{B} \sentail M : A$, $\Gamma \sentail  N_1:B_1,  \cdots ,\Gamma \sentail  N_n : B_n$ are valid judgments of the safe lambda calculus.
\end{lemma}

\begin{proof}
We prove the result by structural induction on $M$. The variable, constant and
weakening cases are trivial.
Otherwise, by Lemma \ref{lem:almostsafe_is_appplicative_safe}, $M$ is of the
  form $\lambda \overline{y} . M_0 \ldots M_m$ where $\overline{y} = y_1
\ldots y_p$, $m,p\geq 0$ and for every $0 \leq i\leq m$, $M_i$ is safe.
The simultaneous capture-permitting substitution gives:
$$M \captsubst{\overline{N}}{\overline{x}} = \lambda \overline{y} . M_0
\captsubst{\overline{N} \filter I}{\overline{x} \filter
I} \ldots M_m
\captsubst{\overline{N} \filter I}{\overline{x} \filter
I} $$
where $I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y}\}$ and for any list $s$, $s \filter I$ denotes the sublist of $s$ obtained by keeping only elements in $s$ whose position index in the list belongs to $I$.


Let $i\in\{0..m\}$. By the induction hypothesis there is no variable capture in $M_i \captsubst{\overline{N} \filter I}{\overline{x} \filter
I}$. Hence variable capture can only happen if the following two conditions are met for some $i \in I$ and $j \in 1..p$: the variable $y_j$
occurs freely in $N_i$, and $x_i$ occurs freely in $P$ . By Lemma \ref{lem:ordfreevar} the later gives:
$$ \ord{y_j} \geq \ord{N_i} = \ord{x_i}$$

Moreover since $i\in I$ we have $x_i \not \in \overline{y}$ therefore $x_i$ occurs freely in the safe term $M \equiv \lambda \overline{y}. M_0 \ldots M_m$, and Lemma \ref{lem:ordfreevar} gives:
$$ \ord{x_i} \geq \ord{\lambda y_1 \ldots y_p . T} \geq 1+ \ord{y_j} > \ord{y_j}$$
which contradicts the previous equation.
\end{proof}


Consequently, in the safe lambda calculus, substitution can be implemented using capture-permitting substitution.


\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \stentail (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    \underline{x}}) : (o,o)\] one should rename the bound variable $x$ to a fresh name to
  prevent the capture of the free occurrence of $x$ in the underlined subterm during substitution. Consequently, by the previous lemma,
  the term is not safe. And indeed the basic property of the safe lambda calculus is not verified because $\ord{x} = 0 < 1
  = \ord{f x}$.
\end{example}

Note that $\lambda$-terms that `satisfy' the No-variable-capture
Lemma are not necessarily safe. For instance the $\beta$-redex in
$\lambda y^o z^o. (\lambda x^o .y) z$ can be contracted using
capture-permitting substitution, even though the term is not safe.

\subsection{Safe beta reduction}

From now on we will use the standard notation $M\subst{N}{x}$ to
denote the substitution of $N$ for $x$ in $M$.  It is understood that,
provided that $M$ and $N$ are safe, this substitution is
capture-permitting.


\begin{lemma}[Substitution Lemma]
\label{lem:subst_preserves_safety}
If $\Gamma, x :A \sentail M : B$ and $\Gamma \sentail N : A$ then $\Gamma \sentail M\subst{N}{x} : B$.
Moreover if $M$ and $N$ are homogeneously safe then so is $M\subst{N}{x}$.
\end{lemma}
\begin{proof}
Suppose that $\Gamma, x:A \sentail M :B$ and $\Gamma \sentail N : A$.
We show $\Gamma \sentail M\subst{N}{x} : B$ by induction
on the proof tree of $\Gamma, x:A \sentail M : B$.
It is trivial for the base cases (variable and constant) and for weakening.
Abstraction case: by definition of safety, $M$ has the form $\lambda \overline{y}. M_0 M_1 \ldots M_p$ for some safe terms $M_k$, $0\leq k \leq p$, $p\geq 0$. By the induction hypothesis, $M_k\subst{N}{x}$ is safe for all $k$.
The rules $\rulename{app_{as}}$ and $\rulename{abs}$ permit us to conclude.
The application cases (\rulenamet{app_{as}} and \rulenamet{app}) are treated similarly.

For the second part: clearly types are preserved by substitution therefore so is type homogeneity.
\end{proof}


\begin{remark}
This result extends immediately to simultaneous substitution:
If $\Gamma, x_1 :A_1, \ldots x_n : A_n  \sentail M : B$
and $\Gamma \sentail N_k : A_k$ for $1\leq k\leq n$ then $\Gamma \sentail
M[N_1/x_1, \ldots, N_n/x_n] : B$.
\end{remark}


It is desirable to have an appropriate notion of reduction for our
calculus. However the standard $\beta$-reduction rule is not
adequate. Indeed, safety is not preserved by $\beta$-reduction as
the following example shows. Suppose that $w,x,y,z : o$ and $f :
(o,o,o) \in \Sigma$ then the safe term $(\lambda x y . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y . f z y}) w$, which is
unsafe since the underlined order-1 subterm contains a free
occurrence of the ground-type $z$. However if we perform one more
reduction we obtain the safe term $f z w$. This suggests
simultaneous contraction of ``consecutive'' $\beta$-redexes. In
order to define this notion of reduction we first introduce the
corresponding notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:

\begin{definition}
Let $l\geq 1$ and $n\geq 1$. We use the abbreviations $\overline{x}$
and $\overline{x}:\overline{A}$  for $x_1 \ldots x_n$ and $x_1:A_1,
\ldots, x_n : A_n$ respectively. A \defname{safe redex} is a safe
term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such
that $M$ is safe and $N_i$ is safe for $1\leq i\leq n$.
\end{definition}
For instance, in the case $n<l$, a safe redex has a derivation tree of the following form:
\begin{mathpar}
  \inferrule* [Left=\rulenamet{app}]
  {
      \inferrule* [Left=\rulenamet{wk}]
      {
          \inferrule* [Left=\rulenamet{abs}]
            {\ldots}
            {\Gamma', \overline{x}:\overline{A} \sentail M : (A_{n+1}, \ldots, A_l, B)}
      }
      {\Gamma \sentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)}
      \\
      \inferrule*
       {\ldots}
       {\Gamma \sentail N_1 :A_1}
%      \\
%      \cdots
      \\
      \inferrule*
       {\ldots}
       {\Gamma \sentail N_l :A_l}
  }
  {\Gamma \sentail (\lambda \overline{x} . M) N_1 \ldots N_l : B}
\end{mathpar}
\smallskip

\begin{example}
The term $(\lambda f . ((\lambda g h . h) a) ) a a$ for some
constant $a:o \rightarrow o$ and variables $x : o$, $f,g,h:o \rightarrow o$ is as safe redex of type $o \rightarrow o$.
This example shows that for a safe redex $(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ we can have $l>n$.
\end{example}


We can now define a notion of reduction for safe terms.
\begin{definition}
\label{dfn:safereduction} We use the abbreviations $\overline{x} =
x_1 \ldots x_n$, $\overline{N} = N_1 \ldots N_l$. The relation
$\beta_s$ (when viewed as a function) is defined on the set of safe
redexes as follows:
\begin{eqnarray*}
  \beta_s &=&
  \{  \ (\lambda \overline{x} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1 \ldots x_l} \mbox{, for $n> l$}
  \} \\
  &\cup&
  \{ \ (\lambda \overline{x}  . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}
where $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution in $M$ of $R_1$,\ldots,$R_k$ for $z_1, \ldots, z_k$.  The
\defname{safe $\beta$-reduction}, written $\betasred$, is the
compatible closure of the relation $\beta_s$ with respect to the
formation rules of the safe lambda calculus.
\end{definition}

\begin{lemma} The safe reduction relation $\betasred$:
\begin{enumerate}[(i)]
\item is a subset of the transitive closure of $\betared$ ($\betasred \subset \betaredtr$);
\item is strongly normalizing;
\item has the unique normal form property;
\item has the Church-Rosser property.
\end{enumerate}
\end{lemma}
\proof
(i) Immediate from the definition: safe $\beta$-reduction is just a multi-step $\beta$-reduction.
(ii) This is because $\betasred \subset \betaredtr$ and, $\betared$ is
strongly normalizing in the simply-typed $\lambda$-calculus. (iii) Clearly, a
safe term has a safe beta-redex iff it has a beta-redex therefore the set
of $\beta_s$-normal forms is equal to the set of $\beta_s$-normal
forms. Hence, the unicity of $\beta$-normal form implies the unicity
of $\beta_s$-normal form. (iv) is a consequence of 1 and 2.
\qed

\begin{lemma}[Subject Reduction]
\label{lem:safered_preserve_safety}
Suppose that $s \betasred t$. Then
$\Gamma \sentail s :A$ implies $\Gamma \sentail t :A$.
\end{lemma}

\proof
  It suffices to show that the relation $\beta_s$ preserves safety.
Suppose that $s\ \beta_s\ t$ where $s$ is the
safe-redex $(\lambda x_1 \ldots x_n . M) N_1
  \ldots N_l $ with $x_1 : B_1, \ldots, x_n: B_n$
and $M$ of type $C$.  W.l.o.g we can assume that the last rule used
to form the term $s$ is \rulenamet{app} (and not the weakening rule
\rulenamet{wk}), thus  we have $\Gamma = fv(s)$, and since $s$ is
safe, Lemma \ref{lem:ordfreevar} gives us $\ord{A} \leq
\ord{\Gamma}$.

Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$. By Lemma
\ref{lem:subst_preserves_safety} we can form the safe term $\Gamma,
x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\sentail M\subst{\overline{N}}{x_1
\ldots x_l} : C$. And since we have $\ord{A} \leq \ord{\Gamma}$, we
can use the \rulenamet{abs} rule to form the safe term $\Gamma
\sentail \lambda x_{l+1} \ldots x_n . M\subst{\overline{N}}{x_1
\ldots x_l} \equiv t : A$.

Suppose $n \leq l$. The Substitution Lemma gives $\Gamma \sentail
M\subst{N_1 \ldots N_n}{\overline{x}} : C$. If $n<l$ then we further apply the rule \rulenamet{app_{as}} to apply the $l-n$ remaining parameters to form the sequent $\Gamma \sentail t :A$.
\qed
\smallskip

\begin{remark}
$\betasred$ \emph{does not} preserves ``unsafety'': Take any safe term $S$ and unsafe term $U$ of the same type $\tau$, then the term $(\lambda x:\tau y:\tau . y) U S :\tau$ is also unsafe but it $\beta_s$-reduces to $S$ which is safe.
\end{remark}

\subsection{Eta-long expansion}

The $\eta$-long normal form (or simply $\eta$-long form) of a term
% (also called \emph{long reduced form}, \emph{$\eta$-normal form} and
% \emph{extensional form} in the literature
% \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding the body of every
lambda abstraction as well as every subterm occurring in an
\emph{operand position} (\ie occurring as the second argument of
some occurrence of the binary application operator). Formally the
\defname{$\eta$-long form}, written $\elnf{t}$, of a term $t:
(A_1,\ldots,A_n,o)$ with $n \geq 0$ is defined by cases according to
the syntactic shape of $t$:
\begin{eqnarray*}
  \elnf{\lambda x . s } &=& \lambda x . \elnf{s} \\
  \elnf{x s_1 \ldots s_m } &=& \lambda \overline{\varphi} . x \elnf{s_1}\ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x . s) s_1 \ldots s_p } &=& \lambda \overline{\varphi} . (\lambda x . \elnf{s}) \elnf{s_1} \ldots \elnf{s_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is either a variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.

\begin{remark}
  This transformation does not introduce
  new redexes therefore the $\eta$-long normal form of a $\beta$-normal
  term is also $\beta$-normal.
\end{remark}

Let us introduce a new typing system:
\begin{definition}
\label{dfn:longsafe}
We define the set of \defname{long-safe terms}
by induction over the following system of rules:
  $$ \rulename{var_l} \ \rulef{}{x : A\lsentail x : A} \qquad
\rulename{const_l} \ \rulef{}{\lsentail f : A}\quad f \in \Xi \qquad
\rulename{wk_l} \ \rulef{\Gamma \lsentail s : A}{\Delta \lsentail s : A}\quad
\Gamma \subset \Delta$$

$$ \rulename{app_l} \ \rulef{\Gamma \lsentail s : (A_1,\ldots,A_n,B)
\quad
  \Gamma \lsentail t_1 : A_1 \quad \ldots \quad \Gamma \lsentail t_n : A_n
} {\Gamma \lsentail s t_1 \ldots t_n : B} \quad
\ord\Gamma \geq \ord B$$

$$ \rulename{abs_l} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \lsentail s : B} {\Gamma \lsentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad
\ord\Gamma\geq \ord{(A_1, \ldots ,A_n,B)} $$
\smallskip

The subscript in $\lsentail$ stands for ``long''.
\end{definition}
The terminology ``long-safe'' is deliberately suggestive of a forthcoming lemma. Note that long-safe terms are not necessarily in $\eta$-long normal form.

Observe that the system of rules from Def.~\ref{dfn:longsafe} is a sub-system of the typing system of Def.~\ref{def:safelambda} where the application rule is  restricted the same way as the abstraction rule \ie it can perform multiple applications at once provided that all the variables in the context of the resulting term have order greater than the order of the term itself. Thus we clearly have:
\begin{lemma}
\label{lem:longsafe_imp_safe}
If a term is long-safe then it is safe.
\end{lemma}
\smallskip

In general, long-safety is not preserved by $\eta$-expansion: for
instance we have
% $f:o,o \lsentail f$ but $f:o,o \not \lsentail \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\lsentail \lambda y^o z^o . y : (o,o,o)$ but
$\not \lsentail\lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$.
On the other hand,  $\eta$-reduction preserves long-safety:

\begin{lemma}[$\eta$-reduction of one variable preserves long-safety]
\label{lem:etared_preserve_longsafety}
  $\Gamma \lsentail \lambda \varphi . s \varphi :A $ with $\varphi$ not
  occurring free in $s$ implies $\Gamma \lsentail s :A$.
\end{lemma}
\proof
  Suppose $\Gamma \lsentail \lambda \varphi . s \varphi :A$. If $s$ is an  abstraction then by construction of the safe term $\lambda \varphi . s \varphi$, $s$ is necessarily safe.  If $s = N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for any $z\in fv(\lambda \varphi . s \varphi)$, $\ord{z} \geq
  \ord{\lambda \varphi . s \varphi} = \ord{s}$. Since  $\varphi$ does not occur free in $s$ we have $fv(s) = fv(\lambda \varphi . s \varphi)$, thus we can use the application rule to form $fv(s) \lsentail N_0 \ldots N_p : A$. The weakening rules permits us to conclude $\Gamma \lsentail s :A$. \qed
\smallskip

\begin{lemma}[Long-safety is preserved by $\eta$-long expansion]
\label{lem:longsafe_imp_elnf_longsafe}
$\Gamma \lsentail s :A$ then $\Gamma \lsentail \elnf{s} :A$.
\end{lemma}
\proof
 First we observe that for any variable or constant $x:A$ we have $x:A \lsentail \elnf{x} :A$. We show this by induction on $\ord{x}$.
It is verified for any ground type variable $x$
since $x = \elnf{x}$.
Step case: $x:A$ with $A=(A_1, \ldots, A_n,o)$ and $n>0$. Let $\varphi_i:A_i$ be fresh variables for $1\leq i\leq n$.
Since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i :A_i \lsentail \elnf{\varphi_i} : A_i$. Using \rulenamet{wk_l} we obtain $x:A, \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \lsentail x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \lsentail \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} =
  \elnf{x} :A$.


We now prove the lemma by induction on $s$.
The base case is covered by the previous observation.
\emph{Step case:}
\begin{compactitem}
\item $s = x s_1 \ldots s_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $s_i : B_i$ for $1 \leq i \leq
  m$.  Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \lsentail \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \lsentail x s_1 \ldots s_m : A$ is formed using the \rulenamet{app_l} rule, each $s_j$ must be long-safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \lsentail \elnf{s_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \lsentail \elnf{s_j} : B_j$.  The \rulenamet{app_l}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \lsentail x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the \rulenamet{abs_l} rule gives $\Gamma \lsentail \lambda \overline{\varphi} . x
  \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} = \elnf{s} : A$, the side-condition of \rulenamet{abs_l} being verified since $\ord{\elnf{s}} = \ord{s}$.


\item $s = t s_0 \ldots s_m$ where $t$ is an abstraction.
For some fresh variables $\varphi_1$, \ldots, $\varphi_n$
we have $\elnf{s} = \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n}$. Again, using the induction hypothesis we can easily derive $\Gamma \lsentail
 \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : A$.

\item $s = \lambda \overline{\eta} . t $ where
$\overline{\eta} : \overline{B}$ and $t:C$ is not an abstraction. The induction hypothesis gives $\Gamma,
  \overline{\eta} : \overline{B} \lsentail \elnf{t} : C$ and using
\rulenamet{abs_l} we get $\Gamma \lsentail \lambda \overline{\eta} . \elnf{t} = \elnf{s} : A$.  \qed
\end{compactitem}

\begin{remark}\hfill
\begin{enumerate}
\item
The converse of this lemma does not hold in general: Performing
$\eta$-reduction over a large abstraction does not in general
preserve long-safety. This does not contradict Lemma
  \ref{lem:etared_preserve_longsafety} which states that safety is
  preserved when performing $\eta$-reduction on an abstraction
  of a \emph{single} variable. The simplest counter-example is
  the
 term $f^{(o,o,o)} \stentail \lambda x^o . f \underline{x}$ which is not long-safe and
whose eta-long normal form $f^{(o,o,o)} \lsentail \lambda x^o y^o .
f x y$ is long-safe. Even for closed terms the converse does not
hold: $\lambda f^{(o,o,o)} g^{((o,o,o),o)} . g(\lambda x^o . f
\underline{x})$ is not long-safe but its eta-normal form $\lambda f^{(o,o,o)}
g^{((o,o,o),o)} . g(\lambda x^o y^o. f x y)$ is long-safe. In fact
even the closed $\beta\eta$-normal term $\lambda
f^{(o,(o,o),o,o)} g^{((o,o),o,o,o),o)} . g(\lambda y^{(o,o)} x^o
. f \underline{x} y)$ which is not long-safe has a long-safe $\eta$-long normal form!

  \item After performing $\eta$-long expansion of a term, all the occurrences of the application rule are made long-safe. Thus if a term remains not long-safe after $\eta$-long expansion, this means that
  some variable occurrence is not bound by the
  first following application of the \rulenamet{abs} rule in the
  typing tree.
  \end{enumerate}
\end{remark}

\begin{lemma}
  \label{lem:safe_iff_etalong_lsafe}
  A simply-typed term is safe if and only if its $\eta$-long normal form is long-safe.
\end{lemma}
\proof Let $\Gamma \stentail M : T$. We want to show that we have $\Gamma \sentail M : T$ if and only if $\Gamma \lsentail \elnf{M} : T$.
`Only if': Take a safe term $\Gamma \sentail M:(A_1,\ldots,A_l,o)$.
We show the result by induction on the structure of $M$.
The base cases and weakening case are trivial.
Abstraction: $M$ has the form $\lambda \overline y . M_0 \ldots M_p$ for some safe terms $M_k$, $0\leq k \leq p$, $p\geq 0$.
By the subject reduction lemma we have $fv(M) \sentail M:(A_1,\ldots,A_l,o)$. The $\eta$-long expansion of $M$
is $\lambda \overline y x_1 .. x_l . \elnf{M} \elnf{x_1} \dots \elnf{x_l}$ for some variables
$x_1:A_1, \ldots, x_l:A_l$ fresh in $M$.
Let $k$ range in $\{1..l\}$. By Lemma \ref{lem:longsafe_imp_elnf_longsafe} and \ref{lem:longsafe_imp_safe}, each $\elnf{x_k}$ is safe, and by the I.H.\ $\elnf{M}$ is also safe. Therefore by $\rulename{app_{as}}$, so is $\elnf{M} \elnf{x_1} \ldots \elnf{x_l}$.
By Lemma \ref{lem:ordfreevar}, all the free variables of $M$ have order greater than $\ord{(A_1,\ldots,A_l,o)}$, hence we can use the abstraction rule to form the judgment
$ fv(M) \sentail \lambda \overline y x_1 .. x_l . \elnf{M} \elnf{x_1} \ldots \elnf{x_l} : (A_1,\ldots,A_l,o)$ and the weakening rule permits us to conclude.
The application case is treated identically.


 For the `if' part we proceed by
induction on the structure of the simply-typed term $\Gamma
\stentail M : T$: The variable, constant and weakening cases are
trivial. Suppose that $M$ is an application of the form $x s_1
\ldots s_m : A$ for $m\geq 1$. Its $\eta$-long normal form is of the
form $x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
\elnf{\varphi_m}: o$ for some fresh variables $\varphi_1$, \ldots
$\varphi_m$. By assumption this term is long-safe term therefore we
have $\ord{A}\leq\ord{\Gamma}$ and for $1\leq i \leq m$,
$\elnf{s_i}$ is also long-safe. By the induction hypothesis this
implies that the $s_i$ are all safe. We can then form the judgment
$\Gamma \sentail x s_1 \ldots s_m : A$ using the rules
$\rulename{var}$ and $\rulename{app}$ (this is allowed since we have
$\ord{A}\leq\ord{\Gamma}$). The case $M\cong (\lambda x. s) s_1
\ldots s_m$ for $m\geq 1$ is treated identically.

Suppose that $M \cong \lambda \overline{x} . s : A$. By assumption,
its  $\eta$-long n.f.\ $\lambda \overline{x} \overline{\varphi} .
\elnf{s} \elnf{\varphi_1} \ldots \elnf{\varphi_m}: A$ (for some
fresh variables $\varphi_1$ \ldots $\varphi_m$) is long-safe. Thus
we have $\ord{A}\leq\ord{\Gamma}$. Furthermore the long-safe subterm
$\elnf{s} \elnf{\varphi_1} \ldots \elnf{\varphi_m}$ is precisely the
eta-long expansion of $s\varphi_1 \ldots \varphi_m : o$ therefore by
the induction hypothesis we have that $s \varphi_1 \ldots \varphi_m
:o$ is safe. Since the $\varphi_i$'s are all safe (by rule
$\rulename{var}$), we can ``peal-off'' $m$ applications (performed using
the rules $\rulename{app_{as}}$ or $\rulename{app}$) from the sequent $\Gamma,
\overline{x}, \overline{\varphi} \sentail s \varphi_1 \ldots
\varphi_m :o$ which gives us the sequent $\Gamma, \overline{x},
\overline{\varphi} \asentail s : A$. Since the $\overline{\varphi}$
variables are fresh for $s$, we can further peal-off $m$
applications of the weakening rule to obtain the judgment $\Gamma,
\overline{x} \sentail s : A$. Finally we obtain $\Gamma \sentail
\lambda \overline{x} . s : A$ using the rule $\rulename{abs}$ (which
is permitted since we have $\ord{A}\leq\ord{\Gamma}$). \qed
\smallskip






\begin{proposition}
\label{prop:safe_iff_elnfsafe}
A term is safe if and only if its $\eta$-long normal form is safe.
\end{proposition}
\proof
`If':
\begin{align*}
  \Gamma \sentail \elnf{M}:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies   \Gamma \sentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (if).}
\end{align*}
`Only if':
\begin{align*}
  \Gamma \sentail M:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies \Gamma \sentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:longsafe_imp_safe}\qquad }
\end{align*}
\qed

% The following statement is wrong:
%``In the homogeneous safe lambda calculus, the notion of safe terms and long-safe terms coincide''
% Because of the example given earlier (which is homogeneously typed)


\subsection{Almost safety}
\label{sec:almostsafety}
We now give an alternative presentation of the safe lambda calculus.
Consider the following system of rules:
$$ \rulename{var_{as}} \ \rulef{}{x : A\asappentail x : A}
\qquad
\rulename{app_{as}} \ \rulef{\Gamma \asappentail s : A\typear B
\quad \Gamma \sentail t : A} {\Gamma \asappentail s~t : B}
\qquad
\rulename{abs_{as}}\  \rulef{\dps  \Gamma, x : A \asentail s : B} {\Gamma \asentail \lambda x  . s : A\typear B}
$$

$$
\rulename{const_{as}} \ \rulef{}{\asappentail f : A}~f \in \Xi \qquad
\rulename{wk_{as}} \ \rulef{\Gamma \asappentail s : A}{\Delta \asappentail s : A} \quad
\Gamma \subset \Delta
\qquad
\rulename{wk} \ \rulef{\Gamma \sentail s : A}{\Delta \sentail s : A} \quad
\Gamma \subset \Delta
$$

$$
\rulename{\delta} \ \rulef{\Gamma \sentail s : A}{\Gamma \asentail s : A}
\qquad
\rulename{\delta'} \ \rulef{\Gamma \asappentail s : A}{\Gamma \asentail s : A}
\qquad
\rulename{\rho}\
\rulef{\Gamma \asentail s : A}{\Gamma \sentail s : A}\
\ord\Gamma\geq\ord A \ .
$$


It is easy to see that this system of rules is equivalent to the one from
Def.\ \ref{def:safelambda} in the sense that both systems generate the same set of judgments of the form $\Gamma \sentail M : T$. The above system, however, has the advantage of decomposing the application and abstraction rules into atomic steps where only one variable is abstracted at a time and only two terms are applied together at a time.

\begin{definition}
Terms typed with the entailment operator $\asentail$  are called \defname{almost safe} terms. Terms typed with the entailment operator $\asappentail$ are distinguished almost safe terms called \defname{almost safe applications}.
\end{definition}


The intuition behind these rules is as follows: almost safe terms represent terms that are not safe but which can become safe if sufficiently many safe terms are applied to them or if sufficiently many variables are abstracted. The rule \rulenamet{app_{as}} is used to form applications in which each applied term is safe:
\begin{lemma}\hfill
\label{lem:almostsafe_is_appplicative_safe}
\begin{enumerate}
  \item
If $\Gamma \asappentail M : T$ then $M \equiv N_0
\ldots N_m$ for some $m\geq 0$ where $N_i$ is safe
for every $0 \leq i\leq m$;

\item If $\Gamma \asentail M : T$ then $M\equiv\lambda x_1 \ldots x_n . N_0 \ldots N_m$ for some $n, m\geq 0$ where $N_i$ is safe for every $0 \leq i\leq m$.
\end{enumerate}
\end{lemma}
This results follows immediately from the definition of the rules.

The rule \rulenamet{abs_{as}} is nothing less than the standard abstraction rule of the lambda calculus. As soon as the context and the type of the term being formed respect the safety condition (\ie all the context variables have order greater that the order of the type), the term can be marked as safe. This is done using the rule \rulenamet{\rho}. Together with the rule \rulenamet{\delta'} this implies that the closure of an almost safe term is always safe:
\begin{lemma}
  \label{lem:closealmostsafe_is_safe}
  If $fv(M) \asappentail M : T$ then $\sentail \closure{M} : T$.
\end{lemma}


The two weakening rules \rulenamet{wk} and \rulenamet{wk_{as}} permit one to extend the context of a safe term or an almost safe application.
We could have added a third rule to allow weakening for almost safe terms $\Gamma \asentail M : T$ as well. This is however not necessary because this kind of weakening can always be eliminated. (In particular if the term is an abstraction then we can instead apply the rule \rulenamet{wk_{as}} just before the abstraction rule).

A term is almost safe if and only if its eta-long normal form is safe:
\begin{lemma}
\label{lem:almostsafe_iff_etalnf_almostsafe}
  $\Gamma \asentail M : T$ if and only if $\Gamma \asentail \etalnf{M} : T$.
\end{lemma}
\begin{proof}
\emph{Only if:} Let $\Gamma \asentail M :T$ be an almost safe term.
We proceed by induction on $M$.
Suppose that the last rule used is \rulenamet{\delta'}.
Then by Lemma \ref{lem:almostsafe_is_appplicative_safe}
$M$ is an application $N_0 N_1 \ldots N_k : (A_1,\ldots,A_n)$ with $k\geq 0$. Let $\varphi_i:A_i$ for $i\in\{1..n\}$ be fresh variables, using the
rules \rulenamet{var_{as}}, \rulenamet{wk_{as}}, \rulenamet{app_{as}} and \rulenamet{abs_{as}} we can build the almost safe term $\Gamma \asentail \lambda \varphi_1 \ldots \varphi_n . N_0 N_1 \ldots N_k \varphi_1 \ldots \varphi_n :T$.

If the last rule used is \rulenamet{\delta} then
$M$ is safe therefore by Proposition \ref{prop:safe_iff_elnfsafe}, its eta-long normal form is safe and therefore by \rulenamet{\delta} it is also almost safe.

If the last rule used is \rulenamet{abs_{as}} then by the induction hypothesis the eta-long nf of the premise is almost safe so we can conclude using \rulenamet{abs_{as}}.

\emph{If:} It is again a proof by structural induction on the eta-long normal form. The basic idea is that the rule \rulenamet{abs_{as}} (resp.\ \rulenamet{app_{app}}) allows us to ``peal-off'' the lambda-abstraction (resp.\ extra operands) introduced during the eta-expansion.
\end{proof}
The two preceding lemmas show that the closure of the eta-long expansion of an almost safe term is safe. This explains the expression ``almost safe'': an almost safe is semantically safe in the sense that it is (extensionally) equivalent to a safe term; on the other hand it is syntactically unsafe since it cannot appear as an operand of an application inside a larger safe term.


\begin{lemma}
\label{lem:betasred_preserves_almostsafety}
Safe beta reduction preserves almost safety.
\end{lemma}
\proof
Let $M$ be an almost safe term. By Lemma \ref{lem:almostsafe_is_appplicative_safe}, $M\equiv\lambda x_1 \ldots x_n . N_0 \ldots N_m$ for some $n, m\geq 0$ where $N_i$ is safe for every $0 \leq i\leq m$.
Suppose that $M \betasred M'$. There are two cases:
If the reduced redex occurs in some $N_i$ for $0 \leq i \leq m$ then we have $N \equiv \lambda x_1 \ldots x_n . N_0 \ldots N'_i \ldots N_m$ where $N_i \betasred N'_i$ for some $N'_i$. Since safety is preserved by safe reduction (Lemma \ref{lem:safered_preserve_safety}), $N'_i$ is safe. Hence we can conclude using the application and abstraction rule.
The second case is when the redex is $N_1 \ldots N_q$ for some $1 \leq q\leq m$. This mean that $N_0$ is of the form $\lambda y_1 \ldots y_q. P$ for some safe term $P$, and $M' \equiv P[N_1/y_1 \ldots N_q/y_q] N_{q+1} \ldots N_m$. The substitution lemma \ref{lem:subst_preserves_safety} and the application and abstraction rule permit to conclude.
\qed




\section{Parameterized safe lambda calculus}

Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \typear A$. We call \defname{type-ranking function}, or just ranking function, any function
${\sf rank} : Types \funto (L, \leq)$ for some set $L$ and preorder $\leq$ verifying the condition:
 $${\sf rank}(B) \leq {\sf rank}(A\typear B) \ .$$

\begin{example}
The followings are type-ranking functions:
\begin{itemize}
\item ${\sf ord} : Types \funto (\nat,\leq)$ with $\ord{o} = 0$
and $\ord{A \typear B} = \max(\ord{A}+1, \ord{B})$;
\item ${\sf height} : Types \funto (\nat,\leq)$ with
$\slheight{A \typear B} = 1 + \max(\slheight{A}, \slheight{B})$ and
$\slheight{o} = 0$ ;
\item ${\sf arity} : Types \funto (\nat,\leq)$ with $\arity{o} = 0$
and $\arity{A_1, \cdots, A_n} = n$;
\item ${\sf size} : Types \funto (\nat,\leq)$ with ${\sf size}(o) = 0$
and ${\sf size}(A \typear B) = {\sf size}(A) + {\sf size}(B)$.
\end{itemize}
The product of two type-ranking function is also a type-ranking function with respect to the lexicographic ordering. For instance ${\sf order} \times {\sf arity} : Types \funto (\nat \times \nat,\leq)$ is a type-ranking function.
\end{example}

\emph{Question: We have defined the safe lambda calculus with respect to the type-ordering function $\ord$. Does it make sense to define a version of the safe lambda calculus parameterized over a ranking function different from $\ord$?}

Such calculus can be defined by replacing the use of the function $\ord$ by another ranking function in the formation rules of the calculus.
Similarly, it is possible to generalize the homogeneity condition to other type-ranking function: We say that a type is {\sf rank}-homogeneous if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition that $\rank{A_1} \geq \rank{A_2}\geq \cdots \geq \rank{A_n}$ and each $A_1$, \ldots, $A_n$ is {\sf rank}-homogeneous. Such parameterization gives rise to the homogeneous $\sf rank$-safe lambda calculus.


\todo{Show that rank-safe lambda calculus makes only sense if rank is the type-order function: \ie such generalization is of no use.}


