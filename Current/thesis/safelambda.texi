% -*- TeX -*- -*- Soft -*-
 The \emph{safety} constraint was originally introduced as a syntactical restriction in order to study decidability of Monadic Second Order theories over infinite trees generated by higher-order recursion schemes \citep{KNU02}. The good algorithmic properties of safety in the setting of higher-order recursion schemes (see background chapter) motivate further investigations in the more general setting of the simply-typed lambda calculus. This chapter presents a generalization of the safety syntactic restriction to the lambda calculus, giving rise to what we call the ``\emph{safe lambda calculus}''.

The first part introduces the typing system of the safe lambda calculus. As remarked in the background chapter, a higher-order grammar can be viewed as a closed simply-typed lambda-term; however this term has a particular shape owing to the structure of the grammatical rules: the right-hand side of a rule is an \emph{applicative} term (\ie, containing no lambda abstraction) of ground type. An adaptation of safety to the lambda calculus setting, however, ought to handle all possible terms, including those containing lambda-abstraction. Our notion of safety is defined in such a way.

The typing system of the safe lambda calculus is a small variation of the simply-typed lambda calculus where the abstraction rule is able to abstract more than one variable at a time but with an extra constraint: the free variables in the resulting term must have order greater than the term itself. The application rule is similarly constrained. The connection with safe higher-order grammars is then made evident by restricting our calculus to pure applicative term: an applicative term of ground type is typable in the safe lambda calculus if and only if it is safe in the sense of Knapik et~al.

We study how terms of this language behave with respect to the term conversions commonly studied in the lambda calculus: we adapt the notion of beta-reduction to ensure that a version of the context-reduction lemma holds---safe terms reduce to safe terms---and we show that the conversion to eta-long normal form preserves safety.

Next, in an attempt to quantify the impact of the safety constraint, we
look at the complexity of the beta-equivalence problem---Given two safe terms, are they beta-equivalent?
The problem is known to be non-elementary for unrestricted terms \cite{Statman:1979:TLE}.
We show PSPACE-hardness for the safe case by reduction from the True Quantifier Boolean Formula problem (TQBF).
This PSPACE-complete problem is encodable in the order-$3$ fragment of the simply-typed lambda calculus, but
our encoding in the safe lambda calculus makes use of the entire type-hierarchy. We conjecture the problem to be elementary recursive.

The loss of expressivity caused by safety is then characterized in terms of the numeric functions that are representable: we show that they are precisely the multivariate polynomials \emph{without} the conditional operator. We then give a similar characterization in terms of word functions representable.

We then consider classical typing problems in the setting of the safe lambda calculus: we show that type-checking and typability are decidable and we observe that type inhabitation is (at least) semi-decidable.

To conclude we consider extensions to the simply-typed lambda calculus such as recursion and imperative features. We define the notion of safety in the context of the languages \pcf\ and Idealized Algol.
\medskip

\begin{remark}[Related work] A first attempt to adapt the safety restriction to the lambda calculus was made by Aehlig et~al.\ in an unpublished technical report \cite{safety-mirlong2004}. The calculus that we present here is both simpler (the typing system is just a slight variation of the simply-typed lambda calculus) and more general (no condition is imposed on types and use of $\Sigma$-constants of any order is allowed).
\end{remark}


\section{Definition and properties}
\label{sec:safe}


\subsection{Safety adapted to the lambda calculus}
We use sequents of the form $\Gamma \entail_\$ M : A$ to represent term-in-context where $\Gamma$ is a typing-context (a consistent set of typing assumptions), $A$ is the type and $M$ is a term (either annotated or untyped). As defined in Sec.~\ref{sec:lambdacalculus},
we write $\Lambda$ for the set of untyped lambda-terms and $\Lambda_{\mathbb{T}}$ for the set of
lambda-terms annotated with simple types $\mathbb{T}$. We will introduced various subscripts $\$$ to represent terms-in-context from different typing systems. The subscript `st' refers to the (Curry-style or Church-style) simply-typed lambda calculus (see Convention \ref{conv:st_entailement}).

We fix an atomic type symbol $o$ and for every natural number $n\in\nat$ we use \emph{type} notation $n$ to refer to the type $n_o$
defined in Sec.~\ref{sec:simpletype} ($0\equiv o$ and $(k+1) \equiv k \typear o$ for $k\geq 0$). A type $A_1 \typear \cdots \typear A_n \typear B$, where $B$ is not necessarily ground, will be written $(A_1, \cdots, A_n, B)$.

\begin{definition}[The safe lambda calculus] \hfill
\index{safe!lambda calculus}
\label{def:safelambda}
\begin{enumerate}[(i)]
\item The \defname[safe!lambda calculus \ala Curry]{safe lambda calculus} \ala Curry, denoted ``safe $\cusystem$'', is a sub-system of the simply-typed lambda calculus \ala Curry. It is defined as the set of judgements of the form $\Gamma \sentail M : A$, where $M$ ranges over untyped term, that are derivable from the system of rules of Table \ref{tab:safelambda_curry}.

\item The \defname[safe!lambda calculus \ala Church]{safe lambda calculus} \ala Church, denoted ``safe $\chsystem$'', is the typing system obtained by adding type annotations in the $\lambda$-binders in the abstraction rule of the safe lambda calculus \ala Curry (see Sec.~\ref{sec:lambda_alachurch}). In this system, $M$ ranges over \emph{annotated} term.

\item The sub-systems defined by the same rules in
(i) and (ii), such that all types that occur in them are homogeneous (Sec.~\ref{sec:safetygrammar}), are called the \defname[homogeneous!safe lambda calculus]{homogeneous safe lambda calculus} \ala Curry and \ala Church respectively.
\end{enumerate}
\end{definition}

\begin{FramedTable}
$$ \rulename{var} \ \rulef{}{x:A\sentail x : A}  \qquad
\rulename{wk} \ \rulef{\Gamma \sentail M : A}{\Delta \sentail M : A} \quad \Gamma \subset \Delta
\qquad
\rulename{\delta} \ \rulef{\Gamma \sentail M : A}{\Gamma \asappentail M : A}
$$

$$ \rulename{app_{as}} \ \rulef{\Gamma \sentail M : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail N_1 : A_1 \quad \ldots
\quad \Gamma \sentail N_n : A_n} {\Gamma \asappentail M\, N_1 \ldots N_n : B} $$

$$ \rulename{app} \ \rulef{\Gamma \sentail M : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail N_1 : A_1 \quad \ldots
\quad \Gamma \sentail N_n : A_n} {\Gamma \sentail M\, N_1 \ldots N_n : B} \quad \ord\Gamma \geq \ord B$$

$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail M : B} {\Gamma \sentail \lambda x_1 \ldots x_n . M :
  (A_1, \ldots ,A_n,B)} \quad \ord\Gamma \geq \ord{(A_1, \ldots ,A_n,B)}
$$
\smallskip

\noindent where $\ord{\Gamma}$ denotes the set $\{ \ord A \ | \  y:A \in \Gamma \}$ and for $S\subseteq \nat$, $u\in\nat$, ``$S \geq u$'' means that $u$ is a lower-bound of $S$.
\caption{The safe lambda calculus \ala Curry.}
\label{tab:safelambda_curry}
\end{FramedTable}

We will consider extension of the safe lambda calculus with constants. For every set $\Xi$ of higher-order constants, we introduce sequents of the form $\Gamma \entail_\$^\Xi M : A$, for some subscript $\$$, to denote the typing system obtained by adding the rule:
$$\rulename{const} \ \rulef{}{\entail_\$^\Xi f : A}~f \in \Xi \enspace . $$
For convenience, we shall omit the superscript from $\entail_\$^\Xi$ whenever the set of constants $\Xi$ is clear from the context.



The safe lambda calculus deviates from the standard definition of the simply-typed lambda calculus in a number of ways. First the application and abstraction rules can respectively perform multiple applications and abstract several variables at once. (Of course this feature alone does not alter expressivity.) Crucially,
the side-conditions in the application rule and abstraction rule require the variables in the typing context to have orders no smaller than that of the term being formed.
Safe terms can be applied together using the rule $\rulename{app_{as}}$, but the resulting term is only ``almost-safe''; it can be turned into a safe term by subsequently applying the abstraction rule. We do not impose any constraint on types. In particular, type-homogeneity, which was an
assumption of the original definition of safe grammars \cite{KNU02}, is not required here. Another difference is that we allow the addition of $\Xi$-constants with arbitrary higher-order types.

\begin{definition}[Safe terms] \hfill
\begin{enumerate}[(i)]
\item An \emph{untyped} term $M \in \Lambda$ is \defname{safe} if the judgement $\Gamma \sentail M : T$ is derivable in the safe lambda calculus \ala Curry for some context $\Gamma$ and type $T$. Otherwise it is said to be \defname{unsafe}.

\item A \emph{type-annotated} term $M \in \Lambda_{\mathbb{T}}$ is \defname{safe} if the judgement $\Gamma \sentail M : T$ is derivable in the safe lambda calculus \ala Church for some context $\Gamma$ and type $T$. Otherwise it is said to be \defname{unsafe}.

\item An \emph{untyped} term $M \in \Lambda$ is \index{safe!universally}\defname{universally safe}
if all its valid type annotations are safe (\ie, for every $M' \in \Lambda_{\mathbb{T}}$, context $\Gamma$ and type $A$ such that $\Gamma \chentail M' : A$ and $|M'|\equiv M$, $M'$ is safe). It is \defname{universally unsafe} if all its valid type annotations are unsafe.

\item A term $M$ that is typable as $\Gamma \asappentail M : T$ for some $\Gamma, T$ is called an \defname{almost safe application}.

\item A \emph{term-in-context} $\Gamma \stentail M : T$ of the Curry-style (resp.\ $\Gamma \chentail M : T$ of the Church-style) simply-typed lambda calculus is said to be \emph{safe} if $\Gamma \sentail M : T$
    is also typable in the Curry-style (resp.\ Church-style) safe lambda calculus.
\end{enumerate}
\end{definition}

\begin{convention}
\label{conv:st_entailement}
To avoid cumbersome notations, we will use sequents of the form $\Gamma \sentail M : A$ to refer to judgements of both versions of the safe lambda calculus (Curry and Church).
When we specify that $M$ is an untyped term in $\Lambda$ then it is understood that the judgement refers to a term-in-context typed in the Curry-style safe lambda calculus;
if $M$ ranges over annotated terms in $\Lambda_{\mathbb{T}}$ then it refers to a term-in-context typed in the Church-style safe lambda calculus.
When the domain of $M$ is not specified then it means that the current argument, definition, lemma or proposition is valid in both systems.
\end{convention}



\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the annotated terms $M_1 \equiv \lambda f^2 . f (\lambda x^o . f (\lambda y^o . y
))$ and $M_2 \equiv \lambda f^2 . f (\lambda x^o . f (\lambda y^o .x ))$. $M_2$ is unsafe because in the
subterm $f (\lambda y^o . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{(\lambda y^o . x)} = 1$.  On the other hand, $M_1$
is safe as the following proof tree shows:
\begin{mathpar}
\inferrule* [Left=\rulenamet{abs}]
    {\inferrule* [Left=\rulenamet{app}]
        {\inferrule* [Left=\rulenamet{var}]{ }{f:2 \sentail f:2}
         \qquad
         \inferrule* [Right=\rulenamet{abs}]
             {\inferrule* [Right=\rulenamet{app}]
                {\inferrule* [Left=\rulenamet{wk}]
                    {\inferrule*[Left=\rulenamet{var}]{ }{f:2 \sentail f:2}}
                    {f:2, x:o \sentail f:2}
                 \qquad
                 \inferrule* [Right=\rulenamet{wk}]
                    {\inferrule* [Right=\rulenamet{abs}]
                            {\inferrule* [Right=\rulenamet{\delta}]
                                {\inferrule* [Right=\rulenamet{var}]{ }{y:o \sentail y:o}}
                                {y:o \asappentail y:o}
                            }
                            {y:o \sentail \lambda y^o . y :1_o}}
                    {f:2 , x:o \sentail \lambda y^o .y:1_o }
                }
                {f:2, x:o \sentail f (\lambda y^o .y ) :o}
            }
            { f:2  \sentail \lambda x^o . f (\lambda y^o .y ):(o,o)}
       }
       { f:2 \sentail f (\lambda x^o . f (\lambda y^o .y )) :o}
  }
  {\sentail M_1 \equiv \lambda f^2 . f (\lambda x^o . f (\lambda y^o .y )) :3}
\end{mathpar}

Now consider the untyped terms underlying $M_1$ and $M_2$:
$|M_1| \equiv \lambda f . f (\lambda x . f (\lambda y . y
))$ and $|M_2| \equiv \lambda f . f (\lambda x . f (\lambda y .x ))$ both have for principal type $\alpha_3 \equiv ((\alpha\typear\alpha)\typear\alpha)\typear\alpha$. Further, every typing derivation for $|M_1|$ and $|M_2|$ in the simply-typed lambda calculus
assigns the same type $\alpha$ to the occurrences of the variables $x$ and $y$. Hence $|M_1|$ is \emph{universally} safe and $|M_2|$ is \emph{universally} unsafe.
\end{example}

\begin{example}
The term-in-context
$ f:(1,1,o) \asappentail (\lambda \varphi^2 \theta^3 . \varphi (\lambda x^o . x)) (f (\lambda x^o .x)) \equiv M : 3$ is almost safe. Abstracting $f$ produces the safe term-in-context $ \sentail \lambda f^{(1,1,o)}. M :((1,1,o),3)$.
\end{example}

The basic properties of the simply-typed lambda calculus also hold in the safe lambda calculus:
\begin{lemma}
\begin{enumerate}[(i)]
\item
$\Gamma  \sentail M : B \ \zand \ \Gamma \subseteq \Gamma' \implies \Gamma' \sentail M : B$
\item $\Gamma \sentail M : B \implies \freevarset(M) \subseteq \dom(\Gamma)$
\item $\Gamma  \sentail M : B \implies \Gamma_M  \sentail M : B$ where $\Gamma_M = \{ z:A \in \Gamma \ | \ z \in \freevarset(M) \}$.
\end{enumerate}
\end{lemma}
\begin{proof} Trivial. \end{proof}
\smallskip

It is easy to see that valid typing judgements of the safe lambda calculus satisfy the following simple invariant that we will later refer as the \emph{basic property of the safe lambda calculus}:
\begin{lemma}[Basic property]
\label{lem:ordfreevar}
Let $\Gamma \sentail M : B$ be a valid judgement of the Curry or Church-like safe lambda calculus. Then
$$\forall z:A \in \Gamma :\ z \in \freevarset(M) \implies \ord{A} \geq \ord{B} \enspace .$$
\end{lemma}

Note that the converse does not hold: Take the annotated term $\lambda y^o z^o. (\lambda x^o . y ) z$. Since it is closed, it trivially satisfies the condition in the conclusion of the previous lemma, but it is not safe because the variable $y$ is not abstracted by the abstraction `$\lambda x$'. The converse does not even hold for applicative terms: for instance the term-in-context $f:2, g:(o,o,o), y:o \stentail f (g\,y) : o$ satisfies the condition of the lemma but it is unsafe because the term $g\,y$ of type $1$ occurs in operand position and contains a free occurrence of a ground-type variable $y$.
\smallskip



\subsection*{Subterms}

The Subterm Lemma of the simply-typed lambda calculus does not hold anymore: a safe term may contain unsafe subterms. For instance the term $\lambda f x. f x$ is universally safe however its subterm $\lambda x . f x$ is universally unsafe. There is, however, a subclass of subterms for which this result holds:
\begin{definition}[Large subterms]
Let $M$ be an untyped term, the set $\maxsubterm(M)$ of \defname{large subterms} of $M$ is defined inductively by
\begin{align*}
  \maxsubterm(x) & = \{ x \} \\
  \maxsubterm(M N) & = \{ N \} \union \maxsubterm(M) \union \maxsubterm(N) \\
  \maxsubterm(\lambda \overline x . M) &= \{ \lambda \overline x . M \} \union \maxsubterm(M)  \mbox{ where $M$ is not an abstraction.}
\end{align*}
The set of large subterms of an annotated type is defined identically.
\end{definition}

\begin{lemma}[Subterm lemma for safe $\chsystem$ and safe $\cusystem$]
\label{lem:largesubterm_prop}
Let $M$ range over $\Lambda$ or $\Lambda_{\mathbb T}$. Then
$$\Gamma \sentail M : T \ \zand\  M' \in \maxsubterm(M) \implies \Gamma' \sentail M' : T' \mbox{ for some $\Gamma', T'$}. $$
\end{lemma}
\begin{proof}
The proof is a trivial induction on the structure of the term
\end{proof}
\smallskip

To indicate that a term is unsafe we will sometimes highlight the source of its unsafety by underlining one of its large subterm as well as some free occurrence of a variable in that subterm that does not satisfy the condition of the previous Lemma; we may underline just the variable if the large subterm is clear. For instance the term $\lambda f^2 . f (\lambda x^o . f (\underline{\lambda y^o .\underline{x}}))$ is unsafe because the subterm $\lambda y^o .x$ has order greater than the order of the variable $x$ occurring free in it.
\smallskip


The applicative homogeneously-typed fragment of the safe lambda calculus captures the original notion of safety due to Knapik et~al.\ in the context of higher-order grammars (Def.~\ref{def:safegrammar}):

\begin{proposition}[Correspondence with safe grammars]
\label{prop:safegram_safelmd}
Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe (in the original sense of Knapik et~al.) if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \sentail^{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} (Curry or Church-style) safe lambda calculus.
\end{proposition}
\begin{proof}
First we observe that since $e$ is an applicative term, the distinction between Curry and Church-style lambda calculus does not matter.
We show by induction that \begin{asparaenum}[(i)]
\item  $z_1,\ldots, z_m \asappentail t:A$ is a valid judgement of the homogeneous safe lambda calculus containing no abstraction if and only if in the Knapik sense, all the occurrences of unsafe subterms of $t$ are safe occurrences.
\item $z_1,\ldots, z_m \sentail t:A$ is a valid judgement of the homogeneous safe lambda calculus containing no abstraction if and only if in the Knapik sense, all the occurrences of unsafe subterms of $t$ are safe occurrences, and all parameters occurring in $t$ have order greater than $\ord{t}$. \end{asparaenum}

The constant and variable rules are trivial. Application case: By definition, a term $t_0 \ldots t_n$ is Knapik-safe iff for all $0\leq i \leq n$, all the occurrences of unsafe subterms of $t_i$ are safe occurrences (in the Knapik sense), and for all $1\leq j \leq n$, the operands occurring in $t_j$ have order greater than $\ord{t_j}$. The \rulenamet{app_{as}} rule and the induction hypothesis permit us to conclude.

Now since $e$ is an applicative term of \emph{ground type}, the previous result gives:
$z_1,\ldots, z_m \sentail e:o$ is a valid judgement of the homogeneous safe lambda calculus iff all the occurrences of unsafe subterms of $e$ are safe occurrences, which by definition of Knapik-safety is equivalent to saying that the rule $F z_1 \ldots z_m \rightarrow e$ is safe.
\end{proof}

\begin{remark}
This result was first proved by de Miranda \cite{demirandathesis} for a different notion of safe lambda calculus. See Remark~\ref{related:demiranda_safelambda}.
\end{remark}

\subsubsection*{In what sense is the safe lambda calculus \emph{safe}?}
It is an elementary fact that when performing $\beta$-reduction in the lambda
calculus, one must use capture-\emph{avoiding} substitution, which
is standardly implemented by renaming bound variables afresh upon
each substitution. In the safe lambda calculus, however, variable
capture can never happen (as the following lemma shows).
Substitution can therefore be implemented simply by
capture-\emph{permitting} replacement, without any need for variable
renaming.

\begin{convention}[Safe variable typing convention]
\label{conv:orderconsistnaming}
We say that a set $\Gamma$ of typing assumptions of the form $x:A$, for some variable $x$
and simple type $T$, is \defname{order-consistent} if all the types assigned to a given variable are of the same order:
$$x:A_1 \in \Gamma\ \zand\ x:A_2 \in \Gamma \implies \ord A_1 = \ord A_2 \enspace .$$

Let $M\in\Lambda_{\mathbb{T}}$ be an annotated term. We define
the set $Ass(M)$ as the set of type-assignments induced by the type annotations in $M$:
\begin{align*}
Ass(x) &= \emptyset \\
Ass(M\, N) &= Ass(M) \union Ass(N) \\
Ass(\lambda x^T . M) &= \{ x: T \} \union Ass(M) \enspace .
\end{align*}
By extension, the set of type-assignments induced by a term-in-context $\Gamma \chentail M : T$ is given by $Ass(\Gamma \chentail M : T) = \Gamma \union Ass(M)$. A type-annotated term $M$ is said to be \defname{order-consistent} just if the set $Ass(M)$ is; a countable set of terms $M_0, M_1, \ldots$ is \defname{order-consistent} just if $\Union_{i\geq 0} Ass(M_i)$ is. This notion naturally extends to (countable sets of) terms-in-context.

We now adopt the \defname[safe!variable typing convention]{safe variable typing convention}:
In any definition, theorem or proof involving countably many terms, it is assumed that the set of terms involved is order-consistent.
\end{convention}

\begin{example}
  The set of typing assumptions $\{x:o, x:1\}$ is not order-consistent. Therefore the annotated term $\lambda x^1 . x (\lambda x^o . x)$ is not order-consistent; however, it is alpha-equivalent to the term
  $\lambda y^1 . y (\lambda x^o . x)$ which is order-consistent.

  The set of terms $\{ \lambda x^0 . x,  \lambda x^1 . x\}$ is not order-consistent.
\end{example}

In the following, we write $M\captsubst{N}{x}$ to denote
the capture-\emph{permitting} substitution that textually replaces all free occurrences of $x$ in $M$ by $N$ without performing variable renaming (see Def.~\ref{def:captpermsubst}) and $M\captsubstl {\overline N} / {\overline x}\captsubstr$ to refer to its simultaneous variant (Def.~\ref{def:captpermsimultsubst}).

\begin{lemma}[No-variable-capture lemma]
\label{lem:nocapture} In the safe lambda calculus \ala Church, there is
no variable capture when performing simultaneous capture-permitting substitution provided that we adopt the \emph{safe variable typing convention}
(Convention \ref{conv:orderconsistnaming}): If $\Gamma, \overline{x}:\overline{B} \sentail M : A$, $\Gamma \sentail  N_1:B_1,  \cdots ,\Gamma \sentail  N_n : B_n$, where $|\overline{x}| = n$ then
$$ M\{\overline{N}/\overline{x}\} \equiv M[\overline{N}/\overline{x}]\enspace . $$
\end{lemma}

\begin{proof}
We prove the result by structural induction on $M$. The variable and constant cases are trivial.
Otherwise, $M$ is of the
  form $\lambda \overline{y}^{\overline C} . M_0 \ldots M_m$ where $\overline{y} = y_1
\ldots y_p$, $m,p\geq 0$ and for every $0 \leq i\leq m$, $M_i$ is safe.
The simultaneous capture-permitting substitution gives:
$$M \captsubst{\overline{N}}{\overline{x}} \equiv \lambda \overline{y}^{\overline C} . M_0
\captsubst{\overline{N} \filter I}{\overline{x} \filter
I} \ldots M_m
\captsubst{\overline{N} \filter I}{\overline{x} \filter
I} $$
where $I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y}\}$ and for every list $s$, $s \filter I$ denotes the sublist of $s$ obtained by keeping only elements in $s$ whose position index in the list belongs to $I$.

Suppose for contradiction that a variable capture occurs in $M \captsubst{\overline{N}}{\overline{x}}$. By the induction hypothesis there is no variable capture in $M_i \captsubst{\overline{N} \filter I}{\overline{x} \filter
I}$ for $0\leq i \leq m$. This means that we are in the following situation: For some $i \in I$ and $1\leq j \leq p$ the variable $y_j$ occurs freely in $N_i$, and $x_i$ occurs freely in $M$. Since $y_j \in \freevarset(N_i)$ we must have $y_j:D \in \Gamma$ for some type $D$, and by the \emph{safe variable typing convention}, we necessarily have $\ord{D}=\ord{C_j}$.
Therefore:
\begin{align*}
\ord{D}  &\geq \ord{B_i} & \mbox{by Lemma \ref{lem:ordfreevar} since $y_j \in \freevarset(N_i)$,} \\
          & \geq \ord A & \mbox{by Lemma \ref{lem:ordfreevar} since $x_i \in \freevarset(M)$,} \\
          &= 1 + \max\{\ord C_k \ | \ 1\leq k\leq p \} \\
          & > \ord{C_j} \\
          & = \ord{D} & \mbox{by the \emph{safe variable typing} convention,}
\end{align*}
which gives us a contradiction.
\end{proof}


\begin{example}
\begin{enumerate}[(i)]
\item
  In order to contract the $\beta$-redex in
\[f:(o,o,o),x:o
  \chentail (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    \underline{x}}) : (o,o)\] one should rename afresh the bound variable $x$ to prevent the capture of the free occurrence of $x$ in the underlined subterm during substitution. Consequently, by the previous lemma,  the term is not safe. And indeed the basic property of the safe lambda calculus is not satisfied because $\ord{x} = 0 < 1
  = \ord{f x}$.
\item
  Adopting the safe variable typing convention is crucial for the lemma to hold. For instance take the safe terms $M \equiv \lambda y^o . x$ and
   $N \equiv y$. We have $ x: 1 \sentail M : o\typear 1$ and
   $y:1 \sentail N : 1$. But
   $$M\captsubst{N}{x} \equiv \lambda y^o.y \not\equiv \lambda x^o . y \equiv M\subst{N}{x} \enspace .$$
\end{enumerate}
\end{example}

Alternatively, the following version of the No-variable capture Lemma does not rely on Convention \ref{conv:orderconsistnaming}:
\begin{lemma}
\label{lem:nocapture_noconvention}
Let $\Gamma, \overline{x}:\overline{B} \sentail M : A$, $\Gamma \sentail  N_1:B_1,  \cdots ,\Gamma \sentail  N_n : B_n$, with $|\overline x| = n$, be valid judgements of the safe lambda calculus \ala Church. Then if further $\Gamma \chentail M\{{\overline N} / {\overline x}\} : A$ is a valid Church simply-typed term-in-context (not-necessarily safe) then
$$ M\{{\overline N} / {\overline x}\} \equiv M[{\overline N} / {\overline x}]\enspace . $$
\end{lemma}
\begin{proof}
 The proof is the same as for the previous Lemma except that to show that $\ord{C_j} = \ord{C}$ we use the assumption $\Gamma \chentail M\{{\overline N} / {\overline x}\} : A$ instead of the safe typing convention:
Since the annotated term
$\lambda \overline{y}^{\overline C} . M_0
\captsubst{\overline{N} \filter I}{\overline{x} \filter
I} \ldots M_m
\captsubst{\overline{N} \filter I}{\overline{x} \filter
I}$ is typable in the Church-like lambda calculus, the free variables $y_j$ in $N_i$ must be bound by the abstraction
$\lambda \overline{y}^{\overline C}$. Consequently its type must be $C_j$. Hence $D\equiv C_j$ and $\ord D = \ord C_j$.
\end{proof}

\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}


Note that lambda-terms that do not require variable-capture
when being reduced are not necessarily safe. For instance the $\beta$-redex in
$\lambda y^o z^o. (\lambda x^o .y) z$ can be soundly contracted using
capture-permitting substitution, even though the term is not safe.
\bigskip

\begin{lemma}[Substitution Lemma]
\label{lem:subst_preserves_safety}
Let $\Gamma \sentail N : A$. Then
\begin{enumerate}[(i)]
\item $\Gamma, x :A \sentail M : B    \implies \Gamma \sentail M\subst{N}{x} : B$,
\item  $ \Gamma, x :A \asappentail M : B  \implies \Gamma \asappentail M\subst{N}{x} : B$.
\end{enumerate}
Further if $\Gamma \sentail N : A$ and $\Gamma \sentail M : A$ are homogeneously safe then so is $\Gamma \sentail M\subst{N}{x} : B$,
and if $\Gamma \sentail N : A$ and $\Gamma \sentail M : A$ are homogeneously almost-safe then so is $\Gamma \sentail M\subst{N}{x} : B$.
\end{lemma}
\begin{proof}
Let $\Gamma \sentail N : A$. We show (i) and (ii) simultaneously by induction on the derivation tree of $\Gamma, x :A \sentail M : B$ or $\Gamma, x :A \asappentail M : B$. The base cases \rulenamet{var} and \rulenamet{const} are trivial. The cases \rulenamet{\delta} and \rulenamet{wk} follow immediately from the induction hypothesis.

Case \rulenamet{abs}: We have
$\Gamma, x:A \sentail \lambda \overline{y}^{\overline{C}}. Q \equiv M : (\overline{C},D)$. Suppose that $x$ belongs to $\overline{y}$ then the substitution is not pushed inside the lambda so the result holds trivially.
Otherwise suppose that $\Gamma, x:A, \overline{y}:\overline{C} \asappentail Q : D$. Applying the induction hypothesis (ii) on this term-in-context gives:
$\Gamma, \overline{y}:\overline{C} \asappentail Q\subst{N}{x} : D$
and by the rule \rulenamet{abs} we obtain:
$\Gamma \sentail \lambda \overline{y}^{\overline{C}} . Q\subst{N}{x} : (\overline{C},D)$. We can then conclude since $\lambda \overline{y}^{\overline{C}} . Q\subst{N}{x} \equiv (\lambda \overline{y}^{\overline{C}} . Q)\subst{N}{x}$ under the \emph{safe variable naming convention} (Convention \ref{conv:orderconsistnaming}).

Case \rulenamet{app_{as}}: We have $M\equiv M_0 M_1 \ldots M_p$ for $p\geq 1$ and $\Gamma \sentail M_k : A_k$ for $1\leq k \leq p$. By the induction hypothesis, we have $\Gamma \sentail M_k\subst{N}{x} : A_k$ for all $k$. The rules $\rulename{app_{as}}$ permit us to conclude.

Case \rulenamet{app}: Again it is proved by applying the induction hypothesis on the premises of the rules.


Finally, term substitution preserves types so in particular it preserves type homogeneity.
\end{proof}


\begin{remark}
\begin{enumerate}[(i)]
\item  This result naturally extends to simultaneous substitution:
If $\Gamma \sentail N_k : A_k$ for $1\leq k\leq n$
then $\Gamma, x_1 :A_1, \ldots x_n : A_n  \sentail M : B$
implies $\Gamma \sentail M[N_1/x_1, \ldots, N_n/x_n] : B$
and $\Gamma, x_1 :A_1, \ldots x_n : A_n  \asappentail M : B$
implies $\Gamma \asappentail M[N_1/x_1, \ldots, N_n/x_n] : B$.

\item Observe that the \emph{type} substitution lemma of the simply-typed lambda calculus does not hold in the safe lambda calculus. This is because type substitution allows one to alter the order of the variables occurring in the term. For instance take
    $M \equiv \lambda f y. f (\lambda x.y)$. Its principal type in the lambda calculus is $A \equiv ((\alpha\typear\beta)\typear\gamma)\typear\beta\typear\gamma$ for some atomic types $\alpha$, $\beta$ and $\gamma$.
    Then the judgement $\stentail M : A$ is unsafe (because $\ord y = \ord x$), the judgement
    $\stentail M : A\subst{\beta\typear\beta}{\beta}$ is safe, and the judgement $\stentail M : A\subst{\beta\typear\beta}{\beta}\subst{\alpha\typear\alpha}{\alpha}$
    is unsafe.
\end{enumerate}
\end{remark}

\subsection{Safe beta reduction}

It is desirable to have an appropriate notion of reduction for our
calculus. The standard $\beta$-reduction rule is not
adequate, however, because safety is not preserved by $\beta$-reduction as
the following example shows: The safe term $\lambda f^{(o,o,o)} z^o w^o. (\lambda x^o y^o . f x y) z w$
$\beta$-reduces in one step to $\lambda f^{(o,o,o)} z^o w^o. (\underline{\lambda y^o . f \underline{z} y}) w$, which is
unsafe since the underlined order-1 subterm contains a free
occurrence of a ground variable; but if we perform one more
reduction we obtain the safe term $\lambda f^{(o,o,o)} z^o w^o. f z w$. This suggests
simultaneous contraction of ``consecutive'' $\beta$-redexes. In
order to define this notion of reduction we first introduce the
corresponding notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:

\begin{definition}[Safe redex]
An \defname[safe!redex]{untyped safe redex} is an untyped almost safe application of the form $(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ for some $l,n\geq 1$ such that $M$ is an almost safe application.
(Consequently $\lambda x_1 \ldots x_n . M$ is safe and
each $N_i$ is safe for $1\leq i\leq n$.)
%\item $R \equiv \lambda y_1 \ldots y_q . (\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ for some $l,n,q\geq 1$ and such that
%    \begin{itemize}
%    \item $R$ is safe,
%    \item $(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ is \emph{almost safe}
%    (and therefore  $\lambda x_1 \ldots x_n . M$ is safe
%    and $N_i$ is safe for $1\leq i\leq n$),
%    \item $M$ is an almost safe application.
%    \end{itemize}
The notion of \emph{annotated} safe redex is defined similarly.
\end{definition}

For instance, in the case $n<l$, a safe redex has a derivation tree of the following form:
\begin{mathpar}
  \inferrule* [Left=\rulenamet{app}]
  {
      \inferrule* [Left=\rulenamet{wk}]
      {
          \inferrule* [Left=\rulenamet{abs}]
            {\ldots}
            {\Gamma', \overline{x}:\overline{A} \sentail M : (A_{n+1}, \ldots, A_l, B)}
      }
      {\Gamma \sentail \lambda \overline{x} . M : (A_1, \ldots, A_l, B)}
      \\
      \inferrule*
       {\ldots}
       {\Gamma \sentail N_1 :A_1}
%      \\
%      \cdots
      \\
      \inferrule*
       {\ldots}
       {\Gamma \sentail N_l :A_l}
  }
  {\Gamma \sentail (\lambda \overline{x} . M) N_1 \ldots N_l : B}
\end{mathpar}
where the abbreviations $\overline{x}$ and $\overline{x}:\overline{A}$ stand for $x_1 \ldots x_n$ and $x_1:A_1,\ldots, x_n : A_n$ respectively.
%\smallskip

\begin{example}
The term $(\lambda f^1 . ((\lambda g^1 h^1 . h) (\lambda z^o.z)) )\, (\lambda z^o.z)\, (\lambda z^o.z)$ is a safe redex of type $o \typear o$.
This example shows that there exist safe redexes of the form $(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ with $l>n$.
\end{example}

A \emph{safe redex} is by definition an almost safe term,
but it is not necessarily a \emph{safe term}. For instance the term $(\lambda x^o y^o. x) z$ is a safe redex but it is only an \emph{almost} safe term.
The reason why we call such redexes ``safe'' is because when they occur within a safe term, it is possible to contract them without breaking the safety of the whole term. Before proving this result, we first define how safe redexes are contracted:
\begin{definition}[Safe redex contraction]
\label{dfn:saferedex_contraction} We use the abbreviations $\overline{x} =
x_1 \ldots x_n$, $\overline{N} = N_1 \ldots N_l$ and
$\overline{y} = y_1 \ldots y_1$m for $n,l,q \geq 1$. The relation
$\beta_s$ (when viewed as a function) is defined on the set of safe
redexes as follows:
\begin{align*}
  \beta_s &=
  \{  \ (\lambda \overline{x} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1 \ldots x_l} \ | \  n> l \} \\
&\cup  \{ \ (\lambda \overline{x}  . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \ | \ n\leq l \} \enspace .
\end{align*}
where the notation $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution (Def.~\ref{dnf:simsubst}).
\end{definition}

\begin{lemma}[$\beta_s$ preserves safety]
\label{lem:betasred_preserves_safety}
Suppose that $M_1\, \beta_s\, M_2$. Then
\begin{enumerate}[(i)]
\item $M_2$ is almost safe;
\item $\Gamma \sentail M_1 : A \implies \Gamma \sentail M_2 : A$.
\end{enumerate}
\end{lemma}
\begin{proof}
Let $M_1\, \beta_s\, M_2$ for some almost safe redex $M_1$ and term $M_2$ of type $A$. By definition, $M_1$ is of the form $(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l $ for some safe terms $N_1$, \ldots, $N_l$ of type $B_1$, \ldots, $B_n$; almost safe term $M$ of type $C$; and such that $(\lambda x_1 \ldots x_n . M)$ is a safe term of type $(B_1,\ldots,B_n,C)$.
\begin{compactitem}[-]
\item
Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$.
(i) By the Substitution Lemma
\ref{lem:subst_preserves_safety}(ii), the term $M\subst{\overline{N}}{x_1
\ldots x_l} : C$ is an almost safe application: $\Gamma, x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\asappentail M\subst{\overline{N}}{x_1
\ldots x_l} : C$.
Thus by definition, $\lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1
\ldots x_l} \equiv M_2$ is almost safe.

(ii) Suppose that $M_1$ is safe. W.l.o.g.~we can assume that the last rule used
to form  $M_1$ is \rulenamet{app} (and not the weakening rule
\rulenamet{wk}), thus we have $\dom\Gamma = \freevarset(M_1)$, and Lemma \ref{lem:ordfreevar} gives us $\ord{A} \leq
\ord{\Gamma}$. This allows us to use the rule \rulenamet{abs} to form the safe term $\Gamma
\sentail \lambda x_{l+1} \ldots x_n . M\subst{\overline{N}}{x_1
\ldots x_l} \equiv M_2 : A$.

\item Suppose $n \leq l$. (i) Again by the Substitution Lemma
we have that $M\subst{N_1 \ldots N_n}{\overline{x}}$ is an almost safe application: $\Gamma \asappentail M\subst{N_1 \ldots N_n}{\overline{x}} : C$. If $n=l$ then the proof is finished; otherwise ($n<l$) we further apply the rule \rulenamet{app_{as}} $l-n$ times which gives us the almost safe application $\Gamma \asappentail M_2 :A$.

(ii) Suppose that $M_1$ is safe.  If $n=l$ then $M_2\equiv M\subst{N_1 \ldots N_n}{\overline{x}}$ is safe by the Substitution Lemma;
if $n<l$ then we obtain the judgement $\Gamma \sentail M_2 :A$ by
applying the rule \rulenamet{app_{as}} $l-n-1$ times on $\Gamma \sentail M\subst{N_1 \ldots N_n}{\overline{x}} : C$ followed by one application of \rulenamet{app}.
\qedhere
\end{compactitem}
\end{proof}


We can now define a notion of reduction for safe terms:
\begin{definition}[Safe beta-reduction]
\indexnotation{$\betasred$}{Safe beta-reduction}%
The \defname[safe!$\beta$-reduction]{safe $\beta$-reduction}, written $\betasred$, is the compatible closure of the relation $\beta_s$ with respect to the formation rules of the safe lambda calculus (\ie, it is the smallest relation such that if $M_1\, \beta_s\, M_2$ and $C[M]$ is a safe term for some context $C[-]$ formed with the rules of the simply-typed lambda calculus then $C[M_1]\betasred C[M_2]$). The relation $\betasconv$ is defined as the reflexive, symmetric, transitive closure of $\betasred$.
\end{definition}

\begin{lemma} The safe reduction relation $\betasred$:
\begin{enumerate}[(i)]
\item is a subset of the transitive closure of $\betared$ ($\betasred \subset \betaredtr$);
\item is strongly normalizing;
\item has the unique normal form property;
\item has the Church-Rosser property.
\end{enumerate}
\end{lemma}
\begin{proof}
(i) Immediate from the definition: The safe $\beta$-reduction is just a multi-step $\beta$-reduction.
(ii) This is because $\betasred \subset \betaredtr$, and $\betared$ is
strongly normalizing in the simply-typed lambda calculus. (iii) It is easy to see that a safe term has a beta-redex if and only if it has a safe beta-redex (Because a beta-redex can always be ``widen'' into consecutive beta-redexes of the shape of those in Def.~\ref{dfn:saferedex_contraction}). Therefore the set
of $\beta_s$-normal forms is equal to the set of $\beta_s$-normal
forms. The uniqueness of $\beta$-normal form then implies the uniqueness
of $\beta_s$-normal form. (iv) is a consequence of (i) and (ii).
\end{proof}

Since $\betasred$ is by definition the compatible closure of
$\beta_s$ by the formation rules of the safe lambda calculus,
Lemma \ref{lem:betasred_preserves_safety} implies
\begin{lemma}[Subject Reduction]
\label{lem:safered_preserves_safety}
Let $M_1 \betasred M_2$. Then
\begin{enumerate}[(i)]
\item $\Gamma \sentail M_1 :B \implies \Gamma \sentail M_2 :B$,
\item $\Gamma \asappentail M_1 :B \implies \Gamma \asappentail M_2 :B$.
\end{enumerate}
\end{lemma}
\begin{proof}
Suppose that $M_1 \betasred M_2$. Then we have $M_1 \equiv C[R_1]$ and $M_2 \equiv C[N_2]$ for some context $C[-]$ and safe redex $N_1$ with $N_1 \, \beta_s \, N_2$.

(i) If the safe redex $N_1$ is a safe term $\Gamma' \sentail N_1 : A$ then by
Lemma \ref{lem:betasred_preserves_safety}(ii) we have
$\Gamma' \sentail N_2 : A$. We can therefore deduce
$\Gamma \sentail C[N_2] \equiv M_2 : B$ by replacing the derivation subtree
of $\Gamma' \sentail N_1 : A$ by the derivation tree of $\Gamma' \sentail N_1 : A$ in the derivation tree of $\Gamma \sentail C[N_1] : B$.

Otherwise $N_1$ is an almost safe application that is not safe and therefore $N_1$ is a strict subterm of $M_1$. In the derivation tree of a safe term, an almost safe application that is not safe can only occur as a premise of the abstraction rule. Thus the context $C[-]$ must be of the form
$C'[\lambda \overline{y}.-]$ for some context $C'[-]$
and such that $\lambda \overline{y}. N_1$ is a safe term: $\Gamma'' \sentail \lambda \overline{y}. N_1 : C$ for some $\Gamma'',C$.
Applying the abstraction rule on $N_2$ gives $\Gamma'' \sentail \lambda \overline{y}. N_2 : C$. Hence as in the previous case we can deduce
$\Gamma \sentail C[N_2] \equiv C'[\lambda \overline{y}. N_2] \equiv M_2 : B$
by substituting the derivation tree of $\Gamma'' \sentail \lambda \overline y. N_2 : C$ for the derivation tree $\Gamma'' \sentail \lambda \overline y. N_1 : C$  in the derivation tree of $\Gamma \sentail M_1 : B$.

(ii) If $N_1$ is a safe term the we conclude as in (i).
Otherwise, $N_1$ is an almost safe application: if $C[-] \equiv -$ then we can conclude immediately by Lemma \ref{lem:betasred_preserves_safety}(i);
otherwise $N_1$ necessarily occurs as a subterm of a safe subterm of $M_1$ so we can conclude as in (i).
\end{proof}

\begin{remark}
$\betasred$ \emph{does not} preserve ``unsafety'': Take any safe annotated-term $S$ and unsafe annotated-term $U$ of the same type $\tau$, then the term $(\lambda x^\tau y^\tau . y)\, U\, S :\tau$ is unsafe but it $\beta_s$-reduces to $S$ which is safe.
\end{remark}

\subsection{Eta-long normal form}
We now restrict our attention to the Church-style (safe) lambda calculus. Since terms are annotated, their type as well as the types of their subterms are uniquely determined.
The $\eta$-expansion of $M : A\typear B$ is defined as the annotated term
$\lambda x^A . M x : A\typear B$ where $x:A$ is a fresh variable. The \emph{$\eta$-long-expansion} of a term $M : (A_1,\ldots,A_n,o)$ is defined as $\lambda \varphi_1^{A_1} \ldots \varphi_l^{A_l} . M \varphi_1 \ldots \varphi_l$
where each $\varphi_i$ is a fresh variable. The \index{eta-long normal form}\emphind{$\eta$-long normal form} (or just $\eta$-long nf) of an annotated term (also referred in the literature as \emph{long reduced form}, \emph{$\eta$-normal form} or  \emph{extensional form} \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding the body of every
lambda abstraction as well as every subterm occurring in an
\emph{operand position} (\ie, occurring as the second argument of
some occurrence of the binary application operator). Formally,
\begin{definition}
\label{dfn:etalongnf}
The \defname[eta-long normal form]{$\eta$-long normal form}, written $\elnf{M}$ or sometimes $\etalnf{M}$, of an annotated term $M$ of type $(A_1,\ldots,A_n,o)$ with $n \geq 0$ is defined by cases according to
the syntactic shape of $M$ (A simply-typed term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a $\Sigma$-constant or an abstraction.):%
\indexnotation{$\elnf{M}$}{Eta-long normal form of the term $M$}%
\begin{eqnarray*}
  \elnf{\lambda x^\tau . N } &\equiv& \lambda x^\tau . \elnf{N} \\
  \elnf{\alpha N_1 \ldots N_m } &\equiv& \lambda \overline{\varphi}^{\overline{A}} . \alpha \elnf{N_1}\ldots \elnf{N_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x^\tau . N) N_1 \ldots N_p } &\equiv& \lambda \overline{\varphi}^{\overline{A}} . (\lambda x^\tau . \elnf{N}) \elnf{N_1} \ldots \elnf{N_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is a variable, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable, and $\alpha$ is either a variable or a constant. The binder notation `$\lambda \overline{\varphi}^{\overline A}$' stands for
`$\lambda \varphi_1^{A_1} \ldots \varphi_n^{A_n}$' if $n\geq 1$, and for `$\lambda$' (called the \emph{dummy lambda}) in the case $n=0$.
\end{definition}

\begin{remark}
The $\eta$-long normal form is defined for every simply-typed lambda-term, whether $\beta$-normal or not.
Furthermore, the transformation does not introduce any new redex therefore the $\eta$-long normal form of a $\beta$-normal term is also $\beta$-normal.
\end{remark}

%\begin{lemma}
%The $\eta$-long normal form of a term in $\beta$-normal form is also in $\beta$-normal form.
%\end{lemma}
%\begin{proof}
%By induction on the structure of the term and the order of its type.
%\emph{Base case}:
%If $M=x:0$ then $\elnf{x} = \lambda . x$ is also in $\beta$-nf.
%\emph{Step case}:
%The case $M = (\lambda x . s) s_1 \ldots s_m : (A_1,\ldots,A_n,o)$ with $m>0$ is not possible since $M$ is in
%$\beta$-normal form.
%Suppose $M = \lambda x . s$ then $s$ is in $\beta$-nf. By the induction hypothesis $\elnf{s}$ is also in $\beta$-nf and therefore
%so is $\elnf{M} = \lambda x . \elnf{s}$.
%
%Suppose $M= \alpha s_1 \ldots s_m : (A_1,\ldots,A_n,o)$. Let $i,j$
%range over $1..n$ and $1..m$ respectively. The $s_j$ are in
%$\beta$-nf and the $\varphi_i$ are variables of order smaller than
%$M$, therefore by the induction hypothesis the $\elnf{\varphi_i}$ and
%the $\elnf{s_j}$ are in $\beta$-nf. Hence $\elnf{M}$ is also in
%$\beta$-nf.
%\end{proof}



\begin{definition}
\label{dfn:longsafe}
We say that a safe annotated term is \defname{long-safe} just if it is typable in the Church-like safe lambda calculus without using the rule \rulenamet{app_{as}} from Def.~\ref{def:safelambda}.
Equivalently, it is long-safe just if the judgement $\Gamma \lsentail M : T$
for some $\Gamma, T$ can be derived from the system of rules
of Table \ref{tab:longsafe}.
\end{definition}
\begin{table}[htbp]
  $$ \rulename{var_l} \ \rulef{}{\Gamma \lsentail x : A}\quad x : A \in \Gamma \qquad
%\rulename{const_l} \ \rulef{}{\lsentail f : A}\quad f \in \Xi \qquad
\rulename{wk_l} \ \rulef{\Gamma \lsentail M : A}{\Delta \lsentail M : A}\quad
\Gamma \subset \Delta$$

$$ \rulename{app_l} \ \rulef{\Gamma \lsentail M : (A_1,\ldots,A_n,B)
\quad
  \Gamma \lsentail N_1 : A_1 \quad \ldots \quad \Gamma \lsentail N_n : A_n
} {\Gamma \lsentail M N_1 \ldots N_n : B} \quad
\ord\Gamma \geq \ord B$$

$$ \rulename{abs_l} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \lsentail M : B} {\Gamma \lsentail \lambda x_1^{A_1} \ldots x_n^{A_n} . M :
  (A_1, \ldots ,A_n,B)} \quad
\ord\Gamma\geq \ord{(A_1, \ldots ,A_n,B)} $$
\smallskip
\caption{Typing rules for long-safe terms-in-contexts.}
\label{tab:longsafe}
\end{table}

The terminology ``long-safe'' does not mean that those terms are in $\eta$-long normal form; the name is deliberately suggestive of a forthcoming lemma (Lemma \ref{lem:safe_iff_etalong_lsafe}). By definition, if an annotated term is long-safe then it is safe:
\begin{lemma}
\label{lem:longsafe_imp_safe}
$ \Gamma \lsentail M : T \implies \Gamma \sentail M : T$.
\end{lemma}
\smallskip

In general, long-safety is not preserved by $\eta$-expansion. For
instance we have
% $f:o,o \lsentail f$ but $f:o,o \not \lsentail \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\lsentail \lambda y^o z^o . y : (o,o,o)$ but
performing one eta-expansion produces the term $\lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$ which is not long-safe.
On the other hand, $\eta$-reduction (of one variable) preserves long-safety:

\begin{lemma}\label{lem:etared_preserve_longsafety}
  $\Gamma \lsentail \lambda \varphi^\tau . M\, \varphi :A \ \zand \ \varphi\not\in\freevarset(M) \implies \Gamma \lsentail M :A$.
\end{lemma}
\begin{proof}
  Suppose $\Gamma \lsentail \lambda \varphi^\tau . M\, \varphi :A$. If $M$ is an  abstraction then by construction the annotated-term $M$ is necessarily safe.  If $M \equiv N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi^\tau . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for every $z\in \freevarset(\lambda \varphi^\tau . M\, \varphi)$, $\ord{z} \geq
  \ord{\lambda \varphi^\tau . M\, \varphi} = \ord{M}$. Since  $\varphi$ does not occur free in $M$ we have $\freevarset(M) = \freevarset(\lambda \varphi^\tau . M\, \varphi)$, thus we can use the application rule to form $\Gamma_M \lsentail N_0 \ldots N_p : A$ where $\Gamma_M$ is the subset of $\Gamma$ satisfying
  $\dom(\Gamma) = \freevarset(M)$. The weakening rules permits us to conclude $\Gamma \lsentail M :A$.
\end{proof}

\begin{lemma}[Long-safety is preserved by $\eta$-long expansion]
\label{lem:longsafe_imp_elnf_longsafe}
$\Gamma \lsentail M :A \implies \Gamma \lsentail \elnf{M} :A$.
\end{lemma}
\begin{proof}
 We first show that for every variable or constant $x:A$ we have $x:A \lsentail \elnf{x} :A$
 by induction on $\ord{x}$. For ground type variable we have $x = \elnf{x}$ thus the property clearly holds. Step case: $A=(A_1, \ldots, A_n,o)$ with $n>0$. Let $\varphi_i:A_i$ be a fresh variable for $1\leq i\leq n$.
Since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i :A_i \lsentail \elnf{\varphi_i} : A_i$. Using \rulenamet{wk_l} we obtain $x:A, \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \lsentail x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \lsentail \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} \equiv
  \elnf{x} :A$.


We now prove the lemma by induction on $M$.
The base case is covered by the previous observation.
Step case:
\begin{compactitem}
\item $M \equiv x N_1 \ldots N_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $N_i : B_i$ for $1 \leq i \leq m$.  Let $\varphi_i : A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \lsentail \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \lsentail \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \lsentail x N_1 \ldots N_m : A$ is formed using the \rulenamet{app_l} rule, each $N_j$ must be long-safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \lsentail \elnf{N_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \lsentail \elnf{N_j} : B_j$.  The \rulenamet{app_l}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \lsentail x \elnf{N_1} \ldots \elnf{N_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the \rulenamet{abs_l} rule gives $\Gamma \lsentail \lambda \overline{\varphi} . x
  \elnf{N_1} \ldots \elnf{N_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} \equiv \elnf{M} : A$, the side-condition of \rulenamet{abs_l} being satisfied since $\ord{\elnf{M}} = \ord{M}$.


\item $M \equiv N_0 \ldots N_m$ where $m\geq 1$ and $N_0$ is an abstraction.
The the eta-long normal form of $M$ is $\elnf{M} \equiv \lambda \overline{\varphi}. \elnf{N_0} \ldots \elnf{N_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n}$ for some fresh variables $\varphi_1$, \ldots, $\varphi_n$. Again, using the induction hypothesis we can easily derive $\elnf{M} : A$.

\item $M \equiv \lambda \overline{\eta}^{\overline{B}} . N$ where $A=(\overline{B},C)$ and $N$ is not an abstraction. The induction hypothesis gives $\Gamma, \overline{\eta} : \overline{B} \lsentail \elnf{N} : C$ and using \rulenamet{abs_l} we get $\Gamma \lsentail \lambda \overline{\eta} . \elnf{N} \equiv \elnf{M} : A$.
\end{compactitem}
\end{proof}

\begin{remark}\hfill
\begin{enumerate}
\item
The converse of this lemma does not hold: performing
$\eta$-reduction over a large abstraction does not in general
preserve long-safety. (This does not contradict Lemma
  \ref{lem:etared_preserve_longsafety} which states that safety is
  preserved when performing $\eta$-reduction on an abstraction
  of a \emph{single} variable.) The simplest counter-example is
  the
 term $f^{(o,o,o)} \stentail \lambda x^o . f \underline{x}$ which is not long-safe and
whose eta-long normal form $f^{(o,o,o)} \lsentail \lambda x^o y^o .
f x y$ is long-safe. Even for closed terms the converse does not
hold: $\lambda f^{(o,o,o)} g^{((o,o,o),o)} . g(\lambda x^o . f
\underline{x})$ is not long-safe but its eta-long normal form $\lambda f^{(o,o,o)}
g^{((o,o,o),o)} . g(\lambda x^o y^o. f x y)$ is long-safe. In fact
even the closed $\beta\eta$-normal term $\lambda
f^{(o,(o,o),o,o)} g^{((o,o),o,o,o),o)} . g(\lambda y^{(o,o)} x^o
. f \underline{x} y)$ which is not long-safe has a long-safe $\eta$-long normal form!

  \item In an eta-long normal term, applications occurring in it can always be chosen large enough so that the side-condition of the rule \rulenamet{app_l} is satisfied. Hence if a term is still not long-safe after $\eta$-long expansion, then it is necessarily due to some occurrence of an abstraction in the term for which the side-condition of the abstraction rule is not satisfied.
\end{enumerate}
\end{remark}

\begin{lemma}
  \label{lem:safe_iff_etalong_lsafe}
  An annotated term $M \in \lambda_{\mathbb{T}}$ is safe if and only if its $\eta$-long normal form is long-safe; formally:
  $$ \Gamma \sentail M : T \iff \Gamma \lsentail \elnf{M} : T \enspace . $$
\end{lemma}
\begin{proof} (Only if) Let $\Gamma \sentail M:(A_1,\ldots,A_l,o)$.
We show the result by induction on the structure of $M$.
The base cases are trivial.
Abstraction: $M$ has the form $\lambda \overline y . M_0 \ldots M_p$ for some safe terms $M_k$, $0\leq k \leq p$, $p\geq 0$.
By the subject reduction lemma we have $\Gamma_M \sentail M:(A_1,\ldots,A_l,o)$
where $\Gamma_M$ is the subset of $\Gamma$ containing only typing for free variables in $M$. The $\eta$-long expansion of $M$ is $\lambda \overline y x_1 .. x_l . \elnf{M} \elnf{x_1} \dots \elnf{x_l}$ for some variables
$x_1:A_1, \ldots, x_l:A_l$ fresh in $M$.
Let $k$ range in $\{1..l\}$. By Lemma \ref{lem:longsafe_imp_elnf_longsafe} and \ref{lem:longsafe_imp_safe}, each $\elnf{x_k}$ is safe, and by the I.H.\ $\elnf{M}$ is also safe. Therefore by $\rulename{app_{as}}$, $\elnf{M} \elnf{x_1} \ldots \elnf{x_l}$ is an almost safe application.
By Lemma \ref{lem:ordfreevar}, all the free variables of $M$ have order greater than $\ord{(A_1,\ldots,A_l,o)}$, hence we can use the abstraction rule to form the judgement
$ \Gamma_M \sentail \lambda \overline y x_1 .. x_l . \elnf{M} \elnf{x_1} \ldots \elnf{x_l} : (A_1,\ldots,A_l,o)$ and the weakening rule permits us to conclude.
The application case is treated identically.


(If) By induction on the structure of the Church-like term $M$: The variable and constant cases are
trivial. Suppose that $M$ is an application of the form $x N_1
\ldots N_m : A$ for $m\geq 1$. Its $\eta$-long normal form is $x \elnf{N_1} \ldots \elnf{N_m} \elnf{\varphi_1} \ldots
\elnf{\varphi_m}: o$ for some fresh variables $\varphi_1$, \ldots
$\varphi_m$. By assumption this term is long-safe therefore we
have $\ord{A}\leq\ord{\Gamma}$ and for $1\leq i \leq m$,
$\elnf{N_i}$ is also long-safe. By the induction hypothesis this
implies that each $N_i$ is safe. We can then form the judgement
$\Gamma \sentail x N_1 \ldots N_m : A$ using the rules
$\rulename{var}$ and $\rulename{app}$ (this is allowed since we have
$\ord{A}\leq\ord{\Gamma}$). The case $M\equiv (\lambda x. N) N_1
\ldots N_m$ for $m\geq 1$ is treated identically.

Suppose that $M \equiv \lambda \overline{x}^{\overline B} . N : A$. By assumption,
its  $\eta$-long n.f.\ $\lambda \overline{x}^{\overline B} \overline{\varphi}^{\overline C} .
\elnf{N} \elnf{\varphi_1} \ldots \elnf{\varphi_m}: A$ (for some
fresh variables $\overline\varphi = \varphi_1 \ldots \varphi_m$) is long-safe. Thus
we have $\ord{A}\leq\ord{\Gamma}$. Furthermore the long-safe subterm
$\elnf{M} \elnf{\varphi_1} \ldots \elnf{\varphi_m}$ is precisely the
eta-long normal form of $M\varphi_1 \ldots \varphi_m : o$ therefore by
the induction hypothesis we have that $M \varphi_1 \ldots \varphi_m
:o$ is safe. Since the $\varphi_i$'s are all safe (by rule
$\rulename{var}$), we can ``peel-off'' $m$ applications of the rule $\rulename{app_{as}}$ (or $\rulename{app}$) from the sequent $\Gamma,
\overline{x}:{\overline B}, \overline{\varphi}:{\overline C} \sentail s \varphi_1 \ldots
\varphi_m :o$ which gives us the sequent $\Gamma, \overline{x}:{\overline B},
\overline{\varphi}:{\overline C} \asappentail M : A$. Since the variables $\overline{\varphi}$
are fresh for $M$, we can further peel-off one
application of the weakening rule to obtain the judgement $\Gamma,
\overline{x}:\overline B \sentail M : A$. Finally we obtain $\Gamma \sentail
\lambda \overline{x}^{\overline B} . M : A$ using the rule \rulenamet{abs} (which
is permitted since we have $\ord{A}\leq\ord{\Gamma}$).
\end{proof}




\begin{proposition}
\label{prop:safe_iff_elnfsafe}
An annotated term $M\in \Lambda_{\mathbb{T}}$ is safe if and only if its $\eta$-long normal form is safe; formally:
$$ \Gamma \sentail M : B \iff \Gamma \sentail \elnf{M} : B \enspace .$$
\end{proposition}
\begin{proof} \begin{align*}
 \mbox{(If):}\qquad \Gamma \sentail \elnf{M}:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies   \Gamma \sentail M:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (if).}
\end{align*}
\begin{align*}
 \mbox{(Only if):}\qquad \Gamma \sentail M:T &\implies   \Gamma \lsentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:safe_iff_etalong_lsafe} (only if),} \\
  &\implies \Gamma \sentail \elnf{M}:T &  \mbox{By Lemma \ref{lem:longsafe_imp_safe}.\qquad } \qedhere
\end{align*}
\end{proof}

% The following statement is wrong:
%``In the homogeneous safe lambda calculus, the notion of safe terms and long-safe terms coincide''
% Because of the example given earlier (which is homogeneously typed)


\subsection{Almost safety}
\label{sec:almostsafety}
We now give an alternative presentation of the safe lambda calculus.
Consider the Curry-style system of rules of Table \ref{tab:currystylesafe_alt}. (The Church-style version of this system is obtained by annotating the $\lambda$-binder in the abstraction rule.)
\begin{table}[htbp]
$$ \rulename{var_{as}} \ \rulef{}{\Gamma \asappentail x : A}\ x : A\in\Gamma
\quad
%\rulename{const_{as}} \ \rulef{}{\asappentail f : A}~f \in \Xi \qquad
\rulename{wk_{as}} \ \rulef{\Gamma \asappentail M : A}{\Delta \asappentail M : A} \  \Gamma \subset \Delta
\quad
\rulename{wk} \ \rulef{\Gamma \sentail M : A}{\Delta \sentail M : A} \ \Gamma \subset \Delta
$$

$$
\rulename{app_{as}} \ \rulef{\Gamma \asappentail M : A\typear B
\quad \Gamma \sentail N : A} {\Gamma \asappentail M\, N : B}
\qquad
\rulename{abs_{as}}\  \rulef{\dps  \Gamma, x : A \asentail M : B} {\Gamma \asentail \lambda x  . M : A\typear B}
$$

$$
\rulename{\delta} \ \rulef{\Gamma \sentail M : A}{\Gamma \asappentail M : A}
\qquad
\rulename{\delta'} \ \rulef{\Gamma \asappentail M : A}{\Gamma \asentail M : A}
\qquad
\rulename{\rho}\
\rulef{\Gamma \asentail M : A}{\Gamma \sentail M : A}\
\ord\Gamma\geq\ord A \enspace .
$$
  \caption{Alternative definition of the safe lambda calculus \ala Curry.}
  \label{tab:currystylesafe_alt}
\end{table}

It is easy to see that these (Curry-style and Church-style) systems of rules are equivalent to the ones from
Def.~\ref{def:safelambda} in the sense that they generate the same set of judgements of the form $\Gamma \sentail M : T$. The above systems, however, have the advantage of decomposing the application and abstraction rules into atomic steps where only one variable is abstracted at a time and only two terms are applied together at a time.

\begin{definition}
Terms typed with the entailment operator $\asentail$  are called \defname{almost safe} terms. Terms typed with the entailment operator $\asappentail$ are called \defname[almost safe!application]{almost safe applications}.
\end{definition}


The intuition behind these rules is that almost safe terms represent terms that are not safe but which can become safe if sufficiently many safe terms are applied to them or if sufficiently many variables are abstracted. The rule \rulenamet{app_{as}} is used to form applications in which each applied term is safe:
\begin{lemma}\hfill
\label{lem:almostsafe_is_appplicative_safe}
\begin{enumerate}
  \item
If $\Gamma \asappentail M : T$ then $M \equiv N_0
\ldots N_m$ for some $m\geq 0$ where $N_i$ is safe
for every $0 \leq i\leq m$;

\item If $\Gamma \asentail M : T$ then $M\equiv\lambda x_1 \ldots x_n . N_0 \ldots N_m$ for some $n, m\geq 0$ where $N_i$ is safe for every $0 \leq i\leq m$.
\end{enumerate}
\end{lemma}
This result follows immediately from the definition of the rules.

The rule \rulenamet{abs_{as}} is nothing less than the standard abstraction rule of the lambda calculus. As soon as the context and the type of the term being formed respect the safety condition (\ie, all the context variables have order greater than the order of the type), the term can be marked as safe. This is done using the rule \rulenamet{\rho}. Together with the rule \rulenamet{\delta'} this implies that the closure of an almost safe term is always safe:
\begin{lemma}
  \label{lem:closealmostsafe_is_safe}
  $\Gamma \asappentail M : T \ \zand\ \dom(\Gamma) = \freevarset(M) \quad \implies
\quad \sentail \closure{M} : T$.
\end{lemma}


The two weakening rules \rulenamet{wk} and \rulenamet{wk_{as}} permit one to extend the context of a safe term or an almost safe application.
We could have added a third rule to allow weakening for almost safe terms $\Gamma \asentail M : T$ as well. This is however not necessary because this kind of weakening can always be eliminated. (In particular if the term is an abstraction then we can instead apply the rule \rulenamet{wk_{as}} just before the abstraction rule).

An annotated term is almost safe if and only if its eta-long normal form is safe:
\begin{lemma} Let $M\in\Lambda_{\mathbb{T}}$. Then
\label{lem:almostsafe_iff_etalnf_almostsafe}
  $\Gamma \asentail M : T$ if and only if $\Gamma \asentail \etalnf{M} : T$.
\end{lemma}
\begin{proof}
\emph{Only if:} Let $\Gamma \asentail M :T$ be an almost safe term.
We proceed by induction on $M$.
Suppose that the last rule used is \rulenamet{\delta'}.
Then by Lemma \ref{lem:almostsafe_is_appplicative_safe}
$M$ is an application $N_0 N_1 \ldots N_k : (A_1,\ldots,A_n,B)$ with $k\geq 0$. Let $\varphi_i$ for $i\in\{1..n\}$ be fresh variables, using the rules \rulenamet{var_{as}}, \rulenamet{wk_{as}}, \rulenamet{app_{as}} and \rulenamet{abs_{as}} we can build the almost safe term $\Gamma \asentail \lambda \varphi_1^{A_1} \ldots \varphi_n^{A_n} . N_0 N_1 \ldots N_k \varphi_1 \ldots \varphi_n :T$.

If the last rule used is \rulenamet{\delta} then
$M$ is safe therefore by Proposition \ref{prop:safe_iff_elnfsafe}, its eta-long normal form is safe and therefore by \rulenamet{\delta} it is also almost safe.
Otherwise the last rule used is \rulenamet{abs_{as}}, so by the induction hypothesis the eta-long nf of the premise is almost safe and we can conclude using \rulenamet{abs_{as}}.

\emph{If:} It is again a proof by structural induction on the eta-long normal form. The basic idea is that we can ``peel-off'' applications of the rules \rulenamet{abs_{as}} and \rulenamet{app_{app}} introduced during the eta-expansion.
\end{proof}
The two preceding lemmas show that the closure of the eta-long normal form of an almost safe term is safe. This explains the expression ``almost safe'': an almost safe is semantically safe in the sense that it is (extensionally) equivalent to a safe term; on the other hand it is syntactically unsafe since it cannot appear as an operand of an application inside a larger safe term.


\begin{lemma}[Safe beta reduction preserves almost safety]
\label{lem:betasred_preserves_almostsafety}
Let $M \betasred M'$. Then
$$\Gamma \asentail M : A \implies \Gamma \asentail M' : A \enspace .$$
\end{lemma}
\begin{proof}
Suppose that $M \betasred M'$ and $\Gamma \asentail M : A$. By Lemma \ref{lem:almostsafe_is_appplicative_safe}, $M\equiv\lambda x_1 \ldots x_n . N_0 \ldots N_m$ for some $n, m\geq 0$ where $N_i$ is safe for every $0 \leq i\leq m$.
There are two cases:
If the redex occurs in some $N_i$ for $0 \leq i \leq m$ then we have $N \equiv \lambda x_1 \ldots x_n . N_0 \ldots N'_i \ldots N_m$ where $N_i \betasred N'_i$ for some $N'_i$. Since safety is preserved by safe reduction (Lemma \ref{lem:safered_preserves_safety}), $N'_i$ is safe. Hence we can conclude using the application and abstraction rule.
The second case is when the redex is $N_1 \ldots N_q$ for some $1 \leq q\leq m$. This means that $N_0$ is of the form $\lambda y_1 \ldots y_q. P$ for some safe term $P$, and $M' \equiv P[N_1/y_1 \ldots N_q/y_q] N_{q+1} \ldots N_m$. The Substitution Lemma \ref{lem:subst_preserves_safety} and the application and abstraction rules permit us to conclude.
\end{proof}


\subsection{Safety with respect to other type-ranking functions}

We call \defname{type-ranking function} any function
$\mathop{rank} : \mathbb{T} \funto (L, \leq)$ mapping the set $\mathbb{T}$ of simple types over a set of atomic types $\mathbb{A}$ to some preorder $(L,\leq)$.
\begin{example}
The followings are examples of type-ranking functions $\mathbb{T} \funto (\nat,\leq)$:

\begin{itemize}
\item Order: $\ord(\alpha) = 0$
for $\alpha\in \mathbb{A}$, and $\ord(A \typear B) = \max(\ord(A)+1, \ord(B))$;
\item Height: $\typeop{height}(\alpha) = 0$ for $\alpha \in \mathbb{A}$ and $\typeop{height}(A \typear B) = 1 + \max(\typeop{height}(A), \typeop{height}(B))$;
\item Arity: $\arity(\alpha) = 0$ for $\alpha \in \mathbb{A}$ and $\arity(A \typear B) = 1 + \arity(B)$;
\item Size: $\typeop{size}(\alpha) = 1$ for $\alpha \in \mathbb{A}$
and $\typeop{size}(A \typear B) = 1 + \typeop{size}(A) + \typeop{size}(B)$;
\item Number of atomic sub-types: $\typeop{natoms}(\alpha) = 1$ for $\alpha \in \mathbb{A}$
and $\typeop{natoms}(A \typear B) = \typeop{natoms}(A) + \typeop{natoms}(B)$;
\item Number of function space sub-types: $\typeop{narrows}(\alpha) = 0$ for $\alpha \in \mathbb{A}$
and $\typeop{narrows}(A \typear B) = 1 + \typeop{narrows}(A) + \typeop{narrows}(B)$.
\end{itemize}
The pairing of two type-ranking functions is also a type-ranking function. For instance the pair $\langle \ord, \arity \rangle : \mathbb{T} \funto (\nat \times \nat,\leq)$ is a type-ranking function
where $\leq$ denotes the lexicographic ordering.
\end{example}

We have defined the safe lambda calculus as a sub-language of the simply-typed lambda calculus obtained by restricting the occurrences of variables according to their \emph{order}. \emph{Does it make sense to define a version of the safe lambda calculus where the constraint relies on a different type-ranking function?}

In the safe lambda calculus, the application and abstraction rules permit us to perform multiple abstraction or application at a time.
For the abstraction rule, the idea is that the side-condition might not be satisfied after one abstraction but it may become after consecutive abstractions, and similarly for the application rule. So by design, the typing system implicitly assumes that abstracting variables increases the order of the term's type, and inversely performing application decreases its order:
\begin{eqnarray}
\typeop{rank}(A\typear B) \geq \typeop{rank}(B)\enspace . \label{eqn:rankprop1}
\end{eqnarray}

On the other hand, in order to prove the No-variable-capture Lemma we need the following property:
\begin{eqnarray}
\typeop{rank}(A\typear B) > \typeop{rank}(A)\enspace . \label{eqn:rankprop2}
\end{eqnarray}
A type-ranking function verifying the above two conditions is said to be \defname{proper}.

\begin{example}
The type-ranking function $\arity$ is not proper.
The type-ranking functions $\ord$, $\typeop{height}$, $\typeop{size}$, $\typeop{natoms}$ and $\typeop{narrows}$ are all proper. Moreover $\ord$ is by definition the \emph{minimal} proper function: any other proper function $\typeop{rank} : \mathbb{T} \funto (L, \leq)$ is greater than $\ord$ by pointwise ordering.
\end{example}

In turns out that this condition suffices to define a notion of safe lambda calculus verifying all the properties that we have proven up to now, including the No-variable-capture property. We can thus define a family of safe lambda calculi as follows: given a proper function $\typeop{rank}$, we define the $\typeop{rank}$-safe lambda calculus as the calculus obtained by replacing the references to the function $\ord$ by the function $\typeop{rank}$ in the typing rules of Table \ref{tab:safelambda_curry}.
We say that a term is $\typeop{rank}$-safe if it is typable in the $\typeop{rank}$-safe lambda calculus.

\begin{example}
  Consider the simply-typed term $g:\alpha \chentail \lambda f^\beta . g : \beta \typear \alpha$
  for some types $\alpha,\beta$. This term is $\typeop{rank}$-safe if and only if $\typeop{rank}(\alpha) > \typeop{rank}(\beta)$.   Now take the types $\mu = o\typear o\typear o\typear o$ and $\tau= (o \typear o) \typear o$. We have $\ord \mu = 1 < 2 = \ord \tau$ but $\typeop{natoms}(\mu) > 4 > 3 = \typeop{natoms}(\tau)$.
Hence $g:\tau \chentail \lambda f^\mu . g : \mu \typear \tau$
is $\ord$-safe but $\typeop{natoms}$-unsafe. Conversely, $g:\mu \chentail \lambda f^\tau . g : \tau \typear \mu$ is $\typeop{natoms}$-safe but $\ord$-unsafe.

  This example shows that there is no hierarchy of $\typeop{rank}$-safe lambda calculi:
  although we can compare two proper type-ranking functions, there is not necessarily an inclusion between the safe lambda calculi that they generate.
\end{example}

This thesis concerns only the $\ord$-safe lambda calculus, but most of the presented results (except those pertaining to expressivity and complexity of the calculus) can easily be generalized to other proper ranking functions.

%It is even possible to generalize the homogeneity condition to other type-ranking function:
% We say that a type is $\typeop{rank}$-homogeneous if it is in $\mathbb{A}$ or if it is $(A_1, \cdots, A_n, \alpha)$ where $\typeop{rank}(A_1) \geq \typeop{rank}(A_2)\geq \cdots \geq \typeop{rank}(A_n)$ and each $A_1$, \ldots, $A_n$ is $\typeop{rank}$-homogeneous. This gives rise to the homogeneous fragment of the $\sf rank$-safe lambda calculus.


\subsection{Maximality}
% Another desirable property of the calculus is that it is closed under (a certain form of) beta reduction.

We have presented the safe lambda calculus as a sub-language of the simply-typed lambda calculus
verifying the so called No-variable-capture lemma (Lemma \ref{lem:nocapture}). A natural question is whether it is the \emph{maximal} such language: \emph{Is there a sub-language of the simply-typed lambda calculus containing the safe lambda calculus and verifying the No-variable-capture lemma?}

In fact not all sub-languages are of interest, we should only consider those verifying some
basic properties. For instance we require the languages to have the \emph{subterm property} (Lemma \ref{lem:largesubterm_prop})---that every (large) subterm of a typable term is also tybable---which subsequently implies the subject reduction property (Lemma \ref{lem:safered_preserves_safety}).

Let $\beth$ denote a set of simply-typed terms-in-context. We write safe $\stsystem + \beth$
to denote the language consisting of the safe terms-in-context plus those of $\beth$ (where the entailment operator $\stentail$ is replaced by $\sentail$) and closed by the typing rules of the safe lambda calculus.

\begin{theorem}
  Safe $\stsystem$ is the maximal fragment of $\stsystem$ containing the safe terms-in-context such that the subterm property and no-variable capture lemma hold.
\end{theorem}
\begin{proof}
  Let $\beth$ be a set of simply-typed terms-in-context and consider the language
  Safe $\stsystem + \beth$.  Suppose that it \emph{strictly} contains the safe lambda calculus. Then $\beth$ must contain an unsafe term-in-context. By definition, this term must have a large subterm of the form  $M \equiv \lambda {\overline x}^{\overline A} . N$
  where ${\overline x} = x_1, \ldots, x_k$, ${\overline A} = A_1, \ldots, A_k$, $k\geq 1$.
  for some term $N\equiv \cdots (\lambda y^B . \cdots x_i \cdots )$ that is not an abstraction
  for some $1\leq i \leq k$ where $\ord B \geq \ord A_i$.

  If Safe $\stsystem + \beth$ satisfies the subterm property then $M$ must also be typable in Safe $\stsystem + \beth$: we have $\overline{z}:\overline{C} \sentail M : ({\overline A},D)$.  But since we have $\ord B \geq \ord A_i$ we can also form
  the judgement $g : B\typear A_i, y : B \sentail g\, y : A$ for some fresh variables $g, y$ not occurring free in $M$, thus by the rule \rulenamet{app_{as}}
  and \rulenamet{abs} the term $\lambda {\overline z}^{\overline C} {\overline x}^{\overline A} g^{B\typear A_i} y^B . M x_1 \ldots x_{i-1} (g y) x_{i+1} \ldots x_k$ belongs to
  Safe $\stsystem + \beth$. This term $\beta_s$-reduces to $\lambda {\overline z}^{\overline C} {\overline x}^{\overline A} g^{B\typear A_i} y^B . N\subst{g y}{x_i}$.
  Now performing the substitution $N\subst{g y}{x_i} \equiv (\lambda y^B . \cdots x_i \cdots )\subst{g y}{x_i}$  without renaming variables would cause the capture of the variable $y$.
  Hence Safe $\stsystem + \beth$ does not verify the No-variable capture lemma.
\end{proof}


\begin{example}
  Consider the language Safe $\stsystem + \{ \stentail M : (2,o) \}$ for $M\equiv \lambda f^2 . f( \lambda x^o . f (\lambda y^o .x)$. It does not verify the subterm property: for instance the subterm $\lambda y^o . x$ is not typable. Further it does not verify the subject reduction lemma.
  Indeed it contains the term-in-context $f: 2 \sentail M f : o$, but $M f$ reduces to  $f( \lambda x^o . f (\lambda y^o .x))$ which is unsafe and different from $M$.

   Now consider instead the language Safe $\stsystem + \beth$ where $\beth$ contains the typing judgements for all $M$'s subterms: $\beth = \{\stentail  M : (2,o) ,
    f: 2 \stentail f (\lambda x^o . f (\lambda y^o .x)) : 1,
    f: 2 \stentail \lambda x^o . f (\lambda y^o .x) \equiv N : 1,
    f:2,x:o\stentail f (\lambda y^o .x) : o,
    x:o\stentail \lambda y^o .x : 1
    \}$.
    In this language we can form the term $\lambda f^2 g^1 y^o. N (g y)$
  (since $\ord y = 0 \geq \ord (g y) = 0$) which reduces to
  $\lambda f^2 g^1 y^o. f (\lambda y^o .x) \subst{g y}{x}$.
  Now the substitution cannot be performed without renaming variables as it would
  cause the capture of the variable $y$. Hence Safe $\stsystem + \beth$ does not verify the No-variable capture lemma.
\end{example}
