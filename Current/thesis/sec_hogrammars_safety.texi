% -*- TeX -*- -*- Soft -*-

We present the safety restriction in the context of higher-order grammars as it was originally defined
\cite{KNU02}. We give a brief introduction to the concept of higher-order grammars, the reader is referred to \cite{KNU02,demirandathesis,safety-mirlong2004} for an in-depth account of this subject.

\subsection{Higher-order grammars}
We consider simple types over a single atom $o$. Given a set of typed symbols $S$, the set of \defname{applicative terms} generated from $S$, written $\mathcal{A}(S)$ is defined as the closure of $S$ under the application rule (\ie, if $M: A\rightarrow B$ and $N:A$ are in $\mathcal{A}(S)$ then so is $M N :B$).

\begin{definition}
A \defname{higher-order grammar}\index{higher-order grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where
\begin{itemize}[-]
\item $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ has an arity $\arity(f) \geq 0$) of \emph{terminals};
\item $\mathcal{N}$ is a finite set of typed
\emph{non-terminals};
\item $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol;
\item $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form:
$$ F z_1 \ldots z_m \rightarrow e$$
where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the typed symbols in $\Sigma \union \mathcal{N} \union \{z_1:A_1, \ldots, z_m:A_m \}$.
\end{itemize}
We say that the grammar is \emph{order-$n$} just in case the order of the highest-order non-terminal is $n$.
\end{definition}

\subsubsection*{Higher-order grammars as generators of term tree languages}
An applicative term generated from the terminals in $\Sigma$ only (without non-terminals), and viewed as a $\Sigma$-labelled tree, is called a \defname{value term}.

A higher-order grammar $G$ defines a tree language denoted $L(G)$ defined as the set of \emph{finite} value terms
which can be seen as applicative terms over $\mathcal{N} \union \Sigma$. It is formally defined as the set consisting of all the finite value terms that can be obtained by normalizing the start symbol $S$ using the the reduction relation induced by the rewriting rules of $G$.
This normalization can be done using different reduction strategies also called \emph{derivation modes}. The three main ones are: outside-in (OI), inside-out (IO), and unrestricted.
As the names suggest, in the OI derivation mode the outermost redex is reduced first; in IO mode the innermost redex is reduced first; and in unrestricted mode, no particular choice of redex is imposed.
It can be shown that the OI derivation is sufficient in the sense that every value term obtained from an IO derivation can also be obtained from an OI derivation. The converse however does not hold \cite{Dam82}.


\begin{remark}
In the literature \cite{Dam82,demirandathesis,KNU02},
the ranked-alphabet $\Sigma$ is usually restricted to terminals of order $1$ at most so that each $f \in\Sigma$ of arity $r \geq 0$ is assumed to have type $(\underbrace{o, \ldots, o}_r, o)$. The idea
is that order-$0$ terminals correspond to leaves of the value tree and order-$1$ terminals correspond to nodes. Such restriction is however not necessary as one can just regard higher-order terminals as special nodes with additional constraints on the type of their children.
\end{remark}




\subsubsection*{Higher-order grammars as word language generators}

Higher-order grammars can be used as generators of word languages by imposing the following constraints on the set of terminals $\Sigma$:
\begin{itemize}
  \item $\Sigma$ contains a special symbol $e:o$,
  \item all other constant $f\in\Sigma$ are of type $(o,o)$.
\end{itemize}
The idea is that the type $o$ represent the type of strings $\Sigma^*$, the symbol $e$ marks the end of the word and a constant $f:(o,o)$ represents the operation that appends the letter `$f$' as a prefix to a string.

\subsubsection*{Higher-order grammars as tree generators}
In order to generate infinite trees, higher-order grammars are specialized into a device called \emph{recursion scheme}. A \defname{higher-order recursion scheme} is a higher-order grammar where the set of rewrite rules is deterministic (\ie, for each non-terminal $F \in \mathcal{N}$ there is exactly one production rule with $F$ on the left-hand side).

A recursion scheme $R$ defines a (potentially infinite) value tree denoted $\sem{R}$ obtained by unfolding its rewrite rules \emph{ad infinitum}, replacing formal by actual parameters each time, starting from the start symbol $S$. Formally, $\sem{R}$ is defined as the least-upper bound of the
\emph{schematological tree grammar} induced by $R$ in the continuous algebra of ranked trees with the appropriate ordering. (See \cite{KNU02,demirandathesis} for a formal definition.)

\parpic[r]{
\raisebox{-15pt}
{\begin{tikzpicture}[baseline=(root.base),level distance=3ex,inner ysep=0.5mm,sibling distance=13mm]
\node (root) {$g$}
child {node {$a$}}
child {node {$g$}
    child {node {$a$}}
    child {node {$h$}
           child {node {$h$}
                  child {node {$\ldots$}}
            }
    }
};
\end{tikzpicture}
}
}
\begin{example}\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}


\subsection{The safety restriction}
\label{sec:safetygrammar}

\emph{Safety} is a syntactic restriction for higher-order grammars
introduced in \cite{KNU02} to study the Monadic Second Order (MSO) theory of infinite trees generated by higher-order pushdown automata.  The safety restriction has appeared under different forms in the literature. The first formulation, due to Damm, appeared in \cite{Dam82} under the name \emph{restriction of derived types}. De miranda's thesis contains a comparison of the two formulations \cite{demirandathesis}. The presentation given here follows that of \cite{KNU02}.

\subsubsection*{Type homogeneity}
We say that a type is \defname{homogeneous}
if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition
that $\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$ and
each $A_1$, \ldots, $A_n$ is homogeneous \cite{KNU02}.

Suppose that $\overline{A_1}$, $\overline{A_2}$, \ldots,
$\overline{A_n}$ are $n$ lists of types, where $A_{ij}$ denotes the
$j$th type in the list $\overline{A_i}$ and $l_i$ the size of
$\overline{A_i}$, then we use the notation:
$$A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)$$
 to mean that
\begin{itemize}
  \item $A$ is the type $(A_{11},A_{12},\cdots, A_{1l_1}, A_{21}, \cdots,A_{2l_2}, \cdots A_{n1},\cdots, A_{nl_n},o)$,
  \item $\forall i: \forall u,v \in A_i : \ord u = \ord v $,
  \item $\forall i,j . \forall u \in A_i . \forall v \in A_j . i<j \implies \ord u > \ord v $.
\end{itemize}
This implies in particular that $A$ is homogenous. In other words, this notation partitions the $A_{ij}$s according to their order. Suppose $B =
(\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$,
we write $(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, |
\, {B})$ as an abbreviation for
$(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, | \,
\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$.

\subsubsection*{Definition}

\begin{definition}[Safe grammar]
\label{def:safegrammar}
  (All types are assumed to be homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname[safe!definition]{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
\end{definition}

This definition is a bit opaque and does not seem to make a lot of sense at first. One can reformulate this definition in a slightly clearer way:
A higher-order grammar $G$ whose non-terminals are of homogeneous type is \emph{unsafe} if and only if there is a rewrite rule $F z_1 \ldots z_m \rightarrow e$ where $e$ contains a subterm that:
\begin{enumerate}
\item occurs in {\em operand} position in $e$,
\item contains a parameter of order strictly less than its order.
\end{enumerate}
(By ``operand position'' we mean ``in the second position of some
occurrence of the implicit application operator of the lambda calculus''.)
A grammar is \emph{safe} if it is not unsafe.

\begin{example}[taken from \cite{KNU02}] Let $f:(o,o,o)$, $g,h:(o,o)$ and $a,b:o$ be $\Sigma$ constants.
 The grammar of level 3 with non-terminals $S:o$ and $F: ((o,o),o,o,o)$ and production rules:
\begin{eqnarray*}
    S &\rightarrow&  F g a b \\
    F \varphi x y &\rightarrow& f ( F ( F \varphi x ) y (h y)) (f (\varphi x) y)
\end{eqnarray*}
is not safe because the term $F \varphi x : (o,o)$ containing a variable of order $0$
occurs at an operand position in the right-hand side expression of the second rule.

On the other hand, the grammar with the following production rules is safe:
\begin{eqnarray*}
    S &\rightarrow&  G (g a) b \\
    G z y &\rightarrow& f ( G ( G z y) (h y)) (f z y)
\end{eqnarray*}
Moreover it can be shown that these two recursion schemes are equivalent in the sense that they generate the same
infinite tree.
\end{example}

\begin{example}
Take $H : ((o, o), o)$ and $f : (o, o, o)$; the
    following rewrite rules are unsafe (in each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x
\end{array}\]
\end{example}

\begin{example}
The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{example}



\subsection{Automata Characterization}
Although very technical, the safety restriction for higher-order recursion schemes as appealing machine characterization. Knapik, Niwi\'nski and Urzyczyn showed in \cite{KNU02} that for generating infinite ranked trees, safe higher-order recursion scheme are as expressive as \emph{higher-order pushdown automata (PDA)}.

A \defname{pushdown automaton} (PDA) is an infinite-state system transition system that can manipulate the content of a stack when performing a transition. Higher-order pushdown automata were introduced in \cite{Mas76} as a generalization of PDA. Instead of manipulating a simple stack, a higher-order PDA manipulates iterated stacks. An order-$1$ PDA is an ordinary PDA, an order-$2$ PDA manipulates order-$2$ stacks which are stacks of order-$1$ stacks. In addition to the usual push and pop transitions of a PDA, an order-$2$ PDA has order-$2$ variants: a $push_2$ operation that duplicates the top order-$1$ stack, and a $pop_2$ that pops the entire top order-$1$ stack. This definition generalizes to any order $n\in\nat$.

\begin{theorem}[Knapik, Niwi\'nski and Urzyczyn, \cite{KNU02}]
  Let $L$ be a $\Sigma$-labelled term tree language. $L$ is the language of a safe order-$n$ grammar (using the OI derivation) if and only if it is accepted by an order-$n$ pushdown automaton.
\end{theorem}
So in particular, a (potentially) infinite tree $t$ is generated by a safe order-$n$ recursion scheme if and only if it is accepted by an order-$n$ pushdown automaton.

A similar characterization has subsequently been obtained for unrestricted grammars: Hague, Murawski, Ong and Serre have introduced a new kind of pushdown automata called \emph{collapsible pushdown automata} (CPDA) and showed their equivalence with unrestricted higher-order grammars. The internal structure manipulated by a CPDA is a stack in which every symbol has a link pointing to some other substacks situated below it. There is an additional stack-operation called $collapse$ whose effect is to replace the content of the stack by the sub-stack indicated by the link attached to the top symbol of the stack.
\begin{theorem}[Hague, Murawski, Ong and Serre, \cite{hmos-lics08}]
  Let $t$ be an potentially infinite tree. $t$ is generated by an order-$n$ recursion scheme if and only if it is accepted by an order-$n$ collapsible pushdown automaton.
\end{theorem}


We have defined higher-order grammars as generators of word languages and tress. Thanks to the machine characterization, it is possible to define the notion of graph generated by a higher-order grammars:
the graph generated by a grammar is defined as the configuration graph of the corresponding collapsible higher-order pushdown automaton. In particular, graph generated by a safe grammar is the configuration graph of the corresponding higher-order PDA.


\subsection{Expressivity}

Higher-order PDA/grammars can be used as generating device for word-languages, trees, or graphs, thus inducing strict infinite hierarchies as the order of the PDA varies.  For word-languages this is known as the Maslov hierachy: orders 0, 1 and 2 correspond respectively to the regular, context-free and indexed languages. For trees, orders 0, 1 and 2 are respectively the regular, algebraic and hyperalgebraic trees.

\subsection{Is safety a genuine restriction?}
The consequences that the safety constraint has on the expressivity of higher-order grammars are not completely understood. A partial answer has been given for word languages: Aehlig, De Miranda and Ong showed that up to order $2$, there is no intrinsically unsafe word language \cite{DBLP:conf/fossacs/AehligMO05}: any word language generated by an unsafe order-$2$ grammar can also be generated by some (potentially non-deterministic) order-$2$ safe grammar.
For trees, Urzycczyn conjectured \cite{demirandathesis} that safety constrains expressivity. He even proposed a tree called Urzycczyn's tree that is generated by an unsafe order-$2$ recursion scheme that he conjectured to not be generated by any safe order-$2$ recursion scheme. At present, no one has managed to prove or disprove this conjecture.

A similar question can be asked from a verification point of view: are the structures generated by safe higher-order grammars easier to verify that those generated by unrestricted grammars? The reason why the safety constraint was introduced in the first place in \cite{KNU02} was precisely to be able to show that the generated trees have decidable Monadic Second Order (MSO) theories.
It turns out in fact that this result holds in the general unrestricted case
as it was later shown in \cite{OngLics2006}:
\begin{theorem}
\label{thm:modalmucalctree_decidable}
The modal mu-calculus model checking problem for trees generated by order-$n$ recursion schemes is $n$-EXPTIME complete for each $n\geq 0$.
\end{theorem}
This result implies that these trees have decidable MSO theories since the two logics are equi-expressive over trees. The proof of this theorem is based on a game semantic argument based on the theory of traversals (that will be presented in Chapter \ref{chap:concrete_gamesem}) which radically differs from the argument used in \cite{KNU02} for the case of safe grammars. A generalization of Theorem \ref{thm:modalmucalctree_decidable} for graphs was later obtained in \cite{hmos-lics08}:
\begin{theorem}
For each $n\geq 0$, the modal mu-calculus model checking problem for configuration graphs of order-$n$ collapsible pushdown systems is $n$-EXPTIME complete.
\end{theorem}
For graphs, the MSO logic is strictly more expressive than the modal mu-calculus. In the same paper it is shown that MSO theories of collapsible pushdown graphs are undecidable while those of pushdown graphs are decidable \cite{hmos-lics08}. Hence from a verification point of view, safety can indeed be considered as a genuine constraint.


\subsection{Higher-order grammars and the simply typed lambda calculus}
\newcommand\ymut{Y_{\sf mut}}
Higher-order grammars are essentially closed simply type lambda terms of ground type extended with recursion and generated from function symbols $\Sigma$. We now make this correspondence explicit.
The syntax of the simply typed lambda calculus is extended with the mutual recursion operator $\ymut$:
 $$ (\ymut) \rulef{\Gamma \vdash M_1 : A \typear A_1 \qquad \Gamma \vdash M_q : A \typear A_q}{\Gamma \vdash \ymut (M_1, \ldots, M_q):A_1}\ A = A_1 \times \ldots \times A_q, q \geq 0$$
whose semantics is given by the rule
$ \ymut (M_1 \ldots M_q) \rightarrow \pi_1 (Y \langle M_1 \ldots M_q \rangle)$
where $\pi_1$ denotes the projection of a $q$-tuple to its first component and $Y$ denotes the extension of the usual $Y$-combinator to product types with a semantics given by the rule:
$$ Y \langle M_1, \ldots, M_q \rangle \rightarrow
\langle M_1 (Y \langle M_1, \ldots, M_q \rangle),
\ldots, M_q (Y \langle M_1, \ldots, M_q \rangle) \rangle \enspace .$$
We write $\Lambda_\rightarrow^{mut}(\Sigma)$ to denote the simply typed calculus extended with  mutual recursion and $\Sigma$-constants.

A higher-order grammar can then be equivalently expressed as a closed simply typed term from $\Lambda_\rightarrow^{mut}(\Sigma)$.
The first direction is trivial: Take a grammar $\langle \Sigma, \mathcal{N}, \mathcal{R}, F_0 \rangle$
where $\mathcal{R} = \{ F_0, \ldots, F_q \}$ for some $q\geq 0$.
We convert each rule $F_i\ x_1 \ldots x_n \rightarrow e$ into a lambda term $\widetilde{F_i} \equiv \lambda F_0 \ldots F_q x_1 \ldots x_n . e$. The grammar can then be equivalently formulated as the term $\ymut ( \widetilde{F_0},\ \ldots,\  \widetilde{F_q})$.

Conversely, any lambda term using mutual recursion and $\Sigma$-constants can be equivalently formulated as a higher-order grammar.
The conversion proceeds inductively over the syntax of the $\eta$-long normal form of the term. The algorithm {\sf LmdToHOGr} is described in Table \ref{tab:LmdToHOGr} in an ML-like syntax.  The function {\sf LmdToHOGr} take a closed term from $\Lambda_\rightarrow^{mut}(\Sigma)$ and returns an equivalent higher-order grammar. The variables $\mathcal{N}$ and $\mathcal{R}$ contain respectively the list of non-terminals and rules created so far.  The auxiliary function {\sf createRules} creates the rules
for an open lambda-term, adds them to the set $\mathcal{R}$ and returns and applicative term in $\mathcal{A}(\mathcal{N}\union\Sigma)$ that is equivalent to the given lambda-term. Observe that since we work on the $\eta$-long normal form, the right-hand side of each generated rule is indeed of ground type, as required by the definition of higher-order grammars.
We use the symbol @ to represent the application of two applicative terms.

\begin{table}[htbp]

{\bf Input}: a closed lambda-term $\vdash_\Sigma M : T$ in $\eta$-normal form
potentially using mutual recursion.

{\bf Output}: an equivalent higher-order grammar scheme $\langle \Sigma, \mathcal{N}, \mathcal{R}, S \rangle$.
$$\begin{array}{ll}
{\sf let\ LmdToHOGr}(\vdash_\Sigma M : T) \\
\quad {\sf let\ createRules} : \Lambda_\rightarrow^{mut}(\Sigma) \typear  \mathcal{A}(\mathcal{N}\union\Sigma)  = {\sf fun} \\
\quad \quad
    \begin{array}{lcl}
     |\ \Gamma \vdash \alpha : T \mbox{\quad with } \alpha \in \Gamma \union \Sigma &\rightarrow& \alpha\\
     |\ \Gamma \vdash M_0 \ldots M_q : o
      &\rightarrow&
        {\sf createRules} (\Gamma \vdash M_0 : T_0) \\
        &&@ \cdots \\
        &&@ {\sf createRules} (\Gamma \vdash M_q: T_q)
      \\
     |\ \overline{x} : \overline{A} \vdash \lambda \overline{y}^{\overline{B}}. M : (\overline{B},o)
       &\rightarrow&
        {\sf let\ } t = {\sf createRules} (\overline{x}: \overline{A}, \overline{y}: \overline{B}\vdash M : o) \\
         && {\sf and \ } F \mbox{ be a fresh non-terminal name } {\sf in}\\
         &&\mathcal{R} \leftarrow \mbox{``}F\ \overline{x}\ \overline{y} \rightarrow t\mbox{''}::\mathcal{R} \\
         &&\mathcal{N} \leftarrow \mbox{``}F : (\overline{A},\overline{B},o)\mbox{''}::\mathcal{N} \\
         && \mbox{``}F\ \overline{x}\mbox{''}
     \\
      |\ \overline{x} : \overline{A} \vdash \ymut (M_1, \ldots, M_q):B_1 &\rightarrow&
      \mbox{// \it where $M_i:B_i$ for $i\in\{1..q\}$}\\
     &&
     {\sf for\ i = 1\ ..\ q\ do} \\
     &&\qquad     {\sf createRules} (\overline{x}: \overline{A} \vdash M_i : B_i) \\
     &&\qquad     {\sf let\ }\mbox{``}F_i\, \overline{x}\, f_1 \ldots f_q\, \overline{y}_i \rightarrow t_i \mbox{''} \leftarrow hd\ \mathcal{R} {\sf\ in} \\
     &&\qquad \mathcal{R} \leftarrow \mbox{``}\widehat{F_i}\ \overline{x} \ \overline{y}_i \rightarrow t_i[\widehat{F_1} \overline{x}/f_1] \ldots [\widehat{F_q} \overline{x}/ f_q]\mbox{''} \\
     &&\qquad\qquad ::tail\ \mathcal{R} \\
     &&\qquad\mathcal{N} \leftarrow \mbox{``}\widehat{F_i} : (\overline{A},B_i)\mbox{''}::tail\ \mathcal{N} \\
     &&{\sf done} \\
     &&\mbox{``}\widehat{F_1}\ \overline{x}\mbox{''}
   \end{array} \\
\qquad {\sf in}\\
\qquad \mathcal{N},\mathcal{R} \leftarrow [],[]  \\
\qquad appterm \leftarrow {\sf createRules}(\vdash M : T) \\
\qquad \langle \Sigma, \mbox{``}S\ \rightarrow appterm\mbox{''}::\mathcal{N}, \mbox{``}S:o\mbox{''}::\mathcal{R}, S \rangle
\end{array}$$

\caption[Algorithm {\sf LmdToHOGr}.]{Algorithm {\sf LmdToHOGr} converting a mutually recursive lambda term into a higher-order grammar.}
\label{tab:LmdToHOGr}
\end{table}


