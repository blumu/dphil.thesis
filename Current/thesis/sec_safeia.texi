% -*- TeX -*- -*- Soft -*-
\section{Safe \pcf}
We define \defname{Safe \pcf} as the applied safe lambda calculus extended with the constants of \pcf\ (additions, substraction, conditional and recursion). Equivalently, it is the restriction of \pcf\ where the application and abstraction rules are constrained similarly as in the safe lambda calculus. The rules are given in Table \ref{tab:safepcf}. The circled rules are those that
differ from their \pcf\ counterpart. Observe that it is necessary to add a further abstraction rule \rulenamet{abs'} to allow terms formed with the arithmetic and recursion rules to be abstracted.

\begin{FramedTable}
 {\bf Functional part}
$$ \rulename{var} \ \rulef{}{x : A\sentail x : A} \qquad
\rulename{wk} \ \rulef{\Gamma \sentail s : A}{\Delta \sentail s : A} \quad
\Gamma \subset \Delta$$

\begin{center}
\ovalbox{%
\begin{Bcenter}
$ \rulename{app_{as}} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \asappentail s~t_1 \ldots t_n : B} $
 \\[12pt]
$ \rulename{app} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \sentail s~t_1 \ldots t_n : B} \quad \ord{B} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail s : B} {\Gamma \sentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs'} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \sentail s : B} {\Gamma \sentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\sentail n :\iaexp}
\qquad \rulename{succ} \ \rulef{\Gamma \sentail M:\iaexp }{\Gamma \sentail \pcfsucc\ M:\iaexp}
\qquad \rulename{pred} \ \rulef{\Gamma \sentail M:\iaexp }{\Gamma \sentail \pcfpred\ M:\iaexp}$$

$$
\rulename{cond} \ \rulef{\Gamma\sentail M : \iaexp \quad \Gamma\sentail N_1 : \iaexp \quad \Gamma\sentail N_2 : \iaexp }{\Gamma \sentail \pcfcond\ M\ N_1\ N_2}
\quad  \rulename{rec} \ \rulef{\Gamma \sentail M : A\rightarrow A }{ \Gamma \sentail Y_A M : A}$$
\caption{Formation rules for Safe \pcf.}
\label{tab:safepcf}
\end{FramedTable}
We extend the notion of \emph{almost safety} (Sec.\ \ref{sec:almostsafety}) to \pcf: a \pcf\ term is \defname{almost safe} if it can be written $\lambda x_1 \ldots x_n . N_0 \ldots N_p$ for some $n,p \geq 0$ where $N_i$ is safe for all $0\leq i \leq p$.

The Substitution Lemma and No-variable-capture Lemma shown for the safe lambda calculus naturally extends to safe \pcf. The small-step semantics of safe \pcf\ is obtained from the one of \pcf\ by replacing $\beta$-reduction by safe $\beta$-reduction (Def.\ \ref{dfn:safereduction}) in the definition of the relation $\rightarrow$.  The Subject Reduction Lemma from the safe lambda calculus implies that the relation $\rightarrow$ preserves safety: Suppose that $M \rightarrow N$, then $\Gamma \sentail M:T$ implies $\Gamma \sentail N:T$. It also preserves almost-safety. Finally, a term is safe if and only if its eta-long normal form is safe.

\subsection*{Remark concerning recursion}
There are many ways to introduce recursion in the syntax of a programming language.
In its usual presentation, \pcf\ introduces recursion by mean of a set of constants $Y_A$, $A$ ranging over \pcf\ types, incarnating the $Y$-combinator of the lambda calculus. Its syntax is given by the rule \rulenamet{rec} of table \ref{tab:safepcf}. For instance, the addition function can be represented by the \pcf\ term:
$$ plus \equiv Y (\lambda p\; x\; y. \pcfcond\ x\;y\;(p\ (\pcfpred\ x)\ (\pcfsucc\ y))) \ .$$
Equivalently, we can introduce recursion using the ``least upper bound'' abstractor $\mu$ given by the formation rule
$$ \rulename{\mu} \rulef{\Gamma, f: A \entail M : A}{\Gamma \entail  \mu f. M: A}$$
where the semantics of $\mu$ is given by the rule:
$ \mu f. M \rightarrow M[(\mu f. M)/f]$.
Using this construct, the addition function can be defined as:
$$ plus \equiv \mu p . \lambda x y. \pcfcond\ x\;y\;(p\ (\pcfpred\ x)\ (\pcfsucc\ y)) \ .$$

Clearly in the context of \pcf, these two definitions are interchangeable:
$\mu f.M:A$ is equivalent to $Y_A (\lambda f . M)$,
and $Y_A F : A$ is eta-equivalent to $Y_A (\lambda f. F f)$ for some fresh variable $f:A$, which is equivalent to $\mu f. F f$.

In the context of safe \pcf, however, the distinction is important.
Indeed, let us call safe $\mu$-\pcf\ the calculus obtain by replacing the rule \rulenamet{rec} by \rulenamet{\mu} in Table \ref{tab:safepcf}. It turns out that safe \pcf\ is strictly contained in safe $\mu$-\pcf.
Indeed, compare the two ways of defining a recursive term:
\begin{mathpar}
\inferrule*[Left=\rulenamet{rec}]{\inferrule*[Left=\rulenamet{abs}]{\Gamma, f: A \sentail M : A}{\Gamma\sentail \lambda f. M : A\typear A}}{\Gamma \sentail Y_A (\lambda f . M)}
\hspace{2cm}
\inferrule* [Left=\rulenamet{\mu}]{\Gamma, f: A \sentail M : A}{\Gamma \sentail  \mu f. M: A}
\end{mathpar}
Both derivations start with the premise $\Gamma, f: A \sentail M : A$ which implies that $\ord{\Gamma} \geq \ord{A}$. In the left derivation, before applying the $Y$ combinator, we need first to abstract the variable $f$. This is done using the abstraction rule whose side-conditions gives $\ord{\Gamma} > \ord{A}$. The right derivation, however, only imposes the condition $\ord{\Gamma} \geq \ord{A}$.

In fact, the safe $\mu$-\pcf\ does not really deserve its name, because
it does not verifies the No-variable-capture lemma!
For instance for any types $A$ and $B$ with $\ord{A}\geq\ord{B}$, the term
$$ \lambda f:A \typear B\; a:A. (\lambda x:B.(\mu f:B.x))(f a)$$
is a safe $\mu$-\pcf\ term that $\beta$-reduces to
$$ \lambda f:A \typear B\; a:A. (\mu f:B.x)[f a/x] \ .$$
At this point it would not be sound to push the substitution under the $\mu$ without first renaming the variables afresh as it would cause the variable $f$ to be captured by $\mu f$.
Hence the definition that we really want for safe \pcf\ is the one based on the Y-combinator.


Observe that if we were able to distinguish variables that are bound by $\lambda$ from those bound by $\mu$ - for instance by tagging their occurrences appropriately - then the clash of variable name could be tolerated in this particular example because the two clashing occurrences of $f$ are bound by a different kind of binder.


Unfortunately, this argument cannot be generalized: there are safe $\mu$-\pcf\ terms that, when reduced using capture-permitting substitution, cause clashes between $\lambda$-bound variables. Take for instance:
\begin{align*}
 M &\equiv \lambda g:3\; h:3\; x:1 . g ( \mu F:3. N(F,g,h,x))\\
 N(F,g,h,x) &\equiv x ( h ( \lambda x:1 . F (\lambda z:0.z)))
\end{align*}
where $0$ denotes the type $o$ and $n+1$ denotes $n \typear o$, for $n\in\nat$.
The safe $\mu$-\pcf\ term $M$ reduces to:
$$ \lambda g:3\; h:3\; x:1 . g (x ( h ( \lambda \underline{x}:1 . F (\lambda z:0.z))))[N(F,g,h,\underline{x})/F] \ .$$
Performing the substitution capture-permitting causes a clash between the two underlined variables.

In fact, the same example shows that the game-semantic characterization of safe \pcf\ that we will give in Chapter \ref{chap:model} does not hold for safe $\mu$-\pcf.


\subsection*{Expressive power}

Despite the strong syntactic constraint imposed on the language, the presence of the Y combinator makes it Turing Complete. One way to prove it consist in showing that partial recursive functions can be computed in Safe \pcf. Instead we will show that 
the \textsc{Queue} programming system is encodable in Safe \pcf.


\subsection{The queue-halting problem}
We fix a finite alphabet $\Sigma = \{ a_1, \ldots, a_p \}$. A \textsc{Queue} program is a finite sequence of instructions that manipulate a queue data-structure.
A program $P$ is a sequence of $n$ instructions for some $n\in \nat$. For $1 \leq i \leq n$, $P i$ denotes the $i^{\sf th}$ instruction of the sequence $P$. There are four possible kinds of instruction: halting, enqueuing, dequeuing and branching. The set of instructions is formally defined as:
$$ \mathcal{I} = \{ {\tt halt} \} \cup
\{ {\tt enqueue \ } a \ | \ a \in \Sigma \}
\cup \{ {\tt dequeue} \} \cup \{ {\tt goto\ } l {\tt\ if\ first =\ } a \ | \ l \in 1..n, a \in \Sigma \}
 $$


The operational semantics is described using a set of states $ \{ \eop \} \cup \{ 1,..,n \} \times \Sigma^* $. The state $\eop$ corresponds to the final state at which the program stops. A state of the form $(i,x) \in \{ 1,..,n \} \times \Sigma^*$ indicates that the queue's content is given by the sequence $x$ and that the next instruction to be executed by the machine is $P i$. The empty queue is denoted by $\epsilon$ and for any sequence $x \in \Sigma^*$, the first element of $x$ corresponds to the element that has been \emph{first} enqueued (i.e. the queue is fed at the right-end side and consumed at the left-end side). The rules defining the operational semantics are:
\begin{eqnarray*}
(i,x) \mbox{ with } P i = {\tt halt} &\longrightarrow& \eop \\
(i,x) \mbox{ with } P i = {\tt enqueue\ } a &\longrightarrow& (i+1,x \cdot a) \\
(i,\epsilon) \mbox{ with } P i = {\tt dequeue } &\longrightarrow& \eop \\
(i,a \cdot x) \mbox{ with } P i = {\tt dequeue } &\longrightarrow& (i+1,x) \\
(i,\epsilon) \mbox{ with } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (i+1,\epsilon) \\
(i,b \cdot x) \mbox{ with } a \neq b \mbox{ and } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (i+1,b \cdot x) \\
(i,a \cdot x) \mbox{ with } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (l,a \cdot x)
\end{eqnarray*}

The \textsc{Queue} programming system is Turing Complete. This is because Post's Tag Systems can be simulated \cite{Minsky67} in \textsc{Queue}, and can simulate Turing machines \cite{Minsky64}. Consequently, the \textsc{Queue-Halting} problem (``Given a queue program, will it halt eventually?'') is undecidable.

\section{Safe Idealized Algol}

In this section we present two possible approaches to accommodate
the safety restriction to a language featuring block-variable constructs such as Idealized Algol. This gives rise to two different versions of ``Safe Idealized Algol''. In the first version, all free variables are required to satisfy the safety constraint whereas in the second version, only variables that are
not abstracted by the \ianew\ construct (including variables of type
\iavar) are required to satisfy the safety constraint.
We then show that the nice properties of the safe $\lambda$-calculus remain in these two extensions of the safe lambda calculus.

\subsection{Strongly Safe \ialgol}

 The obvious way to define safety for \ialgol\ terms consists in extending the safe lambda calculus by adding the usual constant rules of \ialgol. Equivalently, this is the system of rules of \ialgol\ where the application and abstraction rules are restricted by the safety constraint the same way as in the safe lambda calculus. We refer to this language as \defname{strongly safe \ialgol}. The rules are formally given in Table \ref{tab:safeia_formrules}. The rules circled in the table are those that
differ from their IA counterpart. Note that the IA rule $\rulename{new}$ is kept unchanged: it has no side-condition, contrary to the $\rulename{abs}$ rule. In other words, the calculus allows us to abstract variables of type \iavar\ without having to satisfy the safety constraint provided that the binder is a block-variable declaration.


\begin{FramedTable}
 {\bf Functional part}

$$ \rulename{var} \ \rulef{}{x : A  \vsafeentail x : A}
\qquad \rulename{wk} \ \rulef{\Gamma \vsafeentail s :
A}{\Delta \vsafeentail s : A} \quad \Gamma \subset
\Delta
$$

\begin{center}
\ovalbox{%
\begin{Bcenter}
$ \rulename{app_{as}} \ \rulef{\Gamma \vsafeentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \vsafeentail t_1 : A_1 \quad \ldots
\quad \Gamma \vsafeentail t_n : A_n} {\Gamma \asappentail s~t_1 \ldots t_n : B} $
 \\[12pt]
$ \rulename{app} \ \rulef{\Gamma \vsafeentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \vsafeentail t_1 : A_1 \quad \ldots
\quad \Gamma \vsafeentail t_n : A_n} {\Gamma \sentail s~t_1 \ldots t_n : B} \quad \ord{B} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail s : B} {\Gamma \vsafeentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs'} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \vsafeentail s : B} {\Gamma \vsafeentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\vsafeentail n :\iaexp}
\qquad \rulename{succ} \ \rulef{\Gamma \vsafeentail M:\iaexp }{\Gamma \vsafeentail \pcfsucc\ M:\iaexp}
\qquad \rulename{pred} \ \rulef{\Gamma \vsafeentail M:\iaexp }{\Gamma \vsafeentail \pcfpred\ M:\iaexp}$$

$$
\rulename{cond} \ \rulef{\Gamma\vsafeentail M : \iaexp \quad \Gamma\vsafeentail N_1 : \iaexp \quad \Gamma\vsafeentail N_2 : \iaexp }{\Gamma \vsafeentail \pcfcond\ M\ N_1\ N_2}
\quad  \rulename{rec} \ \rulef{\Gamma \vsafeentail M : A\rightarrow A }{ \Gamma \vsafeentail Y_A M : A}$$

{\bf Imperative constructs}
$$ \rulename{seq} \ \rulef{\Gamma| \Gamma^{\ianew} \vsafeentail M : \iacom \quad \Gamma \vsafeentail N :A}
    {\Gamma \vsafeentail \iaseq_A \ M\ N\ : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulename{assign} \ \rulef{\Gamma \vsafeentail M : \iavar \quad \Gamma \vsafeentail N : \iaexp}
    {\Gamma \vsafeentail \iaassign\ M\ N\ : \iacom}
\qquad \rulename{deref} \
 \rulef{\Gamma \vsafeentail M : \iavar}
    {\Gamma \vsafeentail \iaderef\ M\ : \iaexp}$$

$$ \rulename{new} \ \rulef{\Gamma , x : \iavar\ \vsafeentail M : A}
    {\Gamma  \vsafeentail \texttt{new } x \texttt{ in } M : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulename{mkvar} \ \rulef{\Gamma \vsafeentail M_1 : \iaexp \rightarrow \iacom \quad \Gamma \vsafeentail M_2 : \iaexp}
    {\Gamma \vsafeentail \iamkvar\  M_1\ M_2\ : \iavar}$$

\caption{Formation rules for strongly safe \ialgol}
\label{tab:verysafeia_formrules}
\end{FramedTable}
\bigskip

\subsection{Safe \ialgol}
\label{subsec:safeia_rules}

It turns out that the definition of strongly safe \ialgol\ is needlessly
restrictive. Indeed, we would like to identify a fragment of \ialgol\
which restricts the occurrences of the variables in a term
so that the so-called ``No-variable-capture'' lemma holds, \ie it is no necessary to rename variables afresh when performing substitution. But in the present setting of a language with imperative features, one can distinguish two types of variables in a closed term: the ``standard ones'' -- those that are bound by $\lambda$-abstraction; and the ``imperative'' ones -- those that are used as identifiers for memory cells, also called block-allocated variables. We observe that we do not gain anything by imposing constraints on the second kind of variables since no term can ever by substituted for such variables when performing reduction. It is therefore possible to define a more general fragment of \ialgol\ subsuming strongly safe \ialgol\ while preserving its good properties.

We consider a new judgment of the form $\Gamma | \Gamma^{\ianew}
\safeentail M : A$, called a \defname{split term} in \cite{abramsky:game-semantics-tutorial}, where the context is partitioned into two \emph{disjoint} components: The first component contains standard lambda calculus variables; the second component contains block-allocated variables --
abstracted by an occurrence of the \ianew\ construct. The component
$\Gamma^{\ianew}$ contains variables of type \iavar\ only, while the
other component can contain variables of any type including \iavar. We take as a convention that the two components cannot share variable names. It is straightforward to redefine the typing rule of \ialgol\ in
such a way that these two distinct contexts are maintained
appropriately. In particular the abstraction rule must only be able
to abstract variables taken from the first component of the context;
similarly the \ianew\ block construct must only be used to
``abstract'' variables from the block-variable context. The full
system of rules is given in Table \ref{tab:safeia_formrules}. The
rules that are circled in the table are those that differ from their counterpart in Table \ref{tab:verysafeia_formrules}. In particular:
\begin{itemize}
\item the rule $\rulename{abs}$ and $\rulename{new}$ can only
abstract variables from their respective context component;
\item the side-condition in $\rulename{abs}$ constrains only
variables from the first component of the context.
\end{itemize}

\begin{FramedTable}
{\bf Functional part}

$$ \rulename{var} \ \rulef{}{x : A | \emptyset \safeentail x : A} \quad
\rulename{var^{\ianew}} \ \rulef{}{\emptyset | x : \iavar \safeentail x : \iavar} $$
$$
\rulename{wk} \ \rulef{\Gamma | \Gamma^{\ianew} \safeentail s : A}{\Delta | \Gamma^{\ianew} \safeentail s : A} \quad
\Gamma \subset \Delta \qquad
\rulename{wk^{\ianew}} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail s : A}{\Gamma| \Delta^{\ianew} \safeentail s : A} \quad
\Gamma^{\ianew} \subset \Delta^{\ianew}
$$

where $\Gamma^{\ianew}$ and $\Delta^{\ianew}$ are disjoint finite sets of variables of type \iavar.

$$ \rulename{app_{as}} \ \rulef{\Gamma | \Gamma^{\ianew} \safeentail s : (A_1,\ldots,A_n,B) \quad
\Gamma | \Gamma^{\ianew} \safeentail t_1 : A_1 \quad \ldots \quad \Gamma | \Gamma^{\ianew} \safeentail t_n : A_n
} {\Gamma | \Gamma^{\ianew} \asappentail s t_1 \ldots t_n : B}$$

$$ \rulename{app} \ \rulef{\Gamma | \Gamma^{\ianew} \safeentail s : (A_1,\ldots,A_n,B) \quad
\Gamma | \Gamma^{\ianew} \safeentail t_1 : A_1 \quad \ldots \quad \Gamma | \Gamma^{\ianew} \safeentail t_n : A_n
} {\Gamma | \Gamma^{\ianew} \safeentail s t_1 \ldots t_n : B} \quad \ord{B} \leq \ord{\Gamma}$$

\begin{center}\ovalbox{
\begin{Bcenter}
 $\rulename{abs} \ \dps  \rulef{\dps \Gamma, x_1 : A_1, \ldots, x_n : A_n | \Gamma^{\ianew} \asappentail s : B} {\Gamma | \Gamma^{\ianew} \safeentail \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \ord{(A_1, \ldots ,A_n,B)} \leq \ord{\Gamma}$
\\[12pt]
 $\rulename{abs'} \ \dps  \rulef{\dps \Gamma, x_1 : A_1, \ldots, x_n : A_n | \Gamma^{\ianew} \safeentail s : B} {\Gamma | \Gamma^{\ianew} \safeentail \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \ord{(A_1, \ldots ,A_n,B)} \leq \ord{\Gamma}$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\emptyset | \emptyset \safeentail n :\iaexp}
\quad \rulename{succ} \ \rulef{\Gamma | \Gamma^{\ianew}\safeentail M:\iaexp }{\Gamma| \Gamma^{\ianew} \safeentail \pcfsucc\ M:\iaexp}
\quad \rulename{pred} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M:\iaexp }{\Gamma| \Gamma^{\ianew} \safeentail \pcfpred\ M:\iaexp}$$

$$
\rulename{cond} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \iaexp \quad \Gamma| \Gamma^{\ianew} \safeentail N_1 : \iaexp \quad \Gamma| \Gamma^{\ianew} \safeentail N_2 : \iaexp }{\Gamma| \Gamma^{\ianew} \safeentail \pcfcond\ M\ N_1\ N_2}
\ \ \rulename{rec} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : A\rightarrow A }{ \Gamma| \Gamma^{\ianew} \safeentail Y_A M : A}$$

{\bf Imperative constructs}
$$ \rulename{seq} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \iacom \quad \Gamma| \Gamma^{\ianew} \safeentail N :A}
    {\Gamma| \Gamma^{\ianew} \safeentail \iaseq_A \ M\ N\ : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulename{assign} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \iavar \quad \Gamma| \Gamma^{\ianew} \safeentail N : \iaexp}
    {\Gamma| \Gamma^{\ianew} \safeentail \iaassign\ M\ N\ : \iacom}
\qquad
 \rulename{deref} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \iavar}
    {\Gamma| \Gamma^{\ianew} \safeentail \iaderef\ M\ : \iaexp}$$


\begin{center}\ovalbox{$
\rulename{new} \ \dps \rulef{\Gamma | \Gamma^{\ianew}, x :
\iavar\ \safeentail M : A}
    {\Gamma | \Gamma^{\ianew} \safeentail \ianewin{x}\ M : A} \quad A \in \{ \iacom, \iaexp\} $}\end{center}

$$ \rulename{mkvar} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M_1 : \iaexp \rightarrow \iacom \quad \Gamma| \Gamma^{\ianew} \safeentail M_2 : \iaexp}
    {\Gamma| \Gamma^{\ianew} \safeentail \iamkvar\  M_1\ M_2\ : \iavar}$$

\caption{Formation rules for safe \ialgol.} \label{tab:safeia_formrules}
\end{FramedTable}


 Split-terms with an empty block-variable context $\Gamma^\ianew$ are called \defname{semi-closed}. We define \defname{Safe IA} to be the set of semi-closed split-terms typable with the system of rules of Table \ref{tab:safeia_formrules}. For convenience we introduce the additional rule
$$ \rulef{\Gamma | \emptyset \safeentail M : A} {\Gamma \safeentail M : A}$$
so that safe \ialgol\ is given by the set of terms-in-context $\Gamma \safeentail M : A$.

\begin{example}
Clearly strongly safe \ialgol\ is a subset of safe \ialgol\ and the following example shows that the inclusion is strict:
$$ \safeentail \lambda f:{(\iaexp \rightarrow \iacom) \rightarrow \iaexp} .\  \ianewin{i}{f ( \lambda x . \iaassign\ i\ x )} : \iaexp$$
$$ \mbox{ but } \not \vsafeentail \lambda f:{(\iaexp \rightarrow \iacom) \rightarrow \iaexp} .\ \ianewin{i}{f ( \lambda x . \iaassign\ i\ x )} : \iaexp \ .$$

It is not strongly safe because the variables $i$ and $x$ are of the same order but only $x$ is abstracted by the lambda. It is safe because block-allocated variables such as $i$ are not constrained in safe \ialgol.
\end{example}

For split safe \ialgol\ terms, only variables from the left context component are constrained by the safe restriction:
\begin{lemma}
If $\Gamma | \Gamma^{\ianew}
\safeentail M : A$ then for all variable $z \in fv(M) \inter \Gamma$, $\ord{z} \geq \ord{A}$
\end{lemma}
(This is the counterpart of Lemma \ref{lem:ordfreevar} for the safe lambda calculus.)

\subsection{Substitution}
The notion of substitution naturally extends to Safe \ialgol: it is done inductively on the structure of the term; for the block-variable case this gives:
\begin{align*}
  (\ianewin{x}{M})\subst{N}{y} &= \ianewin{z}{M\subst{z}{x}\subst{N}{y}} & \mbox{if $x\neq y$, $z$ fresh;}\\
  (\ianewin{x}{M})\subst{N}{x} &= \ianewin{x}{M} \ .
\end{align*}
And for capture-permitting substitution:
\begin{align*}
  (\ianewin{x}{M})\captsubst{N}{y} &=   \ianewin{x}{M\captsubst{N}{y}} & \mbox{if $x\neq y$;}\\
  (\ianewin{x}{M})\captsubst{N}{x} &=   \ianewin{x}{M} \ .
\end{align*}

\emph{In which sense are the two calculi above-defined ``safe''?} In the lambda calculus, the term ``safety'' refers to the fact that substitution can be performed \emph{capture-permitting}. Unfortunately, in the presence of block-allocation constructs, this lemma does not hold anymore.
The key reason is that the block-allocation construct $\ianew$ does not increase the order of the term that is being formed contrary to the traditional $\lambda$-abstraction, and such property is crucially used in the proof of the No-variable-capture lemma in the safe lambda calculus. The following examples illustrate this. Consider the terms:
\begin{align*}
M_1 &\equiv \ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ ((\lambda y:\overline 0. \ianewin{x}{y})(\iaderef\ x))} \\
M_2 &\equiv \lambda x:\overline 1. (\lambda y:\overline 1. (\ianewin{x}{y\ 0})) x\\
M_3 &\equiv  \lambda f: \overline 2 . \ianewin{x}{(\lambda y:\overline 1. f (\lambda x:\overline 0. y))(\lambda z:\overline 0 . \iaderef\ \underline{x})}
\end{align*}
where $\overline 0$ is an abbreviation for \iaexp\ and for $n\in\nat$, $\overline{n+1}$ stands for the type $n \typear \iaexp$.

Clearly, the \ialgol\ terms $M_1$ and $M_2$ are both strongly safe, and therefore also safe. $M_3$, however, is safe but not \emph{strongly} safe because the underlined occurrence of $x$ is not abstracted together with $z$.
Theses examples shows that it is \emph{not} ``safe'' to use capture-permitting substitution in (strongly-) safe \ialgol. The term $M_1$ gives an example where a block-variable is captured by another block-declaration; in $M_2$ a block-variable is captured by a lambda-abstraction; and in $M_3$ a lambda-bound variable is captured by a block-variable declaration:
\begin{enumerate}[(i)]
  \item
Consider the term $M_1$, we have:
$$M_1 \betared \ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ (\ianewin{x}{y})\subst{(\iaderef\ x)}{y}}$$
Performing the substitution without renaming variables afresh causes the variable $x$ to get captured by the innermost $\ianew\ x$ giving
$$\ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ (\ianewin{x}{\iaderef\ x})}$$
which is observationally equivalent to $0$ (since block-allocated variables are initialized with $0$). On the other hand the standard substitution gives:
$$\ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ (\ianewin{z}{\iaderef\ x})}$$
which is observationally equivalent to $1$.

\item For $M_2$, the capture permitting substitution gives
$\lambda x:\overline 1. (\ianewin{x}{x\ 0})$ which is not even a valid \ialgol\ term;

\item Finally for $M_3$, capture permitting substitution gives
$\lambda f: \overline 2 . \ianewin{x}{\lambda y:\overline 1. f (\lambda x:\overline 0. (\lambda z:\overline 0 . \iaderef\ x))}$
which is also not a valid \ialgol\ term.
\end{enumerate}

To deal with the first two examples, we have no other choice than renaming block-declared variables afresh upon substitution. For the third kind of variable capture (which only happens for safe terms that are not strongly safe) we can fix the problem by making the assumption that the set of names used for block-declared variables is disjoint from the set of names used for lambda-abstracted variables; or equivalent by assuming that each variable occurrence has an implicit tag indicating whether it is a block-allocated variable or a lambda-abstracted variable, thus permitting us to resolve any binding ambiguity. (Observe that the fact that the set of names of the two context components of a split-terms are disjoint is not sufficient because this only constrains the free variables of the term whereas what we are requiring here is a global constraint on all variables names occurring in the term.)

This leads us to the following notion of substitution which performs variable renaming only for block-allocated variables:
\begin{definition}
The \defname{semi-capture-permitting substitution} of the term-in-context $\Gamma | \Gamma^{\ianew}
\entail N : A$ for $x$ in the term-in-context $\Gamma, x:A | \Gamma^{\ianew}
\entail M : B$, written $\Gamma | \Gamma^{\ianew} \entail M\semicaptsubst{N}{x}$, is defined inductively on $M$ as follows:
\begin{align*}
x \semicaptsubst{N}{x} &= N \\
y \semicaptsubst{N}{x} &= y & y\neq x;\\
(\lambda x . M) \semicaptsubst{N}{x} &= \lambda x . M \\
(\lambda y . M) \semicaptsubst{N}{x} &= \lambda y . M\semicaptsubst{N}{x} & \mbox{where $y \not = x$;} \\
(\ianewin{x}{M})\semicaptsubst{N}{x} &=   \ianewin{x}{M} \\
(\ianewin{y}{M})\semicaptsubst{N}{x} &= \ianewin{z}{M\semicaptsubst{z}{y}\semicaptsubst{N}{x}} & \mbox{if $x\neq y$, $z$ fresh.}
\end{align*}
The constant and application cases are defined inductively in the standard way.
\end{definition}

It is now possible to state a weaker version of the \emph{No-variable capture lemma} for safe \ialgol, namely that there is no need to rename \emph{$\lambda$-bound} variables afresh when performing substitution.
\begin{lemma}
\label{lem:nocapture_safeia}
Suppose that $\Gamma | \Gamma^{\ianew}
\safeentail N : A$ and $\Gamma, x:A | \Gamma^{\ianew}
\safeentail M : B$ are safe \ialgol\ terms then
the substitution $M\subst{N}{x}$ can be performed semi-capture-permitting \emph{provided that the set of names for lambda-bound variables and block-allocated variables are disjoint.}
In other words:
$$ M\subst{N}{x} =_\alpha M\semicaptsubst{N}{x} \ .$$
\end{lemma}
The proof is a trivial extension of Lemma \ref{lem:nocapture}.


The small-step reduction semantics of safe IA is defined similarly as in Sec.\ \ref{subsec:smallstep_ia} except that $\beta$-reduction is replaced by safe $\beta$-reduction. A consequence of Lemma \ref{lem:nocapture_safeia} is that safety is preserved by the small-step reduction of \ialgol:
\begin{lemma}[Reduction preserves safety]
\label{lem:ia_safety_preserved} Let $M$ be a safe \ialgol\ term. If
$M \rightarrow N$, where $\rightarrow$ denotes the small-step reduction of safe \ialgol, then $N$ is also a safe term.
\end{lemma}
The proof is by an easy induction.
