% -*- TeX -*- -*- Soft -*-
\section{Safe \pcf}
We define \defname[safe!\pcf]{safe \pcf} as the applied safe lambda calculus extended with the constants of \pcf\ (additions, substraction, conditional and recursion). Equivalently, it is the restriction of \pcf\ where the application and abstraction rules are constrained similarly as in the safe lambda calculus. The rules are given in Table \ref{tab:safepcf}. The circled rules are those that
differ from their \pcf\ counterpart. Observe that it is necessary to have two abstraction rules \rulenamet{abs_{as}} and \rulenamet{abs} to allow both almost safe terms and terms formed with the constant rules to be abstracted.

\begin{FramedTable}
 {\bf Functional part}
$$ \rulename{var} \ \rulef{}{x : A\sentail x : A} \qquad
\rulename{wk} \ \rulef{\Gamma \sentail s : A}{\Delta \sentail s : A} \quad
\Gamma \subset \Delta$$

\begin{center}
\ovalbox{%
\begin{Bcenter}
$ \rulename{app_{as}} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \asappentail s~t_1 \ldots t_n : B} $
 \\[12pt]
$ \rulename{app} \ \rulef{\Gamma \sentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \sentail t_1 : A_1 \quad \ldots
\quad \Gamma \sentail t_n : A_n} {\Gamma \sentail s~t_1 \ldots t_n : B} \quad \ord{B} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs_{as}} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail s : B} {\Gamma \sentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \sentail s : B} {\Gamma \sentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\sentail n :\iaexp}
\qquad \rulename{succ} \ \rulef{\Gamma \sentail M:\iaexp }{\Gamma \sentail \pcfsucc\ M:\iaexp}
\qquad \rulename{pred} \ \rulef{\Gamma \sentail M:\iaexp }{\Gamma \sentail \pcfpred\ M:\iaexp}$$

$$
\rulename{cond} \ \rulef{\Gamma\sentail M : \iaexp \quad \Gamma\sentail N_1 : \iaexp \quad \Gamma\sentail N_2 : \iaexp }{\Gamma \sentail \pcfcond\ M\ N_1\ N_2}
\quad  \rulename{rec} \ \rulef{\Gamma \sentail M : A\rightarrow A }{ \Gamma \sentail Y_A M : A}$$
\caption{Formation rules for Safe \pcf.}
\label{tab:safepcf}
\end{FramedTable}
We extend the notion of \emph{almost safety} (Sec.\ \ref{sec:almostsafety}) to \pcf: a \pcf\ term is \defname{almost safe} if it can be written $\lambda x_1 \ldots x_n . N_0 \ldots N_p$ for some $n,p \geq 0$ where $N_i$ is safe for all $0\leq i \leq p$.


\begin{example}
  The addition function and equality test defined in Sec.\ \ref{sec:pcf} are typable in safe \pcf.
\end{example}

The Substitution Lemma and No-variable-capture Lemma shown for the safe lambda calculus naturally extends to safe \pcf. The small-step semantics of safe \pcf\ is obtained from the one of \pcf\ by replacing $\beta$-reduction by safe $\beta$-reduction (Def.\ \ref{dfn:safereduction}) in the definition of the relation $\rightarrow$.  The Subject Reduction Lemma from the safe lambda calculus implies that the relation $\rightarrow$ preserves safety: Suppose that $M \rightarrow N$, then $\Gamma \sentail M:T$ implies $\Gamma \sentail N:T$. It also preserves almost-safety. Finally, a term is safe if and only if its eta-long normal form is safe.

\subsection{Remark concerning recursion}
There are many ways to introduce recursion in the syntax of a programming language.
In the presentation of \pcf\ given in Sec.\ \ref{sec:pcf}, recursion is introduced by mean of a set of constants $Y_A$, $A$ ranging over \pcf\ types, incarnating the $Y$-combinator of the lambda calculus. Its syntax is given by the rule \rulenamet{rec} of table \ref{tab:safepcf}. For instance, the addition function can be represented by the \pcf\ term:
$$ \userop{plus} \equiv Y (\lambda p\; x\; y. \pcfcond\ x\;y\;(p\ (\pcfpred\ x)\ (\pcfsucc\ y))) \ .$$
Equivalently, we can introduce recursion using the ``least upper bound abstractor'' $\mu$ given by the formation rule
$$ \rulename{\mu} \rulef{\Gamma, f: A \entail M : A}{\Gamma \entail  \mu f. M: A}$$
where the semantics of $\mu$ is given by the rule:
$ \mu f. M \rightarrow M[(\mu f. M)/f]$.
Using this construct, the addition function can be defined as:
$$ \userop{plus} \equiv \mu p . \lambda x y. \pcfcond\ x\;y\;(p\ (\pcfpred\ x)\ (\pcfsucc\ y)) \ .$$

Clearly in the context of \pcf, these two definitions are interchangeable:
$\mu f.M:A$ is equivalent to $Y_A (\lambda f . M)$,
and $Y_A F : A$ is eta-equivalent to $Y_A (\lambda f. F f)$ for some fresh variable $f:A$, which is equivalent to $\mu f. F f$.

In the context of safe \pcf, however, the distinction is important.
Indeed, let us call safe $\mu$-\pcf\ the calculus obtain by replacing the rule \rulenamet{rec} by \rulenamet{\mu} in Table \ref{tab:safepcf}. It turns out that safe \pcf\ is strictly contained in safe $\mu$-\pcf.
Indeed, compare the two ways of defining a recursive term:
\begin{mathpar}
\inferrule*[Left=\rulenamet{rec}]{\inferrule*[Left=\rulenamet{abs}]{\Gamma, f: A \sentail M : A}{\Gamma\sentail \lambda f. M : A\typear A}}{\Gamma \sentail Y_A (\lambda f . M)}
\hspace{2cm}
\inferrule* [Left=\rulenamet{\mu}]{\Gamma, f: A \sentail M : A}{\Gamma \sentail  \mu f. M: A}
\end{mathpar}
Both derivations start with the premise $\Gamma, f: A \sentail M : A$ which implies that $\ord{\Gamma} \geq \ord{A}$. In the left derivation, before applying the $Y$ combinator, we need first to abstract the variable $f$. This is done using the abstraction rule whose side-conditions gives $\ord{\Gamma} > \ord{A}$. The right derivation, however, only imposes the condition $\ord{\Gamma} \geq \ord{A}$.

In fact, the safe $\mu$-\pcf\ does not really deserve its name, because
it does not verifies the No-variable-capture lemma!
For instance for any types $A$ and $B$ with $\ord{A}\geq\ord{B}$, the term
$$ \lambda f:A \typear B\; a:A. (\lambda x:B.(\mu f:B.x))(f a)$$
is a safe $\mu$-\pcf\ term that $\beta$-reduces to
$$ \lambda f:A \typear B\; a:A. (\mu f:B.x)[f a/x] \ .$$
At this point it would not be sound to push the substitution under the $\mu$ without first renaming the variables afresh as it would cause the variable $f$ to be captured by $\mu f$.
Hence the definition that we really want for safe \pcf\ is the one based on the Y-combinator.


Observe that if we were able to distinguish variables that are bound by $\lambda$ from those bound by $\mu$ - for instance by tagging their occurrences appropriately - then the clash of variable name could be tolerated in this particular example because the two clashing occurrences of $f$ are bound by a different kind of binder.


Unfortunately, this argument cannot be generalized: there are safe $\mu$-\pcf\ terms that, when reduced using capture-permitting substitution, cause clashes between $\lambda$-bound variables. Take for instance:
\begin{align*}
 M &\equiv \lambda g:3\; h:3\; x:1 . g ( \mu F:3. N(F,g,h,x))\\
 N(F,g,h,x) &\equiv x ( h ( \lambda x:1 . F (\lambda z:0.z)))
\end{align*}
where $0$ denotes the type $o$ and $n+1$ denotes $n \typear o$, for $n\in\nat$.
The safe $\mu$-\pcf\ term $M$ reduces to:
$$ \lambda g:3\; h:3\; x:1 . g (x ( h ( \lambda \underline{x}:1 . F (\lambda z:0.z))))[N(F,g,h,\underline{x})/F] \ .$$
Performing the substitution capture-permitting causes a clash between the two underlined variables.

In fact, the same example shows that the game-semantic characterization of safe \pcf\ that we will give in Chapter \ref{chap:model} does not hold for safe $\mu$-\pcf.

\subsection{Expressivity}

In the lambda calculus, the safety condition significantly limits the expressivity of the language. The conditional over Church numerals, for instance, is not definable in the safe lambda calculus. In safe \pcf\, since the arithmetic constructs are built in the language, the conditional operator comes for free. In fact, despite the strong syntactic constraint imposed on the language, the presence of recursion gives safe \pcf\ the computational power of a full-fledged Turing complete language.

We first show that termination of safe \pcf\ term is not decidable by a reduction from the \textsc{Queue-Halting} problem.

\subsubsection*{The \textsc{Queue}  programming system}
We fix a finite alphabet $\Sigma = \{ a_1, \ldots, a_p \}$. A \textsc{Queue} program is a finite sequence of instructions that manipulate a FIFO (First In First Out) queue data-structure.
A program $P$ is a sequence of $n$ instructions for some $n\in \nat$. For $1 \leq i \leq n$ we write $P.i$ to denote the $i^{\sf th}$ instruction of $P$. There are four kinds of instruction: halting, enqueuing, dequeuing and branching. The set of instructions is given by:
$$ \mathcal{I} = \{ {\tt halt} \} \cup
\{ {\tt enqueue \ } a \ | \ a \in \Sigma \}
\cup \{ {\tt dequeue} \} \cup \{ {\tt goto\ } l {\tt\ if\ first =\ } a \ | \ l \in 1..n, a \in \Sigma \}
 $$


The operational semantics is described using a set of states $ \{ {\sf halted} \} \cup \{ 1,..,n \} \times \Sigma^* $. The end-of-program state ${\sf halted}$ corresponds to the final state reach when the program terminates. A state of the form $(i,x) \in \{ 1,..,n \} \times \Sigma^*$ indicates that the queue's content is given by the sequence $x$ and that the next instruction to be executed by the machine is $P.i$. The empty queue is represented by the empty sequence $\epsilon$, and for any sequence $x \in \Sigma^*$, the first element of $x$ corresponds to the element that has been \emph{first} enqueued (\ie the queue is fed at the right-end side and consumed at the left-end side). The operational semantics is defined by the following rules:
\begin{eqnarray*}
(i,x) \mbox{ with } P.i = {\tt halt} &\rightarrow& {\sf halted} \\
(i,x) \mbox{ with } P.i = {\tt enqueue\ } a &\rightarrow& (i+1,x \cdot a) \\
(i,\epsilon) \mbox{ with } P.i = {\tt dequeue } &\rightarrow& {\sf halted} \\
(i,a \cdot x) \mbox{ with } P.i = {\tt dequeue } &\rightarrow& (i+1,x) \\
(i,\epsilon) \mbox{ with } P.i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\rightarrow& (i+1,\epsilon) \\
(i,b \cdot x) \mbox{ with } a \neq b \mbox{ and } P.i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\rightarrow& (i+1,b \cdot x) \\
(i,a \cdot x) \mbox{ with } P.i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\rightarrow& (l,a \cdot x)
\end{eqnarray*}
We write $\rightarrow^*$ to denote the reflexive transitive closure of $\rightarrow$.

The \textsc{Queue-Halting} problem  (``Given a \textsc{Queue} program, will it halt eventually?'') is undecidable. This is because Post's Tag Systems, which are Turing complete\cite{Minsky64}, can be simulated \cite{Minsky67} in \textsc{Queue}.


\subsubsection*{Encoding \textsc{Queue-Halting} in safe \pcf}

Given a \textsc{Queue} program $P$ with $n$ instructions, we construct a safe \pcf\ term $\sentail M_P : \pcfexp$ that simulates $P$ in the sense that $P \Downarrow$ if and only if $M_P \rightarrow^* {\sf halted}$.

We fix a distinguished element $\bot$ denoting the end of the queue. Let $\Sigma^\bot = \Sigma \cup \{ \bot \}$. The queue content $s \in \Sigma^*$ is identified with the infinite sequence $s \bot^\omega \in \Sigma^\omega$. We assume that an injective encoding function $\Sigma^\bot \longrightarrow \nat$ is given. For instance take $\encode{\bot} = 0$ and $\encode{a_k} = k$ for $1 \leq k \leq p$.
%\begin{eqnarray*}
%\encode{\_} : \Sigma^\bot &\longrightarrow& \{0..p\} \\
% \bot &\mapsto& 0 \\
% a_k &\mapsto& k \ , \mbox{for } 1 \leq k \leq p \ .
%\end{eqnarray*}

We say that a $\pcf$ term $M$ \emph{computes} the queue content $s$ if and only if $M\, k \eval \encode{s_k}$ for all $k\in \nat$.
For any queue-content $s \in \Sigma^*$ we define the safe \pcf\ term
\begin{eqnarray*}
\sentail \encode{s} \equiv \lambda i:\pcfexp . \sugmatch  i\, \sugwith
               0 \rightarrow \encode{ s_0 }
\ | \ldots  |\ n \rightarrow \encode{ s_{|s|-1} }\ |\ \_\ \rightarrow \encode{\bot}
: \pcfexp\typear\pcfexp
\end{eqnarray*}
which clearly computes $s$. The length $|s|$ of the queue can then by computed by the term
\begin{align*}
\sentail \userop{length}  \equiv &\ Y( \lambda f:\pcfexp\typear(\pcfexp\typear\pcfexp)\typear\pcfexp\ k:\pcfexp\ x:\pcfexp\typear\pcfexp\ . \\
&\qquad\qquad  \sugif x\, k = \encode{\bot} \sugthen k\ \sugelse f\, (k+1)\, x) \ 0 : (\pcfexp\typear\pcfexp)\typear\pcfexp
\end{align*}
verifying $\userop{length}\ \encode{s} \eval |s|$ for all $s\in\Sigma^*$.

Each instruction $c$ of $\mathcal{I}$ is encoded into a unique natural number $\encode{c}$ by some function $\mathcal{I} \rightarrow \nat$. For instance we can use the following injection: for $1 \leq i \leq p, 1 \leq l \leq n$,
\begin{center}
\begin{tabular}{c|c|c|c|c}
$c \in \mathcal{I}$ & {\tt halt} & {\tt dequeue } & {\tt enqueue} $a_i$ &  {\tt goto} l {\tt if first=} $a_i$ \\ \hline
$\encode{ c } \in \nat$ & $0$ & $1$ & $1+i$ & $1+p + n.l +i$ \\
\end{tabular}
\end{center}

The \textsc{Queue} program $P$ is then represented by the safe \pcf\ term:
\begin{equation*}
\sentail \encode{P} \equiv \lambda i :\pcfexp .  \sugmatch i\, \sugwith
   0 \rightarrow \encode{ P.0 }
  \ | \ldots \ |\ n \rightarrow \encode{ P.n }  |\ \_ \rightarrow \encode{\tt halt} : \pcfexp\typear\pcfexp
\end{equation*}
so that for all $i\in\nat$, $\encode{P}\, i$ evaluates to the encoding of the $i^{th}$ instruction of $P$. The following term defines an interpreter for \textsc{Queue}-programs given in ``compiled'' form $\encode{P}$:
\begin{align*}
\sentail \userop{Sim} \equiv & Y ( \lambda f : (\pcfexp,(\pcfexp,\pcfexp),\pcfexp)\ i:\pcfexp \ x:(\pcfexp,\pcfexp) . \\
& \sugmatch\ \encode{P}\, i\ \sugwith\\
& \begin{array}{lcl}
\ \ \encode{\tt halt }&\rightarrow& 0 \\
|\ \encode{\tt dequeue} &\rightarrow& f (i+1) (\lambda j:\pcfexp . x (j+1) ) \\
|\ \encode{{\tt enqueue}\ a_1}  &\rightarrow& f (i+1) ( \lambda j:\pcfexp . \sugif j = \userop{length}\ x\, \sugthen \encode{a_1}\ \sugelse x\, j ) \\
 \ldots \\
|\ \encode{{\tt enqueue}\ a_p} &\rightarrow& f (i+1) ( \lambda j:\pcfexp . \sugif j = \userop{length}\ x\, \sugthen \encode{a_p}\ \sugelse x\, j ) \\
|\ \encode{ {\tt goto\ } l {\tt\ if\ first=\ } a_1 } &\rightarrow&
\sugif \userop{length}\ x = 0\ \sugthen f\, (i+1)\, x \\
&&\sugelse\sugif\encode{a_1} = x\, 0\ \sugthen f\, l\, x \\
&&\sugelse\ f\, (i+1)\, x \\
 \ldots \\
|\ \encode{{\tt goto\ } l {\tt\ if\ first=\ } a_p} &\rightarrow&
\sugif \userop{length}\ x = 0\ \sugthen f\, (i+1)\, x \\
&&\sugelse\sugif\encode{a_p} = x\, 0\ \sugthen f\, l\, x \\
&&\sugelse f\, (i+1)\, x
\end{array}
 \\
& )\ 0\ \encode{\epsilon} : \pcfexp
\end{align*}

Clearly the term $\userop{Sim}$ is safe and simulates the \textsc{Queue} program $P$ in the sense that $\userop{Sim} \eval$ if and only if $P \rightarrow^* {\sf halted}$. Hence
\begin{theorem}
  The \textsc{Halting} problem for (the 2nd order fragment of) safe \pcf\ is undecidable.
\end{theorem}
Since the \textsc{Halting} is reducible to the observational equivalence problem, this also implies that observational equivalence for the 2nd-order fragment of safe $\pcf$ (with $Y_1$ recursion and unbounded base types) is undecidable. This result is in fact not surprising: it is not difficult to see that the partial recursive functions are computable in the order $2$ fragment of safe \pcf, and hence safe \pcf\ is Turing complete. (This can also be proved by simulating Turing machines in safe \pcf\ using an encoding similar to the one used above.)

The reason why these encoding work is because unsafety only appears at order $3$ in \pcf, and the 2nd order fragment of \pcf\ is already Turing complete.
\smallskip

Loader has shown \cite{loader2001fpn} that observational equivalence for \emph{Finitary} PCF (\ie no recursion and finite base types) is already undecidable at order 5. It is unknown whether this result still holds for Finitary safe PCF.

\section{Safe Idealized Algol}

In this section we present two possible approaches to accommodate
the safety restriction to a language featuring block-variable constructs such as Idealized Algol. This gives rise to two different versions of ``Safe Idealized Algol''. In the first version, all free variables are required to satisfy the safety constraint whereas in the second version, the variables abstracted by the \ianew\ construct are not required to satisfy the safety constraint.
We then show that the nice properties of the safe $\lambda$-calculus remain in these two extensions of the safe lambda calculus.

\subsection{Strongly Safe \ialgol}

 The naive way to define safety for \ialgol\ terms consists in extending the safe lambda calculus by adding the usual constant rules of \ialgol. Equivalently, this is the system of rules of \ialgol\ where the application and abstraction rules are restricted by the safety constraint the same way as in the safe lambda calculus. We refer to this language as \defname{strongly safe \ialgol}. The rules are formally given in Table \ref{tab:safeia_formrules}. The rules circled in the table are those that
differ from their IA counterpart. Note that the rule $\rulename{new}$ is kept unchanged from \ialgol. In particular it has no side-condition, contrary to the abstraction rules. Such side-condition is unnecessary because the term being formed has the same type as the term in the premise.


\begin{FramedTable}
 {\bf Functional part}

$$ \rulename{var} \ \rulef{}{x : A  \vsafeentail x : A}
\qquad \rulename{wk} \ \rulef{\Gamma \vsafeentail s :
A}{\Delta \vsafeentail s : A} \quad \Gamma \subset
\Delta
$$

\begin{center}
\ovalbox{%
\begin{Bcenter}
$ \rulename{app_{as}} \ \rulef{\Gamma \vsafeentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \vsafeentail t_1 : A_1 \quad \ldots
\quad \Gamma \vsafeentail t_n : A_n} {\Gamma \asappentail s~t_1 \ldots t_n : B} $
 \\[12pt]
$ \rulename{app} \ \rulef{\Gamma \vsafeentail s : (A_1, \ldots , A_n,B)
\quad \Gamma \vsafeentail t_1 : A_1 \quad \ldots
\quad \Gamma \vsafeentail t_n : A_n} {\Gamma \sentail s~t_1 \ldots t_n : B} \quad \ord{B} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs_{as}} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \asappentail s : B} {\Gamma \vsafeentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
 \\[12pt]
$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \vsafeentail s : B} {\Gamma \vsafeentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad \ord{(A_1, \ldots ,A_n,B)} \leq
\ord{\Gamma}$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\vsafeentail n :\iaexp}
\qquad \rulename{succ} \ \rulef{\Gamma \vsafeentail M:\iaexp }{\Gamma \vsafeentail \pcfsucc\ M:\iaexp}
\qquad \rulename{pred} \ \rulef{\Gamma \vsafeentail M:\iaexp }{\Gamma \vsafeentail \pcfpred\ M:\iaexp}$$

$$
\rulename{cond} \ \rulef{\Gamma\vsafeentail M : \iaexp \quad \Gamma\vsafeentail N_1 : \iaexp \quad \Gamma\vsafeentail N_2 : \iaexp }{\Gamma \vsafeentail \pcfcond\ M\ N_1\ N_2}
\quad  \rulename{rec} \ \rulef{\Gamma \vsafeentail M : A\rightarrow A }{ \Gamma \vsafeentail Y_A M : A}$$

{\bf Imperative constructs}
$$ \rulename{seq} \ \rulef{\Gamma \vsafeentail M : \iacom \quad \Gamma \vsafeentail N :A}
    {\Gamma \vsafeentail \iaseq_A \ M\ N\ : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulename{assign} \ \rulef{\Gamma \vsafeentail M : \iavar \quad \Gamma \vsafeentail N : \iaexp}
    {\Gamma \vsafeentail \iaassign\ M\ N\ : \iacom}
\qquad \rulename{deref} \
 \rulef{\Gamma \vsafeentail M : \iavar}
    {\Gamma \vsafeentail \iaderef\ M\ : \iaexp}$$

$$ \rulename{new} \ \rulef{\Gamma , x : \iavar\ \vsafeentail M : A}
    {\Gamma  \vsafeentail \texttt{new } x \texttt{ in } M : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulename{mkvar} \ \rulef{\Gamma \vsafeentail M_1 : \iaexp \rightarrow \iacom \quad \Gamma \vsafeentail M_2 : \iaexp}
    {\Gamma \vsafeentail \iamkvar\  M_1\ M_2\ : \iavar}$$

\caption{Formation rules for strongly safe \ialgol}
\label{tab:verysafeia_formrules}
\end{FramedTable}
\bigskip

\subsection{Safe \ialgol}
\label{subsec:safeia_rules}

It turns out that the definition of strongly safe \ialgol\ is needlessly
restrictive. Indeed, we would like to identify a fragment of \ialgol\
which restricts the occurrences of the variables in a term
so that the so-called ``No-variable-capture'' lemma holds, \ie it is no necessary to rename variables afresh when performing substitution. But in the present setting of a language with imperative features, one can distinguish two types of variables in a closed term: the ``standard ones'' -- those that are bound by $\lambda$-abstraction; and the ``imperative'' ones -- those that are used as identifiers for memory cells, also called block-allocated variables. We do not gain anything by imposing constraints on the second kind of variables since no term can ever be substituted for such variables when performing reduction.

Similarly, it is possible to remove the constraint for variables bound by a lambda node $\lambda x$ in terms of the form $\iamkvar (\lambda x . M) N$. Indeed, it is harmless (up to eta equivalence) to redefine the \iamkvar\ rule so that it only produces term of the form
$\iamkvar (\lambda x . M) N$
The rule
$$\iaassign\ (\iamkvar M N)\ n \rightarrow M n $$
from the small step semantics of \iamkvar\ can then be replaced by
\begin{equation}\iaassign\ (\iamkvar (\lambda x . M) N)\ n \rightarrow M[n/x] \label{eq:new_mkvar_smallstep}
\end{equation}
which ensures that no substitution will ever be done on the term $\lambda x . M$.


The two previous remarks lead us to a more general notion of safety for \ialgol\ which will turn out to incarnate more faithfully the semantic substance of safety.

We consider a new judgment of the form $\Gamma | \Xi  \safeentail M : A$, called a \defname{split term} (this terminology is borrowed from \cite{abramsky:game-semantics-tutorial}), where the context is partitioned into two \emph{disjoint} components: The first component $\Gamma$ will contain the lambda-bound variables
that are constrained by the safety restriction; the second component will contain block-declared variables as well as \iamkvar-variables \ie variable bound by an occurrence of the \iamkvar\ construct. The component
$\Xi$ contains variables of type \iavar\ and \iaexp\ only, while the
other component can contain variables of any type including \iavar. We take as a convention that the two components cannot share variable names. It is straightforward to redefine the typing rule of \ialgol\ in such a way that these two distinct contexts are maintained appropriately. In particular:
\begin{itemize}
\item the abstraction rules can only abstract variables from the first component of the context;
\item the \ianew\ and \iamkvar\ constructs can only bind variables from the second context component;
\item the side-condition in the abstraction rules constrains only variables from the first context component.
\end{itemize}
The full system of rules is given in Table \ref{tab:safeia_formrules}. The rules that are circled in the table are those that differ from their counterpart in Table \ref{tab:verysafeia_formrules}.

\begin{FramedTable}
{\bf Functional part}

$$ \rulename{var} \ \rulef{}{x : A | \emptyset \safeentail x : A} \qquad
\rulename{var^\iavar} \ \rulef{}{\emptyset | x : \iavar \safeentail x : \iavar}
\qquad
\rulename{var^\iaexp} \ \rulef{}{\emptyset | x : \iaexp \safeentail x : \iaexp} $$
$$
\rulename{wk} \ \rulef{\Gamma | \Xi \safeentail s : A}{\Gamma' | \Xi \safeentail s : A} \quad
\Gamma \subset \Gamma' \qquad
\rulename{wk^{\ianew}} \ \rulef{\Gamma| \Xi \safeentail s : A}{\Gamma| \Xi' \safeentail s : A} \quad
\Xi \subset \Xi'
$$

such that $\Xi'$ contains only variables of type $\iavar$ and $\iaexp$, and the variables names in $\Gamma$ and $\Xi'$ (resp.\ $\Gamma'$ and $\Xi$) are disjoint.


$$ \rulename{app_{as}} \ \rulef{\Gamma | \Xi \safeentail s : (A_1,\ldots,A_n,B) \quad
\Gamma | \Xi \safeentail t_1 : A_1 \quad \ldots \quad \Gamma | \Xi \safeentail t_n : A_n
} {\Gamma | \Xi \asappentail s t_1 \ldots t_n : B}$$

$$ \rulename{app} \ \rulef{\Gamma | \Xi \safeentail s : (A_1,\ldots,A_n,B) \quad
\Gamma | \Xi \safeentail t_1 : A_1 \quad \ldots \quad \Gamma | \Xi \safeentail t_n : A_n
} {\Gamma | \Xi \safeentail s t_1 \ldots t_n : B} \quad \ord{B} \leq \ord{\Gamma}$$

\begin{center}\ovalbox{
\begin{Bcenter}
 $\rulename{abs_{as}} \ \dps  \rulef{\dps \Gamma, x_1 : A_1, \ldots, x_n : A_n | \Xi \asappentail s : B} {\Gamma | \Xi \safeentail \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \ord{(A_1, \ldots ,A_n,B)} \leq \ord{\Gamma}$
\\[12pt]
 $\rulename{abs} \ \dps  \rulef{\dps \Gamma, x_1 : A_1, \ldots, x_n : A_n | \Xi \safeentail s : B} {\Gamma | \Xi \safeentail \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \ord{(A_1, \ldots ,A_n,B)} \leq \ord{\Gamma}$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\emptyset | \emptyset \safeentail n :\iaexp}
\quad \rulename{succ} \ \rulef{\Gamma | \Xi\safeentail M:\iaexp }{\Gamma| \Xi \safeentail \pcfsucc\ M:\iaexp}
\quad \rulename{pred} \ \rulef{\Gamma| \Xi \safeentail M:\iaexp }{\Gamma| \Xi \safeentail \pcfpred\ M:\iaexp}$$

$$
\rulename{cond} \ \rulef{\Gamma| \Xi \safeentail M : \iaexp \quad \Gamma| \Xi \safeentail N_1 : \iaexp \quad \Gamma| \Xi \safeentail N_2 : \iaexp }{\Gamma| \Xi \safeentail \pcfcond\ M\ N_1\ N_2}
\ \ \rulename{rec} \ \rulef{\Gamma| \Xi \safeentail M : A\rightarrow A }{ \Gamma| \Xi \safeentail Y_A M : A}$$

{\bf Imperative constructs}
$$ \rulename{seq} \ \rulef{\Gamma| \Xi \safeentail M : \iacom \quad \Gamma| \Xi \safeentail N :A}
    {\Gamma| \Xi \safeentail \iaseq_A \ M\ N\ : A} \quad A \in \{ \iacom, \iaexp\}$$

$$ \rulename{assign} \ \rulef{\Gamma| \Xi \safeentail M : \iavar \quad \Gamma| \Xi \safeentail N : \iaexp}
    {\Gamma| \Xi \safeentail \iaassign\ M\ N\ : \iacom}
\qquad
 \rulename{deref} \ \rulef{\Gamma| \Xi \safeentail M : \iavar}
    {\Gamma| \Xi \safeentail \iaderef\ M\ : \iaexp}$$


\begin{center}\ovalbox{
\begin{Bcenter}
$
\rulename{new} \ \dps \rulef{\Gamma | \Xi, x :
\iavar\ \safeentail M : A}
    {\Gamma | \Xi \safeentail \ianewin{x}\ M : A} \quad A \in \{ \iacom, \iaexp\} $
\\[12pt]
$ \rulename{mkvar} \ \rulef{\Gamma| x:\iaexp, \Xi \safeentail M_1 : \iaexp \rightarrow \iacom \quad \Gamma, \Xi \safeentail M_2 : \iaexp}
    {\Gamma| \Xi \safeentail \iamkvar\ (\lambda x:\iaexp .M_1)\ M_2\ : \iavar}$
\end{Bcenter}
}\end{center}


\caption{Formation rules for safe \ialgol.} \label{tab:safeia_formrules}
\end{FramedTable}


 Split-terms with an empty context $\Xi$ are called \defname{semi-closed}. We define \defname[safe!\ialgol]{safe \ialgol} to be the set of semi-closed split-terms typable with the system of rules of Table \ref{tab:safeia_formrules}. For convenience we introduce the additional rule
$$ \rulef{\Gamma | \emptyset \safeentail M : A} {\Gamma \safeentail M : A}$$
so that safe \ialgol\ is given by the set of terms-in-context $\Gamma \safeentail M : A$.

\begin{example}
Clearly strongly safe \ialgol\ is a subset of safe \ialgol\ and the following example shows that the inclusion is strict:
$$ \safeentail \lambda f:{(\iaexp \rightarrow \iacom) \rightarrow \iaexp} .\  \ianewin{i}{f ( \lambda x . \iaassign\ i\ x )} : \iaexp$$
$$ \mbox{ but } \not \vsafeentail \lambda f:{(\iaexp \rightarrow \iacom) \rightarrow \iaexp} .\ \ianewin{i}{f ( \lambda x . \iaassign\ i\ x )} : \iaexp \ .$$

It is not strongly safe because the variables $i$ and $x$ are of the same order but only $x$ is abstracted by the lambda. It is safe because unsafe occurrences of  block-allocated variables such as $i$ are tolerated in safe \ialgol.
\end{example}
\begin{example}
The following term is a safe \ialgol\ beta-normal term:
$$
f: ((\iaexp\typear\iaexp)\typear\iacom) \sentail \iamkvar\ (\lambda x. f(\lambda y . \underline{x}))\ 0 : \iacom^\omega \times \iaexp  \ .
$$
Observe that the unsafe occurrence of the variable $x$ is tolerated because it is implicitly ``bound'' by the \iamkvar\ construct.
\end{example}

Since in split safe \ialgol\ terms, only the variables from the left context component are constrained by the safe restriction, we have:
\begin{lemma}
If $\Gamma | \Xi
\safeentail M : A$ then for all variable $z \in \freevarset(M) \inter \Gamma$, $\ord{z} \geq \ord{A}$
\end{lemma}
This is a generalization of Lemma \ref{lem:ordfreevar} in the safe lambda calculus.

\subsection{Substitution}
The notion of substitution naturally extends to Safe \ialgol: it is done inductively on the structure of the term; for the block-variable case this gives:
\begin{align*}
  (\ianewin{x}{M})\subst{N}{y} &= \ianewin{z}{M\subst{z}{x}\subst{N}{y}} & \mbox{if $x\neq y$, $z$ fresh;}\\
  (\ianewin{x}{M})\subst{N}{x} &= \ianewin{x}{M} \ .
\end{align*}
And for capture-permitting substitution:
\begin{align*}
  (\ianewin{x}{M})\captsubst{N}{y} &=   \ianewin{x}{M\captsubst{N}{y}} & \mbox{if $x\neq y$;}\\
  (\ianewin{x}{M})\captsubst{N}{x} &=   \ianewin{x}{M} \ .
\end{align*}

\emph{In which sense are the two calculi above-defined ``safe''?} In the lambda calculus, the term ``safety'' refers to the fact that substitution can be performed \emph{capture-permitting}. Unfortunately, in the presence of block-allocation constructs, this lemma does not hold anymore.
The key reason is that the block-allocation construct $\ianew$ does not increase the order of the term that is being formed contrary to the traditional $\lambda$-abstraction, and such property is crucially used in the proof of the No-variable-capture lemma in the safe lambda calculus. The following examples illustrate this. Consider the terms:
\begin{align*}
M_1 &\equiv \ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ ((\lambda y:\overline 0. \ianewin{x}{y})(\iaderef\ x))} \\
M_2 &\equiv \lambda x:\overline 1. (\lambda y:\overline 1. (\ianewin{x}{y\ 0})) x\\
M_3 &\equiv  \lambda f: \overline 2 . \ianewin{x}{(\lambda y:\overline 1. f (\lambda x:\overline 0. y))(\lambda z:\overline 0 . \iaderef\ \underline{x})}
\end{align*}
where $\overline 0$ is an abbreviation for \iaexp\ and for $n\in\nat$, $\overline{n+1}$ stands for the type $n \typear \iaexp$.

Clearly, the \ialgol\ terms $M_1$ and $M_2$ are both strongly safe, and therefore also safe. $M_3$, however, is safe but not \emph{strongly} safe because the underlined occurrence of $x$ is not abstracted together with $z$.
Theses examples shows that it is \emph{not} ``safe'' to use capture-permitting substitution in (strongly-) safe \ialgol. The term $M_1$ gives an example where a block-variable is captured by another block-declaration; in $M_2$ a block-variable is captured by a lambda-abstraction; and in $M_3$ a lambda-bound variable is captured by a block-variable declaration:
\begin{enumerate}[(i)]
  \item
Consider the term $M_1$, we have:
$$M_1 \betared \ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ (\ianewin{x}{y})\subst{(\iaderef\ x)}{y}}$$
Performing the substitution without renaming variables afresh causes the variable $x$ to get captured by the innermost $\ianew\ x$ giving
$$\ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ (\ianewin{x}{\iaderef\ x})}$$
which is observationally equivalent to $0$ (since block-allocated variables are initialized with $0$). On the other hand the standard substitution gives:
$$\ianewin{x}{\iaseq\ (\iaassign\ x\ 1)\ (\ianewin{z}{\iaderef\ x})}$$
which is observationally equivalent to $1$.

\item For $M_2$, the capture permitting substitution gives
$\lambda x:\overline 1. (\ianewin{x}{x\ 0})$ which is not even a valid \ialgol\ term;

\item Finally for $M_3$, capture permitting substitution gives
$\lambda f: \overline 2 . \ianewin{x}{\lambda y:\overline 1. f (\lambda x:\overline 0. (\lambda z:\overline 0 . \iaderef\ x))}$
which is also not a valid \ialgol\ term.
\end{enumerate}

To deal with the first two examples, we have no other choice than renaming block-declared variables afresh upon substitution. For the third kind of variable capture (which only happens for safe terms that are not strongly safe) we can fix the problem by making the assumption that the set of names used for block-declared variables is disjoint from the set of names used for lambda-abstracted variables; or equivalent by assuming that each variable occurrence has an implicit tag indicating whether it is a block-allocated variable or a lambda-abstracted variable, thus permitting us to resolve any binding ambiguity. (Observe that the fact that the set of names of the two context components of a split-terms are disjoint is not sufficient because this only constrains the free variables of the term whereas what we are requiring here is a global constraint on all variables names occurring in the term.)
All the observations that we have made about \ianew-bound variables also hold for \iamkvar-bound variables.

This leads us to the following notion of substitution which performs variable renaming only for block-allocated variables and \iamkvar-bound variables:
\begin{definition}
The \defname{semi-capture-permitting substitution} of the term-in-context $\Gamma | \Xi
\entail N : A$ for $x$ in the term-in-context $\Gamma, x:A | \Xi
\entail M : B$, written $\Gamma | \Xi \entail M\semicaptsubst{N}{x}$, is defined inductively on $M$ as follows:
\begin{align*}
x \semicaptsubst{N}{x} &= N \\
y \semicaptsubst{N}{x} &= y & y\neq x;\\
(\lambda x . M) \semicaptsubst{N}{x} &= \lambda x . M \\
(\lambda y . M) \semicaptsubst{N}{x} &= \lambda y . M\semicaptsubst{N}{x} & \mbox{where $y \not = x$;} \\
(\ianewin{x}{M})\semicaptsubst{N}{x} &=   \ianewin{x}{M} \\
(\ianewin{y}{M})\semicaptsubst{N}{x} &= \ianewin{z}{M\semicaptsubst{z}{y}\semicaptsubst{N}{x}} & \mbox{if $x\neq y$, $z$ fresh;} \\
(\iamkvar\ (\lambda x. M_1) M_2)\semicaptsubst{N}{x} &=
  \iamkvar\ (\lambda x. M_1) M_2\semicaptsubst{N}{x} \\
(\iamkvar\ (\lambda y. M_1) M_2)\semicaptsubst{N}{x} &=
  \iamkvar\ (\lambda z. M_1\semicaptsubst{z}{y}\semicaptsubst{N}{x}) M_2\semicaptsubst{N}{x}
  & \mbox{if $x\neq y$, $z$ fresh.}
\end{align*}
The other constants and application cases are defined inductively in the standard way.
\end{definition}

It is now possible to state a weaker version of the \emph{No-variable capture lemma} for safe \ialgol, namely that there is no need to rename \emph{$\lambda$-bound} variables afresh when performing substitution.
\begin{lemma}
\label{lem:nocapture_safeia}
Suppose that $\Gamma | \Xi
\safeentail N : A$ and $\Gamma, x:A | \Xi
\safeentail M : B$ are safe \ialgol\ terms then
the substitution $M\subst{N}{x}$ can be performed semi-capture-permitting \emph{provided that the set of names for lambda-bound variables is disjoint from the set of names of block-allocated variables and \iamkvar-bound variables.}
In other words:
$$ M\subst{N}{x} =_\alpha M\semicaptsubst{N}{x} \ .$$
\end{lemma}
The proof is a trivial extension of Lemma \ref{lem:nocapture}.


The small-step reduction semantics of safe IA is defined similarly as in Sec.\ \ref{subsec:smallstep_ia} except that $\beta$-reduction is replaced by safe $\beta$-reduction and the rules for \iamkvar\ are redefined according to Eq.\ \ref{eq:new_mkvar_smallstep}. A consequence of Lemma \ref{lem:nocapture_safeia} is that safety is preserved by the small-step reduction of \ialgol:
\begin{lemma}[Reduction preserves safety]
\label{lem:ia_safety_preserved} Let $M$ be a safe \ialgol\ term. If
$M \rightarrow N$, where $\rightarrow$ denotes the small-step reduction of safe \ialgol, then $N$ is also a safe term.
\end{lemma}
The proof is by an easy induction.



\section{Generalization to any applied lambda calculus}
\label{sec:safe_appliedlambda}
In this section, we define the notion of safety for any given applied lambda calculus extended with a stock of interpreted constants $\Sigma$ but without recursion. The syntax of the language is given by some system of rules producing split-term of the form
$$\Gamma|\Xi \entail M : T$$
for some simple-type $T$, where variables in the context $\Gamma$ (resp.\ $\Xi$) are called $\Gamma$-variables (resp.\ $\Xi$-variables) and such that
\begin{asparaenum}[(i)]
\item The abstraction rule can only abstract $\Gamma$-variables;
\item The terms of the languages are given by the semi-closed split-terms $\Gamma|\emptyset \entail M : T$ abbreviated as $\Gamma \entail M : T$.
\end{asparaenum}
\noindent Consequently, the $\Xi$-variables can only be bound by constant constructs of the language but not by lambda-abstraction. This implies that the $\Xi$-variables appearing in the derivation tree of a term $\Gamma \entail M : T$ correspond to variable nodes that are hereditarily enabled by $\Sigma$-constants in the computation tree of $M$.
\bigskip

The \defname[safe!fragment]{safe fragment} of this applied lambda calculus is then defined as the system generating terms of the form $\Gamma \entail M : T$ obtained by constraining the lambda calculus fragment of the language so that:
\begin{asparaenum}[(i)]
\item The restriction of the system to its pure simply-typed fragment coincides with the definition of the safe lambda calculus;
\item The side-condition of the abstraction and application rules
 constrain only the $\Gamma$-variables.
\end{asparaenum}

Consequently a safe term-in-context $\Gamma \sentail M : T$ verifies the basic property:
$$\forall z \in \Gamma . \ord{z} \geq \ord{T} \ .$$

In order for this language to make sense, the small-step reduction semantics has to preserve safety.

Clearly, the results of the previous sections show that \ialgol\ and the recursion-free fragments of \pcf\ fit in this setting.



\section{Conclusion}

\todo{Conclusion of the chapter on safe lambda calculus} 