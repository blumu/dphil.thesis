% -*- TeX -*- -*- Soft -*-
\input{thesis.pre}

%\includeonly{chap_gamesem,chap_pincrjust,sec_safeia,transfer_chap_gsemsafety,../lmcs/safelambda,../corresp/corresp}


\author{William Blum}
\title{Safe higher-order functional languages\\{\small DPhil thesis}}
\college{Linacre College}
\degree{Doctor of Philosophy}
\degreedate{?}
\renewcommand{\crest}{\beltcrest}

%\institution{Oxford University Computing Laboratory}
\date{Draft of \today}

%set the number of sectioning levels that get number and appear in the contents
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\begin{document}
\maketitle

%\setcounter{chapter}{0}
%\chapapp{Chapter}
\begin{abstract}
We consider a syntactic restriction for higher-order grammars called \emph{safety}  that  constrains occurrences of variables in the production rules according to their type-theoretic order. We transpose and generalize this restriction to the setting of the simply-typed lambda-calculus, giving us what we call the \emph{safe lambda calculus}. We study this language under different angles. First we give an account of its game semantic model. For that purpose, we introduce a new concrete presentation of game semantics based on the theory of \emph{traversals}: We show that the \emph{revealed game denotation} of a term can be computed by traversing some souped-up version of the abstract syntax tree of the term using adequately defined traversal rules. This result was presented at the Galop workshop at ETAPS 2008. This allows us to give a game-semantic analysis of safety via syntactic reasoning: We show that  safe lambda-terms are denoted by what we call \emph{P-incrementally justified strategies}. This result was presented at TLCA 2007.

We study the expressivity of the calculus and show a result in the
  same vein as Schwichtenberg's 1976 characterization of the
  simply-typed lambda calculus, we show that the numeric functions
  representable in the safe lambda calculus are exactly the
  multivariate polynomials; thus conditional is not definable. We
  also give a characterization of representable word functions.
  We then study the complexity of deciding beta-eta equality of two safe simply-typed terms and show that this problem is PSPACE-hard.

Finally we consider extension of the safety restriction to functional languages with recursion and references such as Idealized Algol.

\end{abstract}

\begin{romanpages}
\tableofcontents
\listoffigures
\end{romanpages}

\chapter{Introduction}
    \section{The safety restriction}
    \section{The game-semantic correspondence}
    \section{Organisation of the thesis}
    The present thesis is divided in two parts. The first part lay down the background for the rest of the thesis. It is divided in three chapters.    The first one introduces the three languages that will be considered in this thesis: the simply-typed lambda calculus and two of its extension: PCF and Idealized Algol. The following two chapters are independent: Chapter \ref{{chap:gamesem}} is devoted to the presentation of the basics and main results of game semantics. It also fixes notation that will be use in the second part of the thesis when we analyse the game semantics of the safety restriction. The second chapter presents the original setting in which the safety restriction appeared for the first time, namely \emph{higher-order grammars}. It includes a presentation of the safety restriction with some related results.

    The second part of the thesis presents the contribution. Chapter \ref{chap:safelambda_def} introduces the definition of the \emph{safe lambda calculus} and gives some results about this calculus.

\part{Background}
%The categorical
%interpretation of game semantics is presented as well as the full
%abstraction result for \pcf. We also give a brief summary of some important results in algorithmic game semantics.
%The following chapter introduces the concepts of higher-order grammars and recursion scheme.
    \chapter{Lambda Calculus, PCF, Idealized Algol}

    % chapter presenting game semantics
    \include{chap_gamesem}

    \chapter{Higher-Order Grammars and the Safety Restriction}
    \include{chap_hog_hors}


\part{Contribution}


In the second chapter we present the \emph{safe $\lambda$-calculus}.
Originally, \emph{safety} has been introduced as a syntactical
restriction on higher-order grammars in order to show a decidability
result about MSO theory of infinite trees \citep{KNU02}. In
\cite{safety-mirlong2004}, Aehlig, de Miranda and Ong  proposed an
adaptation of the safety restriction to the $\lambda$-calculus. This
restriction gives rise to the safe $\lambda$-calculus. We first
present this calculus and then give a more general definition which
does not make any assumption on the types of the terms.

In the third chapter, following ideas described in
\cite{OngLics2006}, we introduce the notions of computation tree of
a simply-typed term and traversal over a computation tree. We prove
a theorem showing a correspondence between traversals of the
computation tree and the game semantics of a term. Based on that
correspondence, we give a characterisation of the game semantics of
safe terms by a property called ``P-incremental-justification''. In
P-incrementally-justified strategies, P-pointers are superfluous (i.e.
they can be recovered uniquely from the underlying sequence of
moves and from O-moves' pointers). This simplification of the game semantics suggests some potential applications in algorithmic game semantics. We finish the
chapter by extending the result to safe \pcf\ and by giving the key
elements for an extension to full Safe Idealized Algol.




\chapter{Safe Higher Order Functional Languages}
\label{chap:safelambda_def}
%    \section{Safe Lambda Calculus}
%        \subsection{Definition and properties}
%        \subsection{Expressivity of the calculus}
%        Result a la Schwichtenberg \cite{citeulike:622637}
%        Statman's result for Safe Lambda calculus?
%        \subsection{Game-semantic analysis via a syntactic argument}
    \include{fromlmcs/safelambda}
    \include{fromlmcs/safe_complexity}
    \include{fromlmcs/safe_expressivity}


    %% chapter from the transfer thesis
    \include{transfer_chap_safe_homog}
    \include{transfer_chap_safe_nonhomog}


    \section{Safe PCF}
        \subsection{Definition and properties}
        \subsection{Game-semantic analysis via a syntactic argument}

    %\section{Safe IA}
    \include{sec_safeia}


\chapter{Local Computation of \texorpdfstring{$\beta$}{Beta}-Reduction}
    %The aim of this chapter is to develop tools that will be used in the
    %next chapter to give a characterisation of the game semantics of the
    %safe $\lambda$-calculus. Establishing such a characterisation is
    %complicated by the fact that Safety is a syntactic restriction
    %whereas Game Semantics is by nature a syntax-independent semantics.
    %We therefore need to make an explicit correspondence between the
    %game denotation of a term and its syntax. Our approach follows ideas
    %recently introduced in \cite{OngLics2006}, mainly the notion of
    %computation tree of a simply-typed $\lambda$-term and traversals
    %over the computation tree. A computation tree can be regarded as an
    %abstract syntax tree (AST) of the $\eta$-long normal form of a term.
    %A traversal is a justified sequence of nodes of the computation tree
    %respecting some formation rules. Traversals are used to describe
    %computations. An interesting property is that the \emph{P-view} of a
    %traversal (computed in the same way as P-view of plays in Game
    %Semantics) is a path in the computation tree.
         \include{corresp}
         \include{corresp_pcf_ia}


    \section{Extension to PCF and IA terms}
    \section{Applications}




\chapter{Game-Semantic analysis of safety via syntactic arguments}
    \include{fromlmcs/safe_gamesem}
    \include{chap_safety_gamesem_syntactic}


\chapter{Game-Semantic Models of Safe Languages}


    \include{chap_pincrjust}



\chapter{Conclusion}
    \section{Summary of Contribution}
    \section{Future Work}



\chapter{Further possible developments}

In the previous chapter, we have given an account of the game
semantics of safe $\lambda$-calculus. However the nature of this
calculus is still not well known. We propose the following possible
roadmap for further research:
\begin{enumerate}
\item give a detailed account of
P-incrementally-justified strategies that treats the problem of compositionality;
\item find a categorical interpretation of the safe $\lambda$-calculus;
\item study the proof theory obtained by the Curry-Howard isomorphism and determine whether it has nice properties that can be helpful in theorem proving;
\item identify a non-trivial fragment of safe \ialgol\ for which observational equivalence is decidable;
\item in \cite{DBLP:conf/tlca/LeivantM93}, the $\lambda$-calculus is used to
give several characterisations of the complexity class P. We would
like to investigate whether, by following similar techniques, we can
obtain a characterisation of a different complexity class using the
safe $\lambda$-calculus.
\end{enumerate}


More generally, we would like to study the class of languages for
which pointers are uniquely recoverable. We name this class PUR for
``Pointer Uniquely Recoverable''.

An example is the Serially Re-entrant Idealized Algol (SRIA) proposed
by Abramsky  in \cite{abramsky:mchecking_ia}. This language allows
multiple occurrences or uses of arguments, as long as they do not
overlap in time. In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to safe \ialgol.

Finitary $\ialgol_2$ is also an example of PUR-language for which
observational equivalence is decidable. As we indicated in the first
chapter, decidability of observational equivalence is a very
appealing property which has immediate applications in the domain of
program verification. Intuitively, PUR-languages seem to be good
candidates of languages for which observational equivalence is decidable. It would be interesting to discover classes of PUR
languages having this appealing property. Safe $\ialgol_3$ seems to be a good candidate.

Another possible way to generate PUR-languages may be to constrain
the types of an existing language. In \cite{DBLP:conf/tlca/Joly01},
a notion of ``complexity'' is defined for $\lambda$-terms. It is
proved that a type $T$ can be generated from a finite set of
combinators if and only if there is a constant bounding the
complexity of every closed normal $\lambda$-term of type $T$;
consequently, the only inhabited finitely generated types are the
type of rank $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$. We know that imposing the
first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?



    \bibliographystyle{plain}
    \bibliography{../bib/dphil-all}

    %adds the bibliography to the table of contents
    \addcontentsline{toc}{chapter}
         {\protect\numberline{Bibliography\hspace{-96pt}}}
\end{document}
