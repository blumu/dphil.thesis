% -*- TeX -*- -*- Soft -*-
\input{thesis.pre}

%\includeonly{chap_gamesem,chap_pincrjust,sec_safeia,transfer_chap_gsemsafety,../lmcs/safelambda,../corresp/corresp}


\author{William Blum}
\title{Safe higher-order functional languages\\{\small DPhil thesis}}
\college{Linacre College}
\degree{Doctor of Philosophy}
\degreedate{?}
\renewcommand{\crest}{\beltcrest}

%\institution{Oxford University Computing Laboratory}
\date{Draft of \today}

%set the number of sectioning levels that get number and appear in the contents
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\begin{document}
\maketitle
\begin{romanpages}
\tableofcontents
\listoffigures
\end{romanpages}

%\setcounter{chapter}{0}
%\chapapp{Chapter}

\chapter{Introduction}
    \section{The safety restriction}
    \section{The game-semantic correspondence}
    \section{Organisation of the thesis}

\part{Background}
    \chapter{Lambda Calculus, PCF, Idealized Algol}
    \include{chap_gamesem}
    \chapter{Higher-Order Grammars and the Safety Restriction}

\part{Contribution}

The first chapter of this part is devoted to the presentation of the
basics and main results of game semantics. The categorical
interpretation of game semantics is presented as well as the full
abstraction result for \pcf. We also give a brief summary of the
main results in algorithmic game semantics. There is no personal
contribution in this chapter.

In the second chapter we present the \emph{safe $\lambda$-calculus}.
Originally, \emph{safety} has been introduced as a syntactical
restriction on higher-order grammars in order to show a decidability
result about MSO theory of infinite trees \citep{KNU02}. In
\cite{safety-mirlong2004}, Aehlig, de Miranda and Ong  proposed an
adaptation of the safety restriction to the $\lambda$-calculus. This
restriction gives rise to the safe $\lambda$-calculus. We first
present this calculus and then give a more general definition which
does not make any assumption on the types of the terms.

In the third chapter, following ideas described in
\cite{OngLics2006}, we introduce the notions of computation tree of
a simply-typed term and traversal over a computation tree. We prove
a theorem showing a correspondence between traversals of the
computation tree and the game semantics of a term. Based on that
correspondence, we give a characterisation of the game semantics of
safe terms by a property called ``P-incremental-justification''. In
P-incrementally-justified strategies, P-pointers are superfluous (i.e.
they can be recovered uniquely from the underlying sequence of
moves and from O-moves' pointers). This simplification of the game semantics suggests some potential applications in algorithmic game semantics. We finish the
chapter by extending the result to safe \pcf\ and by giving the key
elements for an extension to full Safe Idealized Algol.




\chapter{Safe Higher Order Functional Languages}

%    \section{Safe Lambda Calculus}
%        \subsection{Definition and properties}
%        \subsection{Expressivity of the calculus}
%        Result a la Schwichtenberg \cite{citeulike:622637}
%        Statman's result for Safe Lambda calculus?
%        \subsection{Game-semantic analysis via a syntactic argument}
    \include{../lmcs/safelambda}

    
    %% chapter from the transfer thesis
    \include{transfer_chap_safe_homog}
    \include{transfer_chap_safe_nonhomog}

    
    \section{Safe PCF}
        \subsection{Definition and properties}
        \subsection{Game-semantic analysis via a syntactic argument}

    %\section{Safe IA}
    \include{sec_safeia}


\chapter{Local computation of $\beta$-reduction}
    %The aim of this chapter is to develop tools that will be used in the
    %next chapter to give a characterisation of the game semantics of the
    %safe $\lambda$-calculus. Establishing such a characterisation is
    %complicated by the fact that Safety is a syntactic restriction
    %whereas Game Semantics is by nature a syntax-independent semantics.
    %We therefore need to make an explicit correspondence between the
    %game denotation of a term and its syntax. Our approach follows ideas
    %recently introduced in \cite{OngLics2006}, mainly the notion of
    %computation tree of a simply-typed $\lambda$-term and traversals
    %over the computation tree. A computation tree can be regarded as an
    %abstract syntax tree (AST) of the $\eta$-long normal form of a term.
    %A traversal is a justified sequence of nodes of the computation tree
    %respecting some formation rules. Traversals are used to describe
    %computations. An interesting property is that the \emph{P-view} of a
    %traversal (computed in the same way as P-view of plays in Game
    %Semantics) is a path in the computation tree.

          \include{../corresp/corresp}


    \section{Extension to PCF and IA terms}
    \section{Applications}




\chapter{Game-Semantic Models of Safe Languages: A Syntactic Argument}
    \include{chap_safety_gamesem_syntactic}


\chapter{Game-Semantic Models of Safe Languages: A Semantic Argument}


    \include{chap_pincrjust}



\chapter{Conclusion}
    \section{Summary of Contribution}
    \section{Future Work}



\chapter{Further possible developments}

In the previous chapter, we have given an account of the game
semantics of safe $\lambda$-calculus. However the nature of this
calculus is still not well known. We propose the following possible
roadmap for further research:
\begin{enumerate}
\item give a detailed account of
P-incrementally-justified strategies that treats the problem of compositionality;
\item find a categorical interpretation of the safe $\lambda$-calculus;
\item study the proof theory obtained by the Curry-Howard isomorphism and determine whether it has nice properties that can be helpful in theorem proving;
\item identify a non-trivial fragment of safe \ialgol\ for which observational equivalence is decidable;
\item in \cite{DBLP:conf/tlca/LeivantM93}, the $\lambda$-calculus is used to
give several characterisations of the complexity class P. We would
like to investigate whether, by following similar techniques, we can
obtain a characterisation of a different complexity class using the
safe $\lambda$-calculus.
\end{enumerate}


More generally, we would like to study the class of languages for
which pointers are uniquely recoverable. We name this class PUR for
``Pointer Uniquely Recoverable''.

An example is the Serially Re-entrant Idealized Algol (SRIA) proposed
by Abramsky  in \cite{abramsky:mchecking_ia}. This language allows
multiple occurrences or uses of arguments, as long as they do not
overlap in time. In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to safe \ialgol.

Finitary $\ialgol_2$ is also an example of PUR-language for which
observational equivalence is decidable. As we indicated in the first
chapter, decidability of observational equivalence is a very
appealing property which has immediate applications in the domain of
program verification. Intuitively, PUR-languages seem to be good
candidates of languages for which observational equivalence is decidable. It would be interesting to discover classes of PUR
languages having this appealing property. Safe $\ialgol_3$ seems to be a good candidate.

Another possible way to generate PUR-languages may be to constrain
the types of an existing language. In \cite{DBLP:conf/tlca/Joly01},
a notion of ``complexity'' is defined for $\lambda$-terms. It is
proved that a type $T$ can be generated from a finite set of
combinators if and only if there is a constant bounding the
complexity of every closed normal $\lambda$-term of type $T$;
consequently, the only inhabited finitely generated types are the
type of rank $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$. We know that imposing the
first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?



    \bibliographystyle{plain}
    \bibliography{../bib/dphil-all}

    %adds the bibliography to the table of contents
    \addcontentsline{toc}{chapter}
         {\protect\numberline{Bibliography\hspace{-96pt}}}
\end{document}

\bigsqcup%\closeout\dependfile
