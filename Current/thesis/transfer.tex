\usepackage{bbm,latexsym}
\usepackage{tabularx}
\usepackage{bigcenter}
\usepackage[draft]{graphicx}
% \CompileMatrices  % this command causes problem with the \justseq macro

The first chapter of this part is devoted to the presentation of the
basics and main results of game semantics. The categorical
interpretation of game semantics is presented as well as the full
abstraction result for \pcf. We also give a brief summary of the
main results in algorithmic game semantics. There is no personal
contribution in this chapter.

In the second chapter we present the \emph{safe $\lambda$-calculus}.
Originally, \emph{safety} has been introduced as a syntactical
restriction on higher-order grammars in order to show a decidability
result about MSO theory of infinite trees \citep{KNU02}. In
\cite{safety-mirlong2004}, Aehlig, de Miranda and Ong  proposed an
adaptation of the safety restriction to the $\lambda$-calculus. This
restriction gives rise to the safe $\lambda$-calculus. We first
present this calculus and then give a more general definition which
does not make any assumption on the types of the terms.

In the third chapter, following ideas described in
\cite{OngLics2006}, we introduce the notions of computation tree of
a simply-typed term and traversal over a computation tree. We prove
a theorem showing a correspondence between traversals of the
computation tree and the game semantics of a term. Based on that
correspondence, we give a characterisation of the game semantics of
safe terms by a property called ``P-incremental-justification''. In
P-incrementally-justified strategies, P-pointers are superfluous (i.e.
they can be recovered uniquely from the underlying sequence of
moves and from O-moves' pointers). This simplification of the game semantics suggests some potential applications in algorithmic game semantics. We finish the
chapter by extending the result to safe \pcf\ and by giving the key
elements for an extension to full Safe Idealized Algol.


% first chapter
\include{chap_gamesem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% second chapter
\chapter{Safe $\lambda$-Calculus}
In \cite{KNU02}, the authors introduced a restriction on
higher-order grammars called \emph{safety} in order to study the
infinite hierarchy of trees recognized by a higher-order pushdown
automaton. They proved that trees recognized by pushdown automata of
level $n$ coincide with trees generated by safe higher-order
grammars of level $n$. This characterisation permitted them to prove
the decidability of the monadic second-order theory of infinite
trees recognized by a higher-order pushdown automaton of any level.

Safety has also appeared in a different form in \cite{Dam82} under
the name \emph{restriction of derived types}. The forthcoming thesis
of Jolie de Miranda \citep{demirandathesis} contains a comparison of
safety and the restriction of derived types.

More recently, Ong proved in \cite{OngLics2006} that the safety
assumption of \cite{KNU02} is in fact not necessary. More precisely,
the paper shows that the MSO theory of trees generated by order-$n$
recursion schemes is $n$-EXPTIME complete.

For this particular problem, \emph{safety} happens to be an
artificial restriction. However when the \emph{safety} condition is
transposed to the simply-typed $\lambda$-calculus, it gives some
interesting properties. In particular, for safe terms, it becomes
unnecessary to rename variables when performing substitution.

This chapter starts with a presentation of the original version of
the safe $\lambda$-calculus where types are required to satisfy a
condition called homogeneity. We then give a more general definition
which does not require type homogeneity.

\include{chap_safe_homog}
\include{chap_safe_nonhomog}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% fourth chapter
\include{chap_gsemsafety}









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Further possible developments}

In the previous chapter, we have given an account of the game
semantics of safe $\lambda$-calculus. However the nature of this
calculus is still not well known. We propose the following possible
roadmap for further research:
\begin{enumerate}
\item give a detailed account of
P-incrementally-justified strategies that treats the problem of compositionality;
\item find a categorical interpretation of the safe $\lambda$-calculus;
\item study the proof theory obtained by the Curry-Howard isomorphism and determine whether it has nice properties that can be helpful in theorem proving;
\item identify a non-trivial fragment of safe \ialgol\ for which observational equivalence is decidable;
\item in \cite{DBLP:conf/tlca/LeivantM93}, the $\lambda$-calculus is used to
give several characterisations of the complexity class P. We would
like to investigate whether, by following similar techniques, we can
obtain a characterisation of a different complexity class using the
safe $\lambda$-calculus.
\end{enumerate}


More generally, we would like to study the class of languages for
which pointers are uniquely recoverable. We name this class PUR for
``Pointer Uniquely Recoverable''.

An example is the Serially Re-entrant Idealized Algol (SRIA) proposed
by Abramsky  in \cite{abramsky:mchecking_ia}. This language allows
multiple occurrences or uses of arguments, as long as they do not
overlap in time. In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to safe \ialgol.

Finitary $\ialgol_2$ is also an example of PUR-language for which
observational equivalence is decidable. As we indicated in the first
chapter, decidability of observational equivalence is a very
appealing property which has immediate applications in the domain of
program verification. Intuitively, PUR-languages seem to be good
candidates of languages for which observational equivalence is decidable. It would be interesting to discover classes of PUR
languages having this appealing property. Safe $\ialgol_3$ seems to be a good candidate.

Another possible way to generate PUR-languages may be to constrain
the types of an existing language. In \cite{DBLP:conf/tlca/Joly01},
a notion of ``complexity'' is defined for $\lambda$-terms. It is
proved that a type $T$ can be generated from a finite set of
combinators if and only if there is a constant bounding the
complexity of every closed normal $\lambda$-term of type $T$;
consequently, the only inhabited finitely generated types are the
type of rank $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$. We know that imposing the
first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?
