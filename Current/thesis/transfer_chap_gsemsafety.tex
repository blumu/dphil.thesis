% chapter on Game-semantic characterisation of safety
\chapter{Game-semantic characterisation of safety}

Safety has been defined as a syntactical constraint. Since Game
Semantics is by essence syntax-independent, it seems difficult at
first sight to characterise Safety in a game-semantic manner.
However, with the help of the tools developed in the previous
chapter and using the Correspondence Theorem, we can interpret plays
of a strategy as sequences of nodes of some AST of the term.
Therefore it is now possible to investigate the impact of the Safety
restriction on Game Semantics.


The main theorem of this chapter (theorem
\ref{thm:safe_ptr_recoverable}) states that pointers in a play of
the strategy denotation of a safe term can be uniquely recovered
from O-questions' pointers and from the underlying sequence of moves. The proof is in several steps. We start by introducing the notion of
\emph{P-incrementally-justified strategies} and prove that for plays
of such strategies, pointers emanating from P-moves can be reconstructed uniquely from the underlying sequences of moves and from O-moves' pointers. We then introduce the notion of \emph{incrementally-bound computation trees} and prove that incremental-binding coincides with P-incremental-justification (proposition \ref{prop:incrbound_imp_incrjustified}). Finally, we show that safe simply-typed terms in $\beta$-normal form have incrementally-bound computation trees, consequently their game denotation is P-incrementally-justified.


The first section of this chapter is concerned only with the safe $\lambda$-calculus without interpreted constants. In the next
section we extend the result by taking into account the interpreted
constants of \pcf\ and \ialgol. We define the language safe \ialgol\
(resp. safe \pcf) to be the fragment of \ialgol\ (resp. \pcf) where
the application and abstraction rules are constrained the same way
as in the safe $\lambda$-calculus. We show that safe \pcf\ terms are
denoted by P-incrementally-justified strategies and we give the key
elements for a possible extension of the result to Safe Idealized
Algol.

\section{Safe $\lambda$-Calculus}
Let us consider the safe $\lambda$-calculus without interpreted
constants. Our aim is to prove that pointers in the game semantics
of safe terms can be uniquely recovered.

The example of section \ref{subsec:pointer_necessary} gives a good
intuition: in order to distinguish the terms $M_1 = \lambda f . f
(\lambda x . f (\lambda y .y ))$ and $M_2 = \lambda f . f (\lambda x
. f (\lambda y .x ))$ we have to keep the pointers in the plays of
strategies. However, if we limit ourselves to the safe
$\lambda$-Calculus then the ambiguity disappears because $M_1$ is
safe whereas $M_2$ is not (in the subterm $f (\lambda y . x)$, the
free variable $x$ has the same order as $y$ but $x$ is not
abstracted together with $y$).

\begin{definition}[P-incremental-justification]
A strategy $\sigma$ on a game $A$ is
\emph{P-incrementally\-justified} if and only if for any sequence of
moves $s q \in P_A$ we have:
\begin{eqnarray*}
s q \in \sigma \wedge q \mbox{ is a P-question } &\implies&
\parbox[t]{9cm}{$q$  points to the last O-move in $\pview{s}$
with order strictly greater than $\ord{q}$.}
\end{eqnarray*}
\end{definition}

\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} Pointers emanating from P-moves are
superfluous for P-incrementally-justified strategies.
\end{lemma}
\begin{proof}
Suppose $\sigma$ is a P-incrementally-justified strategy. We prove that pointers attached to P-moves in a play $s\in \sigma$ are uniquely recoverable by induction on the length of $s$. \noindent \emph{Base case}: if $|s| \leq 1$ then there is no pointer to recover.
\noindent \emph{Step case}: suppose $s m \in \sigma$. If $m$ is an answer move then by the well-bracketing condition $m$ points
to the last unanswered question in $s$. If $m$ is a P-question then by  P-incremental-justification of $\sigma$, $m$ points to the last O-move in
$\pview{s}$ with order strictly greater than $\ord{q}$. Since we have access to O-moves' pointers, we can compute the P-view $\pview{s}$.
Hence $m$'s pointer is uniquely recoverable.
\end{proof}

%\begin{example}
%The denotation of the evaluation map $ev$ is
%P-incrementally-justified since it is the uncurrying of the identity
% map on the game A=>B.
%\end{example}


In a computation tree, a binder node always occurs in the path from the bound node to the root. We now introduce a class of computation trees in which binder nodes can be uniquely recovered from the order
of the nodes. We write $[n_1,n_2]$ to denote the path from node
$n_1$ to node $n_2$ if it exists and $]n_1,n_2]$ for the sequence of
nodes obtained by removing $n_1$ from $[n_1,n_2]$.

\begin{definition}[Incrementally-bound computation tree]
A variable node $x$ of a computation tree is said to be
\emph{incrementally-bound} if either:
\begin{enumerate}
\item $x$ is \emph{bound} by the first $\lambda$-node in the path to the root that has
order strictly greater than $\ord{x}$. Formally:
$$ x \mbox{ bound by } n \quad \imp \quad n \in [r,x] \wedge \ord{n} > \ord{x} \wedge \forall \lambda\mbox{-node } n' \in ]n,x] . \ord{n'} \leq \ord{x},$$

\item $x$ is a \emph{free variable} and all the $\lambda$-nodes in the path to the root except the root have order
smaller or equal to $\ord{x}$. Formally:
$$ x \mbox{ free } \quad \imp \quad  \forall \lambda\mbox{-node } n' \in ]r,x] . \ord{n'} \leq \ord{x}$$
\end{enumerate}
where $r$ denotes the root of the computation tree.

A computation tree is said to be \emph{incrementally-bound} if all
the variable nodes are incrementally-bound.
\end{definition}

\begin{proposition}[Incremental-binding coincides with P-incremental-justification] \
\label{prop:incrbound_imp_incrjustified} Let $M$ be a $\beta$-normal
term.
\begin{enumerate}
\item[(i)] If $\tau(M)$ is incrementally-bound then $\sem{M}$ is P-incrementally-justified.
\item[(ii)] In the $\lambda$-calculus without interpreted constants, conversely, if $\sem{M}$ is P-incrementally-justified then
$\tau(M)$ is incrementally-bound.
\end{enumerate}
\end{proposition}

\begin{proof}
Let $\Gamma \vdash M : A$ be a simply-typed term in $\beta$-normal
form and $r$ denotes the root of $\tau(M)$.

\noindent (i) Suppose that $\tau(M)$ is incrementally-bound.
Consider a justified sequence of move $s \in \sem{\Gamma \vdash M}$
ending with a P-question move $q$. By proposition \ref{prop:rel_gamesem_trav},
there is a traversal $t$ of $\tau(M)$ such that $\psi_M (t\filter r) = s$. We assume that the last node $n$ of $t$ is
hereditarily justified by $r$ (otherwise we replace $t$ by its
longest prefix verifying this condition).
\begin{itemize}
\item First case: $n$ is a variable node $x$ bound by a node $m$ occurring in $t$.

Since $\tau(M)$ is incrementally-bound, $m$ is the last
$\lambda$-node in $[r,n]$ of order strictly greater than
$\ord{n}$. By visibility, $m$ occurs in $\pview{t}$ and since
$m$ is hereditarily justified by $r$ (because $n$ is) $m$ must
occur in $\pview{t} \filter N^{r \vdash}$ which in turn is equal
to $\pview{t \filter r}$ (by corollary
\ref{cor:redtrav_trav}(i), since $M$ is in $\beta$-normal form).

But $\pview{t \filter r}$ is a subsequence of
$\pview{t}$ which is equal to $[r,n]$ (by proposition \ref{prop:pviewtrav_is_path}), therefore $m$ is also the last $\lambda$-node in $\pview{t \filter  r}$ that has order strictly greater
than $\ord{n}$.

By property \ref{proper:psi_properties} (iv), the P-view of $s$ and
the P-view of $t \filter r$ are computed similarly and
have the same pointers. This means that node $n$ and  move $q$ both
point to the same position in the justified sequence
$\pview{t\filter r}$ and $\pview{s}$ respectively.

Finally, since $\psi_M$ maps nodes of a given order to moves of the
same order (property \ref{proper:psi_properties}), $q$ must
point to the last O-move in $\pview{s}$ whose order is strictly
greater than $\ord{q}$.


\item  Second case: $n$ is a free variable node $x$. Then $n$ is enabled by the root which is the first node in $t$.
By definition of $\psi$, $\psi(n) = x$ must be a move enabled
by the initial move $q_0 = \psi(r)$ in the arena $\sem{\Gamma
\rightarrow A}$. Therefore $\ord{q_0} > \ord{x}$. Since the
computation tree is incrementally-bound, all the $\lambda$-nodes in
$]r,n]$ have order smaller than $\ord{n}$. Therefore by the
correspondence theorem, all the O-moves in $\pview{s}$ have order
smaller than $\ord{x}$.
\end{itemize}

\noindent (ii) Suppose that $M$ is $\beta$-normal and the strategy
$\sem{M}$ is P-incrementally-justified. Let $x$ be a variable node of
$\tau(M)$. Since $M$ is $\beta$-normal, by lemma
\ref{lem:betaeta_trav}, $x$ is either hereditarily justified by the root $r$ or by a constant in $N_\Sigma$. Since we are working in the simply-typed
$\lambda$-calculus without constants we have $N_\Sigma = \emptyset$ therefore $x$ is
hereditarily justified by $r$.


We remark that for terms in $\beta$-normal form, every variable node
occurring in the computation tree can be visited by some traversal
i.e. there exists a traversal of the form $t \cdot x$ in
$\travset(M)$. The correspondence theorem gives $\varphi((t \cdot x)
\filter r) = \varphi((t \filter r) \cdot x) \in
\sem{M}$. Since $\sem{M}$ is P-incrementally-justified, $\varphi(x)$
must point to the last O-move in $\pview{\varphi(t \filter
r)}$ with order strictly greater than $\ord{\varphi(x)}$.
Consequently $x$ points to the last $\lambda$-node in $\pview{t
\filter r}$ with order strictly greater than $\ord{x}$. Moreover we
have:
\begin{align*}
\pview{t \filter r} &= \pview{t} \filter N^{r \vdash} & (\mbox{by Corollary \ref{cor:redtrav_trav}}) \\
& = [r,x[\  \filter N^{r \vdash} & (\mbox{by proposition \ref{prop:pviewtrav_is_path}}) \\
& = [r,x[  & (\mbox{$M$ is in $\beta$-nf and $N_\Sigma = \emptyset$}).
\end{align*}
Therefore if $x$ is a bound variable node then it is bound by the
last $\lambda$-node in $[r,x[$ with order strictly greater than
$\ord{x}$ and if $x$ is a free variable then it points to $r$ and
therefore all the $\lambda$-node in $]r,x[$ have order smaller than
$\ord{x}$. Hence $\tau(M)$ is incrementally-bound.
\end{proof}


\parpic[r]{
    \psset{levelsep=4ex}
    \pstree{\TR{$\lambda x^3$}}{\pstree{\TR{$f^2$}}{ \pstree{\TR{$\lambda y^1$}}{ \TR{$x^0$} }}}
}

\noindent \emph{Examples:} Consider the $\beta$-normal term $\lambda
x . f (\lambda y .x)$ where $x,y:o$ and $f:(o,o),o$. The figure on
the right represents the computation tree with the order of each
node in the exponent part. Since node $x$ of order $0$ is not bound
by the order 1 node $\lambda y$, $\tau(M)$ is not
incrementally-bound and by proposition
\ref{prop:incrbound_imp_incrjustified} $\sem{\lambda x . f (\lambda
y .x)}$ is not P-incrementally-justified. Similarly we can check that
$\sem{f (\lambda y .x)}$ is not P-incrementally-justified
whereas $\sem{\lambda y. x}$ is.
Also, for any higher-order variable $x:A$ the computation tree
$\tau(x)$ is incrementally-bound therefore the projection
strategies $\pi_i$ are P-incrementally-justified. From these examples
we observe that application does not preserve
P-incremental-justification ($\sem{f}$ and $\sem{\lambda y. x}$ are
P-incrementally-justified whereas $\sem{f (\lambda y .x)}$ is not).

These examples suggest that P-incremental-justification is not a compositional property.
% Since the
% evaluation map $ev$ is not P-incrementally-justified (see example \ref{examp:evnotincrjust}),
%application cannot conserve P-incremental-justification in the general case.
One interesting problem would be to find some condition under which  the composition of two P-incrementally-justified strategy remains
P-incrementally-justified.
Unfortunately we have not provided an answer to that question yet.


\begin{lemma}[Safe terms have incrementally-bound computation trees]
\label{lem:safe_imp_incrbound} Let $\Gamma \vdash M$ be a
simply-typed term.
\begin{itemize}
\item[(i)] If $M$ is a safe term then $\tau(M)$ is incrementally-bound ;
\item[(ii)] conversely, if $M$ is \emph{closed} and $\tau(M)$ is incrementally-bound then the $\eta$-normal form of $M$ is safe.
\end{itemize}
\end{lemma}
\begin{proof}
(i) Suppose that $M$ is safe. The safety property is preserved after
taking the $\eta$-long normal form, therefore $\tau(M)$ is the tree representation of a safe term.

In the safe $\lambda$-calculus, the variables in the context with the the lowest order must be all abstracted
at once when using the abstraction rule. Since the computation
tree merges consecutive abstractions into a single node,
any variable $x$ occurring free in the subtree rooted at a $\lambda$-node $\lambda \overline{\xi}$ different from the root
must have order greater or equal to $\ord{\lambda \overline{\xi}}$. Reciprocally, if a lambda node
$\lambda \overline{\xi}$ binds a variable node $x$ then
$\ord{\lambda \overline{\xi}} = 1+\max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Let $x$ be a bound variable node. Its binder occurs in the path from $x$
to the root, therefore, according to the previous observation, $x$ must be bound
by the first $\lambda$-node occurring in $[r,x]$ with order strictly
greater than $\ord{x}$. Let $x$ be a free variable node then $x$ is not bound
by any of the $\lambda$-nodes occurring in $[r,x]$. Once again, by the previous observation, all
these $\lambda$-nodes except $r$ have order smaller than $\ord{x}$. Hence
$\tau$ is incrementally-bound.

(ii) Let $M$ be a closed term such that $\tau(M)$ is incrementally-bound.
We assume that $M$ is already in $\eta$-normal form.
We prove that $M$ is safe by induction on its structure. The base case $M =
\lambda \overline{\xi} . \alpha$ for some variable or constant
$\alpha$ is trivial.
\emph{Step case:} If $M = \lambda \overline{\xi} . N_1 \ldots N_p$.
Let $i$ range over $1..p$. $N_i$ can be written $\lambda
\overline{\eta_i} . N'_i$ where $N'_i$ is not an abstraction. By the
induction hypothesis, $\lambda \overline{\xi} . N_i = \lambda
\overline{\xi} \overline{\eta_i} . N'_i$ is safe.
Hence $\vdash \lambda \overline{\xi} \overline{\eta_i} . N'_i$
is a valid judgment of safe $\lambda$-calculus.
But this judgment can only be derived using the (abs) rule on the term $N'_i$. Hence
$N'_i$ is necessarily safe. Let $z$ be a variable occurring free in
$N'_i$. Since $M$ is closed, $z$ is either bound by $\lambda
\overline{\eta_1}$ or $\lambda \overline{\xi}$. If it is bound by
$\lambda \overline{\xi}$ then because $\tau(M)$ is
incrementally-bound we have $\ord{z} \geq \ord{\lambda
\overline{\eta_1}} = \ord{N_i}$. Hence in both case we can abstract the variables
$\overline{\eta_1}$ using the (abs) rule which shows that $N_i$ is safe.

Each of the $N_i$s are safe and $N_1 \ldots N_p$ is of type $o$ therefore
by the (app) rule we have $\overline{\xi} \vdash N_1 \ldots N_p$. Finally, using the (abs) rule we conclude
with the judgement $\vdash M = \lambda \overline{\xi} . N_1 \ldots N_p$.
\end{proof}

Note that the hypothesis that $M$ is closed in (ii) is necessary.
For instance, the two terms $\lambda x y .x$ and $\lambda y . x$,
where $x,y:o$, have (isomorphic) incrementally-bound computation
trees. However $\lambda x y .x$ is safe whereas $\lambda y . x$ is
not.



Putting proposition \ref{prop:incrbound_imp_incrjustified} and lemma
\ref{lem:safe_imp_incrbound} together we obtain a game-semantic
characterisation of safe terms:
\begin{corollary}[P-incrementally-justified strategies characterise safe closed $\eta\beta$-normal terms]
Let $M$ be a simply-typed term without interpreted constants. We have:
$$ \sem{M} \mbox{ is P-incrementally-justified if and only if $\etabetanf{M}$ is safe,} $$
where $\etabetanf{M}$ denotes the $\eta$-normal form of the
$\beta$-normal form of $M$.
\end{corollary}



\begin{theorem}[P's pointers are superfluous for safe terms]
\label{thm:safe_ptr_recoverable} Pointers emanating from P-moves in the game semantics of
safe terms are uniquely recoverable.
\end{theorem}
\begin{proof}
Let $M$ be a safe simply-typed term. The $\beta$-normal form of $M$
denoted by $M'$ is also safe. By lemma \ref{lem:safe_imp_incrbound}
(i), $\tau(M')$ is incrementally-bound and by proposition
\ref{prop:incrbound_imp_incrjustified}, $\sem{M'}$ is a
P-incrementally-justified strategy. By lemma
\ref{lem:incrjustified_pointers_uniqu_recover}, P's pointers in
$\sem{M'}$ are uniquely recoverable. Finally, the soundness of the
game model gives $\sem{M} = \sem{M'}$.
\end{proof}


\section{Safe PCF and Safe Idealized Algol}

Safe Idealized Algol, or safe \ialgol\ for short, is Idealized Algol
where the application and abstraction rules are restricted the same
way as in the safe $\lambda$-calculus (see rules of section
\ref{sec:safe_nonhomog}).

The properties of the safe $\lambda$-calculus can be transposed
straightforwardly to safe \ialgol. In particular, it can be shown
that safety is preserved by $\beta$-reduction and that no variable
capture occurs when performing substitution on a safe term.

A natural question to ask is whether we can extend the result about
game semantics of safe $\lambda$-terms to safe \ialgol-terms. In
this section we lay out the key elements permitting to prove that
the pointers in the game semantics of safe IA terms can be recovered
uniquely.

Such result has potential applications in algorithmic game semantics.
For instance, by following the framework of \cite{ghicamccusker00},
it may be possible to give a characterisation of the game semantics
of some higher-order fragments of safe \ialgol\ using extended
regular expressions. Subsequently, this would lead to the
decidability of program equivalence for the considered fragment.


\subsection{Formation rules of Safe \ialgol}
We call safe \ialgol\ term any term that is typable within the
following system of formation rules:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
%\qquad  \rulename{const} \   \rulef{}{\vdash f : A} \quad f \in \Sigma
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash M : A}{\Delta \vdash
M : A} \quad  \Gamma \subset \Delta$$

$$ \rulename{app} \  \rulef{\Gamma \vdash M : (A,\ldots,A_l,B)
                                        \qquad \Gamma \vdash N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash N_l : A_l  }
                                   {\Gamma  \vdash M N_1 \ldots N_l : B}
                                    \quad
\mbox{\fbox{$\forall y \in \Gamma : \ord{y} \geq \ord{B}$}}$$

$$ \rulename{abs} \   \rulef{\Gamma \union \overline{x} : \overline{A} \vdash M : B}
                                   {\Gamma  \vdash \lambda \overline{x} : \overline{A} . M : (\overline{A},B)} \quad
\mbox{\fbox{$\forall y \in \Gamma : \ord{y} \geq \ord{\overline{A},B}$}}$$

$$ \rulename{num} \rulef{}{\Gamma \vdash n :\texttt{exp}}
\qquad \rulename{succ} \rulef{\Gamma \vdash M:\texttt{exp} }{\Gamma
\vdash \texttt{succ}\ M:\texttt{exp}} \qquad \rulename{pred}
\rulef{\Gamma \vdash M:\texttt{exp} }{\Gamma \vdash \texttt{pred}\
M:\texttt{exp}}$$

$$
\rulename{cond} \rulef{\Gamma \vdash M : \texttt{exp} \qquad \Gamma
\vdash N_1 : \texttt{exp} \qquad \Gamma \vdash N_2 : \texttt{exp}
}{\Gamma \vdash \texttt{cond}\ M\ N_1\ N_2} \qquad  \rulename{rec}
\rulef{\Gamma \vdash M : A\rightarrow A }{ \Gamma \vdash Y_A M :
A}$$

$$ \rulename{seq} \rulef{\Gamma \vdash M : \texttt{com} \quad \Gamma \vdash N :A}
    {\Gamma \vdash \texttt{seq}_A \ M\ N\ : A} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulename{assign} \rulef{\Gamma \vdash M : \texttt{var} \quad \Gamma \vdash N : \texttt{exp}}
    {\Gamma \vdash \texttt{assign}\ M\ N\ : \texttt{com}}
\qquad
 \rulename{deref} \rulef{\Gamma \vdash M : \texttt{var}}
    {\Gamma \vdash \texttt{deref}\ M\ : \texttt{exp}}$$

$$ \rulename{new} \rulef{\Gamma, x : \texttt{var} \vdash M : A}
    {\Gamma \vdash \texttt{new } x \texttt{ in } M} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulename{mkvar} \rulef{\Gamma \vdash M_1 : \texttt{exp} \rightarrow \texttt{com} \quad \Gamma \vdash M_2 : \texttt{exp}}
    {\Gamma \vdash \texttt{mkvar } M_1\ M_2\ : \texttt{var}}$$

\subsection{Small-step semantics of Safe \ialgol}
In the first chapter we defined the operational semantics of
\ialgol\ using a big step semantics. The operational semantics of
\ialgol\ can be defined equivalently using a small-step semantics.
The reduction rules of the small-step semantics are of the form $s,e
\rightarrow s',e'$ where $s$ and $s'$ denotes the stores and $e$ and
$e'$ denotes \ialgol\ expressions.

Let us give the rules that tell how to reduce redexes:
\begin{itemize}
\item the reduction of safe-redex (relation $\beta_s$ from definition \ref{dfn:safereduction});
\item reduction rules for \pcf\ constants:
\begin{eqnarray*}
\pcfsucc\ n &\rightarrow& n+1 \\
\pcfpred\ n+1 &\rightarrow& n \\
\pcfpred\ 0 &\rightarrow& 0 \\
\pcfcond\ 0\ N_1 N_2 &\rightarrow& N_1 \\
\pcfcond\ n+1\ N_1 N_2 &\rightarrow& N_2 \\
Y\ M &\rightarrow& M (Y M)
\end{eqnarray*}
\item reduction rules for \ialgol\ constants:
\begin{eqnarray*}
\iaseq\ \iaskip\  M &\rightarrow& M \\
s, \ianewin{x}\ M &\rightarrow& (s|x\mapsto 0), M \\
s, \iaassign\ x\ n &\rightarrow& (s|x\mapsto n), \iaskip \\
s, \iaderef\ x &\rightarrow& s, s(x) \\
\iaassign\ (\iamkvar M N)\ n &\rightarrow& M n \\
\iaderef\ (\iamkvar M N) &\rightarrow& N
\end{eqnarray*}
\end{itemize}

Redex can also be reduced when they occur as subexpressions within a
larger expression. We make use of evaluation contexts to indicate
when such reduction can happen. Evaluation contexts are given by the
following grammar:
\begin{eqnarray*}
E[-] &::=& - |\ E N\ |\ \pcfsucc\ E\ |\ \pcfpred\ E\ |\ \pcfcond\ E\ N_1\ N_2\ |\ \\
&&    \iaseq\ E\ N\ |\ \iaderef\ E\ |\ \iaassign\ E\ n\ |\ \iaassign\ M\ E \ |\ \\
&&    \iamkvar\ M\ E\ |\ \iamkvar\ E\ M\ |\ \ianewin{x}\ E  .
\end{eqnarray*}

The small-step semantics is completed with following rule:
$$ \rulef{M \rightarrow N}{E[M] \rightarrow E[N]} $$

\begin{lemma}[Reduction preserves safety]
\label{lem:ia_safety_preserved} Let $M$ be a safe IA term. If
$M \rightarrow N$ then $N$ is also a safe term.
\end{lemma}
This can be proved easily by induction on the structure of M.


\subsection{Safe \pcf\ fragment}
In this section, we show how to extend the results obtained for the
safe $\lambda$-calculus to the \pcf\ fragment of safe \ialgol.

The $Y$ combinator needs a special treatment. In order to deal with
it, we follow the idea of \cite{abramsky:game-semantics-tutorial}:
we consider the sublanguage $\pcf_1$ of \pcf\ in which the only
allowed use of the $Y$ combinator is in terms of the form $Y(
\lambda x:A .x )$ for some type $A$. We will write $\Omega_A$ to
denote the non-terminating term $Y(\lambda x:A .x)$ for a given type
$A$.

We introduce the \emph{syntactic approximants} to $Y_A M$:
\begin{eqnarray*}
Y^0_A M &=& \Gamma \vdash \Omega_A : A\\
Y^{n+1}_A M &=& M( Y^n M )
\end{eqnarray*}
For any \pcf\ term $M$ and natural number $n$, we define $M_n$ to be
the $\pcf_1$ term obtained from $M$ by replacing each subterm of the
form $Y N$ with $Y^n N_n$. We have $\sem{M} = \Union_{n\in\omega}
\sem{M_n}$ (\cite{abramsky:game-semantics-tutorial}, lemma 16).


\subsubsection{Computation tree}

We would like to define a unique computation tree for terms that use
the $Y$ combinator.

Let us first define the computation tree for $\pcf_1$ terms. We
introduce a special $\Sigma$-constant $\bot$ representing the
non-terminating computation of ground type $\Omega_o$. Given any
type $A = (A_1, \ldots, A_n, o)$, the computation tree
$\tau(\Omega_A)$ is defined to be the tree representation of
$\lambda x_1:A_1 \ldots x_n:A_n . \bot$. The computation tree of a
$\pcf_1$ term is then computed inductively in the standard way.

We now introduce a partial order on the set of computation trees.

A \emph{tree} $t$ is a labelling function $t:T\rightarrow L$ where
$T$, called the domain of $t$ and written $dom(t)$, is a non-empty
prefix-closed subset of some free monoid $X^*$ and $L$ denotes the
set of possible labels. Intuitively, $T$ represents the structure of
the tree (the set of all paths) and $t$ is the labelling function
mapping paths to labels. Trees can be ordered using the
\emph{approximation ordering} defined in \cite{KNU02}, section 1: we
write $t' \sqsubseteq t$ if the tree $t'$ is obtained from $t$ by
replacing some of its subtrees by $\bot$. Formally:
$$t' \sqsubseteq t \quad \iff dom(t') \subseteq dom(t) \wedge \forall  w \in dom(t'). (t'(w) = t(w) \vee t'(w) = \bot).$$
The set of all trees together with the approximation ordering is a
complete partial order.

We now consider a strict subset of the set of all trees: the set of
computation trees. A computation tree is a tree which represents the
$\eta$-normal form of some (potentially infinite) \pcf\ term. In
other words a tree is a computation tree if it can be written
$\tau(M)$ for some infinite \pcf\ term $M$. The set $L$ of labels is
constituted of the $\Sigma$-constants, @, the special constant
$\bot$, variables and abstractions of any sequence of variables. We
will write $(CT, \sqsubseteq)$ to denote the set of computation
trees ordered by the approximation ordering $\sqsubseteq$ defined
above. $(CT, \sqsubseteq)$ is also a complete partial order.

It is easy to check that the sequence of computation trees
$(\tau(M_n))_{n\in\omega}$ is a chain. We can therefore define the
computation tree of a \pcf\ term $M$ to be the least upper-bound of
the chain of computation trees of its approximants:
$$\tau(M) = \Union_{n\in\omega}(\tau(M_n))_{n\in\omega}.$$

In other words, we construct the computation tree by expanding
infinitely any subterm of the form $Y M$. For instance consider the
term $M = Y (\lambda f x. f x)$ where $f:(o,o)$ and $x:o$. Its
computation tree $\tau(M)$, represented below, is a tree
representation of the $\eta$-normal form of the infinite term
$(\lambda f x. f x) ((\lambda f x. f x) ((\lambda f x. f x)  (
\ldots$.
$$\tau(M) = \tree{\lambda y}{
                \tree{@}{
                        \tree{\lambda f x} { \tree{f}{\tree{\lambda}{\TR{x}} }}
                        \TR{\tau(M)}
                        \tree{\lambda}{\TR{y}}
                }
            }
$$

The remaining operators of \ialgol\ are treated as standard
constants and the corresponding computation tree is constructed from
the $\eta$-normal form of the term in the standard way. For instance
the diagram below shows the computation tree for $\pcfcond\ b\ x\ y$
(left) and $\lambda x . 5$ (right):
$$
\tree{\lambda b x y}
     {  \tree{\pcfcond}
        {   \tree{\lambda} {\TR{b}}
            \tree{\lambda} {\TR{x}}
            \tree{\lambda} {\TR{y}}
        }
    }
\hspace{2cm} \tree{\lambda x}{  \TR{5} }
$$
The node labelled $5$ has, like any other node, children
value-leaves which are not represented on the diagram above for
simplicity.

\subsubsection{Traversal}

New traversal rules accompany the additional constants of \ialgol.
There is one additional rule for natural number constants:
\begin{itemize}
\item (Nat) If $t \cdot n$ is a traversal where $n$ denotes a node labelled with some numeral constant $i\in \nat$ then
            $\Pstr{t \cdot (n){n} \cdot (in-n){i_n}}$
            is also a traversal where $i_n$ denotes the value-leaf of $m$ corresponding to the value $i\in \nat$.
\end{itemize}

\noindent The traversals rules for \pcfpred\ and \pcfsucc\ are
defined similarly. For instance, the rules for \pcfsucc\ are:
\begin{itemize}
\item (Succ) If $t \cdot \pcfsucc$ is a traversal and $\lambda$ denotes the only child node of \pcfsucc\ then
$\Pstr{t \cdot (succ){\pcfsucc} \cdot (l-succ,35:1){\lambda}}$ is also a traversal.

\item (Succ') If
$\Pstr{ t_1 \cdot (succ){\pcfsucc} \cdot (l-succ,35:1){\lambda} \cdot t_2
\cdot (lv-l){i_{\lambda}}} $ is a traversal for some
$i \in \nat$ then $\Pstr{t_1 \cdot (succ){\pcfsucc} \cdot
(l-succ,35:1){\lambda} \cdot t_2 \cdot (lv-l){i_{\lambda}} \cdot
(succv-succ,25){(i+1)_{\pcfsucc}}}$ is also a traversal.
\end{itemize}

\noindent In the computation tree, nodes labelled with \pcfcond\
have three children nodes numbered from $1$ to $3$ corresponding to
the three parameters of the operator \pcfcond. The traversal rules
are:
\begin{itemize}
\item (Cond-If) If $t_1 \cdot \pcfcond$ is a traversal and $\lambda$ denotes the first child of \pcfcond\ then
$\Pstr{ t_1 \cdot (cond){{\pcfcond}} \cdot (l-cond,30:1){\lambda}}$
 is also a traversal.

\item (Cond-ThenElse) If
$\Pstr{t_1 \cdot (cond){\pcfcond} \cdot (l-cond,35:1){\lambda} \cdot t_2
\cdot (lv-l){i_{\lambda}}} $
then $\Pstr{t_1 \cdot
(cond){\pcfcond} \cdot (l-cond,35:1){\lambda} \cdot t_2 \cdot
(lv-l){i_{\lambda}} \cdot (condthenelse-cond,35:{2+[i>0]}){\lambda} }
$
is also a traversal.



\item (Cond') If
$\Pstr{t_1 \cdot (cond){\pcfcond} \cdot t_2 \cdot (l-cond,35:k){\lambda}
\cdot t_3 \cdot (lv-l){i_{\lambda}}}$
 for $k=2$ or $k=3$ then  $\Pstr{ t_1 \cdot
(cond){\pcfcond} \cdot t_2 \cdot (l-cond,35:k){\lambda} \cdot t_3
\cdot (lv-l){i_{\lambda}} \cdot (condv-cond,25){i_{\pcfcond}}}$
 is also a traversal.
\end{itemize}
It is easy to verify that these traversal rules are all well-behaved
and therefore condition (WB) of section \ref{subsec:traversal} is
met. This completes the definition of traversal for the \pcf\ subset
of \ialgol.

\subsubsection{Interaction semantics}
We recall that the interaction semantics defined in section
\ref{sec:interaction_semantics} takes into account the constants
of the language. For any higher-order constant $f : (A_1,\ldots,A_p,B) \in \Sigma$, definition \ref{dfn:interactionstrategy_ofterms} gives the  revealed strategy of a term of the form $\lambda \overline{\xi}. f N_1 \ldots
N_p$ as follows:
$$ \intersem{\lambda \overline{\xi}. f N_1 \ldots N_p} = \langle \intersem{N_1}, \ldots, \intersem{N_p} \rangle \fatsemi^{0..p-1} \sem{f}.$$
where $\sem{f}$ is the standard strategy denotation of the constant $f$.


\subsubsection{Removing $\Sigma$-nodes from the traversals}

To establish the correspondence with the interaction semantics, we
need to remove the superfluous nodes from the traversals. These
nodes are the @-nodes and the constant nodes. We will use the
operation $-@$ (definition \ref{dfn:appnode_filter}) to filter out
the @-nodes and we introduce a similar operation $-\Sigma$ to
eliminate the $\Sigma$-nodes.

\begin{definition}[Hiding $\Sigma$-constants in the traversals]
Let $t$ be a traversal of $\tau(M)$. We write $t-\Sigma$ for the
sequence of nodes with pointers obtained by
\begin{itemize}
\item removing from $t$ all nodes labelled with a $\Sigma$-constant or value-leaf justified by a $\Sigma$-constant,
\item replacing any link pointing to a $\Sigma$-constant $f$
by a link pointing to the predecessor of $f$ in $t$.
\end{itemize}

Suppose $u = t-\Sigma$ is a sequence of nodes obtained by applying
the previously defined transformation on the traversal $t$, then $t$
can be partially recovered from $u$ by reinserting the
$\Sigma$-nodes as follows. For each $\Sigma$-node $f$, where $p$
denotes the parent node of $f$, do the following:
    \begin{enumerate}
    \item replace every occurrence of the pattern $p \cdot n$ in $u$ where
    $n$ is a $\lambda$-node by $p \cdot f \cdot n$;

    \item replace any link in $u$ starting from a $\lambda$-node and pointing to $p$ by a link pointing to the inserted node $f$;

    \item for each occurrence in $u$ of a value-leaf $v_p$ pointing to $p$, add the value-leaf $v_f$
    immediately before $v_p$. The links of $v_f$ points to the node immediately following $p$.
    \end{enumerate}
We write $u+\Sigma$ for this second transformation.
\end{definition}
These transformations are well-defined since in a traversal, a
$\Sigma$-node $f$ always follows immediately its parent
$\lambda$-node $p$, and an occurrence of a value-node $v_p$ always
follows immediately a value-node $v_f$. In other words, if $f$
occurs in $t$ then $t$ must be a prefix of a traversal of the
following form for some $v \in \mathcal{D}$:
$$ \Pstr{ \ldots \cdot (p){p} \cdot (f){f} \cdot \ldots \cdot (vf-f){v_f} \cdot (vp-p){v_p} \cdot \ldots }$$

Remark: $t-\Sigma$ is not a proper traversal since it does not
satisfy alternation. It is not a proper justified sequence either
since after removing a $\Sigma$-node $f$, any $\lambda$-node
justified by $f$ will become justified by the parent of $f$ which is
also a $\lambda$-node.

The following lemma follows directly from the definition:
\begin{lemma}
\label{lem:minus_sig_plus_sig} For any traversal $t$ we have
$(t-\Sigma)+\Sigma \sqsubseteq t$ and if $t$ does not end with an
$\Sigma$-node or a value-leaf of a $\Sigma$-node then
$(t-\Sigma)+\Sigma = t$.
\end{lemma}

The operations $-@$ and $-\Sigma$ are commutative: $(t-@)-\Sigma =
(t-\Sigma)-@$. We write $t^*$ to denote $(t-@)-\Sigma$ i.e. the
sequence obtained from $t$ by removing all the @-nodes as well as
the constant nodes together with their associated value-leaves. We
introduce the notation $\travset(M)^{*} = \{ t^* \ | \  t \in
\travset(M) \}$.

\begin{lemma}[Filtering lemma]
\label{lem:SIGMACONST:varphi_filter} Let $\Gamma \vdash M :T$ be a
term and $r$ be the root of $\tau(M)$. For any traversal $t$ of the
computation tree we have $ \varphi(\travset^*(M)) \filter
\sem{\Gamma \rightarrow T} = \varphi(\travset^{\filter
r}(M)) $.
 Consequently,
$$\varphi(t^*) \filter \sem{\Gamma \rightarrow T} = \varphi(t\filter r).$$
\end{lemma}
\begin{proof}
    From the definition of $\varphi$, the nodes of the computation tree that $\varphi$ maps
    to moves in the arena $\sem{\Gamma \rightarrow T}$ are exactly the nodes that are hereditarily justified by $r$.
    The result follows from the fact that @-nodes, constant nodes and value-leaves of constant nodes
    are not hereditarily justified by the root.
\end{proof}

The following lemma is the counterpart of lemma
\ref{lem:varphiinjective} and it is proved identically.
\begin{lemma}[$\varphi$ is injective]
\label{lem:SIGMACONST:varphiinjective} $\varphi$ regarded as a
function defined on the set of sequences of nodes is injective in
the sense that for any two traversals $t_1$ and $t_2$:
\begin{itemize}
\item[(i)] if $\varphi (t_1^* ) = \varphi (t_2^* )$ then $t_1^* =t_2^*$;
\item[(ii)] if $\varphi (t_1 \filter r ) = \varphi (t_2 \filter r )$ then $t_1\filter r = t_2\filter r$.
\end{itemize}
\end{lemma}

\begin{corollary} \
\label{cor:SIGMACONST:varphi_bij}
\begin{itemize}
\item[(i)] $\varphi$ defines a bijection from $\travset(M)^*$
to $\varphi(\travset(M)^*)$;
\item[(ii)] $\varphi$ defines a bijection from $\travset(M)^{\filter r}$ to
$\varphi(\travset(M)^{\filter r})$.
\end{itemize}
\end{corollary}


\subsubsection{Correspondence theorem}
We would like to prove the counterpart of proposition
\ref{prop:rel_gamesem_trav} in the context of the simply-typed
$\lambda$-calculus \emph{with interpreted PCF constants}. The game
model of the language \pcf\ is given by the category $\mathcal{C}_b$
of well-bracketed strategies. Hence the well-bracketing assumption
stated at the beginning of section \ref{sec:gamesemcorresp} is
satisfied.

We first prove that $\travset^{\filter r}$ is continuous.
\begin{lemma}
\label{lem:travred_continuous} Let $(S,\subseteq)$ denote the set of
sets of justified sequences of nodes ordered by subset inclusion.
The function $\travset^{\filter r} : (CT,\sqsubseteq)
\rightarrow (S,\subseteq)$ is continuous.
\end{lemma}
\begin{proof} \
    \begin{description}
    \item[Monotonicity:] Let $T$ and $T'$ be two computation trees such that $T \sqsubseteq T'$
    and let $t$ be some traversal of $T$.
    Traversals ending with a node labelled $\bot$ are maximal therefore $\bot$ can only occur
    at the last position in a traversal. Let us prove the following two properties:
        \begin{itemize}
            \item[(i)]  If $t = t \cdot n$ with $n\neq \bot$ then $t$ is a traversal of $T'$;
            \item[(ii)] if $t= t_1 \cdot \bot$ then $t_1\in \travset(T')$.
        \end{itemize}

        (i) By induction on the length of $t$. It is trivial for the empty traversal.
            Suppose that $t = t_1 \cdot n$ is a traversal with $n \neq \bot$.
            By the induction hypothesis, $t_1$ is a traversal of $T'$.

            We observe that for all traversal rules, the traversal produced is of the form $t_1 \cdot n$ where
            $n$ is defined to be a child node or value-leaf of some node $m$ occurring in $t_1$.
            Moreover, the choice of the node $n$ only depends on the traversal $t_1$
            (for the constant rules, this is guaranteed by assumption (WB)).

            Since $T \sqsubseteq T'$, any node $m$ occurring in $t_1$ belongs
            to $T'$ and the children nodes and leaves of $m$ in $T$ also belong to the tree $T'$.
            Hence $n$ is also present in $T'$ and the rule used to produce the traversal $t$ of $T$
            can be used to produce the traversal $t$ of $T'$.

        (ii) $\bot$ can only occur at the last position in a traversal
        therefore $t_1$ does not end with $\bot$ and by (i) we have $t_1\in \travset(T')$.
\vspace{6pt}

        Hence we have:
        \begin{align*}
        \travset(T)^{\filter r} &= \{ t \filter r \ | \ t \in \travset(T)     \} \\
        & = \{ (t\cdot n) \filter r \ | \ t\cdot n \in \travset(T) \wedge n \neq \bot \}
            \union \{ (t \cdot \bot ) \filter r \ | \ t \cdot \bot \in \travset(T)  \} \\
\mbox{(by (i) and (ii))} \quad        & \subseteq  \{ (t\cdot n)
\filter r \ | \ t\cdot n \in \travset(T') \wedge n \neq \bot
\}
            \union \{ t \filter r \ | \ t \in \travset(T')  \} \\
        & = \travset(T')^{\filter r}
        \end{align*}

        \item[Continuity:] Let $t \in \travset \left( \Union_{n\in\omega} T_n \right)$.
        We write $t_i$ for the finite prefix of $t$ of length $i$.
        The set of traversals is prefix-closed therefore $t_i \in \travset \left( \Union_{n\in\omega} T_n \right)$ for any $i$.
        Since $t_i$ has finite length we have $t_i \in \travset(T_{j_i})$ for some $j_i \in \omega$.
        Therefore we have:
        \begin{align*}
          t \filter r &= (\bigvee_{i\in\omega} t_i ) \filter r   & (\mbox{the sequence $(t_i)_{i\in\omega}$ converges to $t$}) \\
          &= \Union_{i\in\omega} ( t_i \filter r )   & (\_ \filter r \mbox{ is continuous, lemma \ref{lem:filtercontinous}}) \\
          &\in \Union_{i\in\omega} \travset^{\filter r}(T_{j_i})   & (t_i \in \travset(T_{j_i})) \\
          &\subseteq \Union_{i\in\omega} \travset^{\filter r}(T_i)   & (\mbox{since } \{ j_i \sthat i \in \omega \} \subseteq \omega)
        \end{align*}

        Hence $\travset^{\filter r} (\Union_{n\in\omega} T_n ) \subseteq \Union_{n\in\omega} \travset^{\filter r}(T_n).$

    \end{description}
\end{proof}

\begin{proposition}
Let $\Gamma \vdash M : T$ be a PCF term and $r$ be the root of
$\tau(M)$. Then:
\begin{align*}
(i)  \quad\varphi_M(\travset(M)^*) = \intersem{M},  \\
(ii) \quad \varphi_M(\travset(M)^{\filter r}) = \sem{M}.
\end{align*}
\end{proposition}
\begin{proof}
We first prove the result for $\pcf_1$: (i) The proof is an
induction identical to the proof of proposition
\ref{prop:rel_gamesem_trav}. However we need to complete the case
analysis with the $\Sigma$-constant cases:
\begin{itemize}
\item The cases \pcfsucc, \pcfpred, \pcfcond\ and numeral constants are straightforward.

\item Suppose $M = \Omega_o$ then $\travset(\Omega_o) = \prefset ( \{ \lambda \cdot \bot \} )$ therefore
$\travset(\Omega_o)^{\filter r} = \prefset( \{ \lambda \} )$
and $\sem{\Omega_o} = \prefset( \{ q \})$ with $\varphi(\lambda) =
q$. Hence $\sem{\Omega_o} = \varphi
(\travset(\Omega_o)^{\filter r})$.
\end{itemize}
(ii) is a direct consequence of (i) and the filtering lemma (lemma
\ref{lem:SIGMACONST:varphi_filter}). \vspace{10pt}

\noindent We now extend the result to \pcf. Let $M$ be a \pcf\ term,
we have:
\begin{align*}
\sem{M} &= \Union_{n\in\omega} \sem{M_n} & (\mbox{\cite{abramsky:game-semantics-tutorial}, lemma 16})\\
&= \Union_{n\in\omega} \travset^{\filter r}(\tau(M_n)) & (M_n \mbox{ is a $\pcf_1$ term}) \\
&= \travset^{\filter r}(\Union_{n\in\omega} \tau(M_n) ) & (\mbox{by continuity of $\travset^{\filter r}$, lemma \ref{lem:travred_continuous}}) \\
&= \travset^{\filter r}(\tau(M)) & (\mbox{by definition of } \tau(M)) \\
&= \travset^{\filter r}(M) & (\mbox{abbreviation}).
\end{align*}
\end{proof}

Hence by corollary \ref{cor:SIGMACONST:varphi_bij}, $\varphi$
defines a bijection from $\travset(M)^{\filter r}$ to
$\sem{M}$:
$$\varphi : \travset(M)^{\filter r} \stackrel{\cong}{\longrightarrow} \sem{M}.$$

\subsubsection{Example: \pcfsucc}

Consider the term $M = \pcfsucc\ 5$ whose computation tree is
represented below. The value-leaves are also represented on the
diagram, they are the vertices attached to their parent node with a
dashed line.
$$
\psmatrix[colsep=3ex,rowsep=2ex]
\lambda^0 \\
\pcfsucc & 0 & 1 & \ldots \\
\lambda^1 & 0 & 1 & \ldots \\
5 & 0 & 1 & \ldots \\
  & 0 & 1 & \ldots
\endpsmatrix
\ncline{1,1}{2,1} \ncline{2,1}{3,1} \ncline{3,1}{4,1}
\valueedge{1,1}{2,2} \valueedge{1,1}{2,3} \valueedge{1,1}{2,4}
\valueedge{2,1}{3,2} \valueedge{2,1}{3,3} \valueedge{2,1}{3,4}
\valueedge{3,1}{4,2} \valueedge{3,1}{4,3} \valueedge{3,1}{4,4}
\valueedge{4,1}{5,2} \valueedge{4,1}{5,3} \valueedge{4,1}{5,4}
$$

The following sequence of nodes is a traversal of $\tau(M)$:
$$ \Pstr[20pt]{ t = (l0){\lambda^0} \cdot (succ){\pcfsucc} \cdot (l1){\lambda^1} \cdot (c5){5} \cdot (v55-c5){5_5} \cdot (5l1-l1){5_{\lambda^1}} \cdot (6succ-succ){6_\pcfsucc} \cdot (6l0-l0,35){6_{\lambda^0}}}.
$$

The subsequences $t^*$ and $t \filter r$ are given by:
$$
\Pstr[17pt]{ t^* = (l0){\lambda^0} \cdot (l1-l0){\lambda^1} \cdot
(5l1-l1){5_{\lambda^1}} \cdot (6l0-l0){6_{\lambda^0}}.
\qquad  \mbox{ and } \qquad t
\filter r = (l0){\lambda^0} \cdot
(6l0-l0){6_{\lambda^0}}. }
$$
We have $\varphi(t^*) = q_0 \cdot q_5 \cdot 5_{q_5} \cdot 5_{q_0}$
and $\varphi(t\filter r) = q_0 \cdot 5_{q_0}$ where $q_0$
and $q_5$ denote the roots of two flat arenas over $\nat$. These two
sequences of moves correspond to some play of the interaction
semantics and the standard semantics respectively. The interaction
play is represented below:
$$\begin{array}{ccccc}
  \textbf{1} & \stackrel{5}{\multimap} & !\nat & \stackrel{\pcfsucc}{\multimap} & \nat \\
&&&&  \rnode{q0}{q_0} \\
&&  \rnode{q5}{q_5} \\
&&  \rnode{a5}{5_{q_5}} \\
&&&&  \rnode{a6}{6_{q_0}}
\end{array}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{a5}{q5}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=210]{->}{a6}{q0}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{q5}{q0}
$$

\subsubsection{Another example : \pcfcond}

Consider the term $M = \lambda x y . \pcfcond\ 1\ x\ y$. Its
computation tree is represented below (without the value-leaves):
    $$ \tree{\lambda x y}
       {
          \tree{\pcfcond}
          {
            \tree{\lambda^1}{ \TR{1} }
            \tree{\lambda^2}{ \TR{x} }
            \tree{\lambda^3}{ \TR{y} }
          }
      }
    $$
For any value $v \in\mathcal{D}$ the following sequence of nodes is
a traversal of $\tau(M)$:
$$\Pstr[27pt]{ t = (lxy){\lambda x y} \cdot (cond){\pcfcond} \cdot (l1-cond){\lambda^1} \cdot (1){1} \cdot (v11-1){1_1}
    \cdot (l3){\lambda^3} \cdot (y-vxy){y} \cdot (vy-y){v_y}  \cdot (vl3-l3){v_{\lambda^3}} \cdot (vcond-cond,30){v_{\pcfcond}}
    \cdot (vlxy-lxy,30){v_{\lambda x y}}.
}
$$
The subsequences $t^*$ and $t \filter r$ are given by:
$$
\Pstr[17pt]{ t^* =  t = (lxy){\lambda x y} \cdot
        (l1-lxy){\lambda^1} \cdot
        (l3-lxy){\lambda^3} \cdot
        (y-vxy){y} \cdot
        (vy-y){v_y}  \cdot
        (vl3-l3){v_{\lambda^3}} \cdot
        (vlxy-lxy,35){v_{\lambda x y}}
\qquad  \mbox{ and } \qquad t \filter r =
(lxy){\lambda x y} \cdot (y-vxy){y} \cdot (vy-y){v_y}
\cdot (vlxy-lxy){v_{\lambda x y}}.
}
$$
The sequence of moves $\varphi(t^*)$ corresponds to some play of the
interaction semantics and the sequence $\varphi(t\filter r)$
is a play of the standard semantics obtained by hiding the internal
moves of $\varphi(t^*)$. The interaction play $\varphi(t^*)$ is
represented below:
$$\begin{array}{ccccccccccc}
!\nat & \otimes & !\nat & \stackrel{ \langle \sem{1}, \pi_1,
\pi_2\rangle }{\multimap} & !\nat & \otimes & !\nat & \otimes &
!\nat
& \stackrel{ \pcfcond}{\multimap} & \nat \\
&&&&&&&&&&  \rnode{q0}{q_0^{(\lambda x y)}} \\
&&&&  \rnode{qa}{q_a^{(\lambda^1)}} \\
&&&&  \rnode{1}{1} \\
&&&&&&  \rnode{qb}{q_b^{(\lambda^2)}} \\
&&  \rnode{qy}{q_y^{(y)}} \\
&&  \rnode{vqy}{v_{q_y}} \\
&&&&&&  \rnode{vqb}{v_{q_b}} \\
&&&&&&&&&& \rnode{vq0}{v_{q_0}}
\end{array}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{vq0}{q0}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{vqb}{qb}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{vqy}{qy}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{qy}{qb}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=90,angleB=180]{->}{qb}{q0}
\nccurve[nodesepB=2pt,nodesepA=6pt,ncurv=0.9,angleA=180,angleB=180]{->}{1}{qa}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=90,angleB=180]{->}{qa}{q0}
$$


\subsubsection{Game characterisation of safe terms}

A difficulty arises because of the presence of the Y combinator :
computation trees of \pcf\ terms are potentially infinite. Despite
this particularity, lemma \ref{lem:safe_imp_incrbound} still holds
in the \pcf\ setting:
\begin{lemma} \label{lem:pcf_safe_imp_incrbound} If $M$ is a safe
PCF term then $\tau(M)$ is incrementally-bound.
\end{lemma}
\begin{proof}
Let $i$ denote the number of occurrences of the Y combinator in $M$.
We first prove by induction on $i$ that $M_k$ is safe for any $k\in
\omega$. \emph{Base case:} $i=0$ then $M_k = M$. \emph{Step case:}
$i>0$. Let $Y_A N$ be a subterm of $M$. Since $M$ is safe, $N$ is
also safe. The number of occurrences of the Y combinator in $N$ is
smaller than $i$ therefore by the induction hypothesis $N_k$ is
safe. Consequently the term $Y_A^k N_k = \underbrace{N_k ( \ldots (
N_k}_{k \mbox{ times}} \Omega ) \ldots )$ is also safe and by
compositionality so is $M_k$.

Clearly, lemma \ref{lem:safe_imp_incrbound}(i) is remains valid for infinite
$\pcf_1$ terms (the subterms of the form $\Omega$ are just represented by
the constant $\bot$ in the computation tree), thus since $M_k$
is a safe $\pcf_1$ term, $\tau(M_k)$ is incrementally-bound.
Now let $z$ be a variable node in $\tau(M) =
\Union_{k\in\omega} \tau(M_k)$. There exists $k\in \omega$ such
that $z$ belongs to $\tau(M_k) \sqsubseteq \tau(M)$.
If we write $r_k$ to denote the root of the tree $\tau(M_k)$ then the path $[r_k,z]$ in $\tau(M_k)$ is equal to the path $[r,z]$ in $\tau(M)$.
Hence, since the node $z$ is incrementally-bound in $\tau(M_k)$,
it is also incrementally-bound in $\tau(M)$.
\end{proof}


\begin{theorem}
Safe PCF terms are denoted by P-incrementally-justified strategies.
\end{theorem}
\begin{proof}
Let $M^{\infty}$ be the $\beta$-normal form of $M$ (i.e. the possibly infinite term obtained by reducing all the redexes in $M$). By lemma \ref{lem:ia_safety_preserved}, safety is preserved by small-step reduction therefore, by lemma \ref{lem:pcf_safe_imp_incrbound}, if $M$ is a \pcf\ term then $\tau(M^{\infty})$ is also
incrementally-bound.

Since condition (WB) is verified ({\it i.e.} \pcf\ constant rules
are well-behaved), Corollary \ref{cor:redtrav_trav} holds in the
safe \pcf\ setting. Thus proposition
\ref{prop:incrbound_imp_incrjustified}(i) remains valid in \pcf\ for
infinite computation trees: infinite terms in $\beta$-nf with an
incrementally-bound computation tree are denoted by
P-incrementally-justified strategies. Consequently,
$\sem{M^{\infty}}$ is P-incrementally-justified. By soundness of the
game denotation, $\sem{M^{\infty}} = \sem{M}$, thus $\sem{M}$ is
P-incrementally-justified.
\end{proof}

Consequently, P-pointers are superfluous in the game denotation of safe \pcf\ terms {\it i.e.} pointers emanating from P-moves are uniquely recoverable.

\subsection{Safe \ialgol}

We are now in a position to consider the full safe Idealized Algol
language. The general idea is the same as for safe \pcf, however
there are some difficulties caused by the presence of the two new
base types \iavar\ and \iacom. We just give indications on how to
adapt our framework to the particular case of safe \ialgol\ without
giving the complete proofs. However we believe that enough
indications are given to convince the reader that the argument used
in the \pcf\ case can be easily adapted to \ialgol.

\subsubsection{Computation DAG}
In \pcf, arenas have a single initial move, therefore they can be
regarded as trees. In \ialgol, on the other hand, the base type
\iavar\ is represented by the infinite product of games
$\iacom^{\nat} \times \iaexp$ which has an infinite number of
initial moves. In order to preserve the relationship established
between arenas and computation trees, we need to accommodate the
definition of computation tree to reflect this property. The
consequence is that in \ialgol, ``computation trees'' become
``computation directed acyclic graphs (DAG)'': a computation DAG may
have (possibly infinitely) many roots and two nodes of a given level
can share children at the next level.


We use the notations $\mathcal{D}_{\iaexp} = \nat$ and
$\mathcal{D}_{\iacom} = \{ \iadone \}$ to denote the set of value
leaves of type \iaexp\ and \iacom\ respectively. There are two types
of value-leaves in the computation DAG: the value-leaf \iadone\ of
type \iacom\ and the value-leaves labelled in $\mathcal{D}_{\iaexp}$
of type \iaexp.

Let $n$ be a node. If $\kappa(n)$ is of type $(A_1,\ldots A_n,B)$,
we call $B$ the \emph{return type of $n$}. The set of value-leaves
of a node $n$ is given by $\mathcal{D}_{\iaexp}$ if the return type
of $n$ is \iaexp, by $\mathcal{D}_{\iacom}$ if its return type is
\iacom, and by $\mathcal{D}_{\iaexp} \union \{ \iadone \}$ if its
return type is \iavar.


Table \ref{tab:ia_computationdag} shows the computation DAG for each
construct of \ialgol. The value-leaves are represented in the DAGs
using the following abbreviations:
$$ \tree{n}{ \TRV{\mathcal{D}_\iaexp} }  \quad \mbox{ for }\quad
 \tree{n}{ \TRV{0} \TRV{1} \TRV{2} \TRV{\ldots} }
 \qquad \mbox{ and } \qquad
 \tree{n}{ \TRV{\mathcal{D}_\iadone} }  \quad \mbox{ for }\quad
 \tree{n}{ \TRV{\iadone }}.
$$

A term of type \iavar\ has a computation DAG with an infinite number
of root $\lambda$-nodes. Suppose that $M$ is a term of type \iavar,
then the computation DAG for $\lambda \overline{\xi} . M$ is
obtained by relabelling the root $\lambda$-nodes $\lambda^r$,
$\lambda^{w_0}$, $\lambda^{w_1}$, $\lambda^{w_2}$, \ldots into
$\lambda^r \overline{\xi}$, $\lambda^{w_0} \overline{\xi}$,
$\lambda^{w_1} \overline{\xi}$, $\lambda^{w_2} \overline{\xi}$,
\ldots. For a term $M$  of type \iaexp\ or \iacom, the computation
DAG for $\lambda \overline{\xi} . M$ is computed in the same way as
in the safe $\lambda$-calculus.

\begin{table}
\begin{center}
\begin{tabular}{cc}
$M$ & $\tau(M)$ \\ \hline \hline \\
x $: A \in \{ \iacom, \iaexp \}$ &
    $\psmatrix[colsep=3ex,rowsep=2ex] \lambda \\ x & \mathcal{D}_A \\  & \mathcal{D}_A \endpsmatrix
    \ncline{1,1}{2,1} \valueedge{1,1}{2,2} \valueedge{2,1}{3,2} $
\\ \\
x : \iavar &
    $\psmatrix[colsep=3ex,rowsep=3ex]
    \lambda^r & \lambda^{w_0} & \lambda^{w_1}  & \lambda^{w_2} & \lambda^{w_{\ldots}} \\
    \mathcal{D}_\iaexp &  & x & & \iadone \\
    &  &  & \mathcal{D}_\iaexp & \iadone
    \endpsmatrix
    \ncline{1,1}{2,3} \ncline{1,2}{2,3} \ncline{1,3}{2,3} \ncline{1,4}{2,3} \ncline{1,5}{2,3}
    \valueedge{2,3}{3,4} \valueedge{2,3}{3,5}
    \valueedge{1,1}{2,1}
    \valueedge{1,5}{2,5} \valueedge{1,4}{2,5} \valueedge{1,3}{2,5} \valueedge{1,2}{2,5}
    $
\\ \\
\iaskip : \iacom &
    $\psmatrix[colsep=3ex,rowsep=3ex] \lambda \\ \iaskip & \iadone \\  & \iadone \endpsmatrix
    \ncline{1,1}{2,1} \valueedge{1,1}{2,2} \valueedge{2,1}{3,2} $
\\ \\
$\iaassign\ L\ N :\iacom$ &
    $\psmatrix[colsep=3ex,rowsep=3ex] & \lambda \\ & \iaassign & \iadone \\ \tau(N:\iaexp)  & \tau(L:\iavar) & \iadone \endpsmatrix
    \ncline{1,2}{2,2} \ncline{2,2}{3,2} \ncline{2,2}{3,1}
    \valueedge{1,2}{2,3} \valueedge{2,2}{3,3} $
\\ \\
$\iaderef\ L :\iaexp$ &
    $\psmatrix[colsep=3ex,rowsep=3ex] \lambda \\ \iaderef & \iadone \\ \tau(L:\iavar) & \iadone \endpsmatrix
    \ncline{1,1}{2,1} \ncline{2,1}{3,1} \valueedge{1,1}{2,2} \valueedge{2,1}{3,2} $
\\ \\
$\iaseq_{\iaexp}\ N_1\ N_2 :\iacom$ &
    $\psmatrix[colsep=3ex,rowsep=3ex] & \lambda \\ & \iaseq_{\iaexp} & \mathcal{D}_\iaexp \\ \tau(N_1:\iacom)  & \tau(N_2:\iaexp) & \iadone \endpsmatrix
    \ncline{1,2}{2,2} \ncline{2,2}{3,2} \ncline{2,2}{3,1}
    \valueedge{1,2}{2,3} \valueedge{2,2}{3,3} $
\\ \\
$\iamkvar\ N_w\ N_r :\iavar$ &
    $\psmatrix[colsep=3ex,rowsep=3ex]
    \lambda^r & \lambda^{w_0} & \lambda^{w_1}  & \lambda^{w_2} & \lambda^{w_{\ldots}} \\
    \mathcal{D}_\iaexp &  & \iamkvar & & \iadone \\
    & \tau(N_r) & \tau(N_w) & \mathcal{D}_\iaexp & \iadone
    \endpsmatrix
    \ncline{1,1}{2,3} \ncline{1,2}{2,3} \ncline{1,3}{2,3} \ncline{1,4}{2,3} \ncline{1,5}{2,3}
    \ncline{2,3}{3,2} \ncline{2,3}{3,3}
    \valueedge{2,3}{3,4} \valueedge{2,3}{3,5}
    \valueedge{1,1}{2,1}
    \valueedge{1,5}{2,5} \valueedge{1,4}{2,5} \valueedge{1,3}{2,5} \valueedge{1,2}{2,5}
    $
\\ \\
$\ianewin{x}\ N : A \in \{ \iacom, \iaexp \} $ &
   $\psmatrix[colsep=3ex,rowsep=3ex] \lambda \\ \ianewin{x} & \mathcal{D}_A \\ \tau(N:A) & \mathcal{D}_A \endpsmatrix
    \ncline{1,1}{2,1} \ncline{2,1}{3,1} \valueedge{1,1}{2,2} \valueedge{2,1}{3,2} $
\end{tabular}
\end{center}
  \caption{Computation DAGs for the constructs of \ialgol.}
  \label{tab:ia_computationdag}
\end{table}


\subsubsection{Traversals}
Let $p$ be a node and suppose that its $i$th child $n$ has the
return type \iavar. Then $n$ is in fact constituted of several
$\lambda$-nodes : $\lambda^r \overline{\xi}$, $\lambda^{w_0}
\overline{\xi}$, \ldots. From $p$'s point of view, these nodes are
referenced as follows: $i.r$ refers to $\lambda^r \overline{\xi}$
and  $i.w_k$ refers to $\lambda^{w_k} \overline{\xi}$ for $k \in
\omega$.

\begin{itemize}
\item \emph{The application rule}

There are two rules (app$_{\iaexp}$) and (app$_{\iacom}$)
corresponding to traversals ending with an @-node of return type
\iaexp\ and \iacom\ respectively. These rules are identical to the
rule \iaexp\ of section \ref{subsec:traversal}.

The application rule for $@$-nodes with return type \iavar\ is:
$$(\mbox{app}_{\iavar})
\rulef{ \Pstr{t \cdot (lHyp){\lambda^k \overline{\xi}} \cdot
(appHyp-lHyp,35:0){@} \in \travset }
 }{\Pstr[18pt] {t \cdot (l){\lambda^k
\overline{\xi}} \cdot (app-l,35:0){@} \cdot (l2-app,35:0.k){\lambda^k
\overline{\eta}} \in \travset }}
 \ k \in \{ r, w_0, w_1, \ldots \}
$$


\item \emph{Input-variable rules}

There are two rules (InputVar$^{\iaexp}$) and (InputVar$^{\iacom}$)
which are the counterparts of rule (InputVar$^0$) of section
\ref{subsec:traversal} and are defined identically.

Let $x$ be an input-variable of type \iavar:
$$ (\mbox{InputVar}^{\iavar})
\rulef{t \cdot \lambda^r \overline{\xi} \cdot x \in \travset}
    {t \cdot \lambda^r \overline{\xi} \cdot \rnode{x}{x} \cdot v_x \in \travset }
\hspace{2cm} (\mbox{InputVar}^{' \iavar}) \rulef{t \cdot
\lambda^{w_i} \overline{\xi} \cdot x \in \travset}
    {t \cdot \lambda^{w_i} \overline{\xi} \cdot \rnode{x}{x} \cdot \iadone_x \in \travset }
$$

\item \emph{IA constants rules}

The rules for \ianew\ are purely structural, they are defined the
same way as the rules (app$_{\iaexp}$), (app$_{\iacom}$) and
(app$_{\iadone}$).

The rules for \iaderef\ are:
$$(\mbox{deref}) \rulef{t \cdot \iaderef \in \travset}{\Pstr[15pt]{t \cdot (d){\iaderef} \cdot (n-d,35:1.r){n} \in \travset }}
 \hspace{1.6cm} (\mbox{deref'})
\rulef{t \cdot \iaderef \cdot n \cdot t_2 \cdot v_n \in \travset} {t
\cdot \iaderef \cdot n \cdot t_2 \cdot v_n \cdot v_{\iaderef}\in
\travset }
$$


The rules for \iaassign\ are:
$$(\mbox{assign}) \rulef{t \cdot \iaassign \in \travset}{\Pstr[15pt]{t \cdot (ass){\iaassign} \cdot (n-ass,35:1){n} \in \travset} }
\hspace{1.6cm}
(\mbox{assign'})
\rulef{t \cdot \iaassign \cdot n \cdot t_2 \cdot v_n \in
\travset} {\Pstr[18pt]{t \cdot (ass){\iaassign} \cdot (n){n} \cdot
t_2 \cdot v_n \cdot (m-ass,15:2.w_n){m} \in \travset } }
$$
$$(\mbox{assign''})  \rulef{\Pstr{t \cdot (assHyp){\iaassign} \cdot t_2 \cdot (mHyp-assHyp,35:2.w_k){m} \cdot t_3 \cdot \iadone_m \in \travset}}
{t \cdot \iaassign \cdot t_2 \cdot m \cdot t_3 \cdot \iadone_m \cdot
\iadone_{\iaassign} \in \travset }
$$

The rules for $\iaseq_{\iaexp}$ are:
$$(\mbox{seq}) \rulef{t \cdot \iaseq \in \travset}{\Pstr[13pt]{t \cdot (seq){\iaseq} \cdot (n-seq,35:1){n} \in \travset } }
\hspace{1.6cm} (\mbox{seq'})
\rulef{t \cdot \iaseq \cdot n \cdot t_2 \cdot v_n \in
\travset} {\Pstr[18pt]{ t \cdot (seq){\iaseq} \cdot (n){n} \cdot t_2
\cdot v_n \cdot (m-seq,25:2){m} \in \travset }}
$$
$$(\mbox{seq''})  \rulef{\Pstr{t \cdot (seqHyp){\iaseq} \cdot t_2 \cdot (mHyp-seqHyp,35:2){m} \cdot t_3 \cdot v_m \in \travset}}
{t \cdot \iaseq \cdot t_2 \cdot m \cdot t_3 \cdot v_m \cdot
v_{\iaseq} \in \travset }$$




The rules for \iamkvar\ are:
$$(\mbox{mkvar}_r) \rulef{t \cdot \lambda^r \overline{\xi} \cdot \iamkvar \in \travset}{\Pstr[14pt]{t \cdot \lambda^r \overline{\xi} \cdot (d){\iamkvar} \cdot (n-d,35:1){n} \in \travset} }
\hspace{1cm} (\mbox{mkvar}_r')
\rulef{t \cdot \iamkvar \cdot n \cdot t_2 \cdot v_n \in \travset} {t
\cdot \iamkvar \cdot n \cdot t_2 \cdot v_n \cdot v_{\iamkvar}\in
\travset } $$
$$(\mbox{mkvar}_w) \rulef{t \cdot \lambda^{w_k} \overline{\xi} \cdot \iamkvar \in \travset}{\Pstr[15pt]{t \cdot \lambda^{w_k} \overline{\xi} \cdot (mk){\iamkvar} \cdot (n-mk,35:2){n} \in \travset} }$$
$$ (\mbox{mkvar}_w'')  \rulef{t \cdot \lambda^{w_k} \overline{\xi} \cdot \iamkvar \cdot n \cdot t_2 \cdot \iadone_n \in \travset}
{t \cdot \lambda^{w_k} \overline{\xi} \cdot \iamkvar \cdot n \cdot
t_2 \cdot \iadone_n \cdot \iadone_{\iamkvar} \in \travset }
$$
These four rules are not sufficient to model the constant \iamkvar.
Indeed, consider the term $\iaassign\ (\iamkvar\ (\lambda x . M) N)
7$. The rule (\mbox{mkvar}$_w''$) permits to traverse the node
\iamkvar\ and to go on by traversing the computation tree of
$\lambda x . M$. The problem is that when traversing $\tau(M)$, if
we reach a variable $x$, we are not able to relate $x$ to the value
$7$ that is assigned to the variable.

To overcome this problem, we need to define traversal rules for
variable in such a way that a variable node bound by the second
child of a $\iamkvar$-node is treated differently from other
variables.

\item \emph{Variable rules}
Let $x$ be a non input-variable node. It either corresponds to a $\lambda$-abstracted variable or
a block-allocated variable declared by the $\ianewin{x}$ construct.

\begin{itemize}
\item Suppose that $x$ is $\lambda$-abstracted and let $\lambda \overline{x}$ be its binder.
In \ialgol, the only constant nodes of order greater than 1 is
\iamkvar, therefore there are two cases: $\lambda \overline{x}$ is
either the child of a node in $N_@ \union N_{\sf var}$ or it is the
second child of a \iamkvar-node.

To handle the first case, we define a rule similar to the (Var) rule
of section \ref{subsec:traversal} with some modification to take
into account variables $x$ of type \iavar (in which case $x$ has
multiple parent $\lambda$-nodes). We do not give the details here
but it is easy to see how to redefine this rule.

To handle the case where $\lambda \overline{x}$ is the child of a
\iamkvar-node, we define the following rule:
$$ (\mbox{Var}_{\iamkvar})  \rulef{t \cdot \lambda^{w_k} \overline{\xi} \cdot \iamkvar \cdot \lambda \overline{x} \cdot t_2 \cdot x \in \travset}
{t \cdot \lambda^{w_k} \overline{\xi} \cdot \iamkvar \cdot \lambda
\overline{x} \cdot t_2 \cdot x \cdot k_{x} \in \travset }
$$

\item Suppose that $x$ is block-allocated with $\ianewin{x}$.

We call \emph{overwrite of $x$ relatively to an occurrence of a} ``\ianewin{x}''\emph{-node}, any sequence of nodes of the form
$\Pstr[17pt]{(decl){\ianewin{x}}\cdot \ldots \cdot \lambda^{w_k}\overline{\xi} \cdot (x-decl,25){x}}$ for some $k\in \mathcal{D}_{\iaexp}$ and node $\lambda^{w_k}\overline{\xi}$ parent
of $x$.
$$(\mbox{Var}_w)
    \rulef{
        t \cdot \lambda^{w_k} \overline{\xi} \cdot x \in \travset
    }
    {   t \cdot \lambda^{w_k} \overline{\xi} \cdot x \cdot \iadone_x \in
        \travset
    },
$$

$$(\mbox{Var}_r)
    \rulef{
        \Pstr[17pt]{t_1 \cdot (decl){\ianewin{x}} \cdot t_2 \cdot \lambda^r \overline{\xi} \cdot (x-decl,25){x} \in \travset}
    }
    {   t_1 \cdot \ianewin{x} \cdot t_2 \cdot \lambda^r \overline{\xi}
        \cdot x \cdot 0_x \in \travset
    }
    \mbox{ if $t_2$ contains no overwrite of $x$},
$$

$$(\mbox{Var'}_r)
    \rulef{
        \Pstr[15pt]{
            t_1 \cdot (decl){\ianewin{x}} \cdot t_2 \cdot \lambda^r \overline{\xi} \cdot (x-decl,25){x} \in \travset
        }
    }
    {
        t_1 \cdot \ianewin{x} \cdot t_2 \cdot \lambda^r \overline{\xi} \cdot x \cdot k_x \in \travset
    }
    \mbox{ if $\lambda^{w_k} \cdot x$ is the last overwrite of $x$ in } t_2. $$
\end{itemize}
\end{itemize}

\subsubsection{Game semantics correspondence}
The properties that we proved for computation trees and traversals
of the safe $\lambda$-calculus with constants can easily be lifted
to computation DAGs of \ialgol. In particular:
\begin{itemize}
\item constant traversal rules are well-behaved;
\item P-view of traversals are paths in the computation DAG;
\item the P-view of the reduction of a traversal is the reduction of the P-view,
and the O-view of a traversal is the O-view of its reduction
(Proposition \ref{prop:trav_filtering});
\item there is a mapping from vertices of the computation DAG to moves in the interaction game semantics;
\item there is a correspondence between traversals of the computation tree and plays in interaction game semantics;
\item consequently, there is a correspondence between the standard game semantics and
the set of justified sequences of nodes $\travset^{\filter r}$.
\end{itemize}

\subsubsection{Game-semantic characterisation of safe terms}
Clearly, the computation DAG of a safe term is incrementally-bound.
By using the correspondence between traversals and plays, it is easy
to prove that incrementally-bound computation trees are denoted by
P-incrementally-justified strategies. Consequently, by lemma
\ref{lem:incrjustified_pointers_uniqu_recover}, P's pointers are superfluous in the
game semantics of safe \ialgol\ terms.

Since the game denotation of an \ialgol\ term is fully determined by
the set of complete plays, this pointer economy suggests that the
game denotation of a safe \ialgol\ can be represented in a compact
way. This raises the question of the decidability of observational
equivalence for safe \ialgol.
