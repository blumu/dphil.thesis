\section{Introduction}

The result we present in this paper concerns safety -- a
syntactic restriction introduced by Knapik \emph{et al.}
\cite{KNU01, KNU02}.  They define higher-order grammars as
generators of (possibly infinite) term trees. They show
that if a grammar is safe then the term
tree produced by the grammar enjoys a decidable monadic second
order (MSO) theory. Moreover, safety ensures that the term tree produced
can also be accepted by a higher-order pushdown automaton of the
same level, and vice versa. By providing two characterisations of a
new infinite hierarchy of infinite trees with decidable MSO theories,
their result pushes the frontier of decidability to new
boundaries. (This hierarchy actually coincides with a Caucal Hierarchy
of deterministic term trees \cite{Cau02}.) It is intriguing that
safety \emph{appears} to be key to such good algorithmic behaviour and
desirable properties. In particular it leaves us with two natural
open questions. First, is the restriction of safety essential for MSO
decidability? Secondly, does safety really reduce the generating power of a grammar?

As indicated by Knapik \emph{et al.}, it is interesting to note
that the restriction of safety has previously appeared in the
literature in another setting and under a different name. In the
earlier papers of \cite{Dam82, DG86} higher-order grammars and
higher-order pushdown automata were introduced not as definitional
devices for term trees, but as generators, respectively acceptors,
of string languages. Thus Damm defined an infinite hierarchy of languages,
called the OI-hierarchy, which some consider a more natural,
infinite alternative to the Chomsky Hierarchy \cite{Cho59}. Damm's
grammars are rewrite relations over expressions that are required to
be objects of ``derived types''. An analysis of
his definition reveals that the constraint of ``derived types" is
equivalent to the requirement that all types be \emph{homogeneous} and
the grammar be \emph{safe}, both in the sense of Knapik \emph{et al}. Assuming the grammar makes use of only homogeneous types (which all
definitions in the literature do), it follows that safety and
derived types are equivalent. From now on, we will only use the
term ``safe".

Damm and Goerdt went on to show that if a language is generated by a
safe grammar, then it can be accepted by a higher-order pushdown
automaton of the same level (and vice versa). Another
``good" property Damm illustrates of his safe grammars is that
each level of the hierarchy is a full AFL. However, to date, no
results exist for unsafe grammars. This is surprising -- but
perhaps less so as Damm's definition of a higher-order grammar was
such that the safety restriction was ``built-in" to it. However, in
this paper our definition of a string-language generating grammar will
follow Knapik \emph{et al.} in that we will allow for both safe and
unsafe grammars.

%Revitalised by Knapik \emph{et al.}'s questions and the increasing
%evidence that safety may be more than an ad-hoc restriction, we
%then pose the same question to the string-language setting. In
%particular, does safety really reduce the generating power of a
%(string-language generating) grammar? Not only is this an
%interesting language-theoretic question in its own right, but we
%believe this may also contribute to the understanding of what
%safety really means for both the string-language and term-tree
%setting.

This paper is concerned with the second of the open problems mentioned
at the end of the opening paragraph. We show that we can effectively
transform a level-$2$ grammar (whether safe or not) into a
(non-deterministic) level-2 pushdown automaton that accepts the same
language. Thus it follows from \cite{DG86} that every level-2 string
language that is generated by an unsafe grammar can also by generated
by a (level-2, non-deterministic) safe grammar. In this sense, we say that
safety is not a restriction at level $2$.  As a bonus, we then apply
our result to extract decidability results for level-$2$ unsafe
term-tree generating grammars.


%In \cite{Dam82} the OI-hierarchy was introduced. It is often
%perceived as a more natural, infinite, alternative to the Chomsky
%hierarchy of languages. The first three classes of the
%OI-hierarchy are the regular, context-free, and indexed languages
%(in the sense of \cite{Aho68}). Several characterisations of this
%hierarchy exist. We mention two: the higher-order grammars,
%subject to the restriction of \emph{derived types}, and the
%higher-order pushdown automata. It was shown \cite{DG86} that the
%language of a level-$n$ grammar subject to the restriction of
%derived types is accepted by a level-$n$ pushdown automaton and
%vice versa.
%
%This hierarchy has recently generated much interest due to results
%by Knapik, Niwinski and Urzyczyn \cite{KNU01, KNU02}. They
%re-introduce higher-order grammars and higher-order pushdown
%automata not as definitional devices for string languages, but as
%(respectively) generators and acceptors of term trees. In
%particular, they have shown that subject to a restriction known as
%\emph{safety}, a higher-order grammar generates a term tree with a
%decidable monadic second order theory. Furthermore, safe
%higher-order grammars are equivalent to higher-order pushdown
%automata of the same level, and vice versa.
%
%It is interesting to note that the safety restriction on
%higher-order grammars as introduced by \cite{KNU02} is similar to
%the restriction of derived types in \cite{Dam82}. This is not
%surprising considering the equivalence result for higher-order
%pushdown automata and the grammars using both sets of definitions.
%In fact, ``derived types" may be thought of as an instance of the
%safety restriction.
%
%A key open question, as recently posed by Knapik, Niwinski, and
%Urzyzczyn is whether safety is a proper restriction for
%higher-order grammars. In other words, can every tree generated by
%an unsafe higher-order grammar be generated by a safe higher-order
%grammar? This question is also unanswered in the language
%theoretic setting. However, in this paper we make a first step
%towards answering this question. In particular, we will show that
%for the language theoretic setting:
%\begin{theorem}
%If $G$ is a higher-order grammar at level $2$ that is not assumed
%to be safe, then there exists a non-deterministic level $2$
%pushdown automaton that accepts the same language. Moreover, the
%conversion from higher-order grammar to higher-order pushdown
%automaton is effective.
%\end{theorem}
%Combining this with the result on the equivalence between
%higher-order grammars and higher-order pushdown automata we then
%have:
%\begin{corollary}
%Safety is not a restriction at level $2$ for string languages.
%\end{corollary}

%Our proof of this result is decomposed into two transformations.  The
%first transformation shows that every level 2 grammar can be accepted
%by a machine we call the level 2 pushdown automaton with pointers
%(2PDAP). We then show that every 2PDAP can be simulated by a
%non-deterministic level 2 pushdown automaton.
%
%We will also introduce another intermediary device known as the
%pointer machine. This machine was originally introduced as an aid to
%understanding higher-order grammars as well as giving a possible
%intuitive implementation of such grammars. We make use of it in our
%proof, but we prove an additional result concerning containment in the
%context sensitive languages for $\epsilon$-free higher-order grammars
%(both safe and unsafe). We feel this is of interest because it is not
%yet clear where the OI-hierarchy (viewed in the language-theoretic
%sense) stands in relation to the context sensitive.

\subsection*{Related work}
In a recent preprint \cite{Blu04}, Blumensath has given the first
``pumping lemma'' for languages accepted by higher-order pushdown
automata. Following intricate surgeries on runs on an automaton, his
work gives conditions under which they can be ``pumped''. These
conditions are expressed in terms of the length of a given run and the
size of the stacks of each configuration.
