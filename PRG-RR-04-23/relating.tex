\section{Relating $n$PDAs and $n$-grammars}

\subsection{Known results}

Historically, the notion of safety has been key to relating
$n$PDAs and level-$n$ grammars. In particular, the following
results are due to Damm and Goerdt\footnote{In their paper, safety
is referred to as the restriction of derived types.}:

\begin{theorem} (Damm and Goerdt \cite{DG86}) If $G$ is a safe grammar of
level $n$, then $L(G)$ is accepted by an $n$PDA.
\end{theorem}

\begin{theorem} (Damm and Goerdt \cite{DG86}) If $L$ is the language
of an $n$PDA then it is generated by a level-$n$ safe grammar.
\end{theorem}

%The same results were subsequently proved by Knapik \emph{et al.}
%in \cite{KNU02} for their term-tree setting: a term-tree is
%accepted by an $n$PDA if and only if it is generated by a
%level-$n$ safe grammar.

However, to date, no results exist for \emph{unsafe} level-$n$
grammars. In particular, if $G$ is an unsafe level-$n$ grammar, it
is not known whether $L(G)$ is accepted by an $n$PDA, or perhaps a
PDA of another level. Thus, we believe that our result, which we
present in the following section, is a first step towards solving
this problem. We will show that at level $2$, every unsafe grammar
can be converted into a safe one that generates the same language.\\

%We should mention that our interest in questions conc was
%initially motivated by attempting to solve the safety problem in
%Knapik \emph{et al.}'s term-tree setting.

% Knapik \emph{et al.} \cite{KNU02} prove the same result in their
%term-tree setting: a term term tree is generated by a safe grammar
%of level $n$ if and only if it is accepted by an $n$PDA (for
%trees). Knapik \emph{et al.} go on to ask whether the same result
%applies to unsafe grammars. Although their question concerns their
%setting, we believe it is important to address this question for
%the string-language setting as well - as this is not something yet
%me
%
%This is the motivation for our result: although our result
%concerns the original setting for string languages (as opposed to
%term trees), we believe that it is a first step towards solving
%this question for both settings.

Before we give our result, however, we present a case study. Below
we introduce a deterministic but unsafe level-$2$ grammar that
generates a language $U$. We will show, via a ``bespoke'' proof,
that $U$ can be accepted by $2$PDA. This effort may seem redundant,
given that $U$ is exactly the type of language that is amenable to
our result. However, we believe there is much to be gained from
our case study:
\begin{itemize}
\item It is a non-trivial example of an unsafe grammar at the
lowest possible level (where safety becomes an issue), hence it is
interesting in its own right. \item It provides us with a good
idea as to the capabilities of a $2$PDA. \item Finally, and
perhaps most importantly, it lays the foundation for a conjecture
we will make in Section 7.
\end{itemize}

%It is interesting to note that both theorems were subsequently
%proved again by Knapik et al. in \cite{KNU02}. Their proofs were
%constructed to work in the term tree setting
%(\ref{rem:otherdefinitions}).
%
%
%However, a slight modification of their proofs also enables them
%to work in our string-language setting. In fact, virtually no
%modification of either proof in \cite{KNU02} is required - apart
%from taking into account the input alphabet, which is trivial. In
%fact, for our purposes it will be more convenient to use Knapik et
%al.'s proof as opposed to the one presented in Damm and Goerdt. In
%an effort to make this document relatively self-contained, we
%contain the modified proofs in the appendix.

% subsection: Urzyczyn's language

\subsection{An example: Urzyczyn's language} The
language $U$ consists of words of the form $w \, \ast^n$ where $w$
is a proper prefix of a well-bracketed word such that no prefix of
$w$ is a well-bracketed expression; each parenthesis in $w$ is
implicitly labelled with a number, and $n$ is the label of the
last parenthesis. The two labelling rules are:
\begin{itemize}
\item[I.] The label of the opening \hbox{\pq} is one; the label of any
subsequent \hbox{\pq} is that of the preceding \hbox{\pq} plus one.

\item[II.] The label of \hbox{\oa} is the label of the parenthesis that
precedes the matching \hbox{\pq}.
\end{itemize}
For example, the following are words in $U$
(together with their respective sequences of labels):
\begin{itemize}
\item[(i)]
\[\begin{array}{cccccccccccccccccccc}
\pq & \pq & \pq & \pq & \oa & \oa & \pq  & \pq & \oa & \pq & \pq & \oa & \oa & \oa & \pq & \pq  & \oa & \oa & \ast & \ast \\
1 & 2 & 3 & 4 & 3 & 2 & 5  & 6 & 5 & 7 & 8 & 7 & 5 & 2 & 9 & 10 & 9 & 2 &   &
\end{array}\]
\item[(ii)]
\[\begin{array}{cccccccccccccccccc}
\pq  & \pq & \pq & \pq & \oa & \oa & \pq & \pq & \oa & \pq & \pq & \oa & \oa & \ast &\ast &\ast &\ast &\ast\\
1 &  2 & 3 & 4 & 3 & 2 & 5 & 6 & 5 & 7 & 8 & 7 & 5 & \\
\end{array}\]
\end{itemize}
We first learnt of the language from \cite{Urz03}, wherein it was
conjectured that $U$ is inherently unsafe i.e.~not acceptable by
any higher-order PDA. This is in fact not the case. We shall first
give an unsafe 2-grammar that generates the language, and then
show that it is accepted by a safe (non-deterministic) $2$PDA.

\medskip

A way to compute the labels is to maintain a \emph{configuration},
which is either a triple $\anglebra{\gamma, y, z}$ such that
\begin{itemize}
\item $\gamma$ is a stack of future $\oa$-{labels} (written as a list
$x : \phi$ whose head $x$ is the top of the stack)

\item $y$ is the number of \hbox{\pq} read thus far

\item $z$ is the label of the last parenthesis read,
\end{itemize}
or a number, which is the number of remaining $\ast$ to be read. Note
that the length of $\gamma$ is equal to the number of as yet unmatched
$\pq$'s at that point. The transitions are as follows:
\[\begin{array}{rll}
\anglebra{x:\phi, y, z} & \larr{\pq} & \anglebra{z: x : \phi, y+1, y+1}\\
\anglebra{x:\phi, y, z} & \larr{\oa} & \anglebra{\phi, y, x}\\
\anglebra{x:\phi, y, z} & \larr{\ast} & z\\
z+1 & \larr{\ast} & z\\
\end{array}\]
By mimicking the transition system, we can define a
\emph{deterministic} (and unsafe) 2-grammar that generates $U$. We set
\[\begin{array}{rll}
\Sigma & = & \makeset{\pq , \oa , \ast }\\
N & = & \makeset{S: o, D : ((o, o, o), o, o, o, o), G : (o, o, o),
F : (o, o), E : o}
\end{array}\]
with production rules as follows:
\[\left\{\begin{array}{rll}
S & \larr{\pq} & D \, G \, E \, E \, E \\
D \, \phi \, x \, y \, z & \larr{\pq} & D \, (D \, \phi \, x) \, z \, (F \, y) \, (F \,  y)\\
D \, \phi \, x \, y \, z & \larr{\oa} & \phi \, y \, x \\
D \, \phi \, x \, y \, z & \larr{\ast} & z \\
F \, x & \larr{\ast} & x \\
E \, & \larr{\epsilon} & e
\end{array}\right.\]
Note that we have simply encoded the configuration $\anglebra{x :
\phi, y, z}$ as the term $D \, \phi \, x \, y \, z$, and
$\ast^{n+1}$ as $\underbrace{F( \cdots (F}_{n} E)$.

\subsubsection*{Unique decomposition of $U$-words}
Consider words over the alphabet $\makeset{\pq, \oa, \ast}$ composed
of three parts as follows
\[
\underbrace{\pq \cdots \pq \cdots \pq}_{(1)}
\;
\underbrace{\pq \cdots \oa \cdots \pq \cdots \oa}_{(2)}
\;
\underbrace{\ast \cdots \ast}_{(3)}
\]
\begin{itemize}
\item[{(1)}] is a prefix of a well-bracketed word such that no
prefix of it (including itself) is a well-bracketed word
\item[{(2)}] is a well-bracketed word \item[{(3)}] has length
equal to the number of $\pq$ in (1).
\end{itemize}
Call the collection of such words $V$. We claim that $U = V$. In the
preceding example, the first two parts of the 3-partition for (i) are
$\pq \, \pq$ and $\pq \, \pq \, \oa \, \oa \, \pq \, \pq \, \oa \, \pq
\, \pq \, \oa \, \oa \, \oa \, \pq \, \pq \, \oa \, \oa$; for (ii)
they are $\pq \, \pq \, \pq \, \pq \, \oa \, \oa \, \pq$ and $\pq \,
\oa \, \pq \, \pq \, \oa \, \oa $.

%As another example, let us take the following:
%\begin{verbatim}
%[  [  [  [  ]  ]  [  [  ]  [  [  ]  ]  ]  [  [  ]  * * * * * * * * *
%1  2  3  4  3  2  5  6  5  7  8  7  5  2  9  10 9
%\end{verbatim}
%then we have: $w = [\;[\;[\;[\;]\;]\;[\;[\;]\;[\;[\;]\;]\;]\;[, x_1 = [\;]$
%As a last example, let us take:
%\begin{verbatim}
%[  [  [  [  ]  ]  [  [  ]  [  [  ]  ]  * * * * *
%1  2  3  4  3  2  5  6  5  7  8  7  5
%\end{verbatim}
%then we have $w = [\;[\;[\;[\;]\;]\;[, x_1 = [\;], x_2 [\;[\;]\;]$\\
%%I'm pretty sure that the ``uniqueness" criteria stipulated in my
%%conjecture is correct.
%This division of a word in the language $U$ into the above format,
%is effective and easy to do: especially if one works ``backwards", i.e.
%starting from the right-hand side of the word (ignoring the stars).

%\begin{proposition} Let $y \in U$. Then there exists a unique
%decomposition of $y$ into $wx_1 \cdots x_m*^n$, such that $w$ is a
%proper prefix of a well-bracketed expression which ends in $[$ and
%such that $|w|_{[} = n$. Furthermore we have $m \geq 0$, and each
%$x_i$ is a well-bracketed expression.
%\end{proposition}

\begin{proposition}\label{prop:decompu} Let $y \in \{\pq, \oa, *\}^*$. Then $y \in U$ if
an only if it has a unique decomposition into $wx*^n$ where $w$, $x$, $n$ satisfy
conditions (1),(2),(3) above respectively.
\end{proposition}

\begin{proof}For convenience, given a word $w \in \Sigma^*$ and $a \in \Sigma$, we
denote by $|w|_a$ the number of occurrences of $a$ in $w$.
\begin{itemize}
\item[${\Rightarrow}:$]  First let us show \emph{existence} of such a
decomposition for $y \in U$. We perform a case analysis.
\begin{enumerate}
\item[(i).] Suppose $y = z\pq *^k$. Then, we simply take $w =
z\pq$, and clearly $|w|_{\pq} = k$ as required. \item[(ii).]
Suppose instead that $y = z\oa *^k$. We give an algorithm which
will decompose $y$ correctly. Clearly, the final $\oa$ must have a
matching $\pq$, say it is the following: $y = z_1 \pq z_2 \oa *^k$
where $\pq z_2\oa$ must be a well-bracketed expression. We know
that $k$ is the label of the final $\oa$. We also know that the
label of the final $\oa$ is the label of the parenthesis which
precedes the matching $\pq $. Now, if $z_1$ has final parenthesis
$\pq$, then we are done as we set $w = z_1$ and $x = \pq z_2 \oa$.

%\begin{eqnarray}
%\nonumber w & = & z_3 \pq \\
%\nonumber x_1 & = & \pq  z_2 \oa
%\end{eqnarray}
If, on the other hand, $z_1$ has final parenthesis $\oa$, then we
repeat this process again as $z_1 = z_3 \pq z_4 \oa$. It is
obvious that this process terminates. Note that if this process
requires $n$ iterations, then $x = \pq z_{2n} \oa \cdots \pq z_4
\oa \pq z_2 \oa$ and $w = z_{2n-1}$.
\end{enumerate}
To show \emph{uniqueness}, suppose that $y \in U$ has two
decompositions: $wx *^k$ and $w' x' *^k$. It suffices to observe
that these decompositions are distinct if and only if $w \not =
w'$. However, note that $|w|_{\pq } = k = |w'|_{\pq }$. Thus, it
must be the case that either $w$ or $w'$ violates the condition
that they must end in a $\pq $.

\item[$\Leftarrow$:]
Again, we perform a case analysis.
\begin{enumerate}
\item[(i).] Suppose that $m=0$. This is obviously true.
\item[(ii).] Suppose that $m>0$ and let $y = w x *^n$. Clearly
$wx$ is the proper prefix of a well-bracketed
expression.

Note that $x = x_1 \cdots x_m$ for some $m \geq 0$, where each
$x_i = \pq  z_i \oa$ and each $z_i$ is well-bracketed. Thus we have $y = w \pq_1 z_1\oa_1 \cdots
\pq_m z_m\oa_m *^n$. Parentheses have been labelled for
demonstrative purposes. For $y$ to be in $U$ the number of stars,
$n$, should be the the label of the parenthesis $\oa_m$. We show
this is indeed the case. The label of $\oa_m$ should be equal to
the label of the parenthesis preceding $\pq_m$, which in this case
would be $\oa_{m-1}$. Continuing in this way, we see that the
label of $\oa_m$ is the label of the last parenthesis of $w$,
which is always a $\pq $, hence, it is the number $|w|_{\pq }$.
\end{enumerate}
\end{itemize}
\end{proof}

\subsubsection*{Constructing a $2$PDA that accepts $U$}

So, how do we construct a $2$PDA that accepts $U$? Let $y$ be the
input. Let us reuse the notation from Proposition \ref{prop:decompu},
so each word in $U$ has a unique decomposition into the form $wx*^n$. The $2$PDA guesses what prefix of $y$ constitutes $w$ - say
it is the first $k$ characters. As it reads the first $k$ symbols
it acts like a $1$PDA checking that $w$ is indeed a prefix of a
well-bracketed word such that no prefix of it is well-bracketed.
However, at the same time we need it to keep track of the number
of $\pq$'s read. In order to do this dual job we need the power of
the $2$PDA. Essentially, the topmost $1$-store behaves like the
stack of a normal PDA which checks for a (proper prefix of a)
well-bracketed word. However, each time we find a $\pq$ we do both
a $\push_1$ and a $\push_2$. Each time we find a $\oa$, we do only
a $\pop_1$. Thus, the number of $1$-stores is the number of
$\pq$'s read in $w$. If it turns out that the first $k$ characters
of the input $y$ do not satisfy the criteria for what $w$ should
be, we immediately reject. Otherwise, we enter phase 2 of the
operation. In phase 2 we check that the next portion of the string, $x$, is
well-bracketed (for this we only need the power of a $1$PDA),
until we come across the first $\ast$. If $x$ was indeed
well-bracketed we proceed to phase $3$, otherwise we abort. In phase
$3$, we perform a $\pop_2$ for each $\ast$ we meet. If we end up with
an empty $2$-store after reading the all the $\ast$'s, we accept. Otherwise, reject.

%\subsubsection*{Example} Using the \emph{last} example on the
%previous page:%

%Phase I: guessing w, and checking it is valid:%

%\begin{verbatim}
%1.[0][S] (initial configuration, here we assume the machine does some "precomputing")
%2.read [, [X0][S]
%3.read [, [XX0][X0][S]
%4.read [, [XXX0][XX0][X0][S]
%5.read [, [XXXX0][XXX0][XX0][X0][S]
%6.read ], [XXX0][XXX0][XX0][X0][S]
%7.read ], [XX0][XXX0][XX0][X0][S]
%8.read [, [XXX0][XX0][XXX0][XX0][X0][S]
%\end{verbatim}
%Now, as the topmost 1-store has never read a $0$ as the topmost
%symbol throughout this computation, and the final config has at
%least one $X$, then we can be sure that what we have read is a
%proper prefix of a well-bracketed expression. Furthermore, we have
%counted the number of ['s read -  i.e. the number of 2-stores
%(other than S).

%Phase II: check the remainder of the expression is valid

%\begin{verbatim}
%9.  silent,  [P][XXX0][XX0][XXX0][XX0][X0][S]
%10. read [,  [XP][XXX0][XX0][XXX0][XX0][X0][S]
%11. read ],  [P][XXX0][XX0][XXX0][XX0][X0][S]
%12. read [,  [XP][XXX0][XX0][XXX0][XX0][X0][S]
%13. read [,  [XXP][XXX0][XX0][XXX0][XX0][X0][S]
%14. read ],  [XP][XXX0][XX0][XXX0][XX0][X0][S]
%15. read ],  [P][XXX0][XX0][XXX0][XX0][X0][S]
%16. read *,  ...
%\end{verbatim}
%As the topmost symbol upon reading the first $*$ is a $P$, and as
%we have never tried to pop a $P$, we know that what we have read
%was a well-bracketed expression. We now are left with the task of
%counting off the stars. We have seen one so far.

%\begin{verbatim}
%17. silent, [XX0][XXX0][XX0][X0][S]
%18. read *, [XXX0][XX0][Xo][S]
%19. read *, [XX0][X0][S]
%20. read *, [X0][S]
%21. read *, [S]
%\end{verbatim}

%If there are any more stars (or any symbols on the input tape),
%reject, otherwise, accept.

%Now the above was, of course, an accepting computation. However,
%had we chosen $w$ incorrectly, the input would have been rejected,
%as the Phase II operation would result in a non-well bracketed
%expression.
