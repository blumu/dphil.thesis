\section{Simulating $2$PMs by $2$PDALs}

\subsection{Understanding KNU's proof}

In \cite{KNU02} it was shown that a term tree generated by a safe
grammar of level $n$ is accepted by a pushdown automata of the
same level. Their proof, which given a grammar $G$ constructs a
corresponding pushdown automaton, can easily be adapted to work in
the string-language setting: all one needs to do is incorporate
the input alphabet. Recall, however, that this result for the
string-language setting was proved earlier by Damm and Goerdt
\cite{DG86}. Here we present an adaption of the proof in \cite{KNU02},
specialised to (level $2$) string languages.

\begin{theorem} Let $G$ be a $2$-grammar that generates a string
language. Then $L(G)$ is accepted by some $2$PDA.
\end{theorem}

\begin{proof}
We use the same setup as in Section 5.2 of \cite{KNU02}, but now we
incorporate an input string over the alphabet $\Sigma$. Recall that
there are 6 cases for the transition function; they are given in
Fig.~\ref{fig:KNU}.
\end{proof}

\begin{figure*}[t]
\begin{center}
\makebox{
\begin{shadowbox}[16cm]
\begin{eqnarray}
(q_0, a, {Dt_1 \cdots t_n}) & \rightarrow & (q_0,
\push_1(E)) \mbox{ if $Dx_1 \cdots x_n \larr{a} E$ }\\
(q_0, \epsilon, e)& \rightarrow &
accept\\
(q_0, \epsilon, {x_j})& \rightarrow & (q_j, \pop_1) \mbox{ if $x_j: o$}\\
(q_0, \epsilon, {x_j t_1 \cdots t_n}) & \rightarrow & (q_j, \push_2 \compose \pop_1) \mbox{ if $x_j$ has level $> 0$}\\
{1< j \leq n,} (q_j, \epsilon, {\$t_1 \cdots t_n}) & \rightarrow & (q_0, \pop_1 \compose {\push_1 (t_j)})\\
{j > n,} (q_j, \epsilon, {\$t_1 \cdots t_n}) & \rightarrow & (q_{j-n}, \pop_2)\\
\nonumber
\end{eqnarray}
\end{shadowbox}}
\caption{Adapted transition rules from \cite{KNU02}\label{fig:KNU}}
\end{center}
\noindent\emph{Convention.} In the Figure $x_j$ means the $j$-th
formal parameter of the relevant non-terminal.
\end{figure*}

Let us examine why their proof fails if we attempt to apply it
(blindly) to a level-$2$ unsafe grammar. As an example, we
consider the grammar given in Example~\ref{ex:ex1}. Recall that
the word $h_1h_3h_2f_1a$ is \emph{not} in the language.

The automaton starts off in the configuration $(q_0, h_1h_3h_2f_1a,
\mkstore{\mkstore{S}})$, after a few steps we reach the following configuration:
\begin{eqnarray}
\nonumber (q_0, & h_2f_1a, & \mkstore{\mkstore{\varphi B, D(D \varphi x) y (\varphi y), DGAB,S}})
\end{eqnarray}
As the topmost item, $\varphi B$, is headed by an level-$1$
variable, we need to find out what $\varphi$ is in order to
proceed. Note that $\varphi$ is the $1$st formal parameter of the
preceding item: $ D (D \varphi x) y (\varphi y)$, i.e., it refers
to $D \varphi x$. To this end, we perform a $\push_2$ and then
perform a $\pop_1$, and replace the topmost item with $D \varphi
x$. In other words, we have applied rule $4$ followed by rule $5$
to arrive at:
\begin{eqnarray}
\nonumber (q_0, & h_2f_1a, & \hbox{\tt [}\mkstore{\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & & \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})
\end{eqnarray}
Here we have labelled two store items, one with a $1-$ and the
other with a $1+$. These labels are not part of the store
alphabet, they have been added for our benefit: so that we may
identify these two store items later on.

The crux behind their construction is the following. Suppose we
meet the item $\mklink{D\varphi x}{1-}$ later on in the
computation, and suppose that we would like to request its third
argument, meaning we would be in state $q_3$. Note, however, that
$\mklink{D \varphi x}{1-}$ has only 2 arguments. The missing
argument can be found by visiting the item $\mklink{\varphi
B}{1+}$. Hence the labelling. We need to ensure that there is a
systematic way to get from $\mklink{D \varphi x}{1-}$ to
$\mklink{\varphi B}{1+}$ whenever we are in a state $q_n$ for $n >
2$ and we have $\mklink{D \varphi x}{1-}$ as our topmost symbol.
This systematic way suggested by \cite{KNU02} is embodied by rule
$6$ of Fig.~\ref{fig:KNU}. In particular, it says that all we need
to do is perform a $\pop_2$, followed by a change in state to
$q_{n-2}$, and to repeat if necessary. Note that if we applied
rule $6$ to the current configuration, we would indeed be brought
to the right place, $\mklink{\varphi B}{1+}$. We will see,
however, that with an unsafe grammar, this invariant may be
violated.

After a few more steps of the $2$PDA we will arrive at another
configuration where the topmost symbol is headed by a level-$1$
variable:

\begin{eqnarray}
\nonumber (q_0, & f_1a, & \hbox{\tt [}\mkstore{\varphi x,H (F y) x,\mklink{(D
\varphi x)}{1-}, DGAB, S}, \\
\nonumber & &\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})
\end{eqnarray}
Therefore, we next get:
\begin{eqnarray}
\nonumber (q_0, & f_1a, &  \hbox{\tt [}\mkstore{\mklink{F y}{2-}, \mklink{(D
\varphi x)}{1-}, DGAB, S},\\
\nonumber  & &\mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & &\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})
\end{eqnarray}

Again we have labelled a new pair of store items, so that the same
principle applies: if we want the missing argument of $\mklink{F
y}{2-}$, then we will be able to find it at $\mklink{\varphi
x}{2+}$. The next configuration is now:

\begin{eqnarray}
\nonumber (q_0, & a, &  \hbox{\tt [}\mkstore{x,\mklink{F y}{2-}, \mklink{(D \varphi
x)}{1-}, DGAB, S}, \\
\nonumber & & \mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & & \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})\\
\nonumber \rightarrow (q_1, & a, &  \hbox{\tt [}\mkstore{\mklink{F y}{2-}, \mklink{(D \varphi
x)}{1-}, DGAB, S}, \\
\nonumber & & \mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & & \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})\\
\nonumber \rightarrow (q_0, & a, &  \hbox{\tt [}\mkstore{y, \mklink{(D \varphi
x)}{1-}, DGAB, S}, \\
\nonumber & & \mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & & \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})
\end{eqnarray}

However, at this point $y$ is the $3$rd argument of the preceding
item $\mklink{(D \varphi x)}{1-}$, therefore, we have:

\begin{eqnarray}
\nonumber (q_3, & a, & \hbox{\tt [}\mkstore{\mklink{(D \varphi x)}{1-}, DGAB, S}, \\
\nonumber & & \mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & &\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})
\end{eqnarray}

By rule $6$ we arrive at: (in the following $\rightarrow_n$ means
$n$ steps of $\rightarrow$)
\begin{eqnarray}
\nonumber (q_1, & a, & \hbox{\tt [}\mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & & \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi y),
DGAB,S}\hbox{\tt ]} )\\
\nonumber \rightarrow_1  (q_0, & a, & \hbox{\tt [}
\mkstore{x,H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber && \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi y),
DGAB,S} \hbox{\tt ]})\\
\nonumber \rightarrow_1 (q_2, & a, &\hbox{\tt [}\mkstore{H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & &\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})\\
\nonumber \rightarrow_2 (q_2, & a, & \hbox{\tt [}\mkstore{\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber & &\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]}
)\\
\nonumber \rightarrow_2 (q_2, & a, & \hbox{\tt [}\mkstore{DGAB, S},\\
\nonumber && \mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]}
)\\
\nonumber \rightarrow_2 (q_0, & \epsilon, & \hbox{\tt [}\mkstore{e, S},\\
\nonumber &&\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]}
)
\end{eqnarray}
Note that we have accepted $h_1h_3h_2f_1a$ which is incorrect! Their
construction only works under the assumption that the grammar is
safe. However, the labels we have used lead us to the construction of
a machine which can remedy this problem.

\subsection{$2$PDAL: $2$PDA with links}

Let us suppose that the labels used in the above example $1+, 1-,
2+, \cdots$ were actually part of the alphabet. This would, in
general, lead to an infinite alphabet, but let us ignore the
finiteness requirement for now. Provided that each time we create
a new pair of labels (the $+$ and $-$ part), we ensure they are
unique, then these labels provide a way of always jumping to the
correct $1$-store when we are looking for missing arguments. Why?
Because each time we want the missing argument of an item labelled
with $n-$, we would simply perform as many $\pop_2$'s as necessary
until our topmost symbol was labelled with the corresponding $n+$!
To see how this would work, let us backtrack to the following
configuration in the above example:

\begin{eqnarray}
\nonumber (q_3, & a, &  \hbox{\tt [}\mkstore{\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber && \mkstore{\mklink{\varphi x}{2+},H (F y) x,\mklink{(D \varphi x)}{1-}, DGAB, S},\\
\nonumber &&\mkstore{\mklink{\varphi B}{1+}, D (D \varphi x) y (\varphi
y), DGAB,S}\hbox{\tt ]})
\end{eqnarray}

Applying the rule we have just said, we will keep performing a $\pop_2$ until we find a corresponding $1+$. This brings us to:
\begin{eqnarray}
\nonumber (q_1, & a, &  \mkstore{\mkstore{\mklink{\varphi B}{1+}, D (D
\varphi x) y (\varphi y), DGAB}})\\
\nonumber \rightarrow_1 (q_0, & a, &\mkstore{\mkstore{B , D (D
\varphi x) y (\varphi y), DGAB}} )
\end{eqnarray}
which is indeed what we wanted, and the word is rejected, as the
only rule for $B$ is $B \larr{b} e$. In fact, using the same
computation, but on the word $h_1h_3h_2f_1b$ we end up in an
accepting state.\\

Thus, for the remainder of this section, we afford ourselves the
luxury of this embellished $2$PDA, which we call $2$PDA with links, or
simply $2$PDAL. It is a $2$PDA as defined earlier, but we allow
ourselves to adorn items with matching labels, as we have done in the
previous example. We work under the assumption that each time we
create a new pair of labels they are ``fresh" and unique.

\subsection{Formal definition of $2$PDAL}

Formally each item of a $2$PDAL will now be embellished with
labels from the set
\[
\{n{+} : n \geq 1 \} \cup \{n{-} : n \geq 1 \}
\]
It is possible for an item to have zero, one or two labels -- no
other possibilities exist. We write labels as superscripts, as in
$\mklink{a}{}$ (or simply $a$), $\mklink{a}{3+}$ and
$\mklink{a}{3+, 4-}$. These superscripts are sets of at most two
elements, ranged over by $\lambda$; thus we have ${\langle 3+
\rangle} \cup {\langle 4- \rangle} = \langle 3+, 4- \rangle =
\langle 4-, 3+\rangle$. We shall see that in the case where an
item has two labels, one of these will always be a $+$ and the
other a $-$.\\

These labels come in matching pairs; we will see that if there is
an item labelled by $m-$ then there will be one labelled by $m+$
(although the converse is not necessarily true).  Thus, if one
item is labelled by $m-$ and another is labelled by $m+$, this
pair will be referred to an \textbfit{instance} of the
\textbfit{link} $m$. Each link $m$ may have several instances,
i.e.~several such pairs. For such a given pair, the item which
gains the $-$ part will be called the \textbfit{start point},
whereas that which receives the corresponding $+$ part, the
\textbfit{end point}. This terminology should coincide with
intuition.

%Thus, one may take as the
%formal definition of a link $m$ the set of pairs:
%\begin{equation}
%\nonumber \{(s,t) : \mbox{$s$ has label $m-$ and $t$ has label
%$m+$}\}
%\end{equation}
%where $s$ and $t$ refer to the positions of items in the stack.
%Furthermore, an instance of a link $m$ is an element of the above set.\\

In addition to the usual operations of a $2$PDA, a $2$PDAL has an
iterated form of $\pop_2$, parameterised over links $m$, defined
as follows: for $s$ ranging over 2-stores
\begin{eqnarray}
\nonumber \pop_2(m) \, s & = & \left \{
\begin{array}{ll}
s & \mbox{if $\mytop_1(s)$ has label $m+$}\\
\pop_2(m)(\pop_2(s)) & \mbox{otherwise}
%\pop_2(m) \compose \pop_2(s) & \mbox{otherwise.}
\end{array}
\right .
\end{eqnarray}
For convenience we write $\repl_1(a)$ as a shorthand for $\pop_1
\compose \push_1(a)$ i.e.~replacing the $\mytop_1$ item by $a$. \\

Given a 2-grammar $G$, which is not assumed to be safe,
transitions of the corresponding $2$PDAL, written $2PDAL_G$, are
defined by induction over the set of rules in Fig.~\ref{fig:pdal}.
The store alphabet is a subset of the (finite) set of all
subexpressions of the right hand sides of the productions in $G$.
We assume that each production rule of the grammar assumes the
following format:
\begin{equation}
\label{convention} F \varphi_1 \cdots \varphi_m x_{m+1} \cdots x_{m+n} \larr{a} E
\end{equation}
where the $\varphi$'s are used for level-$1$ parameters, and the
$x$'s are used for level-$0$ parameters.  Also note that, in
Fig.~\ref{fig:pdal}, $\$$ is a place holder for either a
non-terminal or variable. As in \cite{KNU02}, the automaton works
in phases beginning and ending in distinguished states $q_i$, with
some auxiliary states in between. We assume, for the sake of
clarity, that these auxiliary states are disjoint from $\{q_i : 0
\leq i \leq m\}$, where $m$ is the maximum of the arities of any
non-terminal or variable occurring in the grammar. If a
non-terminal or a variable has type $A_1 \rightarrow \cdots \rightarrow A_n
\rightarrow o$, then it is said to have arity $n$. Thus, when we
refer to a state $q_i$, it is \emph{not} an auxiliary state.

\begin{figure*}[t]
\begin{center}
\makebox{
\begin{shadowbox}[16.5cm]
\[\begin{array}{rllr}
(q_0, a, {Dt_1 \cdots t_n}^{\lambda}) & \rightarrow & (q_0, \push_1(E)) \mbox{ if $Dx_1 \cdots x_n \larr{a} E$ } & \rm{(1)}\\
(q_0, \epsilon ,e )& \rightarrow & accept & \rm{(2)}\\
(q_0, \epsilon ,{x_j})& \rightarrow & (q_j, \pop_1) & \rm{(3)}\\
(q_0, \epsilon, {\varphi_j t_1 \cdots t_n}^{\lambda}) &
\rightarrow & (q_0, \repl_1( {\varphi_j t_1 \cdots t_n}^{\lambda
\cup \anglebra{m+}})\compose \push_2 \compose \pop_1
\compose \repl_1(\mklink{s_j}{m-}))\\
& & \hbox{where $m$ is fresh and ${D s_1 \cdots
s_{n'}}^{\lambda'}$ precedes ${\varphi_j t_1 \cdots
t_n}^\lambda$.} & \rm{(4)}\\
1 \leq j \leq n, (q_j, \epsilon, {\$t_1 \cdots t_n}^\lambda) & \rightarrow & (q_0, \repl_1(t_j)) & \rm{(5)}\\
j > n, (q_j, \epsilon, {\$t_1 \cdots t_n}^\lambda) & \rightarrow &
(q_{j-n}, \pop_2(m)) \mbox{ if $m- \in \lambda$}& \rm{(6)}\\
\end{array}\]
\end{shadowbox}}
\end{center}
\caption{Transition rules of the $2$PDAL, $2PDAL_G$.
\label{fig:pdal}}
\end{figure*}

%\begin{figure*}[t]
%\begin{center}
%\makebox{
%\begin{shadowbox}[15cm]
%\[\begin{array}{rll}
%(q_0, a, {Dt_1 \cdots t_n}^{\lambda}) & \rightarrow & (q_0, \push_1(E)) \mbox{ if $Dx_1 \cdots x_n \larr{a} E$ }\\
%(q_0, \epsilon ,e )& \rightarrow & accept\\
%(q_0, \epsilon ,{x_j})& \rightarrow & (q_j, \pop_1)\\
%(q_0, \epsilon, {\varphi_j t_1 \cdots t_n}^{\lambda}) &
%\rightarrow & (q_0, \repl_1( {\varphi_j t_1 \cdots t_n}^{\lambda
%\cup \anglebra{m+}})\compose \push_2 \compose \pop_1
%\compose \repl_1(\mklink{s_j}{m-}))\\
%& & \hbox{where $m$ is fresh and ${D s_1 \cdots
%s_{n'}}^{\lambda'}$ precedes ${\varphi_j t_1 \cdots
%t_n}^\lambda$.}\\
%j \geq 1, (q_j, {\$t_1 \cdots t_n}^\lambda) & \rightarrow &
%\left \{ \begin{array}{ll} (q_0, \repl_1(t_j)) & \mbox{if } j \leq n\\
%(q_{j-n}, \epsilon, \pop_2(m)) & \mbox{if $j > n$ and $m{-} \in
%\lambda$}
%\end{array} \right .\\
%\end{array}\]
%\end{shadowbox}}
%\end{center}
%\caption{Transition rules of the $2$PDAL, $2PDAL_G$. \label{fig:pdal}}
%\end{figure*}

\subsection{Proof of correctness}

\begin{theorem}\label{labels}The language generated by a (possibly unsafe)
$2$-grammar is accepted by $2PDAL_G$.
\end{theorem}

\begin{remark} We believe this theorem can be extended to unsafe
grammars of all levels, but we do not prove this here.
\end{remark}

First, some notation. Let $s$ be a 2-store. We define
\[\begin{array}{rll}
s' \sqsubseteq s & \iff & \hbox{$s'$ is obtained from $s$
by performing zero or more $\pop_1$'s and $\pop_2$'s} \\
s' \sqsubseteq_i s & \iff & \hbox{$s'\sqsubseteq s$ and the final action
is a $\pop_1$ (hence the ``$i$'' for internal)}\\
s' \sqsubseteq_1 s & \iff & \hbox{$s' =
\pop_1^n(s)$ for some $n > 0$}\\
s' \sqsubseteq_2 s & \iff & \hbox{$s' = \pop_2^n(s)$ for some $n > 0$.}
\end{array}\]

We define a function $pm$ that transforms a $2$-store of $2PDAL_G$
to an equivalent stack of a $2$PM as follows:
\[\begin{array}{rlll}
pm(s) & = &
\left \{
\begin{array}{ll}
{\mkstore{S}} & \mbox{if } \mytop_1(s) = S\\
\mytop_1(s)_{pm(\pop_1(s))} : pm(\pop_1(s)) & \mbox{elseif } \mytop_1(s) : o\\
join({\mytop_1(s)_{pm(\pop_1(s))}}, split(pm(\pop_2(m)s))) &
\hbox{elseif $\mytop_1(s)$ has label $m{-}$}\\

\end{array}
\right .\\
\end{array}\]
where the auxiliary functions $split$ and $join$ are defined as
follows: where $t$ ranges over 2PM stacks
\[\begin{array}{rlll}
split(t) & = & (\anglebra{u_1, \cdots, u_r}, {\sf tail}(t)) &
\hbox{where ${\sf head}(t) = \varphi u_1 \cdots u_r$} \\
join(\theta, (\anglebra{u_1, \cdots, u_r}, t)) & = & (\theta . u_1
\cdots u_r) \; : \; t \\
\end{array}\]
(Note: The case of $r = 0$ never arises.)

%\begin{example}Here is an example.

%\begin{eqnarray}
%\nonumber q_0, & & [\;x, H\varphi y, \mklink{D\varphi x }{1-}, Dgab, S]\\
%\nonumber       && [\;\mklink{\varphi a }{3+}, \mklink{(L\varphi) }{2-}, K(fx)x, H\varphi y, \mklink{D\varphi x }{1-}, Dgab, S]\\
%\nonumber       && [\;\mklink{\varphi d }{2+},M\varphi x,J(L\varphi)x,K(fx)x, H\varphi y, \mklink{D\varphi x }{1-}, Dgab, S]\\
%\nonumber       && [\;\mklink{\varphi c }{1+}, D(D\varphi x)ab, Dgab, S]
%\end{eqnarray}
%applying $pm$ to the above 2-store gives us:
%\begin{equation}
%[x_{p_1}, H\varphi y_{p_2}, D\varphi x_{p_3}.c_{p_4}, D(D\varphi
%x)ab_{p_5}, Dgab_{p_6}, S]
%\end{equation}
%where
%\begin{eqnarray}
%\nonumber p_1 &=& [H\varphi y, D\varphi x.c, D(D\varphi x)ab, Dgab, S]\\
%\nonumber p_2 &=& [D\varphi x.c, D(D\varphi x)ab, Dgab, S]\\
%\nonumber p_3 &=& [Dgab, S]\\
%\nonumber p_4 &=& [D(D\varphi x)ab, Dgab,S]\\
%\nonumber p_5 &=& [Dgab, S]\\
%\nonumber p_6 &=& [S]
%\end{eqnarray}
%\end{example}

%\subsection{The induction argument}

\begin{lemma}\label{lem:main} If $(q_i,s)$ is a reachable configuration of $2PDAL_G$, then the following hold, where $s = \mkstore{s_1, s_2,
\cdots, s_n}$:
\begin{enumerate}
\item[(i)] If $s' \sqsubseteq s$ and $\mytop_1(s') = u^\lambda$
such that $m- \in \lambda$, and $u : \tau$, then there exists
unique $s'' \sqsubseteq_2 s'$ such that $\mytop_1(s'') = {\varphi
\cdots}^{\lambda'}$ and $m+ \in \lambda$ and $\varphi : \tau$.

%has label $m+$. Furthermore, $\mytop_1(s'') = \varphi \cdots$ such
%that $\varphi : \tau$.

\item[(ii)] If $s' \sqsubseteq_i s$ then $\mytop_1(s')$ is headed by
a non-terminal.

\item[(iii)] \label{level1} If $s' \sqsubseteq s$, and
$\mytop_1(s') = D \cdots^\lambda$ then all level-$1$ arguments of
$D$ are present. Furthermore, $\lambda$ is either $\langle m-
\rangle$ for some $m$ (in the case that $D \cdots $ is of type
level $1$) or it is empty (in the case that $D \cdots : o$).

\item[(iv)] \label{fps} If an item $t$ occurs in a $1$-store
directly atop another of the form $D \cdots^\lambda$, where $D$ is
a non-terminal (by the above), then all the variables occurring in
$t$ are formal parameters of $D$.

\item[(v)] \label{rightnum} If $i > 0$ and $\mytop_1(s) = {\$
\cdots }^\lambda$, then  $\$ : (A_1, \cdots, A_n, o)$ for some $n
\geq i$.
% Furthermore, if $i > k$, then $m- \in \lambda$ for
%some $m$.

%Furthermore, if $\mytop_1(s) = \$ t_1 \cdots t_n^\lambda$ and $n <
%i$ then $m- \in \lambda$ for some $m$.

\item[(vi)] \label{musthavelabel} If $s' \sqsubseteq s$ and
$\mytop_1(s') = {\varphi \cdots}^\lambda$ has type level $1$, then
$m- \in \lambda$ for some $m$.

%\item[(vi)] \label{atleastone} Finally, if $i=0$ and $\mytop_1(s)
%= \varphi \cdots^\lambda $, then $\lambda$ is either $\langle m-
%\rangle$ or empty.

%And, for $j = 2, \cdots, n$, $\mytop_1(s_j)$ is
%either $\mklink{\varphi \cdots}{k_j+}$ or $\mklink{\varphi \cdots
%}{k_j+,l_j-}$.

%\item suppose that $s_j$
%
%\item suppose that $s_j$, for $j = 2, \cdots, n$ is headed by
%$\varphi x_1 \cdots x_n$ of type $\tau$, then the topmost incomplete
%application of $s_{j-1}$ has type $\tau$
\end{enumerate}
\end{lemma}

\begin{proof} By induction on the number of transitions, where a
transition constitutes the application of one rule in
Fig.~\ref{fig:pdal}.
\end{proof}


\begin{lemma}\label{lem:order}
Let $(q_i, s)$ be a reachable configuration of $2PDAL_G$, and let
\[ \mkstore{\cdots,
a^{\lambda \cup \langle m- \rangle}, \cdots , \mklink{b}{k-},
\cdots}\] be a $1$-store in $s$. The end point of the link $m$ is
a $1$-stack strictly above the end point of the link $k$.
\end{lemma}

\begin{proof} Routine induction on the number of
transitions.
\end{proof}

\begin{lemma} \label{lem:pmpop} If $(q_i, s)$ is a reachable
configuration of $2PDAL_G$ and $s' \sqsubseteq s$ and $s'' =
\pop_1(s')$, then $pm(s') = (\mytop_1(s')_{pm(s'')} . \cdots):
\cdots : pm(s'')$.
\end{lemma}

\begin{proof}
By induction on the number of transitions, where a transition
constitutes the application of one rule. For the inductive step
one performs a case analysis on $\mytop_1(s)$. The only case which
requires some care is when we are in state $q_0$ with $\mytop_1(s) = {\varphi_i u_1 \cdots
u_n}^{\lambda}$; we do this here. If $\mytop_1(s) = {\varphi_i u_1
\cdots u_n}^{\lambda}$, then by Lemma~\ref{lem:main}(iv) we must have that $s = \mkstore{s_1, s_2, \cdots, s_k}$
where $s_1 = \mkstore{{\varphi_i u_1 \cdots u_n}^{\lambda}, {D v_1
\cdots v_{n'}}^{ \lambda'}, s_{11}, \cdots, s_{1N}} $. Now, the
next transition results in $(q_0, t)$ where $t =
\mkstore{s_0, s_1', s_2, \cdots s_k}$, where
\begin{eqnarray}
\nonumber s_0 & = & \mkstore{\mklink{v_i}{m-}, s_{11}, \cdots, s_{1N}}\\
\nonumber s_1' &  = & \mkstore{{\varphi_i u_1 \cdots u_n}^{\lambda \cup \langle m+ \rangle}, {D v_1 \cdots v_{n'}}^{\lambda'}, s_{11}, \cdots, s_{1N}}
\end{eqnarray}
where $m$ is a fresh label. We now check that the induction
hypothesis holds. Certainly, it holds for any $s' \sqsubseteq
\pop_2(t)$ (as these have not been affected by the transition).
However, we do need to check the cases where:
\begin{enumerate}\item $s' = t$ and the case where\item  $s' \sqsubseteq_1
t$\end{enumerate}
For (1) we note that:
\begin{equation}
\nonumber pm(t) = join((v_i)_{pm(\pop_1(t))}, split(pm(\pop_2(m)(t))))
\end{equation}
However, $pm(\pop_2(m)(t))$ is equivalent to $pm(s)$, as the only
difference between $\pop_2(m)(t)$ and $s$ is that the topmost
symbol of the former has the extra label $m+$, but it is obvious
from the definition of $pm$, that the extra $m+$ makes no
difference to the output. Hence we have:
\begin{eqnarray}
\nonumber pm(t) & = & join((v_i)_{pm(\pop_1(t))}, split(pm(s)))\\
\nonumber pm(t) & = & ((v_i)_{pm(\pop_1(t))} . \cdots) : ({\sf tail}\;pm(s))
\end{eqnarray}
Now, by the induction hypothesis we have:
\begin{eqnarray}
\nonumber pm(t) & = & ((v_i)_{pm(\pop_1(t))} . \cdots) : ({\sf tail}\;((\varphi_i u_1 \cdots {u_n}_{pm(\pop_1(s))} . \cdots) : \cdots : pm(\pop_1(s)))) \\
\nonumber pm(t) & = & ((v_i)_{pm(\pop_1(t))} . \cdots) : \cdots : pm(\pop_1(s))
\end{eqnarray}
It is easy to check, with the aid of Lemma~\ref{lem:order} that $pm(\pop_1(t)) = pm(\pop_1(\pop_1(s)))$. Furthermore, by the induction hypothesis, $pm(\pop_1(s)) = \cdots : pm(\pop_1(\pop_1(s)))$. Hence we have:
\begin{eqnarray}
\nonumber pm(t) = ((v_i)_{pm(\pop_1(t))} . \cdots) : \cdots :
pm(\pop_1(t))
\end{eqnarray}
As for case (2), this follows easily with the aid of Lemma~\ref{lem:order}.\\
\end{proof}

\begin{lemma}\label{lem:q0}
Let $(q_j,s)$ be a reachable configuration of $2PDAL_G$ for $j>0$
such that $pm(s) = (({s_0})_{p_0}({s_1})_{p_1} \cdots
({s_j})_{p_j} \cdots ({s_n})_{p_n}) : \cdots : p_j$. If $s_j$
After a finite number of transitions we will reach a configuration
$(q_0, s')$ such that $pm(s') = ({s_j})_{p_j}:p_j$. In the case that
$s_j$ contains no variables, $p_j$ is dictated by the function $pm$.
\end{lemma}

\begin{proof}
Induction with respect to $s$. For the inductive step we perform a
case analysis on $\mytop_1(s)$. Suppose that $\mytop_1(s) = {\$
t_1 \cdots t_n}^{\lambda}$ and that $j \leq n$, then the
hypothesis is immediate. If, on the other hand we have $j > n$,
then it must be the case that that $m- \in \lambda$ for some $m$,
and the next configuration is $(q_{j-n},s')$ where $s' =
\pop_2(m)(s)$. The result now follows by the induction hypothesis
and by noting that the ${j-n}$th argument of $\head pm(s')$ equals
the $j$th argument in $\head pm(s)$.
%Note that
%\begin{equation}
%\nonumber pm(s) = (\$t_1 \cdots t_n)_{q}({u_1})_{p_1} \cdots
%({u_r})_{p_r} : {\sf tail}(pm(\pop_2(m)(s)))
%\end{equation}
%for some PM stacks $q, p_1, \cdots, p_r$. Also note that:
%\begin{equation}
%\nonumber pm(s') = \$'_p({u_1})_{p_1} \cdots ({u_r})_{p_r} : p'
%\end{equation}
%where $\mytop_1(s')$ is headed by $\$'$ and for some PM stack $p$,
%where $p' = {\sf tail}(pm(\pop_2(m')(s')))$ or $p' =
%(pm(\pop_1(s')))$ depending on $\mytop_1(s')$. The result now
%follows by the induction hypothesis.
\end{proof}

We say a configuration is \textbfit{stable} if it is of the form
$(q_0, s)$. A stable transition is one from one stable
configuration $(q_0, s)$ to another $(q_0, s')$ such that $(q_0,
s) \rightarrow \cdots \rightarrow (q_0, s')$ and there are no
stable configurations in the $\cdots$'s.

\begin{lemma} Let $G$ be a level $2$ (possibly unsafe) grammar. If $(q_0, s)$ is a reachable configuration of the $2PDAL_G$, then $pm(s)$ is a reachable configuration of the corresponding compacting pointer
machine for $G$.
\end{lemma}

\begin{proof} Induction on the number of stable transition.
With the aid of Lemma~\ref{lem:pmpop} and Lemma~\ref{lem:q0}, it follows almost
immediately.
\end{proof}

%\begin{enumerate}
%\item Each stack item has either no label $()$, a single label
%$(m+)$ or $(m-)$, or a pair $(m+,n-)$ one of which is always a $+$
%and the other a $-$, furthermore, $m \not = n$. \item an item in
%$s_2, \cdots, s_n$ is marked with a $(m+)$ if an only if it is of
%the form $\varphi x_1 \cdots x_n$ and has type $0$. \item an item in
%$s_2, \cdots, s_n$ is marked with $(m+,n-)$ if and only if it is
%of the form $\varphi x_1 \cdots x_n$ and has type $1$ \item an item
%is marked with a $(n-)$ is and only if it is of the form $D t_1
%\cdots t_n x_1 \cdots x_m$ or $ft_1 \cdots t_m$ for $m \geq 0$,
%such that the term is of level $1$. \item All items of terms of
%level $0$ not headed by a variable have no label. \item All
%internal items are headed by a non-terminal, and all of them
%contain all their level 1 parameters \item If an item $t$ occurs
%in a $1$-stack directly atop another of the form $F \cdots$, where
%$F$ is a non-terminal (by the above), then all the variables
%occurring in $t$ are formal parameters of $F$. \item
%\label{rightnum} If $i \not = 0$ then $\mytop_1(s)$ has at least $i$
%formal parameters. \item \label{atleastone} For $j = 2, \cdots,
%n$, $s_j$ is headed by either $\varphi x_1 \cdots x_n (m+)$ or $\varphi
%x_1 \cdots x_n (m+,l-)$ for some $n \geq 1$ \item suppose that
%$s_j$, for $j = 2, \cdots, n$ is headed by $\varphi x_1 \cdots x_n$
%of type $\tau$, then the topmost incomplete application of
%$s_{j-1}$ has type $\tau$ \item The last item in each $1$-stack,
%is always $S$, where $S$ is the start symbol of the higher-order
%grammar. \item $pm(s)$ is a reachable configuration of the
%corresponding pointer machine. \item Finally, if $s' \sqsubseteq_i
%s$ then $pm(s')$ is a suffix of $pm(s)$ and the pointers are in
%agreement.
%\end{enumerate}
%\begin{proof}
%By the induction on the number of stable transitions. The base
%case is obvious. As for the inductive step, suppose that $s=[s_1,
%s_2, \cdots, s_k]$. We perform a case by analysis on the topmost
%symbol. The interesting cases are the following:
%
%\begin{enumerate} \item Suppose that the topmost symbol is $\varphi x_1 \cdots x_n ()$, note the
%absence of a label implies it is of type $0$. In particular, the
%2-store therefore looks something like $[[\varphi x_1 \cdots x_n ,
%s_{11}, \cdots ,s_{1N}], s_2, \cdots, s_k]$. Now, clearly, we
%have:
%\begin{equation} \label{prev}
%pm(s) = [\varphi x_1 \cdots x_n , A_1 , \cdots , A_2 , \cdots, A_3,
%\cdots , A_N ]
%\end{equation}
%where $A_i = s_{1i} \;.\; \cdots$ for each $1 \leq i \leq N$, and
%such that $\varphi$ points to $A_1$, and the $s_{11}$ portion of
%$A_1$ points to $A_2$, and the $s_{12}$ portion of $A_2$ points to
%$A_3$, and so forth, finally the $s_{1n-1}$ portion of $A_{n-1}$
%points to $A_n$. This follows from the induction hypothesis.\\
%Also from the induction hypothesis, we have that each $s_{1i}$
%contains all its level $1$ variables. This guarantees that the
%``search" function terminates (because it would terminate on the
%pointer machine), and has the correct behaviour. In particular,
%the next configuration will be:
%\begin{equation}\label{next}
%s' = [[a (m+), s_{ij}, \cdots ,s_{iN}][\varphi x_1 \cdots x_n (m-),
%s_{11}, \cdots s_{1N}], s_2, \cdots s_k]
%\end{equation}
%where $a$ is a subterm of $s_{ij}$. We now just need to check that
%the invariant is maintained. Note that the previous pointer
%machine configuration was given in Eq. \ref{prev}. Clearly, the
%next step for the pointer machine would be, to uncover what $\varphi$
%with the first application it finds. Of course, this will be $a$.
%Thus we get:
%\begin{equation}
%pm(s) \rightarrow [a . x_1 \cdots x_n, A_1, \cdots, A_2, \cdots,
%A_3, \cdots, A_N]
%\end{equation}
%and the $a$ points to $A_j$. We need to check that this is what we
%get when we apply $pm$ to Eq. \ref{next}. And this is indeed the
%case. Applying $pm$ to any $t \sqsubseteq s'$ will also give the
%correct result for $t \sqsubseteq \pop_2(s')$, but this also holds
%for $t = \pop_1^m(s')$ for $1 \leq m \leq {N-j}$ - easy to check,
%with the help of lemma 4.5 in preceding note. Another interesting
%case involves the top symbol $\varphi x_1 \cdots x_n (m-)$ - this
%follows in a similar fashion. \item Suppose that the topmost item
%is $f t_1 \cdots t_n (m-)$, and that the environment chooses the
%state $q_j$, for some $j > n$. That we eventually reach state
%$q_0$ follows from the induction hypothesis (\ref{rightnum}) and
%(\ref{atleastone}). Suppose that $(q_0, s')$ is the first stable
%configuration we reach - that $pm(s')$ is indeed the next
%configuration for the corresponding pointer machine can be shown
%with an argument similar to the above. The situation if the
%topmost item is $x$, where $x$ is the $j$th argument of the
%preceding item, is similar.
%\end{enumerate}
%\end{proof}
%\end{document}
