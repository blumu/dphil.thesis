\documentclass{article}

\usepackage{url}

\begin{document}

\section*{Previous Academic Work: MSc Thesis}

\textbf{Title:}
\textsl{Termination Analysis of $\lambda$-calculus and a subset of core ML.}
\\

\noindent
\textbf{Abstract:}

Termination analysis is a very important component of software
verification: it is futile trying to prove a property on a program
result if the program does not terminate and therefore never returns
the result. Turing showed that termination is an undecidable
property. However in \cite{jones01}, Lee, Jones and Ben-Amram
introduced ``size-change termination'', a decidable property
strictly stronger than termination. They proposed a method called
the ``size-change principle'' to analyze it.

\noindent Size-change analysis relies on a finite approximation of
the program computational behavior. A call semantics is defined such
that the presence of infinite call sequences characterizes
non-termination. Since the approximated computational space is
finite, infinite call sequences must contain loops. Deciding the
size-change property then amounts to analyze loops of the program
through the use of ``size-change graphs'' describing program calls.
\\

\noindent We first explain the size-change principle in the
first-order case (\cite{jones01}) and its adaptation to the untyped
$\lambda$-calculus (\cite{jones04}). My implementation provides some
improvements over the original method: it avoids variable renaming
and generates a more accurate approximation.

\noindent Finally we extend the size-change principle to a subset of
ML featuring ground type values, higher-order type values and
recursively defined functions. Compared to other works, this is the
first time that the size-change principle is applied to a
higher-order functional language.

\noindent In a first attempt, the ML program is converted into a
$\lambda$-calculus expression, by means of Church numerals and the
$Y$ combinator, and analyzed using the algorithm of \cite{jones04}.
Implementing numbers with church numerals has two important
drawbacks: the size of the converted program increases
proportionally to the integer values used in its definition.
Secondly, since the decrease in integer values is not properly
reflected by church numerals, most recursively defined functions
operating on numbers are not recognized as terminating!

\noindent In the second approach, being inspired by \cite{jones04}
we redefine from scratch an algorithm for the core ML case which
handles natively {\tt if-then-else} and {\tt let rec} structures
with no conversion. This algorithm produces the same result as
\cite{jones04} for higher-order values but can also analyze the size
of ground type values. This enhances the scope of the termination
analyzer to some recursively defined function operating on numbers.
\\


\pagebreak

\section*{Brief description of the proposed topic of research}

\textbf{Title:}
\textsl{Verification of program properties using a fully abstracted game semantics for a Caml like language}
\\


\noindent \textbf{Description}

I propose to work in the field of computer-assisted formal verification and program analysis.
I would like to contribute to the work already achieved in the Game Semantics research group in Oxford.

Prior research by the Game Semantics group in Oxford shows that Game Semantics is a powerful tool for giving semantics to computer programs (\cite{abram01}).

In \cite{abr00} and \cite{ong00} full abstractions of PCF programming language has been established using  Game Semantics concepts.

The case of functional programming is of particular interest for me. Being inspired by the work done by Luke Ong and Samson Abramsky in the Oxford Computer Laboratory, I would like to explore the possibilities of extension of their work to the case of a Caml like programming language. 

My work will consist in investigating applications of Algorithmic Game Semantics to the case of a ML programming language like Caml.
\textsl{}
The aim will be to find a full abstraction of a ML programming language such as Objective Caml (\cite{ocaml}) where functionnal and imperative programming paradigms are present.
This language is a call-by-value language implementing recursive procedure, conditionals, sequential composition, variable assignment, while/for loops, and object oriented programming paradigms such as classes, objects and methods.


The full abstraction will then be used as a basis for different verification tools.
These tools should be able to read Objective Caml code as an input and to do verification 
on that program. The following properties should be supported by the verfication tools:
\begin{itemize}
\item proof of termination (when it is possible)
\item equivalence of two ocaml programs
\item other properties to be expressed in a temporal logic which need to be defined. 
\end{itemize}


The full abstraction should permit to generate structures which approximate the semantics of the program.
These structures should be adapted to the properties which need to be proved.

One possible approach to this project can be to find an interesting extension of the size-change principle introduced by Neil Jones in \cite{jones01}. The size-change principle has been used by Neil Jones in \cite{jones04} to develop
an algortihm for the termination analysis of the untyped lambda-calculus (subject of my MSc project last years).

\pagebreak

\bibliography{proposal}
\bibliographystyle{plain} 

\end{document}
