%\documentclass[RR]{OUCLdocument}
%\reportnumber{??} \theyear{2007}

\documentclass[12pt]{llncs}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{pst-tree}
\usepackage{a4wide}

\usepackage{pstring}
\definecolor{darkGreen}{rgb}{0.03,0.35,0.05}
\pstrSetArrowColor{darkGreen}

\usepackage[defblank]{paralist}
%\usepackage[compact]{titlesec} % saves even more space

\usepackage{picins}
\usepackage{wrapfig}
%\usepackage{floatflt}


% highlight for definition names
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

% reduction, substitution
\newcommand\betared{\rightarrow_\beta}
\newcommand\betasred{\rightarrow_{\beta_s}}
\newcommand\betaredtr{\twoheadrightarrow_\beta} % transitive closure of the beta reduction
\newcommand\subst[2]{\left[ #1/#2 \right]}
\newcommand\captsubst[2]{\{#1/#2 \}}

% computation tree, eta normal form, traversals
\newcommand{\elnf}[1]{\lceil #1\rceil} % eta long normal form
\newcommand\travset{\mathcal{T}rv}

% lambda calculus
\newcommand{\encode}[1]{\overline{#1}} \newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{\dps #2}}
\newcommand\rulefex[3][5pt]{\frac{\dps
    #2}{\stackrel{\rule{0pt}{#1}}{\dps #3}}}
\newcommand\ord[1]{{\sf
    ord}(#1)} \newcommand\typear{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(\sf #1)}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\nat{\mathbb{N}}


% game semantics
\newcommand{\sem}[1]{{[\![ #1 ]\!]}}
\newcommand{\intersem}[1]{{\langle\!\langle #1 \rangle\!\rangle}}

% logic
\newcommand\imp{\Longrightarrow}
\newcommand\zand{\wedge}
\newcommand\entail{\vdash}

% pcf and ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}
\newcommand\pcf{\textsf{PCF}}

% justified sequence of moves
\newcommand{\oview}[1]{\llcorner #1 \lrcorner}
\newcommand{\pview}[1]{\ulcorner #1 \urcorner}


% trees
\newcommand{\tree}[2][levelsep=3.5ex]{\pstree[levelsep=3.5ex,#1]{\TR{#2}}}
\newcommand{\arclabel}[1]{\mput*{\mbox{{\small $#1$}}}}
\newcommand\mng[1]{{\mathopen{[\![}\,#1\,\mathclose{]\!]}}}


%\theoremstyle{plain}% default
%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem*{corollary}{Corollary}
%\newtheorem*{KL}{Klein's Lemma}
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}[section]
%\newtheorem{conj}{Conjecture}[section]
%\newtheorem{example}{Example}[section]
%\theoremstyle{remark}
%\newtheorem*{remark}{Remark}
%\newtheorem*{note}{Note}
%\newtheorem{case}{Case}
%



\title{The Safe Lambda Calculus \\ {\small Long version of the TLCA07
paper}\\ {\small \it version of \today}}

\author{William~Blum~~~~~~~~~~~C.-H.~Luke~Ong}
%\date{{\it version of \today}}


\institute{Oxford University Computing Laboratory\\
Wolfson Building, Parks Road, Oxford OX1 3QD, ENGLAND\\
\email{{\fontfamily{cmr}\{}william.blum,luke.ong{\fontfamily{cmr}\}}@comlab.ox.ac.uk
}}


\begin{document}

\maketitle              % typeset the title of the contribution

\begin{abstract}
  Safety is a syntactic condition of higher-order grammars that
  constrains occurrences of variables in the production rules
  according to their type-theoretic order. In this paper, we introduce
  the \emph{safe lambda calculus}, which is obtained by transposing
  (and generalizing) the safety condition to the setting of the
  simply-typed lambda calculus. In contrast to the original definition
  of safety, our calculus does not constrain types (to be
  homogeneous). We show that in the safe lambda calculus, there is no
  need to rename bound variables when performing substitution, as
  variable capture is guaranteed not to happen.  We also propose an
  adequate notion of $\beta$-reduction that preserves safety.  In the
  same vein as Schwichtenberg's 1976 characterization of the
  simply-typed lambda calculus, we show that the numeric functions
  representable in the safe lambda calculus are exactly the
  multivariate polynomials; thus conditional is not definable.
  Finally we give a game-semantic analysis of safety: We show that
  safe terms are denoted by \emph{P-incrementally justified
    strategies}. Consequently pointers in the game semantics of safe
  $\lambda$-terms are only necessary from order 4 onwards.
\end{abstract}

\input safelambda.tex

\bibliographystyle{abbrv} % {nat} % {splncs}
\bibliography{../bib/dphil-all}
\input appendix.tex

\end{document}
