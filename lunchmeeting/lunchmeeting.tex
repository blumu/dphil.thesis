\input{lunchmeeting.pre}

\pstrSetArrowColor{black}

\title{\texorpdfstring{The Safe $\lambda$-Calculus}{The Safe Lambda-Calculus}}

\author[W. Blum, C.-H. L. Ong]{\\ William Blum\\ \ \\
 Joint work with C.-H. Luke Ong}


\institute[University Of Oxford]{Oxford University Computing Laboratory}

\date{\small \color{red}{Lunch-time meeting, 14 May 2007}}


\begin{document}


\section{Title page}
  \frame{\titlepage}


%\section<presentation>*{Outline}
%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents[part=1]
%\end{frame}
%\AtBeginSection[] {
%   \begin{frame}<beamer>
%     \frametitle{Outline}
%     \tableofcontents[currentpart,currentsection]
%   \end{frame}
% }
%
%\part<presentation>{Main Talk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}
\frame{\frametitle{Overview}

\begin{itemize}
\item \textcolor{blue}{Safety}: a restriction for higher-order grammars.
\item Transposed to the $\lambda$-calculus, it gives rise to the \textcolor{blue}{Safe $\lambda$-calculus}.
\item Safety has nice algorithmic properties, automata-theoretic and game-semantic characterisations.
\end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Outline for this talk}
\frame{
\frametitle{Outline for this talk}
\begin{enumerate}
\item The Safety Restriction
\item The simply typed $\lambda$-calculus
\item The Safe $\lambda$-calculus
\item Game-semantic characterisation of Safety
\end{enumerate}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simply Typed \texorpdfstring{$\lambda$}{Lambda}-Calculus}
\frame{\frametitle{Simply Typed $\lambda$-Calculus}
\begin{itemize}
\item \highlight{Simple types} $A := o\ |\ A \rightarrow A$.
%We write $(A_1,\ldots, A_n)$ for $A_1\rightarrow \ldots \rightarrow A_n$.
\pause
\item The \highlight{order} of a type is given by $\textsf{order}(o) = 0$,
$\textsf{order}(A \rightarrow B) = \max(\textsf{order}(A) + 1, \textsf{order}(B))$.
\pause
\item Jugdements of the form $ \Gamma \vdash M : T $ where $\Gamma$ is the context, $M$ is the term and $T$ is the type:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash M : A}{\Delta \vdash M : A} \ \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash M : A \rightarrow B \quad \Gamma \vdash N : A }
                           {\Gamma  \vdash M N : B}
\quad \rulename{abs} \   \rulef{\Gamma, x : A \vdash M : B}
                                {\Gamma  \vdash \lambda x^A. M : A \rightarrow B}$$
\pause
\item Example: $f:o\rightarrow o\rightarrow o, x:o \vdash (\lambda \varphi^{o \rightarrow o} x^o . \varphi\ x) (f\ x)$
\pause
\item A single rule: \highlight{$\beta$-reduction}. e.g. $(\lambda x. M) N \betared M [N/x]$
\end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Variable Capture}
\frame{\frametitle{Variable Capture} \highlight{The usual
``problem'' in $\lambda$-calculus}: avoid \alert{variable capture}
when performing substitution: $ (\lambda x . (\lambda y . x)) y
\betared (\lambda \underline{y} . x) [\underline{y}/x] \neq \lambda
y . y$\pause
\begin{enumerate}
\item \highlight{Standard solution}: Barendregt's convention. Variables are renamed so that free variables and bound variables have different names.
Eg. $(\lambda x . (\lambda y . x)) y$ becomes $(\lambda x . (\lambda
z . x)) y$ which reduces to $(\lambda z . x) [y/x] = \lambda z . y$
\pause

\alert{Drawback:} requires to have access to an unbounded supply of names to perform
a given sequence of $\beta$-reductions.
\note{Drawback 1, eg. $(\lambda x_1 \ldots x_n . (\lambda y_1 \ldots y_n . x_1 \ldots x_n)) y_1 \ldots y_n$}
\pause

\item \highlight{Another solution}: switch to the $\lambda$-calculus \`a la de Brujin where variable binding is specified by an index instead of a name.
Variable renaming then becomes unnecessary.
\pause

\alert{Drawback:} the conversion to nameless de Brujin $\lambda$-terms requires an unbounded supply of indices.
\pause
\end{enumerate}
\alert{The Safety restriction avoids the need for variable renaming!} }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{What is the Safety Restriction?}
\frame{\frametitle{What is the Safety Restriction?}
\begin{itemize}
\item First appeared under the name ``restriction of derived types'' in ``IO and OI Hierarchies'' by W. Damm, TCS 1982
\item It is a \highlight{syntactic restriction} for higher-order grammars that constrains the occurrences
of the variables in the grammar equations according to their orders.
\pause
\begin{thm}[Knapik, Niwi\'nski and Urzyczyn (2001,2002)]
\begin{enumerate}
\item
The Monadic Second Order (MSO) model checking problem for trees generated by \alert{safe} higher-order grammars of any order is decidable.
\item \highlight{Automata-theoretic characterisation}:
Safe grammars of order $n$ are as expressive as pushdown automata of order $n$.
\end{enumerate}
\end{thm}
\pause
In an unpublished technical report (2004),
Aehlig, de~Miranda and Ong  were the first to propose
a notion of safety adapted to the setting of the $\lambda$-calculus.
\end{itemize}

\note{
\begin{itemize}
\item nPDA = finite state machines + order n stack
\item For words: 1PDA recognizes context-free language.
        and 0PDA = recognizes regular language.
\item MSO is very expressive: more than the modal mu-calculus (into which LTL CTL CTL* can be embedded.
But over trees, MSO and modal mu-calculus are equi-expressive.)
\end{itemize}
}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Safe \texorpdfstring{$\lambda$}{Lambda}-Calculus}
\begin{frame} \frametitle{The Safe $\lambda$-Calculus}

\begin{block}{The formation rules}
$$ \rulename{var} \   \rulef{}{x : A\vdash_s x : A}
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash_s M : A}{\Delta \vdash_s
M : A} \ \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash M : (A_1,\ldots,A_l,B)
                                        \quad \Gamma \vdash_s N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash_s N_l : A_l  }
                                   {\Gamma  \vdash_s M N_1 \ldots N_l : B}$$
\hfill with the side-condition $\textcolor{red}{\forall y \in \Gamma
: \ord{y} \geq \ord{B}}$
$$ \rulename{abs} \   \rulef{\Gamma, x_1:A_1 \ldots x_n : A_n \vdash_s M : B}
                                   {\Gamma  \vdash_s \lambda x_1:A_1 \ldots x_n : A_n . M : A_1 \rightarrow \ldots \rightarrow A_n \rightarrow B}$$
\hfill with the side-condition $\textcolor{red}{\forall y \in \Gamma
: \ord{y} \geq \ord{A_1 \rightarrow \ldots \rightarrow A_n
\rightarrow B}}$
\end{block}
\pause
\begin{block}{Property}
In the Safe $\lambda$-calculus there is no need to rename variables when
performing substitution.
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}
\frame{\frametitle{Examples}
\begin{itemize}
\item
Contracting the $\beta$-redex in the following term
$$f:o\rightarrow o\rightarrow o, x:o \vdash (\lambda \varphi^{o \rightarrow o} x^o . \varphi\ x) (\temporal<2>{f\ x}{\underline{f\ \alert{x}}}{\underline{f\ \alert{x}}})$$
leads to variable capture:
$$(\lambda \varphi x . \varphi\ x) (f\ x) \not\betared (\lambda \alert{x} . (f\ \alert{x}) x).$$
\pause
Hence the term is \alert{unsafe}.

Indeed, $\ord{x} = 0 \leq 1 = \ord{f\ x}$.
\pause

\item The term $(\lambda \varphi^{o \rightarrow o} x^o . \varphi\ x) (\lambda y^o . y )$ is safe.
\end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Numerical functions}
\frame{ \frametitle{Numerical functions}

Church Encoding: for $n\in\nat$, $\overline{n} = \lambda s z. s^n z$
of type $I = (o\rightarrow o)\rightarrow o\rightarrow o$.

\begin{theorem}[Schwichtenberg 1976]
The numeric functions representable by simply-typed terms of type $I\rightarrow \ldots \rightarrow I$ are
exactly the multivariate polynomials extended with the conditional function:
$$ cond(t,x,y) =
\left\{ \begin{array}{ll} x, & \mbox{if $t=0$} \\
y, & \mbox{if $t = n+1$}\ .
\end{array} \right.
$$
\end{theorem}
$cond$ is represented by the term $C = \lambda F G H \alpha x . H (
\temporal<2>{\lambda y . G \alpha x}
{\underline{\lambda y . G \alpha x}}{\underline{\lambda y . G \alpha x}}
 ) (F \alpha x)$.
\pause
\begin{theorem}
Functions representable  by safe $\lambda$-expressions of type $I\rightarrow \ldots \rightarrow I$  are
exactly the multivariate polynomials.
\end{theorem}
So $cond$ is not representable in the Safe $\lambda$-calculus and $C$ is unsafe.
}
%\def\highlightat#1#2{\temporal<#1>{#2}{\underline{#2}}{\textcolor{blue}{#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Game Semantics}
\frame{ \frametitle{Game Semantics}
Let $\vdash M:T$ be a pure simply typed term.

\begin{itemize}
\item \highlight{Game-semantics} provides a model of $\lambda$-calculus.
$M$ is denoted by a strategy $\sem{M}$ on a 2-player game induced by $T$.
\item A \highlight{strategy} is represented by a set of sequences of moves together with \highlight{links}: each move points
to a preceding move.
\pause
\item \textcolor{DarkGreen}{Computation tree} = canonical tree representation of a term.
\item \textcolor{DarkGreen}{Traversals $\travset(M)$ } = sequences of nodes with links respecting some formation rules.
\end{itemize}
\pause

\begin{block}{The Correspondence Theorem}
The game semantics of a term can be represented on the computation
tree:
$$ \textcolor{DarkGreen}{\travset(M)} \cong \textcolor{blue}{\intersem{M}} $$
$$ \textcolor{DarkGreen}{Reduction(\travset(M))} \cong \textcolor{blue}{\sem{M}}$$
where $\textcolor{blue}{\intersem{M}}$ is the revealed game-semantic denotion (i.e. internal moves are uncovered).
\end{block}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Correspondence Theorem}
\frame{\frametitle{Game semantics} Model programming languages using
games (Abramsky et al.; Hyland and Ong; Nickau)
\begin{itemize}
\item 2 players: \highlight{O}pponnent (system) and \highlight{P}roponent (program)
\item The term type induces an \highlight{arena} defining the possible moves
$\sem{\nat} = \begin{tikzpicture}[baseline=(root.base),level distance=7mm,inner ysep=0.5mm,sibling distance=5mm]
 \node (root) {$q$}
    child {node {$\scriptstyle 0$}}
    child {node {$\scriptstyle 1$}}
    child {node {$\scriptstyle \ldots$}}
;
\end{tikzpicture}$
\hspace{2cm}
$\sem{\nat \rightarrow \nat} = \begin{tikzpicture}[baseline=(root.base),level distance=7mm,inner ysep=0.5mm,sibling distance=5mm]
 \node (root) {$q^0$}
    child{
      node{$q^1$}
      child{node {$\scriptstyle 0$} }
      child{node {$\scriptstyle 1$} }
      child {node {$\scriptstyle \ldots$}}
    }
    child {node {$\scriptstyle 0$}}
    child {node {$\scriptstyle 1$}}
    child {node {$\scriptstyle \ldots$}}
;
\end{tikzpicture}$
\item \highlight{Play} = sequence of moves played alternatively by O and P with justification pointers.
\item \highlight{Strategy for P} = prefix-closed set of plays. $s  a  b$ in the strategy means that
P should respond $b$ when O plays $a$ in position $s$.
\item The \highlight{denotation} of a term $M$, written $\sem{M}$, is a strategy for P.
\item $\sem{ 7 : \nat} = \{ \epsilon, q, q\ 7 \}$\\
$\sem{ \pcfsucc : \nat \rightarrow \nat} = Pref( \{ q^0 q^1 n ( n+1)
\ | \ n \in \nat \} )$
\item Compositionality: $\sem{ \pcfsucc\  7} = \sem{ \pcfsucc } ; \sem{7}$
\end{itemize}
}

\def\highlightat#1#2{\temporal<#1>{#2}{\underline{#2}}{\textcolor{blue}{#2}}}

\section{Computation trees and traversals}
\frame{ \frametitle{Computation trees and traversals} {\it
Computation tree} = tree representation of the $\eta$-long normal
form of a term.

\visible<2->{ \textcolor{blue}{\it Traversal} = justified sequence
of nodes representing the computation (given by formation rules). }

\visible<11->{ \textcolor{red}{\it  Traversal reduction} = keep only
nodes hereditarily justified by the root. }

\vspace{0.5cm} \textcolor{blue}{Example} $M \equiv \lambda f z .
(\lambda g x . f x) (\lambda y. y) z$ of type $(o \typear o) \typear
o \typear o$. \vspace{0.5cm}
\begin{columns}
\column{4cm}
\begin{tikzpicture}[level distance=7mm,inner ysep=0.5mm]
 \node {\highlightat{3}{$\lambda f z$}}
    child {
        node {\highlightat{4}{@}}
        child {
            node {\highlightat{5}{$\lambda g x$}}
            child{
                node{\highlightat{6}{$f$}}
                child {
                    node{\highlightat{7}{$\lambda$}}
                    child {
                        node{\highlightat{8}{$x$}}
                    }
                }
            }
        }
        child {
            node {$\lambda y$}
            child{ node {$y$} }
        }
        child {
            node {$\highlightat{9}{\lambda}$}
            child{ node {\highlightat{10}{$z$}} }
            }
        };
\end{tikzpicture}

\column{7cm}
\setbox0=\hbox{$\textcolor{blue}{
\pstr{\only<3->{\nd t= (q1){\lambda f z}}
        \only<4->{\nd \cdot (n2-q1) {@}}
        \only<5->{\nd \cdot (n3-n2){\lambda g x}}
        \only<6->{\nd \cdot (q3-q1){f}}
        \only<7->{\nd \cdot (q4-q3){\lambda}}
        \only<8->{\nd \cdot (n8-n3){x}}
        \only<9->{\nd \cdot (n9-n2){\lambda}}
        \only<10->{\nd \cdot (q2-q1){z}}
}}$}
\ht0 1cm\box0 % Make sure the height of box containing the traversal remains constant across the different generated slides


\visible<11->{
\vspace*{0.2cm}
$\color{red}{
\Pstr[0.7cm]{t \upharpoonright r = (q1){\lambda f z} \cdot (q3-q1,50){f}
\cdot (q4-q3,50){\lambda} \cdot (q2-q1){z} } }$
}

%%\vspace*{0.8cm}
\visible<12->{ $\Pstr[0.7cm]{ t - @ = (q1){\lambda f z}
 \cdot (n3-q1){ \lambda g x}
 \cdot (q3-q1){ f}
 \cdot (q4-q3){ \lambda}
 \cdot (n8-n3){ x}
 \cdot (n9-q1){ \lambda}
 \cdot (q2-q1){z}
} $}
\end{columns}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Correspondence Theorem}
\frame{ \frametitle{The Correspondence Theorem} Let $M$ be a pure
simply typed term of type $T$.
\begin{itemize}
\item $\textcolor{blue}{\travset(M)}$ = set of traversals of the computation tree of $M$
\item $\textcolor{blue}{\travset(M)}^{\upharpoonright r} = \{ t \upharpoonright r \ | \  t \in {\travset(M)} \}$
\item $\textcolor{blue}{\travset(M)}^{-@} = \{ t - @ \ | \  t \in {\travset(M)} \}$
\item $\textcolor{red}{\sem{M}}$ = game-semantic denotation of $M$
\item $\textcolor{red}{\intersem{M}}$ = revealed denotion (i.e. internal moves are not hidden)
\end{itemize}

\begin{block}{}
There exists a partial function $\textcolor{DarkGreen}{\varphi}$
from the nodes of the \textcolor{blue}{computation tree} to the
moves of the \textcolor{red}{arena} for $T$ such that
$$ \textcolor{DarkGreen}{\varphi}  : \textcolor{blue}{\travset(M)}^{-@} \textcolor{DarkGreen}{\stackrel{\cong}{\longrightarrow}} \textcolor{red}{\intersem{M}} $$
$$ \textcolor{DarkGreen}{\varphi}  : \textcolor{blue}{\travset(M)}^{\upharpoonright r}  \textcolor{DarkGreen}{\stackrel{\cong}{\longrightarrow}} \textcolor{red}{\sem{M}}.$$
\end{block}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Correspondence Theorem (example)}
\frame{\frametitle{Correspondence Theorem (example)}
\begin{center}
\begin{tikzpicture}[level distance=7mm,inner ysep=0.5mm,inner xsep=0.5mm,sibling distance=10mm]
%\color{blue}
\node (root) {$\lambda f z$}
    child{
      node{$@$}
          child{
            node {$\lambda g x$}
            child{
              node (f) {$f$}
              child{
                node (lmd) {$\lambda$}
                child{
                  node {$x$}
                }
              }
            }
          }
          child{
            node {$\lambda y$}
            child{
              node {$y$}
            }
          }
          child{
            node {$\lambda$}
            child{
              node (z) {$z$}
            }
          }
      }
;
%\color{red}
\draw +(5,0) node (q1) {$q^1$}
    [level distance=20mm]
      child{
        node (q3) {$q^3$}
        [level distance=10mm]
        child{ node (q4) {$q^4$} }
      }
      child{ node (q2) {$q^2$} }
      child{ node (q5) {$q^5$} }
;
\color{DarkGreen}
\draw[->] (root) -- node[above] {$\varphi$} (q1);
\draw[->] (f) -- (q3);
\draw[->] (lmd) -- (q4);
\draw[->] (z) to [bend right=20]  (q2);
\end{tikzpicture}
\end{center}
Take the traversal
%\textcolor{blue}
{\Pstr{t = (q1){\lambda f z} \cdot (n2){@}
\cdot (n3-n2){\lambda g x}
\cdot (q3-q1,35){f}
\cdot (q4-q3){\lambda}
\cdot (n8-n3){x}
\cdot (n9-n2,35){\lambda}
\cdot (q2-q1,35){z}}}, then $\textcolor{DarkGreen}{\varphi}$ maps its reduction
to the play:
$$
\textcolor{DarkGreen}{
\varphi (} %\textcolor{blue}
{t \upharpoonright r}
\textcolor{DarkGreen}{)} = \textcolor{DarkGreen}{\varphi (}
\textcolor{blue}{
\Pstr[70mm]{ (q1){\lambda f z}
            \cdot (q3-q1){f}
            \cdot (q4-q3){\lambda}
            \cdot (q2-q1){z} }
}
\textcolor{DarkGreen}{)} = %\textcolor{red}
{
\Pstr[70mm]{
    (q1){q}^1\
    (q3-q1){q}^3\
    (q4-q3){q}^4\
    (q2-q1){q}^2
}}
\in %\textcolor{red}
{\sem{M}}.
$$
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Correspondence Theorem (2)}
\frame{ \frametitle{The Correspondence Theorem (2)}
\begin{center}
\begin{tabular}{c|c}
computation tree & arena \\ \\
traversals & uncovered plays \\ \\
reduced traversal & plays \\ \\
paths in the computation tree & P-views of uncovered plays
\end{tabular}
\end{center}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Game-semantic Characterisation of Safety}
\frame{ \frametitle{Game-semantic Characterisation of Safety}

\begin{itemize}
\item The computation tree of  a safe term is \highlight{incrementally-bound} :
each variable $x$ is bound by the first $\lambda$-node occurring in
\textcolor{DarkGreen}{the path to the root} with order $> \ord{x}$.
\pause

\item Using the Correspondence Theorem, since paths in the computation tree correspond to P-views
of plays in game semantic, we can show:

\begin{block}{Proposition}
Safe terms are denoted by \highlight{P-incrementally justified strategies}: each P-move $m$ points to the
last O-move in \textcolor{DarkGreen}{the P-view} with order $> \ord{m}$.
\end{block}
\end{itemize}
\pause

\begin{block}{Corollary}
Justification pointers attached to P-moves are redundant in the game-semantics of safe
terms.
\end{block}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion and Future Works}
\frame{ \frametitle{Conclusion and Future Works}

\highlight{Conclusion:}

Safety is a syntactic constraint with interesting algorithmic and
game-semantic properties.

\highlight{Future works:}
\begin{itemize}
\item Find a categorical model of Safe PCF.
\item Complexity classes characterised with the Safe $\lambda$-calculus?
\item Safe Idealized Algol: is contextual equivalence decidable?
\end{itemize}


\highlight{Related works:}
\begin{itemize}
\item Jolie G. de Miranda's thesis on unsafe grammars.
\item Ong introduced computation trees in LICS2006 to prove decidability of MSO theory on infinite trees
generated by higher-order grammars (whether safe or not).
%\item Stirling recently proved decidability of higher-order pattern matching with a game-semantic approach
%relying on equivalent notions of computation tree and traversal.
\end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bibliography}

\end{document}
\endinput

\begin{frame} \frametitle<presentation>{Bibliography}

%  \begin{thebibliography}{10}
  \beamertemplatearticlebibitems
    \bibitem{abramsky:game-semantics-tutorial}
    Samson Abramsky and Guy McCusker.
    \newblock Game semantics, Lecture notes.
    \newblock In {\em Proceedings of the 1997 Marktoberdorf Summer School}. Springer-Verlag, 1998.

    \bibitem{safety-mirlong2004}
    Klaus Aehlig, Jolie~G. de~Miranda, and C.-H.~Luke Ong.
    \newblock Safety is not a restriction at level 2 for string languages.
    \newblock Technical report. University of Oxford, 2004.

    \bibitem{OngLics2006}
    C.-H.~Luke Ong.
    \newblock On model-checking trees generated by higher-order recursion schemes.
    \newblock In {\em Proceedings of LICS.} Computer Society Press, 2006.

%    \bibitem{DBLP:conf/icalp/Stirling06}
%    Colin Stirling
%    \newblock A Game-Theoretic Approach to Deciding Higher-Order Matching.
%    \newblock In {\em Proceedings of ICALP.} Springer, 2006.

%  \end{thebibliography}
\end{frame}

\end{document}
