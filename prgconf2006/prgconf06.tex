\documentclass[12pt]{article}

\newcommand\ialgol{\textsf{IA}}
\newcommand\pcf{\textsf{PCF}}
\newtheorem{thm}{Theorem}
\pagestyle{empty}
\begin{document}
\begin{center}
{\Large \bf Game semantics of the Safe $\lambda$-calculus}
\vspace{0.2cm}

{\small Abstract for the PRG Conference 2006} \vspace{0.4cm}

William Blum \vspace{0.4cm}

\today \vspace{0.5cm}
\end{center}

%\section{The Safe $\lambda$-calculus}

The \emph{safety condition} has been introduced in \cite{KNU02} as a
syntactic restriction for higher-order recursion schemes (grammars)
that constrains the order of the variables occurring in the grammar
equations. The authors were able to prove that the Monadic Second
Order (MSO) theory of the term tree generated by a safe recursion
scheme of any order is decidable\footnote{in fact it has been shown
recently in \cite{OngLics2006} that it is also true for unsafe
recursion schemes.}.

When transposed to the $\lambda$-calculus, the safety condition
gives rise to the \emph{Safe $\lambda$-calculus}, a strict
sub-language of the $\lambda$-calculus. A first version appeared in
the technical report \cite{safety-mirlong2004}. We propose a more
general and less intricate version where term types are not required
to be homogeneous (\cite{blumtransfer}). Interestingly, in the Safe
$\lambda$-calculus, no variable capture can occur when performing
substitution, therefore it is unnecessary to rename variables when
computing $\beta$-reductions.

Little is known about the Safe $\lambda$-calculus and there are many
 problems that have yet to be studied concerning its
computational power, the complexity classes that it characterises,
its interpretation under the Curry-Howard isomorphism and its
repercussion on game semantics
(\cite{abramsky:game-semantics-tutorial}). We have contributed to
give an answer to the latter by proving the following result:
\begin{thm}
\label{thm:safeptrrecover} The pointers in the game semantics of
safe simply-typed terms can be recovered uniquely from the
underlying sequences of moves.
\end{thm}

%\section{Game-semantic characterisation}
Giving a game-semantic account of Safety is complicated by the fact
that it is a syntactic restriction whereas Game Semantics is by
essence a syntax-independent semantics. Our approach consists in
making an explicit correspondence between the syntax of a term and
its game denotation using ideas recently introduced in
\cite{OngLics2006}. A term is represented by a \emph{computation
tree} which is an abstract syntax tree (AST) of its $\eta$-long
normal form. A computation is represented by a \emph{traversal}, a
justified sequence of nodes of the computation tree respecting some
formation rules. Traversals permit to do a \emph{local computation}
of $\beta$-reductions as opposed to a global approach that would
reduce $\beta$-redexes by performing substitutions. A notable
property is that the \emph{P-view} (in the game-semantic sense) of a
traversal is a path in the computation tree.

We prove the \emph{Correspondence Theorem} which states that
traversals are just representations of the uncovering of plays of
the game-semantic denotation of the term. By defining a
\emph{reduction} operation on traversals that eliminates the
``internal nodes'' of the computation, we obtain an isomorphism
between the strategy denotation of a term and the set of reductions
of traversals over its computation tree.

Since we can regard plays of a strategy as sequences of nodes of the
computation tree, we are in a position to investigate the impact of
the Safety restriction on Game Semantics. The proof of Theorem
\ref{thm:safeptrrecover} is in several steps. First, we introduce
the notion of \emph{incrementally-justified strategies} and prove
that pointers are uniquely reconstructible for such strategies. We
then introduce the notion of \emph{incrementally-bound computation
trees} and prove, using the Correspondence Theorem, that
incremental-binding coincides with incremental-justification.
Finally, we show that safe simply-typed terms in $\beta$-normal form
have incrementally-bound computation trees.

We define Safe \ialgol\ to be the Safe $\lambda$-calculus augmented
with the constants of Idealized Algol (\ialgol) as well as a family
of combinators $Y_A$ for every type $A$. We show that terms of the
Safe \pcf\ fragment are denoted by incrementally-justified
strategies and we give the key elements for a possible extension to
full Safe \ialgol.

\bibliographystyle{plain}
\bibliography{prgconf}

\end{document}
