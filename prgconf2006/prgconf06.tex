\documentclass[12pt]{article}
\usepackage{natbib}

\newcommand\ialgol{\textsf{IA}}
\newcommand\pcf{\textsf{PCF}}


\author{William Blum}
\title{Game semantics of the Safe $\lambda$-calculus\\ {\small Abstract for the PRG Conference 06}}
\begin{document}
\maketitle

\section{The Safe $\lambda$-calculus}

The \emph{Safe $\lambda$-calculus} is a strict sub-language of the
$\lambda$-calculus where terms are required to satisfy a property
called \emph{safety}. The safety condition has been introduced in
\cite{KNU02} as a syntactic restriction for higher-order recursion
schemes (grammars). It constraints the order of the variables
occurring in the equations constitutive of the grammar. This
restriction being defined, the authors were able to prove that the
Monadic Second Order (MSO) theory of the term tree generated by a
safe recursion scheme of any order is decidable (in fact it has been
shown recently in \cite{OngLics2006} that the safety assumption is
not necessary for the decidability of MSO theories).

The first version of a Safe $\lambda$-calculus derived from the
safety condition appeared in the technical report
\cite{safety-mirlong2004}. I propose a more general and less
intricate version of the Safe $\lambda$-calculus where the type of
terms is not required to be homogeneous \citep{blumtransfer}.
Interestingly, in the Safe $\lambda$-calculus, it is unnecessary to
rename variables when performing $\beta$-reduction, in other words,
no variable capture can occur during substitution.

The nature of the Safe $\lambda$-calculus is not well known. There
many intriguing questions concerning its computational power, the
complexity classes that it characterises, its interpretation under
the Curry-Howard isomorphism or its repercussion on game semantics
\citep{abramsky:game-semantics-tutorial}. My contribution concerns
the latter, I have proved the following result about the game
semantics of safe terms: \emph{the pointers in the game semantics of
safe simply-typed terms can be recovered uniquely from the
underlying sequences of moves}.

\section{Game-semantic characterisation}
Giving a game-semantic account of Safety is complicated by the fact
that it is a syntactic restriction whereas Game Semantics is by
essence a syntax-independent semantics. It is therefore necessary to
make an explicit correspondence between the game denotation of a
term and its syntax.

Our approach follows ideas recently introduced in
\cite{OngLics2006}, mainly the notion of computation tree of a
simply-typed $\lambda$-term and traversals over the computation
tree. A computation tree can be regarded as an abstract syntax tree
(AST) of the $\eta$-long normal form of a term. A traversal is a
justified sequence of nodes of the computation tree respecting some
formation rules.  Traversals of a computation tree provide a way to
perform \emph{local computation} of $\beta$-reductions as opposed to
a global approach where the $\beta$-reduction is implemented by
performing substitutions. An interesting property is that the
\emph{P-view} (in the game semantics sense) of a traversal is a path
in the computation tree.

We prove the \emph{Correspondence Theorem} which states that
traversals over the computation tree are just representations of the
uncovering of plays in the strategy-denotation of the term. We then
define a \emph{reduction} operation on traversals responsible of
eliminating the ``internal nodes'' of the computation. This leads to
a correspondence between the standard game denotation of a term and
the set of reductions of traversals over its computation tree. Using
the Correspondence Theorem, we can interpret plays of a strategy as
sequences of nodes of the AST of the $\eta$-long normal form of the
term. This allows us to investigate the impact of the Safety
restriction on Game Semantics.

The proof of the theorem stating that pointers in the strategy
denotation of a safe term are uniquely recoverable from the
underlying sequence of moves is in several steps. First, we
introduce the notion of \emph{incrementally-justified strategies}
and prove that pointers are uniquely reconstructible for such
strategies. We then introduce the notion of
\emph{incrementally-bound computation trees} and prove that
incremental-binding coincides with incremental-justification.
Finally, we show that safe simply-typed terms in $\beta$-normal form
have incrementally-bound computation trees.


We show how to extend the result to take into account the
interpreted constants and the Y combinator of \pcf\ and Idealized
Algol (\ialgol). We call Safe \ialgol\ the fragment of \ialgol\
where the application and abstraction rules are constrained in the
same way as in the Safe $\lambda$-Calculus. We show that terms of
the Safe \pcf\ fragment are denoted by incrementally-justified
strategies and we give the key elements for a possible extension of
the result to Safe \ialgol.

\bibliographystyle{plainnat}
\bibliography{../transfer/gamesem,../transfer/modelchecking,../transfer/proganalys,../transfer/higherorder,prgconf}

\end{document}
