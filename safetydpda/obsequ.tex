\documentclass{article}
\usepackage{a4wide}
\usepackage{amsmath, amsthm, amssymb}

\newcommand\nat{\mathbb{N}}
\newcommand\eop{{\sf eop}}
\newcommand{\betared}{\rightarrow_\beta}
\newcommand{\encode}[1]{\ulcorner #1 \urcorner}

%pcf
\newcommand\ialgol{{\textsl{IA}}}
\newcommand\pcf{\textsl{PCF}}
\newcommand\pcfcond{\texttt{cond}}
\newcommand\pcfsucc{\texttt{succ}}
\newcommand\pcfpred{\texttt{pred}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{prop}[thm]{Proposition}

\author{William Blum}
\title{Observational equivalence is undecidable for the Safe non-finitary fragment of $\ialgol_2 + Y_1$}

\begin{document}
\maketitle

\section{Undecidabilty of observational equivalence for $\ialgol_2 + Y_1$}

In \cite{Ong02}, Ong shows that observational equivalence for finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is undecidable by reducing the Queue-Halting problem to the obvservational equivalence of two $\ialgol_2 + Y_1$ programs. Similarly, it is possible to show that observational equivalence for the Safe non-finitary fragment of $\ialgol_2 + Y_1$ is undecidable.


We fix a finite alphabet $\Sigma = \{ a_1, \ldots, a_p \}$. A queue program is a finite sequence of instructions that manipulate a queue data-structure. 
A program $P$ is a sequence of $n$ instructions for some $n\in \nat$. For $1 \leq i \leq n$, $P i$ denotes the $i^{\sf th}$ instruction of the sequence $P$. There are four possible kinds of instruction: halting, enqueuing, dequeuing and branching. The set of instructions is formally defined as:
$$ \mathcal{I} = \{ {\tt halt} \} \cup
\{ {\tt enqueue \ } a \ | \ a \in \Sigma \}
\cup \{ {\tt dequeue} \} \cup \{ {\tt goto\ } l {\tt\ if\ first =\ } a \ | \ l \in 1..n, a \in \Sigma \}
 $$


The operational semantics is described using a set of states $ \{ \eop \} \cup 1..n \times \Sigma^* $. The state $\eop$ corresponds to the final state at which the program stops. A state of the form $(i,x) \in 1..n \times \Sigma^*$ indicates that the queue's content is given by the sequence $x$ and that the next instruction to be executed by the machine is $P i$. The empty queue is denoted by $\epsilon$ and for any sequence $x \in \Sigma^*$, the first element of $x$ corresponds to the element that has been \emph{first} enqueued (i.e. the queue is fed at the right-end side and consumed at the left-end side). The rules defining the operational semantics are:
\begin{eqnarray*}
(i,x) \mbox{ with } P i = {\tt halt} &\longrightarrow& \eop \\
(i,x) \mbox{ with } P i = {\tt enqueue\ } a &\longrightarrow& (i+1,x \cdot a) \\
(i,\epsilon) \mbox{ with } P i = {\tt dequeue } &\longrightarrow& \eop \\
(i,a \cdot x) \mbox{ with } P i = {\tt dequeue } &\longrightarrow& (i+1,x) \\
(i,\epsilon) \mbox{ with } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (i+1,\epsilon) \\
(i,b \cdot x) \mbox{ with } a \neq b \mbox{ and } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (i+1,b \cdot x) \\
(i,a \cdot x) \mbox{ with } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (l,a \cdot x)
\end{eqnarray*}


We now describe a transformation which, given a queue-program $P$, produces an \ialgol\ term $M_P$ that simulates $P$ in the sense that $P \Downarrow$ if and only if $M_P \rightarrow^* \eop$.

We fix a distinguished element $\bot$ denoting the end of the queue. Let $\Sigma^\bot = \Sigma \cup \{ \bot \}$. We assume that an injective function $\encode{\underline{\ }}$ is defined that encodes  the
elements of $\Sigma^\bot$ into $\nat$. It can for instance be defined as follows:
\begin{eqnarray*}
\encode{\underline{\ }} : \Sigma^\bot &\longrightarrow& 0..p \\
 \bot &\mapsto& 0 \\
 a_k &\mapsto& k \ , \mbox{for } k \in 1..p \ .
\end{eqnarray*}

We say that a $\ialgol_2$-term $M$ computes a sequence $s \in {(\Sigma^\bot)}^\omega$ if and only if 
$M k \betared^* \encode{s k}$ for all $k\in \nat$.

We now identify a queue content $s \in \Sigma^*$ with the infinite sequence $s \bot^\omega \in \Sigma^\omega$. In the \ialgol\ program that we are about to define, a queue content $s \in \Sigma^*$ will be represented by a term $\hat{s}$ that computes $s \bot^\omega$.

Each instruction $c$ of $\mathcal{I}$ is encoded uniquely into a natural number $\encode{ c }$. The following table give an example of such a (injective) function:
\begin{center}
\begin{tabular}{c|c|c|c|c}
$c \in \mathcal{I}$ & {\tt halt} & {\tt dequeue } & {\tt enqueue} $a_i$ &  {\tt goto} l {\tt if first=} $a_i$ \\ \hline
$\encode{ c } \in \nat$ & $0$ & $1$ & $1+i$ & $1+p + n.l +i$ \\
\end{tabular} 
\end{center}
where $1 \leq i \leq p, 1 \leq l \leq n$.

Let us fix a queue-program $P$ with $n$ instructions. 
The code of $P$ is compiled into the following \pcf\ program $\hat{P}$
which maps an index $i$ to the encoding of the $i^{\sf th}$ instruction of $P$:
\begin{equation}
\hat{P} = \lambda i .  {\sf match\ } i {\sf \ with\ } 
   0 \rightarrow \encode{ P 0 } 
  \ | \ldots \ | n \rightarrow \encode{ P n }  | \_ \rightarrow \encode{\bot}
\end{equation} 

We now define a \pcf\ program which interprets the queue-program $P$ given  its compiled form $\hat{P}$.
\begin{eqnarray*}
SIM = Y ( \lambda f i x . {\sf match\ } \hat{P} i  {\sf \ with\ }   \\
 \encode{ \tt halt }&\rightarrow& \encode{\eop} \\
| \encode{ {\tt enqueue\ } a_1 } &\rightarrow& f (i+1) ( \lambda j . {\sf if} j = \underline{\sf length}\ x\ {\sf then\ } \encode{a_1} {\sf\ else\ } x j ) \\
| \ldots \\
| \encode{ {\tt enqueue\ } a_p } &\rightarrow& f (i+1) ( \lambda j . {\sf if} j = \underline{\sf length}\ x\ {\sf then\ } \encode{a_p} {\sf\ else\ } x j ) \\
| \encode{ {\tt dequeue } } &\rightarrow& f (i+1) (\lambda j . x (j+1) ) \\
| \encode{ {\tt goto\ } l {\tt\ if\ first=\ } a_1 } &\rightarrow&  
{\sf if\ } \underline{\sf length}\ x = 0 {\ \sf then\ } f (i+1) x \\
&&{\sf else\ if\ } \encode{a_1} = x 0 {\sf\ then\ } f l x \\
&&{\sf else\ } f (i+1) x \\
| \ldots \\
| \encode{{\tt goto\ } l {\tt\ if\ first=\ } a_p} &\rightarrow&  
{\sf if\ } \underline{\sf length}\ x = 0 {\ \sf then\ } f (i+1) x \\
&&{\sf else\ if\ } \encode{a_p} = x 0 {\sf\ then\ } f l x \\
&&{\sf else\ } f (i+1) x \\
)\ 0\ (\lambda j . 0)
\end{eqnarray*}

where $f: (o,(o,o),o)$, $i:o$, $x:(o,o)$ and $\encode{\eop}$ is defined to be some \ialgol\ natural number constant.
$$ \underline{\sf  length}  = Y( \lambda f x k . {\sf if\ } x k = \encode{\bot} {\sf\ then\ } 0 {\sf\ else\ } 1 + (f x (k+1)))$$

Note that the test of equality of two natural numbers is definable in $\pcf_2$ since the substraction operation is  also definable (by recursion). Moreover, it is easy to verify that the corresponding term is safe.


It is easy to show that $SIM \betared^* \encode{\eop}$ if and only if $P \rightarrow^* \eop$. Therefore since $SIM$ is a safe $\pcf_2$ 
non-finitary (variable $i$ is unbounded) term, we have the following result:
\begin{theorem}
Observational equivalence for Safe (non-finitary) $\pcf_2$ is undecidable.
\end{theorem}
Since $SIM$ is also an $\ialgol_2 + Y_1$ term, we have:
\begin{corollary}
Observational equivalence for Safe (non-finitary) $\ialgol_2 + Y_1$ is undecidable.
\end{corollary}

\section{Does this imply that 2-DPDA equivalence is undecidable?}

The simply-typed $\lambda$-calculus augmented with a $Y$-combinator written $\lambda^\rightarrow + Y$ is as expressive as recursion schemes in the sense that any ground type term of $\lambda^\rightarrow + Y$ with redexes of order $n$ at most can be encoded into an order-$n$ recursion scheme. Furthermore, the transformation is such that safe terms correspond to safe recursion schemes.

For instance any number $n \in \nat$ represented in $\lambda^\rightarrow + Y$ using the Church Numerals $\encode{n}$ can also be transformed into a recursion scheme whose value tree is a flat tree over the alphabet $\Sigma = \{s:o\rightarrow o, z:o\}$ representing the word $s^n z$. 


Similarly, if \pcf\ could also be encoded into an equivalent recursion scheme then we could transform $SIM$ into a safe recursion scheme. Consequently \footnote{In \cite{KNU02} it is shown that order-$n$ safe recursion schemes are as expressive as $n$-DPDA and the author give an effective transformation in both direction.}, we could build a 2-DPDA computing $SIM$ and a 2-DPDA computing $\encode{\eop}$. And since Queue-Halting is undecidable, this would imply that equivalence of 2-DPDA is undecidable.

Instead of trying to see whether \pcf\ terms can be encoded into recursion schemes, we can look at the equivalent problem of whether \pcf\ constants can be simulated in $\lambda^\rightarrow + Y$?''.

It is well-known that the Church Numeral representation does not permit
to represent the predecessor function in $\lambda^\rightarrow$ \cite{DBLP:journals/jacm/FortuneLO83}. It is however possible to represent the predecessor function provided that we allow a different representation of input and output numbers \cite{DBLP:journals/jacm/FortuneLO83}.
Unfortunately, the substraction function is not definable in $\lambda^\rightarrow$ (equivalently  the equality test function $\lambda xy. {\sf if\ } x = y {\sf\ then\ } u {\sf\ else\ } v$ is not definable) \cite{DBLP:journals/jacm/FortuneLO83}.
Hence \pcf\ cannot be simulated into the simply-typed $\lambda$-calculus $\lambda^\rightarrow$.

Would the $Y$ combinator help to fill the gap? i.e. Can \pcf\ be simulated in  $\lambda^\rightarrow + Y$?  

It does not seem so. As we have just seen, substraction -- which is definable in $\pcf$  by recursion and using the conditional operator $\pcfcond$ -- is not definable in $\lambda^\rightarrow$. Throwing in the recursion
can  be useful only if we have some destruction function, such as the predecessor function, permitting to make recursive call with decreasing parameters (otherwise the function would not terminate or would not compute substraction correctly). Hence we are bound to use a numeral representation
that can differ from input to output. But then recursion becomes useless since we work with simple types and therefore a recursively defined function accepts numeral parameters encoded in a fixed representation whereas the predecessor changes the representation of numbers, thus preventing any decreasing recursive call to happen.

%Suppose that equality test is definable by recursion by an the expression of  the form  $Y (\lambda f x y . e)$. 
%
%A \emph{recursive call} in $e$ is an occurrence of $f$ in $e$.
%A recursive call is \emph{decreasing} if it is of the form $f t_x t_y$ where $t_x$ and $t_y$ denote $\lambda$-expressions in which $x$ and $y$ may occur free and such that for all $n_x, n_y \in \nat$: $t_x [\encode{n_x},\encode{n_x} /x,y] \betared^* \encode{m_x}$ and $t_y[\encode{n_x},\encode{n_x} /x,y] \betared^* \encode{m_y}$ for some $m_x,m_y \in \nat$ with  $m_x < n_x \vee  m_y < n_y$. 
%
%We can assume that all recursive calls $f t_x t_y$ are such that
%$t_x$ and $t_y$ depends either on $x$ or $y$ or both (otherwise the recursive call can just be replaced by the $\beta$-normal form of $Y (\lambda f x y . e) t_x t_y$). 
%
%In order to guarantee termination, at least one of the recursive call to $f$ in $e$ must be decreasing. This suggests that in order to define $e$, one needs to have access to a deconstructing function such as the predecessor function. Such function can only be encoded if we allow input and output value to have different representations.

\subsection{Other approach}

Another approach would consist in proving that the set of traversals of a closed Safe \pcf\ term of ground type with redexes of order $n$ at most can be encoded by an order $n$-DPDA by adapting the construction of \cite{KNU02}. It is not sure whether this is possible. If so then this would imply undecidability of equivalence of order $2$-DPDA.



\cite{citeulike:622637}


\bibliographystyle{plain}
\bibliography{../transfer/current/gamesem,lambdacalculus}

\end{document}
