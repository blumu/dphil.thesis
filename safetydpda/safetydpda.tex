\documentclass{article}
\usepackage{amssymb}
\usepackage{pst-tree}



% computation tree, eta normal form, traversals
\newcommand{\aux}[1]{\lceil #1\rceil}
\newcommand{\betared}{\rightarrow_\beta}
\newcommand{\syneq}{\equiv}

% back pointer using psttricks
\newcommand{\bkptr}[2][nodesep=0pt]{\ncarc[linewidth=0.4pt,offset=-2pt,nodesep=0pt,ncurv=1,arcangleA=-#2, arcangleB=-#2,#1]{->}}
\newcommand{\bklabel}[1]{\mput*{\mbox{{\tiny $#1$}}}}
\newcommand{\bklabelc}[1]{\Bput[1pt]{\mbox{{\tiny $#1$}}}}
\newcommand\treelabel[1]{\mput*{\mbox{{\small $#1$}}}}

% ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\ialgolmnew{\ialgol-$\{\ianew\}$}
\newcommand\iaseqcom{$\tt{seq_{com}}$}
\newcommand\iaseqexp{$\tt{seq_{exp}}$}
\newcommand\iaseq{\texttt{seq}}
\newcommand\iaskip{\texttt{skip}}
\newcommand\iaderef{\texttt{deref}}
\newcommand\iaassign{\texttt{assign}}
\newcommand\iadone{\texttt{done}}
\newcommand\iarun{\texttt{run}}
\newcommand\iawrite{\texttt{write}}
\newcommand\iaread{\texttt{read}}
\newcommand\iaok{\texttt{ok}}
\newcommand\iamkvar{\texttt{mkvar}}
\newcommand\ianew{\texttt{new}}
\newcommand{\ianewin}[1]{\texttt{new}\ #1\ \texttt{in}}
\newcommand\iabool{\texttt{bool}}
\newcommand\iawhile{\texttt{while}}
\newcommand\iado{\texttt{do}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}

% pcf
\newcommand\pcf{\textsf{PCF}}
\newcommand\pcfcond{\texttt{cond}}
\newcommand\pcfsucc{\texttt{succ}}
\newcommand\pcfpred{\texttt{pred}}


\begin{document}

\section{The correspondence theorem for PCF}

\subsection{Computation tree}
For PCF terms, we have define the computation tree to be the least upper bound of the computation trees of its approximants. Equivalently, it can be defined as follows. Consider a term of the form $Y_A F$ where $F:A\rightarrow A$ and $A = (A_1,\ldots,A_n,o)$.
We have $Y_A F \betared F (Y_A F)$.
We define the eta-normal form $\aux{Y_A F}$ of $Y_A F$ to be the unique infinite term satisfying the recursive equation $X \syneq \lambda \overline{x}: \overline{A} . \aux{F} X \aux{x_1} \ldots \aux{x_n} $
where $\overline{x} = x_1 \ldots x_n$ are fresh variables.
The computation tree $\tau(Y_A F)$ is the infinite tree verifying the equation 
$\tau =  \lambda \overline{x}: \overline{A} . \tau X \overline{x}$ (consequently we have $\tau(Y_A F) = \tau(F (Y_A F))$).

Take $F \syneq \lambda f x. f x$. We have:
$$\aux{Y F} \syneq \lambda x . \aux{F} \aux{Y F} \lambda.x \syneq \lambda x. (\lambda f x. f \lambda.x ) \aux{Y F} \lambda.x$$ therefore its computation tree is the solution of the equation in $\tau$: $$\tau = \lambda x . (\lambda f x. f \lambda.x) \ \tau \ \lambda.x \ .$$


Our eventual goal is to derive a finite transition system (such as a DPDA) that recognizes the set of traversals of the compuation tree. In the simply typed lambda calculus, this can be achieved by creating a DPDA whose states are the nodes of the computation tree.
In the PCF case however, a term containing a Y combinator has an infinite computation tree and therefore the construction of a finite DPDA seems less straightforward.
To remedy this problem, we introduce an alternative definition of computation tree for Safe PCF terms.

\subsection{Alternative version of the computation tree}

In order to handle the Y combinators, we introduce a new kind of abstraction node. Such node is labelled $\lambda \overline{x}$ where each variable occurring in $\overline{x}$ is either a standard variable or a ``recursion variable''.
Recursion variables are surrounded by parenthesis in order to distinguish them from standard ones. The set of labels $L$ is therefore given by the following grammar:
\begin{eqnarray*}
L &::=& \lambda\ V_{abs}^*\ |\ @\ |\ \mathcal{V} \\
V_{abs} &::=& \mathcal{V}\ |\ (\mathcal{V})
\end{eqnarray*}
where $\mathcal{V}$ is a countable set of variables.


A term of the form $Y_A (\lambda f. M)$ where $f,M:A$ will be written  $\lambda (f) . M$. Ground type recursion can also be represented using this notation. For instance the \iawhile operator of Idealized Algol 
$\iawhile\ C\ \iado\ I \syneq Y( \lambda f. \pcfcond\ C\ \iaskip\ (\iaseq I f))$ will be written $\lambda (f) . \pcfcond\ C\ \iaskip\ (\iaseq I f)$.


To construct the computation tree of a PCF term, we first compute the $\eta$-normal form as usual except for the Y combinator case which is treated as follows. 
For each term $Y_A F$ where $F:A\rightarrow A$, let  $\aux{F} = \lambda f \overline{x} M$ where $f:A$ and $M:o$. The eta-normal form of $Y_A F$ is defined to be
$\aux{Y_A F} = \lambda (f) \overline{x} M$.
The computation tree is then obtained from the eta-normal form in the standard way.

The definition of the  order of an abstraction node does not change: it is the order of the term represented by the subtree rooted at this node. In other word, the order 
of $\lambda \overline{x}$ is the same as order of node $\lambda \overline{y}$ where $\overline{y}$ is the sublist of $\overline{x}$ obtained by filtering out the recursion variables.

The numbering of variables bound in a $\lambda$-node labelled $\lambda \overline{x}$ is as follows: the $i^{\sf th}$ standard variable in $\overline{x}$ is denoted by $i$ and the
the $i^{\sf th}$ recursion variable in $\overline{x}$ 
is denoted by $(i)$. The links in a justified sequence of nodes are labelled accordingly.

We can now define a notion of traversals adapted to this new kind of computation tree as follows. All the traversal rules are kept unmodified. The recursion variables in the $\lambda$-nodes are automatically ignored by each rule since such variables are numbered differently from standard variables. In particular, the (Var) rules only applies to non-recursion variables. 
We add a new rule to handle recursion variable:

{\bf ($Var_{rec}$)}
If  \raisebox{0cm}[0.6cm]{$t' \cdot \rnode{n}{n} \cdot
    \rnode{l}{\lambda \overline{x}}  \ldots
    \rnode{f}{f_i}  \bkptr[ncurv=0.6]{50}{f}{l} \bklabel{(i)}$} is a traversal for some \emph{recursion} variable $f_i$ bound by $\lambda \overline{x}$ then
    so is
\raisebox{0cm}[0.55cm]{
    $t' \cdot \rnode{n}{n} \cdot
    \rnode{l}{\lambda \overline{x}}  \ldots
    \rnode{f}{f_i} \cdot
    \rnode{letai}{\lambda \overline{x}}
     \bkptr[ncurv=0.6]{50}{f}{l} \bklabel{(i)}
    $}.

The node visited by this rule has no pointer associated to it (strictly speaking the resulting sequence is therefore not a justified sequence of nodes).




The original definition of PCF computation tree permitted us to prove the Correspondence Theorem straightforwardly by reducing it to the special case of the simply typed lambda-calculus (without recursion) through the use of approximants. The counterpart is that traversals were defined over infinite computation trees.

With our finite version of computation trees, it is not obvious to see which uncovering of moves gives rises to a correspondence with the set of traversals.
However, after performing a proper reduction, it will become obvious that the set of reductions of traversals of the finite computation tree is equal to the set of reductions of 
traversals of the standard computation tree.
Therefore the correspondence theorem concerning the \emph{unrevealed} game semantics still holds.

\subsection{Consistence of the two version}

Let us write $\tau$ for the computation tree corresponding to the original definition of computation tree and $\tau'$ the finite version of the computation tree.
Let $r$ denote the root of $\tau$ and $r'$ denote the root of $\tau'$.

We write $N^{\upharpoonright r}$ for the set of nodes of $\tau$ that are hereditarily enabled by $r$ and $N'^{\upharpoonright r'}$ for the set of nodes of $\tau'$ that are hereditarily enabled by $r'$.

We define a mapping $\alpha :N'^{\upharpoonright r} \longrightarrow N^{\upharpoonright r}$ as follows.

%If the term does not contain any subterm of the form $Y F$ then the two trees $\tau$ and $\tau'$ are identical and 
%$\alpha$ is just the identity function.
%If the term contains a
%
%$\alpha(r') = r$ and for each variable $x$ bound by $r'$, 

\end{document}
