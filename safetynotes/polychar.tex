\documentclass{article}
\usepackage{a4wide}
\usepackage{amsmath, amsthm, amssymb}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\encode}[1]{\ulcorner #1 \urcorner}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}

\author{William Blum}
\title{The Numerical Functions representable in the Safe Simply Typed Lambda Calculus are exactly the polynomials}

\begin{document}
\maketitle

In \cite{citeulike:622637}, Schwichtenberg showed that 
numerical functions representable in the Simply Typed Lambda Calculus are exactly the multivariate polynomials \emph{extended with the conditional function}:
\begin{theorem}
The functions representable by $\lambda$-expressions of type $I\rightarrow I \rightarrow \ldots \rightarrow I$ where $I = ((o,o),o,o)$ are exactly the functions generated by the constants $0$ and $1$ using the operations addition, multiplication and conditional.
\end{theorem}

We prove that if we limit ourselves to Safe terms, the representable functions are exactly the multivariate polynomials:
\begin{theorem}
The functions representable by Safe $\lambda$-expressions of type $I\rightarrow I \rightarrow \ldots \rightarrow I$ where $I = ((o,o),o,o)$ are exactly the functions generated by the constants $0$ and $1$ using the operations addition and multiplication.
\end{theorem}
\begin{proof}
Numbers constants are encoded using Church Numerals: $\encode{n} = \lambda s z. s^n z$. 
Addition: for $n,m \in \nat$, $\encode{n+m} = \lambda \alpha^{(o,o)} x^o . (\encode{n} \alpha) (\encode{m} \alpha x)$. Multiplication: $\encode{n . m} = \lambda \alpha^{(o,o)} . \encode{n} (\encode{m} \alpha)$.
All these terms are safe and clearly any multivariate polynomial $P(n_1, \ldots, n_k)$ can be computed by composing the addition and multiplication terms as appropriate.

We now prove the converse. We consider safe lambda terms of type $I\rightarrow I  \rightarrow I$ which corresponds to polynomials with 2 variables. It is straightforward to generalize to $I^n \rightarrow I$ (i.e. polynomial with $n$ variables) for $n>2$.
 
Consider a Safe $\lambda$-term $U:I\rightarrow I\rightarrow I$. Without lose of generality we can assume that $U = \lambda x y \alpha z. u$ where $u$ is a safe term of ground type in $\beta$-normal form with $fv(u) \subseteq \{ x, y, z, \alpha \}$.

\emph{Notation:} Let $T$ be a set of terms of type $\tau \rightarrow \tau$ and $T'$ be a set of terms of type $\tau$ then $T \cdot T'$ denotes the set of terms $\{ s s' : \tau \ | \ s \in T \wedge s' \in T' \}$. For $k\in\nat$, $T^k \cdot T'$ denotes  $\{ s_1( \ldots (s_k s'))  \ | \ s_1, \ldots, s_k \in T \wedge s' \in T' \}$, in particular $T^0 \cdot T' = T'$. We   define $T^*\cdot T' = \Union_{k \in \omega} T^k \cdot T'$.

Let us write $Sub^\tau$ for the set of sub terms of $u$ of type $\tau$ where $\tau$ ranges in $\{ o; (o,o); I  \}$. Clearly since $u$ is in $\beta$-normal form, $Sub^o \cup Sub^{(o,o)} \cup Sub^I$ is exactly the set of sub terms of $u$.
We have $Sub^I = \{ x, y\}$, $Sub^{(o,o)} = A \cup \{ s s' \ | \ s \in Sub^I \wedge s' \in Sub^{(o,o)} \}$ and
$Sub^o = \{ z \} \cup \{ s s' \ | \ s \in Sub^{(o,o)} \wedge s' \in Sub^o \}$ where $A = \{ \alpha \} \cup \{ \lambda a^o . b^o \mbox{ for some variables } a,b:o \}$. 

In other words we have:
\begin{eqnarray*}
Sub^I &=& \{ x, y\} \\
Sub^{(o,o)} &=&  A \cup Sub^I \cdot Sub^{(o,o)} \\
Sub^o &=& \{ z \} \cup Sub^{(o,o)} \cdot Sub^o
\end{eqnarray*}
Hence: $Sub^{(o,o)} = (Sub^I)^* \cdot A$ and $Sub^o = (Sub^{(o,o)})^* \cdot \{ z \} = (\{ x, y\}^* \cdot A)^* \cdot \{ z \}$.

Since $u$ is in $Sub^o$, we have $u \in (\{ x, y\}^l \cdot A)^r \cdot \{ z \}$ for some $l,r \in \nat$.
We prove by induction on $r \in \nat$ that for all $m,n \in\nat$, $u[\encode{m}, \encode{n}/x,y] =_\beta \alpha^{P(m,n)} z$ for some polynomial $P$ (therefore $U \encode{m} \encode{m}  = \lambda \alpha z . \alpha^{P(m,n)} z = \encode{P(m,n)}$ i.e. $U$ computes $P$).


\begin{itemize}

\item \emph{Base case:} If $r = 0$ then $u = z$, thus $U$ encodes the constant function $0$.

%If $r >0$ and $l=0$ then 
%$u = s_1 ( \ldots (s_r ( z)))$ for some $s_1,\ldots s_r \in A$.
%Since $u$ is in $\beta$-normal form we have $s_1 = \alpha$ and since $u$ is safe, for all $2 \leq i \leq r$, $s_i$ is either $\alpha$ or $\lambda a . a$ ($u$ would be unsafe if a term of the form $\lambda a . b$ with $b\neq a$ occurred at an operand position). Therefore $u = \alpha^i z$ for some $1 \leq i \leq r$ and thus $U$ computes the constant function $i$.

\item \emph{Step cases:} Let $r>0$. We have
 $u \in (\{ x, y\}^l \cdot A) \cdot \left( (\{ x, y\}^l \cdot A)^{r-1} \cdot \{ z \} \right)$. Thus $u = t t'$ for some $t \in \{ x, y\}^l \cdot A$ and $t' \in
(\{ x, y\}^l \cdot A)^{r-1} \cdot \{ z \}$. By the induction hypothesis, $t' = \alpha^{P'(m,n)} z$ for some polynomial $P'$.

We have $t[\encode{m}, \encode{n}/x,y] = (\encode{k_1} (\ldots (\encode{k_l} s)))$ where for $1 \leq i \leq l$, $k_i = m$ or $k_i = n$ and $s \in A$.

Since $u$ is in $\beta$-normal form, $l=0$ implies $s = \alpha$ 
(otherwise $u = s t'$ would contain a redex).
Therefore if $s \neq \alpha$ then $s=\lambda a . b$ and $l>0$ which means that $s$ occurs in an operand position. But since $u$ is safe the variable $b$ must necessarily be abstracted in $s$, hence $a=b$ and $s =  \lambda a . a = \underline{i}^{(o,o)}$.

\begin{itemize}
\item Suppose $s= \underline{i}^{(o,o)}$.
For any $n \in \nat$, we have $\encode{n} \underline{i}^{(o,o)} =_\beta \underline{i}^{(o,o)}$ therefore $t[\encode{m}, \encode{n}/x,y] =_\beta \underline{i}^{(o,o)}$ and $u[\encode{m}, \encode{n}/x,y] = t [\encode{m}, \encode{n}/x,y] t' [\encode{m}, \encode{n}/x,y] =_\beta t' [\encode{m}, \encode{n}/x,y] =_\beta \alpha^{P'(m,n) z}$.

Thus $U$ computes $P'(m,n)$.

\item Suppose $s=\alpha$. 
We have
$\lambda \alpha . t[\encode{m}, \encode{n}/x,y] = \lambda \alpha . (\encode{k_1} (\ldots (\encode{k_l} \alpha))) =_\beta \encode{k_1 \times \ldots \times k_l}$.

Hence  $u[\encode{m}, \encode{n}/x,y] = \encode{k_1 \times \ldots \times k_l} (\alpha^{P'(m,n)} z)=_\beta \alpha^{k_1 \times \ldots \times k_l + P'(m,n)} z$

Thus $U$ computes $m^j . n^{l-j} + P'(m,n)$ for some $0\leq j \leq l$.
\end{itemize}
\end{itemize}
\end{proof}

\begin{corollary}
The conditional operator $C:I\rightarrow I\rightarrow I$ verifying the following equations:
\begin{eqnarray*}
C t y z &\rightarrow_\beta& y \mbox{, if } t \rightarrow_\beta \encode{0} \\
C t y z &\rightarrow_\beta& z \mbox{, if } t \rightarrow_\beta \encode{n+1}
\end{eqnarray*}
is not definable in the Safe Simply Typed $\lambda$-Calculus.
\end{corollary}



\bibliographystyle{plain}
\bibliography{../bib/gamesem,../bib/higherorder,../bib/lambdacalculus}


\end{document}
