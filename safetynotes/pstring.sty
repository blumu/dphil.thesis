\NeedsTeXFormat{LaTeX2e}
% Created by William Blum on 28 January 2007
% Version 0.02

\ProvidesClass{pstring}[2007/02/14 Package for representing pointer-strings]

\newif\ifpstricks
\DeclareOption{pstricks}{\pstrickstrue}
\DeclareOption{pgf}{\pstricksfalse}
\ExecuteOptions{pstricks}
\ProcessOptions

\ifpstricks
    % Implement pointer string using pstricks
    \RequirePackage{pstricks}
    \RequirePackage{pst-node}
\else
    % Implement pointer string using pgf
    \RequirePackage{pgf}
\fi

\edef\TheAtCode{\the\catcode`\@}
\catcode`\@=11

\newif\ifwriteprologue

\def\@nil{}
\ifpstricks

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Version of the package relying on PSTRICKS

%%%% If the prologue .pro file is not present then
% we need to include the definitions of our custom Postscript procedures in the dvi file itself.
% The drawback is that the code for the postscript procedures will be copied for each use of the procedure.
\IfFileExists{pstring.pro}{\writeprologuefalse}{\writeprologuetrue}

\ifwriteprologue
  \newwrite\prologuefile
  \openout\prologuefile = pstring.pro
  \newlinechar = `\^^J
  %\chardef\percent = `\%
 	%\write\prologuefile{\percent!^^J}
   %\write\prologuefile{\percent PostScript prologue for pstring.sty.^^J}
  %\write\prologuefile{\percentFor distribution, see pstring.^^J}
\fi

% The macro \pstr@def creates a macro named #1 where #1 is the name of a postscript procedure and #2 is the postscript code for the procedure.
\def\pstr@def#1<#2>{\ifwriteprologue
	% prologue absent: dump the content of the postscript code
	\write\prologuefile{/#1 { #2 } def}
	\fi
	% prologue present: just dump the name of the postscript command (the code being already defined in the .pro file)
	\@namedef{#1}{#1 }
}



% TODO : I should move the following 3 macros to a prologue .pro file in order to avoid multiple instanciation of them for each link that is created in the document!
\pstr@def{pstr@GetEdge}< dup 0 eq
{ pop begin
%%%%% WB: the cosinus and the sinus are set to 1 and 0 which correspond to a direction going toward the top of the page. This way, the node position computed by the procedure NodePos will correspond exactly to the middle of the top line of the node box (the coordinates returned by NodePos are relative to the center of the node box).
  %1 0 NodeMtrx dtransform CM idtransform
  %exch atan sub dup sin /Sin ED cos /Cos ED /NodeSep ED NodePos
%%%%% BECOMES
 pop 1 /Sin ED 0 /Cos ED /NodeSep ED NodePos
%%%%%
NodeMtrx dtransform CM idtransform
end }
{ 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse >


\pstr@def{pstr@GetEdgeA}< NodeSepA AngleA NodeA NodeSepTypeA \pstr@GetEdge
%%%% WB: The offset is not computed the same way as in pst-node: it is an horizontal offset instead of an offset along the line (AB). Thus the line
%   OffsetA AngleA AddOffset yA add /yA1 ED xA add /xA1 ED
%%%% becomes:
yA add /yA1 ED xA add OffsetA add /xA1 ED
% This last line computes the absolute position of the connector ending by adding up its relative position to the position of the center of the node box plus the horizontal offset.
%%%%
>

\pstr@def{pstr@GetEdgeB}< NodeSepB AngleB NodeB NodeSepTypeB \pstr@GetEdge
% OffsetB AngleB AddOffset yB add /yB1 ED xB add /xB1 ED
 yB add /yB1 ED xB add OffsetB sub /xB1 ED
>


\pstr@def{pstr@NCCurve}<%
%%%%%% Redirect the call to \pstr@GetEdgeA  and \pstr@GetEdgeB instead of \tx@GetEdgeA and \tx@GetEdgeB
\pstr@GetEdgeA \pstr@GetEdgeB
xA1 xB1 sub yA1 yB1 sub Pyth
2 div dup
3 -1 roll mul /ArmA ED mul /ArmB ED
/ArmTypeA 0 def /ArmTypeB 0 def GetArmA GetArmB
xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end
xB2 yB2 xB1 yB1 tx@Dict begin ArrowB end
curveto
/LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ] cvx def
/LPutPos { t LPutVar BezierMidpoint } def
/HPutPos { { HPutLines } HPutCurve } def
/VPutPos { { VPutLines } HPutCurve } def>


\ifwriteprologue
  %\write\prologuefile{^^J\% END pstring.pro^^J}
  \closeout\prologuefile
\fi



% We define a new pstricks command: ncHarc.
% The H is for "horizontal". It acts as ncarc
% except that the angle parameter
% angleA (resp. angleB) specifies the angle between the X axis
% and the tangent to the arrow at point A (resp B) instead
% of the angle between the line (AB) and the tangent of the arrow  at A (or B).
%
% This kind of arc is not really usefull for graphs however it is easier to specify angles like this for links in justified sequences.
\def\ncHarc{\pst@object{ncHarc}}
\def\ncHarc@i{\check@arrow{\ncHarc@ii}}
\def\ncHarc@ii#1#2{\nc@object{Open}{#1}{#2}{.5}{%
%yB yA sub xB xA sub \tx@Atan
  180
\psk@arcangleA\space sub /AngleA ED
\psk@arcangleB\space %sub 180 add
/AngleB ED
\psk@ncurvB\space \psk@ncurvA\space \pstr@NCCurve
%\tx@NCCurve
}}

% Create a link using psttricks
\newcommand{\link}{\@ifstar
                     \linkStar%
                     \linkNoStar%
}
\newcommand{\linkNoStar}[2][]{
\edef\options{#1}
\ifx\options\@empty
\def\opt{[linewidth=0.4pt,offset=-2pt,nodesep=0pt,arcangleA=-#2, arcangleB=-#2]}
\else
\def\opt{[linewidth=0.4pt,offset=-2pt,nodesep=0pt,arcangleA=-#2, arcangleB=-#2,#1]}
\fi
\expandafter\ncarc\opt{->}
}

% the starred version uses ncHarc instead of ncarc.
\newcommand{\linkStar}[2][]{
\edef\options{#1}
\ifx\options\@empty
\def\opt{[linewidth=0.4pt,offsetA=0pt,offsetB=2pt,nodesep=1pt,arcangleA=#2, arcangleB=#2]}
\else
\def\opt{[linewidth=0.4pt,offsetA=0pt,offsetB=2pt,nodesep=1pt,arcangleA=#2, arcangleB=#2, #1]}
\fi
\expandafter\ncHarc\opt{->}
}

% Label the last link created
\newcommand{\lnklabel}{\@ifstar
                     \lnklabelStar%
                     \lnklabelNoStar%
}
\newcommand{\lnklabelStar}[1]{\mput*{\mbox{{\tiny $#1$}}}}
\newcommand{\lnklabelNoStar}[1]{\Bput[1pt]{\mbox{{\tiny $#1$}}}}





%\edef\OpenSqBrCode{\the\catcode`\[}
%\edef\CloseSqBrCode{\the\catcode`\]}
\begingroup
%\catcode`\@=11
%\catcode`&=\active
%\catcode`\[=\active
%\catcode`\]=\active
%\catcode`-=\active

\newbox\pstr@tempbox
\newdimen\pstr@tempdim

%%%%%%%%%%%%%%%%
%% First way of creating a pointer string:
%  \Pstr[0.4cm][1pt]{ (b) this (a-b,45) that }

\gdef\Pstr{\@ifnextchar[{\Pstr@i}{\Pstr@ii[0cm][1pt]}}
% Pstr with one optional parameter
\gdef\Pstr@i[#1]{\@ifnextchar[{\Pstr@ii[#1]}{\Pstr@ii[#1][1pt]}}
% Pstr with two optional parameters
% [#1] specifies the amount of vertical space to add to the box
% containing the pointer string.
% [#2] specifies the distance between the node and the arc
% #3 contains the specification of the nodes and pointers of the sequence.
\gdef\Pstr@ii[#1][#2]#3{%
\begingroup
 \setlength\pstr@tempdim{#1}%
 \def\pstr@arcoptions{#2}%
\setbox\pstr@tempbox\hbox\bgroup$%
\Pstr@ParseSpecification#3(@-@,@){}\@nil
 %\Pstr@ParseSpecification#2(@-@,@){@}\@nil\ignorespaces
$\egroup%
 \ht\pstr@tempbox\pstr@tempdim
 \box\pstr@tempbox
\endgroup
}

% Parse the specification of the pointer string.
% #1 stuff to be typset in the pointer string
% #2 a new node definition
% #3 node content
\gdef\Pstr@ParseSpecification#1(#2)#3{%
 #1% dump the stuff
 % parse the node specification
 \Pstr@ParseNodeSpecif#2-,#3\@nil
 % proceeds to the rest of the specification.
 \@ifnextchar\@nil{\@gobble}{\Pstr@ParseSpecification}
}

% Parse a node specification
\gdef\Pstr@ParseNodeSpecif#1-#2,{%
% create the node only if it is not the dummy node (@-@,@){@}
\if#1@
 \expandafter\Pstr@skipdummynode
\else
  % if a target node is specified then create a link for it:
  \def\dst{#2}
  \ifx\dst\@empty \Pstr@skipdstangle{#1}%
  \else \Pstr@createlink{#1}{#2}
  \fi
\fi
}
%%%%% auxiliary macros for node specification parsing
\gdef\Pstr@skipdummynode#1-,#2\@nil{}
\gdef\Pstr@skipdstangle#1#2\@nil{ \rnode{#1}{#2} }
% create a new node together with a link
%  #1 node name
%  #2 link destination name
%  #3 link arc angle
%  #4 node content
\gdef\Pstr@createlink#1#2#3-,#4\@nil{
\rnode{#1}{#4}%
\edef\angle{#3}%
\ifx\angle\@empty\else\link*[nodesep=\pstr@arcoptions]{\angle}{#1}{#2}\fi
}

%%%%%%%%%%%%%%%%
%%Second way of creating a pointer string:
%  \pstr[raiseamount][nodesep]{ sequencespecification }
% example:
%  \pstr[0.4cm][1pt]{ \lnk(b) this \lnk(a-b,45) that }

\gdef\pstr{\@ifnextchar[{\pstr@i}{\pstr@ii[0cm][1pt]}}
% pstr with one optional parameter
\gdef\pstr@i[#1]{\@ifnextchar[{\pstr@ii[#1]}{\pstr@ii[#1][1pt]}}
% pstr with two optional parameters
\gdef\pstr@ii[#1][#2]#3{%
\begingroup
 \setlength\pstr@tempdim{#1}%
 \def\pstr@arcoptions{#2}%
 \setbox\pstr@tempbox\hbox{$#3$}%
 \ht\pstr@tempbox\pstr@tempdim
 \box\pstr@tempbox
\endgroup
}
\gdef\lnk(#1)#2{\Pstr@ParseNodeSpecif#1-,#2\@nil}

\endgroup

\@addtofilelist{pstring.pro}
\special{header=pstring.pro}


\else
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Version of the package relying on PGF (the Tikz interface is not used)

% Create a new node with pgf:
%   #1 text preceding the node
%   #2 name of the node
%   #3 content of the node
\def\pstr@createpgfnode#1#2#3{%
  \pgfsetfillcolor{white!100}%
  \pgfsetshapeinnerxsep{1pt}%
  \pgfsetshapeinnerysep{0.6pt}%
  \pgfnode{rectangle}{base west}{\color{black}${}#1{}$}{#2@Next}{\pgfusepath{discard}}%
  \pgftransformshift{\pgfpointanchor{#2@Next}{base east}}%

  \pgfnode{rectangle}{base west}{\color{black}${}#3{}$}{#2}{\pgfusepath{discard}}%
  \pgftransformshift{\pgfpointanchor{#2}{base east}}% 
}


% Draw an arrow with PGF
%    #1 angle
%    #2 source node name
%    #3 target node name
%    #4 label
\def\pstr@createpgfarrow#1#2#3#4{%
\def\angleB{#1}
\count255=180 \advance \count255 by -\angleB
\def\angleA{\number\count255}
\def\ptA{\pgfpointdiff{\pgfpoint{0.5pt}{0pt}}{\pgfpointanchor{#2}{north}}}% shift the end of the arrow a bit to the right
\def\ptB{\pgfpointanchor{#3}{north}}
\def\bendpt{ \pgfpointintersectionoflines
{\ptA}{\pgfpointadd{\ptA}{\pgfpointpolar{\angleA}{1cm}}}
{\ptB}{\pgfpointadd{\ptB}{\pgfpointpolar{\angleB}{1cm}}}}
% control points
%\def\cptC{\bendpt}
%\def\cptD{\bendpt}

\pgfextracty{\pstr@mydimA}{\ptA}
\pgfextracty{\pstr@mydimB}{\ptB}
\pgfextracty{\pstr@mydimC}{\bendpt}
\def\maxdim{\ifdim\pstr@mydimA>\pstr@mydimB \pstr@mydimA \else \pstr@mydimB \fi}
\advance \pstr@mydimC by \maxdim
\divide \pstr@mydimC by 2 % mydimC now contains (max(y_A, y_B) + y_C)/2

% control points
\def\cptC{ \pgfpointintersectionoflines{\ptA}{\bendpt}
{\pgfpoint{0pt}{\pstr@mydimC}}{\pgfpoint{16pt}{\pstr@mydimC}}}
\def\cptD{ \pgfpointintersectionoflines{\ptB}{\bendpt}
{\pgfpoint{0pt}{\pstr@mydimC}}{\pgfpoint{16pt}{\pstr@mydimC}}}


%%%% draw using two halves of parabolas
  %\pgfpathmoveto{\ptA}\pgfpathparabola{\pgfpointdiff{\ptA}{\bendpt}}{\pgfpointdiff{\bendpt}{\ptB}}%
  %\color{orange} \pgfusepath{stroke}%
%%%%
%%%% draw using lines
  %\pgfpathmoveto{\ptA}\pgflineto{\bendpt}\pgflineto{\ptB}%
  %\color{black} \pgfusepath{stroke}%
%%%%
%%%% draw using bezier curves
  \pgfpathmoveto{\ptA}\pgfpathcurveto{\cptC}{\cptD}{\ptB}%
  \color{red} \pgfusepath{stroke}%
%%%%



%%% Put the label on the link if there is one
\def\label{#4}%
\ifx\label\@empty%
\else%
  \pgfsetfillcolor{white!100}
  \pgfsetshapeinnerxsep{1pt}%
  \pgfsetshapeinnerysep{0pt}%
  %\pgftransformshift{\bendpt} % position the label at the bendpoint
  \pgftransformshift{\pgfpointcurveattime{0.5}{\ptA}{\cptC}{\cptD}{\ptB}} % position the label at half-way on the curve
  \pgfnode{rectangle}{mid}{\color{black} \label}{}{\pgfusepath{fill}}%
\fi
}

\newdimen\pstr@mydimA
\newdimen\pstr@mydimB
\newdimen\pstr@mydimC
\newtoks\pstr@ptrlist

\begingroup

%%%%%%%%%%%%%%%%
%% Parser for the succint syntax. 

%  Example of use: \Pstr[0.4cm][1pt]{ (b) this (a-b,45,label) that }

\gdef\Pstr{\@ifnextchar[{\Pstr@i}{\Pstr@ii[0cm][1pt]}}
% Pstr with one optional parameter
\gdef\Pstr@i[#1]{\@ifnextchar[{\Pstr@ii[#1]}{\Pstr@ii[#1][1pt]}}
% Pstr with two optional parameters
% [#1] ignored in this mode (in pstricks mode: specifies the amount of vertical space to add to the box
% containing the pointer string).
% [#2] ignored in this mode (in pstricks mode: specifies the distance between the node and the arc
% #3 contains the specification of the nodes and pointers in the sequence).
\gdef\Pstr@ii[#1][#2]#3{%
\begin{pgfpicture}%
  \pgfsetbaseline{0pt}%
  \pgfsetshapeminwidth{0cm}%
  \pgfsetshapeminheight{0cm}%
  \pgfsetshapeinnerxsep{0pt}%
  \pgfsetshapeinnerysep{0.3pt}%
  \pgfsetarrows{-stealth}%
  \pgfsetlinewidth{0.3pt}%
  \pstr@ptrlist={}% Create an empty list of links.
  \Pstr@ParseSpecification#3(@-@,@,@){}\@nil%
  \the\pstr@ptrlist% dump the list of links.
\end{pgfpicture}%
}

% Parse the specification of the pointer string.
% #1 stuff to be typset in the pointer string
% #2 a new node definition
% #3 node content
\gdef\Pstr@ParseSpecification#1(#2)#3{%
 % parse the node specification
 \Pstr@ParseNodeSpecif#1(#2-,,)#3\@nil
 % proceeds to the rest of the specification.
 \@ifnextchar\@nil{\@gobble}{\Pstr@ParseSpecification}
}

% Parse a node specification
% #1  stuff to be dumped (not part of the node specification)
% #2-#3,   node specification: #2 source #3 target
\gdef\Pstr@ParseNodeSpecif#1(#2-#3,{%
% if it is the the dummy node (@-@,@,@){@} then skip it
\if#2@
  \def\suite{\Pstr@skipdummynode}
\else
  % if a target node is specified then create the link for it.
  \edef\target{#3}
  \ifx\target\@empty
    \def\suite{\Pstr@skiplinkparam{#1}{#2}}
  \else 
    \def\suite{\Pstr@parselinkparam{#1}{#2}{#3}}
  \fi
\fi
\suite
}

%%%%% auxiliary macros for parsing node specification
% In the following, #1 should contains: @,@){@}
\gdef\Pstr@skipdummynode#1-,,)#2\@nil{}

% In the following #1 and #2 have been parsed already
%  #1 dump
%  #2 source node
%   #3 link angle parameter (should be empty)
%   #4 link label parameter (should be empty)
%   #5 node content
\gdef\Pstr@skiplinkparam#1#2#3,#4)#5\@nil{%
\pstr@createpgfnode{#1}{#2}{#5}
}

% In the following, #1, #2 and #3 have been parsed already, we are now parsing the link parameters
%  #1 dump
%  #2 source node
%  #3 target node name
%   #4 link arc angle
%   #5 link arc label
%   #6 node content
\gdef\Pstr@parselinkparam#1#2#3#4,#5-,,)#6\@nil{%
\pstr@createpgfnode{#1}{#2}{#6}
\edef\angle{#4}%
\ifx\angle\@empty \else 
% add the arrow to the list of arrows
\toks0={\pstr@createpgfarrow{#4}{#2}{#3}{#5}}%
\edef\act{\noexpand\pstr@ptrlist={\the\pstr@ptrlist \the\toks0}}%
\act
\fi
}

%%%%%%%%%%%%%%%%
%%Second way of creating a pointer string:
%  \pstr[raiseamount][nodesep]{ sequencespecification }
% example:
%  \pstr[IGNORED][IGNORED]{ \lnk(b) this \lnk(a-b,45) that }

\gdef\pstr{\@ifnextchar[{\pstr@i}{\pstr@ii[0cm][1pt]}}
% pstr with one optional parameter
\gdef\pstr@i[#1]{\@ifnextchar[{\pstr@ii[#1]}{\pstr@ii[#1][1pt]}}
% pstr with two optional parameters
\gdef\pstr@ii[#1][#2]#3{%
\begin{pgfpicture}%
  \pgfsetbaseline{0pt}%
  \pgfsetshapeminwidth{0cm}%
  \pgfsetshapeminheight{0cm}%
  \pgfsetarrows{-stealth}%
  \pgfsetlinewidth{0.3pt}%
  #3%
\end{pgfpicture}%
}

% Commands to be used directly by the user of the package
\gdef\nd#1(#2){\pstr@createpgfnode{#1}{#2}}
\gdef\lnk{\pstr@createpgfarrow}

%\gdef\lnk(#1)#2{\Pstr@ParseNodeSpecif#1-,#2\@nil}

\endgroup


\fi %%% \ifpstricks  ... \else ...


\catcode`\@=\TheAtCode\relax


