\input{safeia.pre}

\psset{linecolor=darkGreen,linewidth=0.5pt}


\author{William Blum}
\title{Safe Idealized Algol}

\begin{document}
\maketitle

\section{Safe Idealized Algol}

In this section, we present two possible approaches to accommodate
the safety restriction to a language such as Idealized Algol
featuring block-variable constructs. This gives rise to two
different versions of ``Safe Idealized Algol''. In the first
version, all free variables are required to satisfy the safety
constraint whereas in the second version, only variables that are
not abstracted by the \ianew\ construct (including variables of type
\iavar) are required to satisfy the safety constraint.

We recall the definition of the \defname{safety constraint} $SC(\Gamma ; B)$
for some finite type alphabet $\Gamma$ and type $B$:
$$SC(\Gamma ; B) \quad \mbox{iff} \quad  \forall x:A\; \in \Gamma . \forall A' \in Pr(A) . \ord A' \geq \ord B$$
where $Pr(A)$ denotes the set of prime sub-types of $A$.



\subsection{Very Safe IA}

 The obvious way to define safety for IA terms consists in extending the safe lambda calculus by adding rules
 for constants and constructs of IA.
Said equivalently, it is the system of rules of IA where the
application and abstraction rules  have been restricted by the
safety constraint as in the safe lambda calculus. Let us call this
language \defname{Very Safe IA}. The rules are formally given in
Table \ref{tab:safeia_formrules}. The circled rules are those that
differs from their IA counterpart. Note that the $\rulename{new}$
rule remains the same: it does not have the side-condition present
in the $\rulename{abs}$ rule. Therefore the calculus allows us to
(indirectly) abstract variables of type \iavar\ without having to
meet the safety requirement.



\begin{FramedTable}
 {\bf Functional part}

$$ \rulename{var} \ \rulef{}{x : A  \vsafeentail x : A}
\qquad \rulename{wk} \ \rulef{\Gamma \vsafeentail s :
A}{\Delta \vsafeentail s : A} \quad \Gamma \subset
\Delta
$$

\begin{center}
\ovalbox{%
\begin{Bcenter}
$ \dps \rulename{app} \ \rulef{\Gamma  \vsafeentail s :
(A_1,\ldots,A_n,B) \quad \Gamma  \vsafeentail t_1 : A_1 \quad \ldots
\quad \Gamma  \vsafeentail t_n : A_n
} {\dps \Gamma  \vsafeentail s t_1 \ldots t_n : B} \quad SC(\Gamma ; B)$ \\[12pt]
$ \dps  \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \vsafeentail s : B} {\Gamma \vsafeentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \quad SC(\Gamma ; (A_1, \ldots ,A_n,B) )$
\end{Bcenter}
}
\end{center}
\smallskip


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\emptyset  \vsafeentail n :\texttt{exp}}
\qquad \rulename{succ} \ \rulef{\Gamma \vsafeentail M:\texttt{exp} }{\Gamma \vsafeentail \texttt{succ}\ M:\texttt{exp}}
\qquad \rulename{pred} \ \rulef{\Gamma \vsafeentail M:\texttt{exp} }{\Gamma \vsafeentail \texttt{pred}\ M:\texttt{exp}}$$

$$
\rulename{cond} \ \rulef{\Gamma\vsafeentail M : \texttt{exp} \quad \Gamma\vsafeentail N_1 : \texttt{exp} \quad \Gamma\vsafeentail N_2 : \texttt{exp} }{\Gamma \vsafeentail \texttt{cond}\ M\ N_1\ N_2}
\quad  \rulename{rec} \ \rulef{\Gamma \vsafeentail M : A\rightarrow A }{ \Gamma \vsafeentail Y_A M : A}$$

{\bf Imperative constructs}
$$ \rulename{seq} \ \rulef{\Gamma| \Gamma^{\ianew} \vsafeentail M : \texttt{com} \quad \Gamma \vsafeentail N :A}
    {\Gamma \vsafeentail \texttt{seq}_A \ M\ N\ : A} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulename{assign} \ \rulef{\Gamma \vsafeentail M : \texttt{var} \quad \Gamma \vsafeentail N : \texttt{exp}}
    {\Gamma \vsafeentail \texttt{assign}\ M\ N\ : \texttt{com}}
\qquad \rulename{deref} \
 \rulef{\Gamma \vsafeentail M : \texttt{var}}
    {\Gamma \vsafeentail \texttt{deref}\ M\ : \texttt{exp}}$$

$$ \rulename{new} \ \rulef{\Gamma , x : \texttt{var} \vsafeentail M : A}
    {\Gamma  \vsafeentail \texttt{new } x \texttt{ in } M : A} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulename{mkvar} \ \rulef{\Gamma \vsafeentail M_1 : \texttt{exp} \rightarrow \texttt{com} \quad \Gamma \vsafeentail M_2 : \texttt{exp}}
    {\Gamma \vsafeentail \texttt{mkvar } M_1\ M_2\ : \texttt{var}}$$

\caption{Formation rules for Very Safe IA}
\label{tab:verysafeia_formrules}
\end{FramedTable}
\bigskip

The result about the game semantics of Safe PCF extends trivially to
Very Safe IA:
\begin{proposition}
  Very Safe IA terms are denoted by closed P-i.j. strategies.
\end{proposition}
\begin{proof}
The proof is by structural induction over the structure of the term.
The functional rules and the arithmetic/recursion rules are treated
the same way as in the corresponding proof for the safe lambda
calculus and for Safe PCF respectively. For the imperative rules, we
observe that the strategies $assign$, $deref$, $mkvar$, $seq$ and
$cell$ are all closed P-i.j. The fact that pairing, tensor product
and strategy composition all preserve closed P-incremental
justification permits us to conclude.
\end{proof}


\subsection{Safe IA}

It turns out that the definition of Very Safe IA is needlessly
restrictive. Indeed, the major benefit of the safety constraint is
that it avoids variable renaming when performing substitution. To
achieve this, the safety constraint restricts the occurrences of the
variables in a term. In the present setting of a language with
imperative features, one can distinct two types of variables: The
``standard ones'' -- those that we abstract using
$\lambda$-abstraction, for instance $x$ in the term $\lambda x . x$;
and the ``imperative'' ones -- those that are used as identifier for
memory cell, also called block-allocated variables. We observe that
for this second type of variables there is no gain in imposing any
constraint since no substitution can ever occur for such variables
when performing reduction!

Inspired by this observation we can now identify a new fragment of
IA subsuming Very Safe IA and which incarnates the notion ``safety''
 more faithfully.

We introduce a new judgment of the form $\Gamma | \Gamma^{\ianew}
\safeentail M : A$ where the context is partitioned into two
components: The first component contains standard lambda calculus
variables; the second component contains block-allocated variable --
abstracted by an occurrence of the \ianew\ construct. The component
$\Gamma^{\ianew}$ contains variables of type \iavar\ only while the
other component can contain variables of any type including the type
\iavar. It is straightforward to redefine the typing rule of IA in
such a way that these two distinct contexts are maintained
appropriately. In particular the abstraction rule must only be able
to abstract variables taken from the first component of the context;
similarly the \ianew\ block construct must only be used to
``abstract'' variables from the block-variable context. The full
system of rules is given in Table \ref{tab:safeia_formrules}. The
rules that are circled correspond to those that differs from their
counterpart in Table \ref{tab:verysafeia_formrules}; the differences
being that:
\begin{itemize}
\item the rule $\rulename{abs}$ and $\rulename{new}$ can only
abstract variables from their respective context component;
\item the side-condition in $\rulename{abs}$ refers only to
the first context component.
\end{itemize}

\begin{FramedTable}
{\bf Functional part}

$$ \rulename{var} \ \rulef{}{x : A | \emptyset \safeentail x : A} \quad
\rulename{var^{\ianew}} \ \rulef{}{\emptyset | x : \iavar \safeentail x : \iavar} $$
$$
\rulename{wk} \ \rulef{\Gamma | \Gamma^{\ianew} \safeentail s : A}{\Delta | \Gamma^{\ianew} \safeentail s : A} \quad
\Gamma \subset \Delta \qquad
\rulename{wk^{\ianew}} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail s : A}{\Gamma| \Delta^{\ianew} \safeentail s : A} \quad
\Gamma^{\ianew} \subset \Delta^{\ianew}
$$

where $\Gamma^{\ianew}$ and $\Delta^{\ianew}$ are finite sets of variables
of type \iavar.

$$ \rulename{app} \ \rulef{\Gamma | \Gamma^{\ianew} \safeentail s : (A_1,\ldots,A_n,B) \quad
\Gamma | \Gamma^{\ianew} \safeentail t_1 : A_1 \quad \ldots \quad \Gamma | \Gamma^{\ianew} \safeentail t_n : A_n
} {\Gamma | \Gamma^{\ianew} \safeentail s t_1 \ldots t_n : B} \ SC(\Gamma ; B)$$

\begin{center}\ovalbox{$
 \rulename{abs} \ \dps  \rulef{\dps \Gamma, x_1 : A_1, \ldots, x_n : A_n |
\Gamma^{\ianew}
  \safeentail s : B} {\Gamma | \Gamma^{\ianew} \safeentail \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \ SC(\Gamma ; (A_1, \ldots ,A_n,B) )$}\end{center}


{\bf Arithmetic and recursion}
$$ \rulename{const} \ \rulef{}{\emptyset | \emptyset \safeentail n :\texttt{exp}}
\quad \rulename{succ} \ \rulef{\Gamma | \Gamma^{\ianew}\safeentail M:\texttt{exp} }{\Gamma| \Gamma^{\ianew} \safeentail \texttt{succ}\ M:\texttt{exp}}
\quad \rulename{pred} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M:\texttt{exp} }{\Gamma| \Gamma^{\ianew} \safeentail \texttt{pred}\ M:\texttt{exp}}$$

$$
\rulename{cond} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \texttt{exp} \quad \Gamma| \Gamma^{\ianew} \safeentail N_1 : \texttt{exp} \quad \Gamma| \Gamma^{\ianew} \safeentail N_2 : \texttt{exp} }{\Gamma| \Gamma^{\ianew} \safeentail \texttt{cond}\ M\ N_1\ N_2}
\quad  \rulename{rec} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : A\rightarrow A }{ \Gamma| \Gamma^{\ianew} \safeentail Y_A M : A}$$

{\bf Imperative constructs}
$$ \rulename{seq} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \texttt{com} \quad \Gamma| \Gamma^{\ianew} \safeentail N :A}
    {\Gamma| \Gamma^{\ianew} \safeentail \texttt{seq}_A \ M\ N\ : A} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulename{assign} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \texttt{var} \quad \Gamma| \Gamma^{\ianew} \safeentail N : \texttt{exp}}
    {\Gamma| \Gamma^{\ianew} \safeentail \texttt{assign}\ M\ N\ : \texttt{com}}
\qquad
 \rulename{deref} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M : \texttt{var}}
    {\Gamma| \Gamma^{\ianew} \safeentail \texttt{deref}\ M\ : \texttt{exp}}$$


\begin{center}\ovalbox{$
\rulename{new} \ \dps \rulef{\Gamma | \Gamma^{\ianew}, x :
\texttt{var} \safeentail M : A}
    {\Gamma | \Gamma^{\ianew} \safeentail \texttt{new } x \texttt{ in } M : A} \quad A \in \{ \texttt{com}, \texttt{exp}\} $}\end{center}

$$ \rulename{mkvar} \ \rulef{\Gamma| \Gamma^{\ianew} \safeentail M_1 : \texttt{exp} \rightarrow \texttt{com} \quad \Gamma| \Gamma^{\ianew} \safeentail M_2 : \texttt{exp}}
    {\Gamma| \Gamma^{\ianew} \safeentail \texttt{mkvar } M_1\ M_2\ : \texttt{var}}$$

\caption{Formation rules for Safe IA} \label{tab:safeia_formrules}
\end{FramedTable}

 We define \defname{Safe IA} as the subset of terms typable with
the system of rules of Table \ref{tab:safeia_formrules} for which
the block-variable context is empty. For convenience we introduce
the additional rule
$$ \rulef{\Gamma | \emptyset \safeentail M : A} {\Gamma \safeentail M : A}$$
so that Safe IA terms are exactly those denoted by judgments of the
form $\Gamma \safeentail M : A$.

\subsubsection{Examples}

Clearly Very Safe IA is a subset of Safe IA, the following example
showing that the inclusion is strict:

$$ \safeentail \lambda f^{(\iaexp \rightarrow \iacom) \rightarrow \iaexp} . \ianewin{i}\ f ( \lambda x . \iaassign\ i\ x ) : \iaexp$$
$$ \mbox{ but } \not \vsafeentail \lambda f^{(\iaexp \rightarrow \iacom) \rightarrow \iaexp} . \ianewin{i}\ f ( \lambda x . \iaassign\ i\ x ) : \iaexp \ .$$

\notetoself{Need more examples}

\subsubsection{Game-semantic denotation}

In this section, our aim is to extend the game-semantic result to
Safe IA:
\begin{proposition}
\label{prop:safeia_closedpij} Safe IA terms are denoted by closed
P-incrementally justified strategies.
\end{proposition}


Let us first introduce some definitions before proving this
proposition.

\begin{definition}[P-i.j. modulo $\mathfrak{M}$]
\label{def:pij_modulo} Let $\sigma$ be a strategy on some game $A$
and $\mathfrak{M}$ be a set of moves. We say that $\sigma$ is P-i.j.
modulo $\mathfrak{M}$ iff for all $s m \in \sigma$ with $m \not\in
\mathfrak{M}$, the play $s m$ is P-i.j.

Similarly we say that $\sigma$ is \emph{closed} P-i.j. modulo
$\mathfrak{M}$ iff for all $s m \in \sigma$ with $m \not\in
\mathfrak{M}$ the play $s m$ is \emph{closed} P-i.j.

Hence a strategy is P-i.j. if and only if it is P-i.j. modulo
$\emptyset$.
\end{definition}

Given a term $\Gamma | \Gamma^{\ianew} \safeentail M : A$, we write
$\sem{\Gamma | \Gamma^{\ianew} \safeentail M : A}$ to denote the
game denotation of the corresponding IA term {\it i.e.}
$\sem{\Gamma, \Gamma^{\ianew} \vdash M : A}$. Instead of showing
Proposition \ref{prop:safeia_closedpij} we will prove the following
more general result:
\begin{proposition}
\label{prop:safeia_closedpijmodulo} Let $\Gamma | \Gamma^{\ianew}
\safeentail M : A $ be a Safe IA term. Its denotation $\sem{\Gamma |
\Gamma^{\ianew} \safeentail M : A}$ is closed P-i.j. modulo
$\mathfrak{M}_{\Gamma^{\ianew}}$ where
$\mathfrak{M}_{\Gamma^{\ianew}}$ is the set of initial moves in
$\Gamma^{\ianew}$.
\end{proposition}

\begin{remark}
Since the context $\Gamma^{\ianew}$ contains variable of type
\iavar\ only, $\mathfrak{M}_{\Gamma^{\ianew}}$ contains only moves
of the form `$read$' or `$write_i$' for some $i\in \nat$.
\end{remark}

\begin{lemma}
\label{lem:leftcompos_preserv_pijmodulo}
 Let $\sigma : A \rightarrow
B$ and $\mu : B \rightarrow C$.
  Let $\mathfrak{M}$ be any set of order $0$ moves initial in $A$.
  If $\sigma$ is closed  P-i.j. modulo $\mathfrak{M}$ and $\mu$ is
  P-i.j. (resp. closed P-i.j.) then $\sigma \fatsemi \mu$ is P-i.j. (resp. closed P-i.j.) modulo $\mathfrak{M}$.
\end{lemma}
\notetoself{
\begin{proof}
Let us analyze the proof of compositionality for closed P-i.j.
strategies.

\end{proof}
}


\begin{lemma}
\label{lem:cellcomposition_preserve_pijmodulo} Let $\tau : I
\rightarrow C_2$, $\sigma : C_1 \otimes C_2 \rightarrow B$  and
$\mathfrak{M}$ be any set of order $0$ moves initial in $C_1 \otimes
C_2$.
  If $\tau$ is P-i.j. and
  $\sigma$ is P-i.j. (resp. closed P-i.j.) modulo $\mathfrak{M}$
  then $(id_{C_1} \otimes \tau) \fatsemi \sigma$ is P-i.j. (resp. closed P-i.j.) modulo $\mathfrak{M} \inter C_1$.
\end{lemma}
\notetoself{
\begin{proof}
\end{proof}
}


\notetoself{
\begin{proof}[Proof of Prop. \ref{prop:safeia_closedpijmodulo}]
By induction and and case analysis on the structure of Safe IA
terms:
\begin{itemize}
  \item[$\rulename{var}$, $\rulename{var^\ianew}$
  , $\rulename{wk}$, $\rulename{wk^\ianew}$]

  These cases are treated the same way as in the corresponding
  proof for the Safe Lambda Calculus.

  \item[$\rulename{app}$]

  \item[$\rulename{abs}$]




  \item[$\rulename{const}$]
  \item[$\rulename{succ}$]
  \item[$\rulename{pred}$]
  \item[$\rulename{cond}$]
  \item[$\rulename{rec}$]

  \item[$\rulename{seq}$]
  \item[$\rulename{assign}$]
  \item[$\rulename{deref}$]
  \item[$\rulename{new}$] $\Gamma | \Gamma^\ianew \safeentail \ianewin{x}\ M : B$.

Let $cell : I \rightarrow !\iavar$ denotes the ``storage cell''
strategy (see \cite{abramsky:game-semantics-tutorial}).  Let
$\sigma = \sem{\Gamma | \Gamma^\ianew, x : \iavar \safeentail M
: B}$.  We have $\sem{\Gamma | \Gamma^\ianew \safeentail
\ianewin{x}\  M : B} = (id_{\Gamma,\Gamma^\iavar} \otimes cell)
\fatcompos \sigma$. By induction hypothesis $\sigma$ is closed
P-i.j. modulo $\mathfrak{M}_{\Gamma^{\ianew} \otimes !\iavar}$
and one can easily check that $cell$ is P-incrementally
justified. Hence instancing Lemma
\ref{lem:cellcomposition_preserve_pijmodulo} with $\tau
\leftarrow cell$, $C_1 \leftarrow \Gamma \otimes  \Gamma^\ianew$
and $C_2\leftarrow !\iavar$ gives the desired result.
  \item[$\rulename{mkvar}$]

\end{itemize}
\end{proof}
}


\subsection{Algorithmic game semantics}

An important theorem (\cite{AM97a}) about the game-semantics model
of IA states that two IA terms are equivalent if and only if the set
of complete plays of their denotations are equal. This result has
been used in \cite{ghicamccusker00} to show that observational
equivalence for the $IA_2$ fragment of IA is decidable -- the set of
complete plays being representable by regular expressions. In
\cite{Ong02} it was shown that it is still decidable
 for $IA_3+Y_0$. Indeed, for this fragment, the set of complete plays becomes context-free
therefore the problem reduces to the DPDA equivalence problem which
is itself decidable (with an unknown complexity).

Imposing the safety condition should lead to some improvement in
complexity. The complexity of  Safe $IA_3$ (resp. Safe $IA'_3$) for
instance, must be lower than the complexity of the DPDA equivalence
problem. Moreover the fact that Safe $IA_3$ (resp. Safe $IA'_3$)
contains terms whose denotation is context free -- e.g. $\lambda f .
f (\lambda x .x )$ -- strongly suggests that its complexity is
strictly higher than the complexity of regular language equivalence.

Murawski \cite{Murawski2003} has shown that observational
equivalence for $\ialgol_4$ is undecidable. The proofs proceeds by
showing that the computations of $\Gamma$-machine -- some variation
of queue machines that are Turing complete -- are representable
using IA terms.

Does this result extend to the safe fragments? For Safe IA, it does,
simply because the $IA_4$ term exhibited in \cite{Murawski2003} to
represent computations of the $\Gamma$-machine is also a Safe IA
term. The same argument does not carry over to Very Safe IA since
the term is not typable in this language. We do not know whether
observational equivalence is decidable for Very Safe $IA_4$.



\subsection{Expressivity of Safe IA/Very Safe IA}

Murawski representability : Safe IA representable languages are
exactly the context free languages. For Very Safe IA however, we
believe that the representable languages are a proper subclass of
the context free languages.




\bibliographystyle{plain}
\bibliography{../bib/higherorder,../bib/gamesem,../bib/lambdacalculus}

\end{document}
