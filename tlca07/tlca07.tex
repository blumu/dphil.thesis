% the LaTeX macro package from Springer-Verlag for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
\documentclass{llncs}

%%% Safe lambda calculus
\newcommand\funto{\longrightarrow}
\newcommand\ord[1]{{\sf ord}(#1)}
\newcommand\rank[1]{{\sf rank}(#1)}
\newcommand\order[1]{{\sf order}(#1)}
\newcommand\slheight[1]{{\sf height}(#1)}
\newcommand\nparam[1]{{\sf nparam}(#1)}
\newcommand\level[1]{{\sf level}(#1)}
\newcommand\nat{\mathbb{N}}


\newcommand{\typear}{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(#1)}}


\newcommand\textbfit[1]{{\bf\em #1}\index{#1}}
\newcommand\blambda{\hbox{\boldmath $\lambda$}}
\newcommand\lterm[2]{{\blambda{#1}.{#2}}}
\newcommand\terms[2]{{\cal T}^{#1}(#2)}
\newcommand{\funsp}{\rightarrow}
\newcommand\seq[2]{{{#1} \vdash {#2}}}


\newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{#2}}


\begin{document}

\frontmatter          % for the preliminaries
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC


\mainmatter              % start of the contributions

\title{Game semantics of the Safe $\lambda$-calculus}

\titlerunning{Game semantics of the Safe $\lambda$-calculus}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used


\author{William Blum\inst{1} \and C.-H. Luke Ong\inst{2}}
%
\authorrunning{William Blum et al.}   % abbreviated author list (for running head)
%
%%%% modified list of authors for the TOC (add the affiliations)
\tocauthor{William Blum (University of Oxford), C.-H. Luke Ong (University of Oxford)}


\institute{Oxford University Computing Laboratory\\ Wolfson Building, Parks Road, Oxford, OX1 3QD, ENGLAND\\
\email{william.blum@comlab.ox.ac.uk\inst{1} luke.ong@comlab.ox.ac.uk\inst{2}} }

\maketitle              % typeset the title of the contribution

\newcommand\ialgol{\textsf{IA}}
\newcommand\pcf{\textsf{PCF}}
\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}
\pagestyle{empty}

% TLCA05:
%    Papers should not exceed 15 pages in Springer LNCS format.
%    An abstract (ASCII text) of no more than 150 words should be sent separately at least a weak before the paper submission deadline.

% LNCS:
%    The abstract should summarize the contents of the paper
%    using at least 70 and at most 150 words. It will be set in 9-point
%    font size and be inset 1.0 cm from the right and left margins.
%    There will be two blank lines before and after the Abstract. \dots

\begin{abstract}
The \emph{safety condition} has been introduced in \cite{KNU02} as a syntactic
restriction for higher-order recursion grammars that constrains the order
of the variables occurring in the grammar equations.

When transposed to the $\lambda$-calculus, the safety condition gives rise to the \emph{Safe $\lambda$-calculus}, a
strict sub-language of the $\lambda$-calculus (\cite{safety-mirlong2004}).

We present a new version of Safe $\lambda$-calculus and give a game-semantic
account of it. In particular we show that pointers are superfluous in the plays
of the game denotation of safe terms.
\end{abstract}

\section{Introduction and Related Work}

The \emph{Safety restriction} has been introduced in by Knapik, Niwi{\'n}ski and Urzyczyn in \cite{KNU02}
for the purpose of studying infinite trees generated by higher-order grammars.
Safety is very similar to the ``restriction of derived types'' which was introduced
by Damm in \cite{Dam82} however the formulation differs.

Safety is a syntactic restriction for higher-order grammars that
constrains the occurrences of the variables in the grammar
equations according to their order.
The definition of the Safety is a somewhat complex but it has an important algorithmic impact.
In particular, the authors of \cite{KNU02} proved that the Monadic Second
Order (MSO) theory of the term tree generated by a safe recursion
scheme of any order is decidable\footnote{In fact it has been shown
recently in \cite{OngLics2006} that it is also true for unsafe
recursion schemes.}. They also give the following nice automata-theoretic characterization of safety:
an infinite term is generated by a \emph{safe} higher-order grammar if and only if
it is generated by a level-$n$ pushdown automaton.


When transposed to the $\lambda$-calculus, the safety condition
gives rise to the \emph{Safe $\lambda$-calculus}, a strict
sub-language of the $\lambda$-calculus. A first version appeared in
the technical report \cite{safety-mirlong2004}. We propose a more
general and simpler version where term types are not required to be
homogeneous. A noteworthy feature of the Safe
$\lambda$-calculus is that no variable capture can occur when
performing substitution and therefore it is unnecessary to rename
variables when computing $\beta$-reductions.

Little is known about the Safe $\lambda$-calculus and there are many
problems that have yet to be studied concerning its
computational power, the complexity classes that it characterises,
its interpretation under the Curry-Howard isomorphism and its
game-semantic characterisation. This paper contributes to give an
answer to the last problem.


The difficulty in giving a game-semantic account of Safety lies in
the fact that it is a syntactic restriction whereas Game Semantics
is by essence a syntax-independent semantics. The solution consists
in finding a particular syntactical representation of terms on which
the plays of the game denotation can be represented.
To achieve this, we use ideas recently introduced in \cite{OngLics2006}: a term
is canonically represented by the abstract syntax tree of its
$\eta$-long normal form, referred as the \emph{computation tree}. A
computation is described by a justified sequence of nodes of the
computation tree respecting some formation rules and called a
\emph{traversal}. Traversals permit us to model $\beta$-reductions
without altering the structure of the computation tree via
substitution. A notable property is that \emph{P-view} (in the game-semantic sense) of traversals
corresponds to paths in the computation tree.

These notions permit us to establish a correspondence between the game semantics of a term and
the syntactic representation given by its computation tree.
More precisely, we show that traversals are just representations of the
uncovering of plays of the strategy denoting the term.
Then by defining an appropriate \emph{reduction} operation which eliminates traversal
nodes that are ``internal'' to the computation, we obtain an
isomorphism between the strategy denotation of a term and the set of
reductions of traversals of its computation tree.



Using that correspondence and after introducing the notion of \emph{incrementally-justified
strategies}, we are able to show that $\beta$-normal terms are \emph{safe} if and only if
their strategy denotation is incrementally-justified.
A consequence of this is that pointers in the game semantics of safe simply-typed terms can be recovered uniquely from the underlying sequences of moves.

\vspace{1cm}

\emph{Related work:} De Miranda's forthcoming thesis \cite{demirandathesis} proposes a unified framework for the study of higher-order grammars. The thesis contains a detailed analysis of the safety constrain at level 2. The reader is referred to it for a full account of the Safety condition for higher-order grammars.


\section{The Safe $\lambda$-calculus}
Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \funsp A$. Any type different from the base
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \funsp \cdots \funsp A_n \funsp o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the arity of $T$, written $arity(T)$, is
defined to be $n$.
The order of a type is defined by $\ord{o} = 0$ and
$\ord{A \funsp B} = \max(\ord{A}+1, \ord{B})$.

%Following \cite{KNU02}, we say that a type is homogeneous
%if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition
%that $\ord{A_1} \geq \ord{A_2}\geq \ord \geq \rank{A_n}$ and
%each $A_1$, \ldots, $A_n$ is homogeneous.





The \textbf{Safe $\lambda$-Calculus} is a sub-system of the
simply-typed $\lambda$-calculus. 
We use a set of sequents of the form $\Gamma \vdash M : A$ to represent
terms-in-context where $\Gamma$ is the context and $A$ is the type. Let
$\Sigma$ be a set of higher-order constants. We call \emph{safe term} any
simply-typed lambda term that is typable within the following system
of formation rules:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{const} \   \rulef{}{\vdash f : A} \quad f \in \Sigma
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash s : A}{\Delta \vdash s : A} \quad \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash s : (A_1,\ldots,A_n,B)
                                        \ \Gamma \vdash t_1 : A_1
                                        \  \ldots\  \Gamma \vdash t_n : A_n }
                                   {\Gamma  \vdash s t_1 \ldots t_n : B}
                                    \ 
                                   \ord{B} \leq \min \ord{\Gamma}$$
$$ \rulename{abs} \   \rulef{\Gamma, x_1 : A_1 \ldots x_n : A_n \vdash s : B}
                                   {\Gamma  \vdash \lambda x_1 \ldots x_n . s : (\overline{A},B)} \
                                   \ord{\overline{A},B} \leq \min \ord{\Gamma}$$

where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$.

%\begin{thm}[Correspondence theorem]
%\label{thm:corresp} The set of traversals of the computation tree is
%isomorphic to the set of uncovered plays of the game denotation of
%the term.
%\end{thm}

%\begin{thm}[Game-semantic characterisation of safety]
%\label{thm:gamesem_charact} Safe simply-typed terms in
%$\beta$-normal form have incrementally-bound computation trees.
%Reciprocally, a closed term in $\eta$-long normal form with an
%incrementally-bound computation trees is safe.
%\end{thm}

%\begin{cor}
%\label{cor:safeptrrecover} The pointers in the game semantics of
%safe simply-typed terms can be recovered uniquely from the
%underlying sequences of moves.
%\end{cor}

\section{Further work}

\subsection{Extension to Safe Idealized Algol}

%We define Safe \textsf{IA} to be the Safe $\lambda$-calculus
%augmented with the constants of Idealized Algol (\textsf{IA})
%\cite{Reynolds81} as well as a family of combinators $Y_A$ for every
%type $A$. We show that terms of the Safe \textsf{PCF}
%\cite{DBLP:journals/tcs/Plotkin77} fragment are denoted by
%incrementally-justified strategies and we give the key elements for
%a possible extension to full Safe \textsf{IA}.





\bibliographystyle{splncs}
\bibliography{../transfer/higherorder}

\end{document}
