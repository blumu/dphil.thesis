% the LaTeX macro package from Springer-Verlag for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
\documentclass{llncs}

%%% Safe lambda calculus
\newcommand\funto{\longrightarrow}
\newcommand\ord[1]{{\sf ord}(#1)}
\newcommand\rank[1]{{\sf rank}(#1)}
\newcommand\order[1]{{\sf order}(#1)}
\newcommand\slheight[1]{{\sf height}(#1)}
\newcommand\nparam[1]{{\sf nparam}(#1)}
\newcommand\level[1]{{\sf level}(#1)}
\newcommand\nat{\mathbb{N}}


\newcommand{\typear}{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(#1)}}


\newcommand\textbfit[1]{{\bf\em #1}\index{#1}}
\newcommand\blambda{\hbox{\boldmath $\lambda$}}
\newcommand\lterm[2]{{\blambda{#1}.{#2}}}
\newcommand\terms[2]{{\cal T}^{#1}(#2)}
\newcommand{\funsp}{\rightarrow}
\newcommand\seq[2]{{{#1} \vdash {#2}}}


\newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{#2}}

\newcommand\ialgol{\textsf{IA}}
\newcommand\pcf{\textsf{PCF}}


\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{dfn}{Definition}
%\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\newtheorem{exmp}[thm]{Example}


\begin{document}

\frontmatter          % for the preliminaries
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC


\mainmatter              % start of the contributions

\title{Game semantics of the Safe $\lambda$-calculus}

\titlerunning{Game semantics of the Safe $\lambda$-calculus}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used


\author{William Blum\inst{1} \and C.-H. Luke Ong\inst{2}}
%
\authorrunning{William Blum et al.}   % abbreviated author list (for running head)
%
%%%% modified list of authors for the TOC (add the affiliations)
\tocauthor{William Blum (University of Oxford), C.-H. Luke Ong (University of Oxford)}


\institute{Oxford University Computing Laboratory\\ Wolfson Building, Parks Road, Oxford, OX1 3QD, ENGLAND\\
\email{william.blum@comlab.ox.ac.uk\inst{1} luke.ong@comlab.ox.ac.uk\inst{2}} }

\maketitle              % typeset the title of the contribution

\pagestyle{empty}

% TLCA05:
%    Papers should not exceed 15 pages in Springer LNCS format.
%    An abstract (ASCII text) of no more than 150 words should be sent separately at least a weak before the paper submission deadline.

% LNCS:
%    The abstract should summarize the contents of the paper
%    using at least 70 and at most 150 words. It will be set in 9-point
%    font size and be inset 1.0 cm from the right and left margins.
%    There will be two blank lines before and after the Abstract. \dots

\begin{abstract}
The \emph{safety condition} has been introduced in \cite{KNU02} as a syntactic
restriction for higher-order recursion grammars that constrains the order
of the variables occurring in the grammar equations.

When transposed to the $\lambda$-calculus, the safety condition gives rise to the \emph{Safe $\lambda$-calculus}, a
strict sub-language of the $\lambda$-calculus (\cite{safety-mirlong2004}).

We present a new version of Safe $\lambda$-calculus and give a game-semantic
account of it. In particular we show that pointers are superfluous in the plays
of the game denotation of safe terms.
\end{abstract}

\section{Introduction and Related Work}

The \emph{Safety restriction} has been introduced in by Knapik, Niwi{\'n}ski and Urzyczyn in \cite{KNU02}
for the purpose of studying infinite trees generated by higher-order grammars.
Safety is very similar to the ``restriction of derived types'' which was introduced
by Damm in \cite{Dam82} however the formulation differs.

Safety is a syntactic restriction for higher-order grammars that
constrains the occurrences of the variables in the grammar
equations according to their order.
The definition of the Safety is a somewhat complex but it has an important algorithmic impact.
In particular, the authors of \cite{KNU02} proved that the Monadic Second
Order (MSO) theory of the term tree generated by a safe recursion
scheme of any order is decidable\footnote{In fact it has been shown
recently in \cite{OngLics2006} that it is also true for unsafe
recursion schemes.}. They also give the following nice automata-theoretic characterization of safety:
an infinite term is generated by a \emph{safe} higher-order grammar if and only if
it is generated by a level-$n$ pushdown automaton.


When transposed to the $\lambda$-calculus, the safety condition
gives rise to the \emph{Safe $\lambda$-calculus}, a strict
sub-language of the $\lambda$-calculus. A first version appeared in
the technical report \cite{safety-mirlong2004}. We propose a more
general and simpler version where term types are not required to be
homogeneous. A noteworthy feature of the Safe
$\lambda$-calculus is that no variable capture can occur when
performing substitution and therefore it is unnecessary to rename
variables when computing $\beta$-reductions.

Little is known about the Safe $\lambda$-calculus and there are many
problems that have yet to be studied concerning its
computational power, the complexity classes that it characterises,
its interpretation under the Curry-Howard isomorphism and its
game-semantic characterisation. This paper contributes to give an
answer to the last problem.


The difficulty in giving a game-semantic account of Safety lies in
the fact that it is a syntactic restriction whereas Game Semantics
is by essence a syntax-independent semantics. The solution consists
in finding a particular syntactical representation of terms on which
the plays of the game denotation can be represented.
To achieve this, we use ideas recently introduced in \cite{OngLics2006}: a term
is canonically represented by the abstract syntax tree of its
$\eta$-long normal form, referred as the \emph{computation tree}. A
computation is described by a justified sequence of nodes of the
computation tree respecting some formation rules and called a
\emph{traversal}. Traversals permit us to model $\beta$-reductions
without altering the structure of the computation tree via
substitution. A notable property is that \emph{P-view} (in the game-semantic sense) of traversals
corresponds to paths in the computation tree.

These notions permit us to establish a correspondence between the game semantics of a term and
the syntactic representation given by its computation tree.
More precisely, we show that traversals are just representations of the
uncovering of plays of the strategy denoting the term.
Then by defining an appropriate \emph{reduction} operation which eliminates traversal
nodes that are ``internal'' to the computation, we obtain an
isomorphism between the strategy denotation of a term and the set of
reductions of traversals of its computation tree.



Using that correspondence and after introducing the notion of \emph{incrementally-justified
strategies}, we are able to show that $\beta$-normal terms are \emph{safe} if and only if
their strategy denotation is incrementally-justified.
A consequence of this is that pointers in the game semantics of safe simply-typed terms can be recovered uniquely from the underlying sequences of moves.

\vspace{1cm}

\emph{Related work:} De Miranda's forthcoming thesis \cite{demirandathesis} proposes a unified framework for the study of higher-order grammars. The thesis contains a detailed analysis of the safety constrain at level 2. The reader is referred to it for a full account of the Safety condition for higher-order grammars.


\section{The Safe $\lambda$-calculus}
We consider simple types generated by the grammar $A
\, ::= \, o \; | \; A \funsp A$. Any type different from the ground
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \funsp \cdots \funsp A_n \funsp o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the arity of $T$, written $arity(T)$, is
defined to be $n$.
The order of a type is defined by $\ord{o} = 0$ and
$\ord{A \funsp B} = \max(\ord{A}+1, \ord{B})$.

%Following \cite{KNU02}, we say that a type is homogeneous
%if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition
%that $\ord{A_1} \geq \ord{A_2}\geq \ord \geq \rank{A_n}$ and
%each $A_1$, \ldots, $A_n$ is homogeneous.





The \textbf{Safe $\lambda$-Calculus} is a sub-system of the simply-typed $\lambda$-calculus formally defined by the definition that follows.
We use a set of sequents of the form $\Gamma \vdash M : A$ to represent
terms-in-context where $\Gamma$ is the context (a typed-alphabet) and $A$ is the type. We assume that a set
of higher-order constants $\Sigma$ is given.

\begin{dfn}[The Safe $\lambda$-calculus]
We call \emph{safe term} any simply-typed lambda term that is typable using the following
formation rules:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{const} \   \rulef{}{\vdash f : A} \quad f \in \Sigma
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash s : A}{\Delta \vdash s : A} \quad \Gamma \subset \Delta$$

$$ \rulename{app} \  \rulef{\Gamma \vdash s : (A_1,\ldots,A_n,B)
                                        \ \Gamma \vdash t_1 : A_1
                                        \  \ldots\  \Gamma \vdash t_n : A_n }
                                   {\Gamma  \vdash s t_1 \ldots t_n : B}
                                    \
                                   \ord{B} \sqsubseteq \ord{\Gamma}$$

$$ \rulename{abs} \   \rulef{\Gamma, x_1 : A_1 \ldots x_n : A_n \vdash s : B}
                                   {\Gamma  \vdash \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \
                                   \ord{A_1, \ldots ,A_n,B} \sqsubseteq \ord{\Gamma}$$

where in the side-conditions, $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$ and $c \sqsubseteq S$ is a notation for
``$c$ is a lower-bound for $S$''.
\end{dfn}

Note a first deviation from the standard definition of the simply-typed $\lambda$-calculus: it is possible to perform multiple applications at a time using the {\sf (app)} rule, and similarly to abstract several variables at a time using the {\sf (abs)} rule.
Of course, this change does not alter expressivity. However, at the same time, we have an additional condition
which constrains the possible occurrences of variables within a term. More precisely, the side-condition in the application rule and abstraction rules ensures that all variables in the context of the term being formed have order greater than the order of the term itself.



Note that there is no specific constraint on the term type. In particular, the type-homogeneity constraint that is used
in the definition of safe higher-order grammars in \cite{KNU02} is not required here.
In that regard, our formulation of the Safe $\lambda$-calculus differs from the one proposed in \cite{safety-mirlong2004}.
However if we add a further constraint ensuring that each type occurring in our rules is homogeneous then we obtain a calculus equivalent to the one of \cite{safety-mirlong2004}.




\begin{exmp}[Kierstead terms]
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y ))$ and
$M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where $x,y:o$ and $f:((o,o),o)$.
$M_2$ is not safe because in the subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which is smaller than $\ord{\lambda y . x} = 1$.
On the other hand, $M_1$ is safe as the following proof tree shows:
$$
 \rulef{
     \rulef{
        \rulef{}{f \vdash f} {\sf(var)}
        \
        \rulef{
             \rulef{
                \rulef{
                    \rulef{}{f \vdash f} {\sf(var)}
                }
                {f , x \vdash f } {\sf(wk)}
                \
                \rulef{
                    \rulef{
                        \rulef{}{y \vdash y} {\sf(var)}
                    }
                    {y \vdash \lambda y . y } {\sf(abs)}
                }
                {f , x \vdash \lambda y .y } {\sf(wk)}
             }
             {f , x \vdash f (\lambda y .y )} {\sf(app)}
        }
        { f  \vdash \lambda x . f (\lambda y .y )} {\sf(abs)}
     }
     {
        f  \vdash f (\lambda x . f (\lambda y .y ))} {\sf(app)}
     }
 { \vdash M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } {\sf(abs)}
$$
\end{exmp}

The following lemma is an immediate consequence of the definition
\begin{lem}
If $\Gamma \vdash M : A$ then every variable in $\Gamma$ occurring free in $M$ has order at least $ord(M)$.
\end{lem}

It is desirable to have an appropriate notion of reduction for our calculus. However the standard $\beta$-reduction rule is not adequate. Indeed, Safety is not preserved by $\beta$-reduction as the following example shows. Suppose that $x,y,z,y : o$ and $\varphi : (o,o,o)$ then the safe term $(\lambda x y . \varphi x y) z w$ $\beta$-reduces to $(\underline{\lambda y . \varphi z y}) w$ which is unsafe since the underline order-1 subterm  contains a free occurrence of the ground type variable $z$. However if we perform one more reduction we obtain the safe term
$\varphi z w$. This suggests an alternative notion of reduction that performs simultaneous reduction of consecutive $\beta$-redexes. We will define this reduction shortly.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the Safe
lambda calculus, a redex is a succession of several standard redexes:
\begin{dfn}[Safe redex]
We call \emph{safe redex} a safe term whose derivation tree has the following form:
$$   \rulef{
            \rulef{\rulef{\vdots}{\Gamma, \overline{x}\vdash M}}{\Gamma \vdash \lambda \overline{x} . M} (\sf{abs})
            \quad
            \rulef{\vdots}{\Gamma \vdash N_1}  \ \ldots \  \rulef{\vdots}{\Gamma \vdash N_l}
    }
    {
       \Gamma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
    } (\sf{app})
$$
where $\overline{x}$ denotes the list of variables $x_1\ldots x_n$ and $l\leq n$.
\end{dfn}

In other words a safe redex is a safe term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such that
the variable $\overline{x}$ are abstracted altogether by one occurrence of the rule $\rulename{abs}$ and the terms $(\lambda \overline{x} . M)$, $N_1$, $N_l$ are applied together at once using the $(\sf{app})$ rule
(and consequently each $N_i$ must be safe).

Note that the condition $l\leq n$ is not too restrictive. Indeed if
$l>n$ then the application rule is ``wider'' than the abstraction
and therefore it can be replaced by an application of exactly $n$
terms followed by another application for the remaining terms
$N_{n+1}, \ldots, N_l$.


The relation $\beta_s$ is defined on safe-redex: $(s\mapsto t) \in
\beta_s$ iff $s \equiv (\lambda \overline{x} . M) N_1 \ldots N_l$ is
a safe redex and $t \equiv \lambda x_l \ldots x_n . M \subst{N_1
\ldots N_l}{x_1 \ldots x_l}$. The safe $\beta$-reduction denoted by
$\betasred$ is the closure of the relation $\beta_s$ by
compatibility with the formation rules of the Safe
$\lambda$-Calculus. It is straightforward to show, as we did for the
homogeneous Safe $\lambda$-Calculus, that $\betasred \subseteq
\betared^*$.


\begin{lem}
\label{lem:safereduction} A safe redex reduces to a safe term.
\end{lem}

This lemma, which is a consequence of lemma
\ref{lem:subst_preserve_i}, is the counterpart of lemma
\ref{lem:homoh_safered_preserve_safety} in the homogeneous safe
lambda calculus. Their proofs are identical.






%%%%%%%%%%%%%%%%%%%%
With the traditional substitution, it is necessary to rename
variables when performing substitution on an abstraction in order to
avoid possible variable capture. As a consequence, in order to
implement substitution one needs to have access to an unbound number
of variable names. An interesting property of the homogeneous Safe
$\lambda$-Calculus is that variable capture never occurs when
performing substitution. In other words, the traditional
substitution can be safely replaced by the capture-permitting
substitution:


\begin{lem}[No variable capture]
\label{lem:homog_nocapture} In the Safe $\lambda$-Calculus, there is
no variable capture when performing the following capture-permitting
simultaneous substitution:
$$ M[N_1 / x_1 , \cdots, N_n / x_n] $$
provided that $\Gamma \union \overline{x} \vdash M$, $\Gamma \vdash  N_1, \cdots ,\Gamma \vdash  N_n$ are valid judgments.
\end{lem}

\begin{proof}
We prove the result by induction. The variable, constant and
application cases are trivial. For the abstraction case, suppose $M
= \lambda \overline{y} : \overline{A}. P$ where $\overline{y} = y_1
\ldots y_p$. The capture-permitting simultaneous substitution gives:
$$M \subst{\overline{N}}{\overline{x}} = \lambda \overline{y} . P
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright
I} \mbox{ where } I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y}
\}. $$


By the induction hypothesis there is no variable capture in $P
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright
I}$. Hence variable capture can only happen when the variable $y_j$
occurs freely in $N_i$ and $x_i$ occurs freely in $P$ for some $i
\in I$ and $j \in 1..p$. In that case, property
\ref{proper:safe_basic_prop} (ii) gives:
$$ \ord{y_j} \geq \ord{N_i} = \ord{x_i}$$

Moreover $i\in I$ therefore $x_i \not \in \overline{y}$ and since $x_i$ occurs freely in $P$, $x_i$ must also occur freely in the safe term
$\lambda \overline{y}. P$. Thus, property \ref{proper:safe_basic_prop} (ii) gives:
$$ \ord{x_i} \geq \ord{\lambda y_1 \ldots y_p . T} \geq 1+ \ord{y_j} > \ord{y_j}$$

which, together with the previous equation, gives a contradiction.
\end{proof}




%\begin{thm}[Correspondence theorem]
%\label{thm:corresp} The set of traversals of the computation tree is
%isomorphic to the set of uncovered plays of the game denotation of
%the term.
%\end{thm}

%\begin{thm}[Game-semantic characterisation of safety]
%\label{thm:gamesem_charact} Safe simply-typed terms in
%$\beta$-normal form have incrementally-bound computation trees.
%Reciprocally, a closed term in $\eta$-long normal form with an
%incrementally-bound computation trees is safe.
%\end{thm}

%\begin{cor}
%\label{cor:safeptrrecover} The pointers in the game semantics of
%safe simply-typed terms can be recovered uniquely from the
%underlying sequences of moves.
%\end{cor}

\section{Further work}

\subsection{Extension to Safe Idealized Algol}

%We define Safe \textsf{IA} to be the Safe $\lambda$-calculus
%augmented with the constants of Idealized Algol (\textsf{IA})
%\cite{Reynolds81} as well as a family of combinators $Y_A$ for every
%type $A$. We show that terms of the Safe \textsf{PCF}
%\cite{DBLP:journals/tcs/Plotkin77} fragment are denoted by
%incrementally-justified strategies and we give the key elements for
%a possible extension to full Safe \textsf{IA}.





\bibliographystyle{splncs}
\bibliography{../transfer/higherorder}

\end{document}
