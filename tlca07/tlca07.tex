% the LaTeX macro package from Springer-Verlag for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
\documentclass{llncs}
\usepackage{amssymb}
\usepackage{pst-tree}
\usepackage[all]{xy}
\usepackage{wrapfig}

%\usepackage{picins}
%\usepackage{floatflt}
%
 
% highlight for definition names
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

% reduction, substitution
\newcommand\betared{\rightarrow_\beta}
\newcommand\betasred{\rightarrow_{\beta_s}}
\newcommand\betaredtr{\twoheadrightarrow_\beta} % transitive closure of the beta reduction
\newcommand\subst[2]{\left[ #1/#2 \right]}
\newcommand\captsubst[2]{\{#1/#2 \}}

% computation tree, eta normal form, traversals
\newcommand{\elnf}[1]{\lceil #1\rceil} % eta long normal form
\newcommand\travset{\mathcal{T}rv}

% lambda calculus
%\newcommand\bot{\perp}
\newcommand{\encode}[1]{\overline{#1}}
\newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{\dps #2}}
\newcommand\rulefex[3][5pt]{\frac{\dps #2}{\stackrel{\rule{0pt}{#1}}{\dps #3}}}
\newcommand\ord[1]{{\sf ord}(#1)}
\newcommand\typear{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(#1)}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\nat{\mathbb{N}}


% game semantics
\newcommand{\sem}[1]{{[\![ #1 ]\!]}}
\newcommand{\intersem}[1]{{\langle\!\langle #1 \rangle\!\rangle}}

% logic
\newcommand\imp{\Longrightarrow}
\newcommand\zand{\wedge}
\newcommand\entail{\vdash}

% pcf and ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}
\newcommand\pcf{\textsf{PCF}}

% justified sequence of moves
\newcommand{\oview}[1]{\llcorner #1 \lrcorner}
\newcommand{\pview}[1]{\ulcorner #1 \urcorner}

% links using psttricks
\newcommand{\link}[2][nodesep=0pt]{\ncarc[linewidth=0.4pt,offset=-2pt,nodesep=0pt,ncurv=1,arcangleA=-#2, arcangleB=-#2,#1]{->}}
\newcommand{\lnklabel}[1]{\mput*{\mbox{{\tiny $#1$}}}}
\newcommand{\lnklabelc}[1]{\Bput[1pt]{\mbox{{\tiny $#1$}}}}
\newcommand{\arclabel}[1]{\mput*{\mbox{{\small $#1$}}}}

% trees
\newcommand{\tree}[2][levelsep=3.5ex]{\pstree[levelsep=3.5ex,#1]{\TR{#2}}}


\begin{document}

\frontmatter          % for the preliminaries
\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{} % additional mark in the TOC

\mainmatter              % start of the contributions

\title{The Safe $\lambda$-Calculus \\ {\small -- draft of \today\ -- }}

\titlerunning{The Safe $\lambda$-Calculus}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used


\author{William Blum\inst{1} \and C.-H. Luke Ong\inst{2}}
%
\authorrunning{William Blum et al.}   % abbreviated author list (for running head)
%
% modified list of authors for the TOC (add the affiliations)
\tocauthor{William Blum (University of Oxford), C.-H. Luke Ong (University of Oxford)}


\institute{Oxford University Computing Laboratory\\ Wolfson Building, Parks Road, Oxford, OX1 3QD, ENGLAND\\
\email{william.blum@comlab.ox.ac.uk\inst{1} luke.ong@comlab.ox.ac.uk\inst{2}} }

\maketitle              % typeset the title of the contribution

\pagestyle{empty}

% TLCA05:
%    Papers should not exceed 15 pages in Springer LNCS format.
%    An abstract (ASCII text) of no more than 150 words should be sent separately at least a weak before the paper submission deadline.

% LNCS:
%    The abstract should summarize the contents of the paper
%    using at least 70 and at most 150 words. It will be set in 9-point
%    font size and be inset 1.0 cm from the right and left margins.
%    There will be two blank lines before and after the Abstract. \dots

\begin{abstract}
We present a sub-language of the $\lambda$-calculus derived from the \emph{safety condition}, a syntactic restriction for higher-order grammars constraining occurrences of variables in the production rules according to their order \cite{KNU02}. 
Contrary to the original definition of safety, our calculus does not constrain types.
We show that it is $\alpha$-conversion free and propose an adequate notion of $\beta$-reduction that preserves safety.
In the vein of Schwichtenberg's result 
\cite{citeulike:622637}, we obtain that the numerical functions representable in our calculus are exactly the multivariate polynomials. Thus conditional is not definable.
Finally we give a game-semantic account of safety by showing that safe terms are denotated by \emph{P-incrementally-justified} strategies. 
Consequently pointers in the game semantics only start to be necessary at order $4$.
\end{abstract}


\section{Introduction}

\subsection{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and Urzyczyn in \cite{KNU02} for the purpose of studying infinite trees generated by higher-order grammars.
It is an equivalent formulation of the ``restriction of derived types'' introduced by Damm in \cite{Dam82}.\footnote{Level-$n$ tree grammars as defined by Damm correspond exactly to a subset of safe level-$n$ grammars -- namely the safe complete ones -- and every safe grammar corresponds to a safe complete one. The equivalence of two notions is shown in \cite{demirandathesis}.}
A higher-order grammar is said to be \emph{safe} if it obeys certain syntactical conditions that constrain the occurrences of the variables in the grammar equations according to their order. Furthermore, a condition called \emph{homogeneity} is imposed on the type of the grammar equations.
The formal definition is intricate and seems a bit odd but the safety condition has important algorithmic impacts.
For instance, the authors of \cite{KNU02} proved that the Monadic Second Order (MSO) theory of the term tree generated by a safe recursion scheme of any order is decidable\footnote{In fact it has been shown recently in \cite{OngLics2006} that it is also true for unsafe recursion schemes.}. They also give the following nice automata-theoretic characterisation of safety:
an infinite term is generated by a \emph{safe} higher-order grammar if and only if it is generated by a level-$n$ pushdown automaton.


When transposed to the $\lambda$-calculus, the safety condition
gives rise to the \emph{safe $\lambda$-calculus}, a strict
sub-language of the $\lambda$-calculus. A first version appeared in the technical report \cite{safety-mirlong2004}. We propose a more general and simpler version where terms are not required to be homogeneously typed. A noteworthy feature of the safe $\lambda$-calculus is that no variable capture can occur when performing substitution and therefore it is unnecessary to rename variables when computing $\beta$-reductions.

Little is known about the safe $\lambda$-calculus and there are many problems that have yet to be studied concerning its computational power, the complexity classes that it characterises, its interpretation under the Curry-Howard isomorphism and its game-semantic characterisation. This paper is a contribution to the last problem.


The difficulty in giving a game-semantic account of safety lies in the fact that it is a syntactic restriction whereas Game Semantics is by essence a syntax-independent semantics. The solution consists in finding a particular syntactical representation of terms on which the plays of the game denotation can be represented.
To achieve this, we use ideas recently introduced in \cite{OngLics2006}: a term is canonically represented by a certain abstract syntax tree of its $\eta$-long normal form referred as the \emph{computation tree}. This abstract syntax tree is specially designed to establish a correspondence with the game arena of the term. A computation is described by a justified sequence of nodes of the computation tree respecting some formation rules and called a \emph{traversal}. Traversals permit us to model $\beta$-reductions without altering the structure of the computation tree via substitution. A notable property is that \emph{P-view} (in the game-semantic sense) of traversals corresponds to paths in the computation tree.
We show that traversals are just representations of the uncovering of plays of the game-semantic denotation. We then define a \emph{reduction} operation which eliminates traversal nodes that are ``internal'' to the computation, this implements the counterpart of the hiding operation of game semantics. Thus, we obtain an isomorphism between the strategy denotation of a term and the set of reductions of traversals of its computation tree.

Using this correspondence between the game semantics of a term and the syntactic representation given by its computation tree, we show that $\beta\eta$-normal terms are \emph{safe} if and only if their strategy denotation is \emph{P-incrementally-justified}. A consequence of this is that P-moves' pointers can be recovered uniquely from the underlying sequences of moves and from O-moves' pointers.

\subsection{Related Work}

\subsubsection{The Safety Condition for Higher-Order Grammars}

We have already mentioned the result of Knapik \emph{et al.} in \cite{KNU02} that infinite trees generated by \emph{safe} higher-order grammars have decidable MSO theories. 
A natural question to ask is whether the \emph{safety condition} is really necessary. 
This has then been partially answered in \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not a requirement at level $2$ to guarantee MSO decidability. Also, for the restricted case of word languages, \cite{DBLP:conf/fossacs/AehligMO05} shows that level $2$ safe higher-order grammars are as powerful as (non-deterministic) unsafe ones. 
De Miranda's thesis \cite{demirandathesis} proposes a unified framework for the study of higher-order grammars and gives a detailed analysis of the safety constraint at level 2.

More recently, one of us obtained a more general result and showed that the MSO theory of infinite trees generated by higher-order grammars of any level, \emph{whether safe or not}, is decidable \cite{OngLics2006}.
Using an argument based on innocent game-semantics, he establishes a correspondence between the tree generated by a higher-order grammar called \emph{value tree} and a certain regular tree called  \emph{computation tree}. Paths in the value tree correspond to traversals in the computation tree.
Decidability is then obtain by reducing the problem to the acceptance of the (annotated) computation tree by a certain alternating parity tree automaton.
The approach that we follow in Sec. \ref{sec:correspondence} uses many ingredients introduced in this paper.


The equivalence of \emph{safe} higher-order grammars and
higher-order deterministic push-down automata
for the purpose of generating infinite trees \cite{KNU02}
has its counterpart in the general (not necessarily safe) case:
the forthcoming paper \cite{hague-sto07} establishes the equivalence of order-$n$ higher-order grammars and order-$n$ \emph{collapsible pushdown automata}. Those automata form a new kind of pushdown systems in which every stack symbol has a link to a stack situated somewhere below it and with an additional stack operation whose effect is to ``collapse'' a stack $s$ to the state indicated by the link from the top stack symbol.

\subsubsection{Computation trees and traversals}

In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph based on
Lamping's graphs \cite{lamping} is introduced to represent
$\lambda$-terms. The authors unify different notions of paths
(regular, legal, consistent and persistent paths) that have appeared
in the literature as ways to implement graph-based reduction of
$\lambda$-expressions. We can regard a traversal as an alternative
notion of path adapted to the graph representation of
$\lambda$-expressions given by computation trees.

The traversals of a computation tree provide a way
to perform \emph{local computation} of $\beta$-reductions as opposed
to a global approach where the $\beta$-reduction is implemented by
performing substitutions. A notion of local computation of
$\beta$-reduction has been investigated in
\cite{DanosRegnier-Localandasynchronou} through the use of special
graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The Safe $\lambda$-Calculus}

\subsection{Safe Higher-Order Grammars}
We present the safety restriction as it was originally defined in \cite{KNU02} for higher-order grammars.

\begin{definition}
A \defname{higher-order grammar} is a tuple $\langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$, where
 $\Sigma$ is a ranked alphabet of terminals of order at most 1,
 $V$ is a finite set of typed variables,
 $\mathcal{N}$ is a finite set of non-terminals,
 $S$ a distinguished symbol of $\mathcal{N}$ of ground type, called the start symbol,
 $\mathcal{R}$ is a finite set of production rules, one for each $F : (A_1, \ldots, A_n, o) \in N$, of the form
$ F z_1 \ldots z_m \rightarrow e$
where $z_i$ is a variable of type $A_i$ and $e$ is an applicative
term of type $o$ in $\mathcal{N}(\Sigma \union \mathcal{N} \union
\{z_1 \ldots z_m \} )$.
\end{definition}

A type is \defname{homogeneous} if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with $\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$ and each $A_1$, \ldots, $A_n$ is homogeneous \cite{KNU02}.
A grammar is homogenous if the non-terminals in $\mathcal{N}$ are all homogeneously typed.

\begin{definition}[Safe higher-order grammars]
A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be \defname{unsafe} if $e$ has a subterm $t$
of order $k$ occurring in an operand position and containing a parameter $z_i$ of order $<k$.
An homogeneous grammar is \defname{safe} if none of its production rules is unsafe.
\end{definition}

The reader is referred to \cite{KNU02,demirandathesis,safety-mirlong2004}
for details about the safety restriction for higher-order grammars.

\subsection{Safety adapted to the $\lambda$-calculus}

We consider simple types generated by the grammar $A
\, ::= \, o \; | \; A \typear A$. Any type different from the ground
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \typear \cdots \typear A_n \typear o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then $arity(T)$, the arity of $T$, is
defined as $n$.
The order of a type is given by $\ord{o} = 0$ and
$\ord{A \typear B} = \max(\ord{A}+1, \ord{B})$.
We use a set of sequents of the form $\Gamma \vdash M : A$ to represent
terms-in-context where $\Gamma$ is the context (a typed-alphabet) and $A$ is the type of $M$. We assume that a set
of higher-order constants $\Sigma$ is given.

\begin{definition}
The \defname{safe $\lambda$-calculus} is a sub-system of the simply typed $\lambda$-calculus
defined by the following formation rules:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{const} \   \rulef{}{\vdash f : A} \quad f \in \Sigma
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash s : A}{\Delta \vdash s : A} \quad \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash s : (A_1,\ldots,A_n,B)
                                        \ \Gamma \vdash t_1 : A_1
                                        \  \ldots\  \Gamma \vdash t_n : A_n }
                                   {\Gamma  \vdash s t_1 \ldots t_n : B}
                                    \
                                   \ord{B} \sqsubseteq \ord{\Gamma}$$
$$ \rulename{abs} \   \rulef{\Gamma, x_1 : A_1 \ldots x_n : A_n \vdash s : B}
                                   {\Gamma  \vdash \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \
                                   \ord{A_1, \ldots ,A_n,B} \sqsubseteq \ord{\Gamma}$$
where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$ and ``$c \sqsubseteq S$'' expresses that
$c$ is a lower-bound for $S$.
\end{definition}

The first deviation from the standard definition of the simply typed $\lambda$-calculus is that the rules {\sf (app)} and {\sf (abs)}
can perform multiple applications or abstract several variables at once.
Of course this single change would not alter expressivity if there were not at the same time the additional condition
constraining the occurrences of variables within a term:  the side-condition in the application rule and abstraction rules ensures that all variables in the context of the term being formed have order greater than the order of the term itself.


We do not impose any constraint on the term type. In particular, the type-homogeneity constraint used in \cite{KNU02} to define safe higher-order grammars is not required here. Another difference is that we allow $\Sigma$-constants to be of any higher-order types whereas \cite{KNU02} focuses on the restricted case of first-order $\Sigma$-constants.
In these regards, our formulation of the safe $\lambda$-calculus is more general than the one proposed in \cite{safety-mirlong2004}.
It is possible to reconcile the two definitions by adding the further constraint that each type occurring in our rules is homogeneous
and by restricting constants to at most order 1.

The equivalence of Knapik \emph{et al.}'s definition of safety and
the formulation via the homogeneous $\lambda$-calculus is shown in \cite{demirandathesis}:
\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$ be a grammar.
A rule $F z_1 \ldots z_m \rightarrow e$ in $\mathcal{R}$ is safe if and only if
$ z_1 \ldots z_m \vdash r : o$
is a valid typing judgement (without abstraction) of the \emph{homogeneous} safe $\lambda$-calculus.
\end{proposition}



\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y ))$ and
$M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where $x,y:o$ and $f:((o,o),o)$.
$M_2$ is not safe because in the subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which is smaller than $\ord{\lambda y . x} = 1$.
On the other hand, $M_1$ is safe.
%On the other hand, $M_1$ is safe as the following proof tree shows:
%$$
% \rulef{
%     \rulef{
%        \rulef{}{f \vdash f} {\sf(var)}
%        \
%        \rulef{
%             \rulef{
%                \rulef{
%                    \rulef{}{f \vdash f} {\sf(var)}
%                }
%                {f , x \vdash f } {\sf(wk)}
%                \
%                \rulef{
%                    \rulef{
%                        \rulef{}{y \vdash y} {\sf(var)}
%                    }
%                    {y \vdash \lambda y . y } {\sf(abs)}
%                }
%                {f , x \vdash \lambda y .y } {\sf(wk)}
%             }
%             {f , x \vdash f (\lambda y .y )} {\sf(app)}
%        }
%        { f  \vdash \lambda x . f (\lambda y .y )} {\sf(abs)}
%     }
%     {
%        f  \vdash f (\lambda x . f (\lambda y .y ))} {\sf(app)}
%     }
% { \vdash M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } {\sf(abs)}
%$$
\end{example}

\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \vdash M : A$ then every variable in $\Gamma$ occurring free in $M$ has order at least $ord(M)$.
\end{lemma}




In the simply typed $\lambda$-calculus, it is necessary to rename
variables when performing substitution on an abstraction in order to
avoid possible variable capture. As a consequence, in order to
implement substitution one needs to have access to an unbound number
of variable names.
In the safe $\lambda$-calculus, however, variable capture never happens as the following lemma shows. Substitution can therefore be implemented naively by capture-permitting replacement, avoiding any need for variable renaming.


We write $M\captsubst{N}{x}$ to denote the capture-permitting substitution of $N$ for $x$ in $M$.\footnote{This substitution is implemented
by textually replacing all free occurrences of $x$ in $M$ by $N$ without performing variable renaming.
In particular for the abstraction case
$(\lambda \overline{y} . P)\captsubst{N}{x}$ is
defined as $\lambda \overline{y} . P\captsubst{N}{x}$ if $x\not\in \overline{y}$ and $\lambda \overline{y} . P$ elsewhere.}

\begin{lemma}[No variable capture]
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x \vdash M$ and $\Gamma \vdash  N$ are valid judgments of the safe $\lambda$-calculus.
\end{lemma}

\begin{proof}
We proceed by induction. The variable, constant and
application cases are trivial. For the abstraction case, suppose $M
= \lambda \overline{y} : \overline{A}. P$ where $\overline{y} = y_1
\ldots y_p$. If $x \in \overline{y}$ then $M \subst{N}{x} = M$ and there is no variable capture.
Suppose that $x \not\in \overline{y}$ then the capture-permitting substitution gives
$M \captsubst{N}{x} = \lambda \overline{y} . P \captsubst{N}{x}$.

By the induction hypothesis there is no variable capture in $P \captsubst{N}{x}$.
Hence variable capture can only happen if for some $1 \leq i \leq p$, the variable $y_i$
occurs freely in $N$ and $x$ occurs freely in $P$. Then Lemma \ref{lem:ordfreevar} gives
$ \ord{y_i} \geq \ord{N} = \ord{x}$.

Since $x \not \in \overline{y}$ and $x$ occurs freely in $P$, $x$ also occurs freely in the safe term
$\lambda \overline{y}. P$ therefore by Lemma \ref{lem:ordfreevar} we have
$ \ord{x} \geq \ord{\lambda \overline{y} . T} \geq 1+ \ord{y_i} > \ord{y_i}$
which gives a contradiction. \qed
\end{proof}

\begin{example}
In order to contract the $\beta$-redex in the term $f:(o,o,o),x:o \vdash (\lambda \varphi^{(o,o)} x^o . \varphi x) (\underline{f x})$ one needs to rename the bound variable $x$ into a fresh name to prevent the free occurrence of $x$ in the underline term from being captured during substitution. Consequently, by the previous lemma, this term is not safe. Indeed, it cannot be safe since $\ord{x} = 0 < 1 = \ord{f x}$.
\end{example}

Note that safety does not capture the entire set of $\alpha$-conversion free terms. For instance the reduction $\lambda y^o z^o. (\lambda x^o .y) z \betared \lambda yz.y$ can be done via capture-permitting substitution although the first term is not safe.

\subsection{Reductions and transformations preserving safety}

From now on we will use the standard notation $M\subst{N}{x}$ to denote the substitution of $N$ for $x$ in $M$.
It is understood that, provided that $M$ and $N$ are safe, this substitution
is implemented by capture-permitting substitution.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x \vdash M$ and $\Gamma \vdash N$ then $\Gamma \vdash M[N/x]$.
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.


It is desirable to have an appropriate notion of reduction for our calculus. However the standard $\beta$-reduction rule is not adequate. Indeed, safety is not preserved by $\beta$-reduction as the following example shows. Suppose that $w,x,y,z : o$ and $f : (o,o,o) \in \Sigma$ then the safe term $(\lambda x y . f x y) z w$ $\beta$-reduces to $(\underline{\lambda y . f z y}) w$ which is unsafe since the underline order-1 subterm  contains a free occurrence of variable $z$ of ground type. However if we perform one more reduction we obtain the safe term
$f z w$. This suggests an alternative notion of reduction that performs simultaneous reduction of consecutive $\beta$-redexes. In order to define this reduction we first introduce an appropriate notion of redex.

In the simply typed $\lambda$-calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe $\lambda$-calculus, a redex is a succession of several standard redexes:
\begin{definition}
A \defname{safe redex} is a safe term with a derivation tree of the form:
$$   \rulef{
            \rulef{\rulef{\ldots}{\Gamma, \overline{x}\vdash M}}{\Gamma \vdash \lambda \overline{x} . M} (\sf{abs})
            \quad
            \rulef{\ldots}{\Gamma \vdash N_1}  \ \ldots \  \rulef{\ldots}{\Gamma \vdash N_l}
    }
    {
       \Gamma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
    } (\sf{app})
$$
for some list of variables $\overline{x}=x_1\ldots x_n$.
\end{definition}

In other words a safe redex is a safe term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such that
the variable $\overline{x}$ are abstracted altogether by one occurrence of the rule $(\sf{abs})$ and the terms $(\lambda \overline{x} . M)$, $N_1$, \ldots, $N_l$ are applied together at once using the $(\sf{app})$ rule
(and consequently each $N_i$ is safe).



We are now in a position to define a notion of reduction for safe terms.

\begin{definition}
\label{dfn:safereduction} We use the
abbreviations $\overline{x} = x_1 \ldots x_n$,
$\overline{N} = N_1 \ldots N_l$, and when $n\geq l$, $\overline{x_L}
= x_1 \ldots x_l$ and $\overline{x_R} = x_{l+1} \ldots x_n$.
The relation $\beta_s$ is defined on the set of safe redex as:
\begin{eqnarray*}
\beta_s &=&
\{  \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}} \mbox{, for $n> l$}
\} \\
&\cup&
\{ \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l
\mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}
with $T\subst{\overline{N}}{\overline{x}}$ being the simultaneous substitution of $N_1,\ldots,N_n$ for $x_1, \ldots, x_n$ in $T$.
The \defname{safe $\beta$-reduction}, written $\betasred$, is the closure of
the relation $\beta_s$ by compatibility with the formation rules of
the safe $\lambda$-calculus.
\end{definition}

\noindent \emph{Remark:} The $\beta_s$-reduction is a multi-step $\beta$-reduction i.e. $\betared \subset \betasred \subset \betaredtr$\ .


\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:safered_preserve_safety}
If $\Gamma \vdash s$ and $s \betasred t$ then $\Gamma \vdash t$.
\end{lemma}

\begin{proof}
It suffices to show that the relation $\beta_s$ preserves safety.
Consider the safe-redex $ s \equiv (\lambda x_1 \ldots x_n . M) N_1 \ldots N_l $ such that
$s\ \beta_s\ t$ for some simply typed term $t$.
Without lose of generality we can assume that the last rule used to form the term $s$ is {\sf(app)} i.e. not the weakening rule
{\sf(wk)}. Hence we have $\Gamma = fv(s)$.

By Lemma \ref{lem:subst_preserve_safety}, $T\subst{\overline{N}}{\overline{x_L}}$ is safe.
By Lemma \ref{lem:ordfreevar}, all variables in $\Gamma$ have order greater than $\ord{s} = \ord{t}$. Therefore
if $n>l$ then we can use the {\sf(abs)} rule to form $\Gamma \vdash t \equiv \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}}$
and if $n \leq l$ we can use the {\sf(app)} rule to form $\Gamma \vdash t \equiv  T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l$.
\qed
\end{proof}

In general, safety is not preserved by $\eta$-expansion for instance we have $f:o,o \vdash f$ but $f:o,o \not \vdash \lambda x^o . f x$.
This remark remains true for closed terms, for instance $\vdash \lambda y z . y$ but 
$\not \vdash \lambda x . (\lambda y z . y) x$.
However, as the following lemma shows, safety is preserved by $\eta$-reduction:

\begin{lemma}[$\eta$-reduction preserves safety]
$\Gamma \vdash \lambda \varphi . s \varphi $ with $\varphi$ not occurring free in $s$ implies $\Gamma \vdash s$.
\end{lemma}
\begin{proof}
Suppose $\Gamma \vdash \lambda \varphi . s \varphi $. If $s$ is an abstraction then by construction of the safe term $\lambda \varphi . s \varphi$, $s$ is necessarily safe.
If $s$ is an applicative term: $s = N_0 \ldots N_p$ for $p\geq 1$ then again, since $\lambda \varphi . N_0 \ldots N_p \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$ and for any $z\in \Gamma$, $\ord{z} \geq \ord{\lambda \varphi . s \varphi} = \ord{s}$. Hence, since $\varphi \not\in \Gamma$, we obtain $\Gamma \vdash N_0 \ldots N_p = s$ using the application rule.
\end{proof}



The $\eta$-long normal form of a term is obtained by hereditarily $\eta$-expanding every
subterm occurring at an operand position.
It also appeared in the literature \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76} under the names \emph{long reduced form}, \emph{$\eta$-normal form} and \emph{extensional form}.

\begin{definition}
The \defname{$\eta$-long normal form} $\elnf{t}$ of a term $t: (A_1,\ldots,A_n,o)$ with $n \geq 0$ is defined as follows:
\begin{eqnarray*}
\elnf{\lambda x . s } &=& \lambda x . \elnf{s} \\
\elnf{x s_1 \ldots s_m } &=& \lambda \overline{\varphi} . x \elnf{s_1}\ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
\elnf{(\lambda x . s) s_1 \ldots s_p } &=& \lambda \overline{\varphi} . (\lambda x . \elnf{s}) \elnf{s_1} \ldots \elnf{s_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is a  variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.
\end{definition}

%\begin{remark}
%Converting a term to its $\eta$-long normal form does not introduce new redex therefore
%the $\eta$-long normal form of $\beta$-normal term is a $\beta$-normal term.
%\end{remark}

\begin{lemma}[$\eta$-long normalisation preserves safety]
\label{lem:elnf_preserves_safety}
If $\Gamma \vdash s$ then $\Gamma \vdash \elnf{s}$.
\end{lemma}
\begin{proof}

First we observe that for any variable or constant $x$ we have $x \vdash \elnf{x}$. The proof is by induction on $\ord{x}$. Base case: $x$ is of ground type and we have $x \vdash x = \elnf{x}$. Step case:
$x:(A_1, \ldots, A_n,o)$ with $n>0$. Let $\varphi_i:A_i$ be fresh variables for $1\leq i\leq n$. The (var) rules gives $\varphi_i  \vdash \varphi_i$ and since $\ord{A_i} < \ord{x}$ the induction hypothesis gives $\varphi_i \vdash \elnf{\varphi_i}$. Using (wk) we obtain $x, \overline{\varphi} \vdash \elnf{\varphi_i}$.
The application rule gives $x, \overline{\varphi} \vdash x \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$ and the abstraction rule gives $ x \vdash \lambda \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} = \elnf{x}$.


We now prove the lemma by induction on the structure of $s$.
The base case (where $s$ is some variable $x$) is covered by the previous observation.
\emph{Step case:} 
\begin{itemize}
\item $s = x s_1 \ldots s_m$ with $x: (B_1, \ldots, B_m, A_1, \ldots, A_n, o)$ with $m\geq 0$, $n>0$ and $s_i : B_i$ for $1 \leq i \leq m$. 
Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq n$. By the previous observation we have $\varphi_i \vdash \elnf{\varphi_i}$ which in turn gives $\Gamma , \overline{\varphi} \vdash \elnf{\varphi_i}$ using the weakening rule.
The judgement $\Gamma \vdash x s_1 \ldots s_m$ is formed using the (app) rule therefore each $s_j$ is safe for $1\leq j \leq m$. By the induction hypothesis we have $\Gamma \vdash \elnf{s_j}$ and by weakening we get $\Gamma, \overline{\varphi} \vdash \elnf{s_j}$.
The application rule gives $\Gamma, \overline{\varphi} \vdash 
x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally the (abs) rule gives $\Gamma \vdash \lambda \overline{\varphi} . x \elnf{s_1} \ldots \elnf{s_m}  \elnf{\varphi_1} \ldots \elnf{\varphi_n} = \elnf{s}$, the side-condition of (abs) being met since $\ord{\elnf{s}} = \ord{s}$.


\item $s = t s_0 \ldots s_m$ where $t$ is an abstraction. Again, using the induction hypothesis it is easy to show that $\Gamma \vdash \elnf{s} = \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n}$ holds for some fresh variables $\varphi_1$, \ldots, $\varphi_n$.

\item $s = \lambda \overline{\eta} . t$ where $t$ is not an abstraction. By the induction hypothesis we have $\Gamma, \overline{\eta} \vdash \elnf{t}$ and by the abstraction rule we have $\Gamma \vdash \lambda \overline{\eta} . \elnf{t} = \elnf{s}$.
\end{itemize} \qed
\end{proof}

Note that in general the converse does not hold, for instance $\lambda x^o . f^{o,(o,o),o} x^o$ is unsafe although $\elnf{\lambda x . f x} = \lambda x^o \varphi^{o,o} . f x \varphi$ is safe (and not homogeneous). For terms with homogeneous types however, the converse does hold:
\begin{lemma}
If $\Gamma \vdash \elnf{s}$ is homogeneously safe (i.e. it is a safe judgement of the safe $\lambda$-calculus and each sequent occurring at the nodes of the proof tree is homogeneously typed) then
$\Gamma \vdash s$ is homogeneously safe.
\end{lemma}
\begin{proof}

\end{proof}

\subsection{Numerical Functions Representable in the Safe $\lambda$-Calculus}

Natural numbers can be encoded into the simply-typed $\lambda$-calculus using the Church Numerals: each $n\in\nat$ is encoded into the term $\encode{n} = \lambda s z. s^n z$ of type $I = ((o,o),o,o)$ where $o$ is a ground type.  In \cite{citeulike:622637}, Schwichtenberg showed the following:


\begin{theorem}[Schwichtenberg, 1979]
The numerical functions representable by simply typed $\lambda$-terms of type $I\rightarrow \ldots \rightarrow I$ using the Church Numeral encoding are exactly the multivariate polynomials \emph{extended with the conditional function}.
\end{theorem}

If we limit ourselves to safe terms, the representable functions are exactly the multivariate polynomials:
\begin{theorem}
\label{thm:polychar}
The functions representable by safe $\lambda$-expressions of type $I\rightarrow \ldots \rightarrow I$ are exactly the multivariate polynomials.
\end{theorem}

\begin{corollary}
The conditional operator $C:I\rightarrow I\rightarrow I \rightarrow I$ verifying  $C t y z \rightarrow_\beta y$  if $t \rightarrow_\beta \encode{0}$ and $C t y z \rightarrow_\beta z$ if $t \rightarrow_\beta \encode{n+1}$ is not definable in the safe simply typed $\lambda$-calculus.
\end{corollary}
\begin{proof}
Natural numbers are encoded using Church Numerals: $\encode{n} = \lambda s z. s^n z$. 
Addition: for $n,m \in \nat$, $\encode{n+m} = \lambda \alpha^{(o,o)} x^o . (\encode{n} \alpha) (\encode{m} \alpha x)$. Multiplication: $\encode{n . m} = \lambda \alpha^{(o,o)} . \encode{n} (\encode{m} \alpha)$.
All these terms are safe and clearly any multivariate polynomial $P(n_1, \ldots, n_k)$ can be computed by composing the addition and multiplication terms as appropriate.

For the converse, let $U$ be a safe $\lambda$-term of type $I\rightarrow I\rightarrow I$. 
The generalisation to terms of type $I^n \rightarrow I$ for $n>2$ is immediate (they correspond to polynomials with $n$ variables). Without lose of generality we can assume that $U = \lambda x y \alpha z. u$ where $u$ is a safe term of ground type in $\beta$-normal form with $fv(u) \subseteq \{ x, y : I, z :o, \alpha : o\rightarrow o \}$.

\emph{Notation:} Let $T$ be a set of terms of type $\tau \rightarrow \tau$ and $T'$ be a set of terms of type $\tau$ then $T \cdot T'$ denotes the set of terms $\{ s s' : \tau \ | \ s \in T \wedge s' \in T' \}$. We also define 
$T^k \cdot T'$ recursively as follows:  $T^0 \cdot T' = T'$ and
for $k\geq 0$, $T^{k+1} \cdot T' = T \cdot (T^k \cdot T')$ (i.e. $T^k \cdot T'$ denotes $\{ s_1( \ldots (s_k s'))  \ | \ s_1, \ldots, s_k \in T \wedge s' \in T' \}$). We define $T^+\cdot T' = \Union_{k > 0} T^k \cdot T'$ and 
$T^*\cdot T' = (T^+\cdot T') \union T'$.

Let us write $\mathcal{N}^\tau$ for the set of $\beta$-normal terms of type $\tau$ where $\tau$ ranges in $\{ o, o\rightarrow o, I  \}$ and with free variables in $\{ x,y:I, z:o, \alpha:o\rightarrow o\}$. We write $\mathcal{A}^\tau$ for the subset of $\mathcal{N}^\tau$ consisting of applicative terms only (i.e. not abstractions).

Let $B$ be the set of terms of type $o\rightarrow o$ defined by $B = \{ \alpha \} \union \{ \lambda a.b \ | \ b \in \{a,z\}, a \neq z \}$.
It is easy to see that the following equations hold:
\begin{eqnarray*}
\mathcal{A}^I &=& \{ x,y \} \\
\mathcal{N}^{(o,o)} &=& B \union \mathcal{A}^I \cdot
\mathcal{N}^{(o,o)} = (\mathcal{A}^I)^* \cdot B \\
\mathcal{A}^{(o,o)} &=& \{ \alpha \} \union (\mathcal{A}^I)^+ \cdot B \\
\mathcal{A}^o = \mathcal{N}^o &=& \{ z \} \union \mathcal{A}^{(o,o)} \cdot \mathcal{N}^o = (\mathcal{A}^{(o,o)})^* \cdot \{ z \}
\end{eqnarray*}
Consequently, $\mathcal{A}^o = \left( \{\alpha \} \union \{x,y\}^+ \cdot \left( \{\alpha \} \union \{\lambda a.b \ | \ b \in \{a,z\}, a \neq z \} \right) \right)^* \cdot \{ z \}$.

$u$ belongs to $\mathcal{A}^o$ and since it is safe,
terms of the form $\lambda a . z$ with $a \neq z$ cannot occur at an operand position in $u$. Therefore:
\begin{equation}
u \in \left( \{\alpha\} \union \{x,y\}^+ \cdot \{\alpha,
\underline{i} \} \right)^* \cdot \{ z \} \label{eqn:u}
\end{equation}
where $\underline{i}$ is the identity term of type $o\rightarrow o$.

For two sets of terms $T$ and $T'$, we use the notation $T =_\beta T'$ expressing that any term of $T$ is $\beta$-convertible to some term $t'$ of $T'$ and reciprocally.

We observe that for all $m \in \nat$, we have $\encode{m} \underline{i} =_\beta \underline{i}$ and for $l\geq 1$, for all $k_1, \ldots k_l \in \nat$, 
$\encode{k_1}\ldots \encode{k_l} \alpha =_\beta
\encode{k_1\times \ldots \times k_l} \alpha$. Hence
\begin{equation}
\begin{array}{llr}
\{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} &=_\beta
\{ \underline{i} \} \union
\{ \encode{m^i n^j} \alpha \ |\ i+j \geq 1 \} \nonumber \\
&= \{ \encode{m^i n^j} \alpha \ |\ i,j \geq 0 \} & ( \mbox{since } \encode{0} \alpha = \underline{i}) %\label{eqn:intermediate}
\end{array} 
\label{eqn:intermediate}
\end{equation}
and therefore:
$$\begin{array}{llr}
u[\encode{m} \encode{n}/x,y] &\in \left( \{ \alpha \} \union \{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} \right)^* \cdot \{ z \}  & \mbox{(by eq. \ref{eqn:u})} \\
&=_\beta \left( \{\alpha \} \union \{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \} \right)^* \cdot \{ z \} & \mbox{(by eq. \ref{eqn:intermediate})}  \\
&=_\beta \left\{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \right\}^* \cdot \{ z \} & \mbox{($\alpha z =_\beta \encode{1} \alpha z$)}
\end{array}$$

Furthermore, for all $m,n,r,i,j\in \nat$ 
we have $\encode{m^i n^j} \alpha (\alpha^r z) =_\beta
\alpha^{r + m^i n^j} z$,
hence $u[\encode{m} \encode{n}/x,y] =_\beta \alpha^{p(m,n)} z$ where $p(m,n) = \sum_{0\leq k \leq d} m^{i_k} n^{j_k}$ for some $i_k,j_k \geq 0$, $k \in\{ 0,..,d \}$ and $d\geq 0$.
Thus $U \encode{m} \encode{n} =_\beta \encode{p(m,n)}$. 

Consequently, safe terms of type $I \rightarrow I \rightarrow I$ computes
exactly the polynomials of two variables. \qed
\end{proof}

For instance, the term $ C = \lambda F G H \alpha x . H ( \underline{\lambda y . G \alpha x} ) (F \alpha x)$ used in \cite{citeulike:622637} to define the conditional operator is
unsafe since the underlined term is of order $1$, occurs at an operand position and contains an occurrence of $x$ of order $0$.


\section{A Game-Semantic Account of Safety}
\label{sec:gamesemaccount}
Game Semantics being by essence syntax-independent, it seems vain to look for a game-semantic account of a syntactical constraint such as safety. However, as we said in the introduction, it is possible to represent the game semantics of a term on a particular  abstract syntax tree, called \emph{computation tree}, specifically designed for that purpose. A computation tree is a tree representation of a term  computed from its $\eta$-long normal form. The notion of play in game semantics is incarnated by a certain notion of traversal of the computation tree. This is formalised by a theorem called the Correspondence Theorem stating that the set of traversals of a computation tree is a representation of the plays of the game semantics in which  the internal moves have been revealed.

This technique was first introduced in \cite{OngLics2006} for the purpose of studying the decidability of MSO on infinite structure generated by higher-order grammars. In this setting, free variables are interpreted as constructors and therefore they do not have the ``full power'' of true free variables and are limited to order $1$ at most. Also, although the grammar can perform higher-order computations, the structure being studied is itself of ground type.

In Appendix A, we present an extension of this framework to the general case of the simply-typed $\lambda$-calculus with free variables of any order. The framework of  \cite{OngLics2006} is completed with the addition of a new traversal rule to handle nodes of the computation tree labelled with free variables. Also new nodes are added to the computation tree in order to model the answer moves of the game semantics, thus making it easy to extend  the framework to languages with interpreted constants (by adding traversal rules handling constant nodes) such as \pcf.


If $s$ is a sequence of moves, we write $?(s)$ for the subsequence of $s$ consisting only of unanswered questions. The \defname{order} of
a question move $q$ written $\ord{q}$ is defined as the length of the path from $q$ to its furthest leaf in the arena minus 1.
%height of the subarena rooted at $q$ minus 2.

\begin{definition}
A strategy $\sigma$ is said to be \defname{P-incrementally-justified}
if for any play $s q \in \sigma$ where $q$ is a P-question,
$q$ points to the last O-move in $\pview{?(s)}$ with order strictly greater than $\ord{q}$.
\end{definition}
Note that P-incremental-justification does not imply innocence: the pointer is determined by the P-view but the choice of the move itself can be based on the whole history of the play.
\begin{example}
Take the evaluation map $ev : (o^1 \Rightarrow o^2) \times  o^3 \rightarrow o^4$ and
the play $s = q^4 q^2 q^1 q^3 \in \sem{ev}$. We have $\ord{q^4} = \ord{q^2} = 1 > \ord{q^1} = \ord{q^3} = 0$.
$q^3$ points to $q^4$ but $q^2$ is the last O-move in $?(\pview{s})= s$
with order $>\ord{q^3}$, hence $\sem{ev}$ is not P-incrementally-justified.
\end{example}

\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} In P-incrementally-justified strategies, pointers emanating from P-moves are superfluous i.e.\ 
there is an algorithm that, given a play of the denotation, recovers uniquely the pointers from the underlying sequence of moves and from the pointers associated to O-move.
\end{lemma}


The Correspondence Theorem permits to show the following (see Appendix B for a sketch of the proof):

\begin{theorem}[Safety and incremental-justification]
\label{thm:safeincrejust}
(i) $M$ safe implies $\sem{M}$ is P-incrementally justified.
(ii) If $M$ is a closed simply typed term and $\sem{M}$ is P-incrementally justified then the $\eta$-normal form of the $\beta$-normal form  of $M$ is safe.
\end{theorem}



Putting Theorem \ref{thm:safeincrejust}(i)
and Lemma \ref{lem:incrjustified_pointers_uniqu_recover} together
we get:
\begin{proposition}
\label{prop:safe_ptr_recoverable} In the game semantics of
safe $\lambda$-terms, pointers emanating from P-moves are
unnecessary i.e.\ they are uniquely recoverable from the underlying sequences of moves and from O-moves' pointers.
\end{proposition}

\begin{example} If justification pointers are omitted, the two Kierstead terms from Ex. \ref{ex:kierstead} have
the same denotation. In the safe $\lambda$-calculus the ambiguity disappears since $M_1$ is safe whereas $M_2$ is not.
\end{example}

In fact, as the last example highlights, at order $3$ pointers are superfluous for safe terms. Indeed, it is well-known that  pointers are not necessary for question moves of order up to $2$ and since order $3$ moves are P-moves, their associated pointers can be recovered uniquely by P-incremental-justification.

The following counter-example shows that this is not true anymore at order $4$. Take the safe term $M = \lambda f . f (\lambda \varphi x . \varphi x) : ((((o^4,o^3),o^{3'},o^2),o^1),o^0)$ where $f:(((o,o),o,o),o)$, $\varphi:(o,o)$, $x:o$. There are two different plays of $\sem{M}$ whose underlying sequence of moves is $q_0 q_1 q_2 q_3 q_2 q_3 q_4$, each one having $q_4$ pointing to a different occurrence of $q_3$, thus pointer-less plays are ambiguous.


\pcf\ is the $\lambda$-calculus augmented with the ground type of natural numbers, first-order arithmetic operators, if-then-else branching
and a family of recursion combinator $Y_A : ((A,A),A)$ for any type $A$.
We can define safe \pcf\ to be \pcf\ where the application and abstraction rules are restricted as in the safe $\lambda$-calculus.
This language inherits the good properties of the safe $\lambda$-calculus: no variable capture occurs when performing substitution and safety is preserved by the reduction rules of the small-step semantics of \pcf\ constants. Using a \pcf\ version of the Correspondence Theorem we can prove the following:
\begin{theorem}
\label{thm:safepcfpincr}
Safe PCF terms are denoted by P-incrementally justified strategies.
\end{theorem}

Similarly, we can define safe \ialgol\ to be safe \pcf\ augmented with the imperative features of Idealized Algol (\ialgol\ for short) \cite{Reynolds81}.  Adapting the game-semantic correspondence and safety characterisation to \ialgol\ seems feasible although the presence of the base type \iavar, whose game arena $\iacom^{\nat} \times \iaexp$ has infinitely many initial moves, causes a mismatch between the simple tree representation of the term and its game arena. It may be possible to overcome this problem by replacing the notion of computation tree by a ``computation directed acyclic graph''. 

The pointer economy obtained by imposing the safety condition suggests potential application in algorithmic game semantics. 
For example it was shown in \cite{ghicamccusker00} that observational equivalence of the order $2$ finitary fragment of Idealized Algol ($\ialgol_2$ for short) is decidable (and in PSPACE) by remarking that pointers are unnecessary up to order $2$. At order $3$, although pointers are necessary, 
observational equivalence is still decidable with the complexity EXPTIME \cite{DBLP:conf/fossacs/MurawskiW05}. Restricting the problem to the safe fragment of $\ialgol_3$ may lead to a lower complexity (note that it is unlikely to obtain the complexity PSPACE because the set of complete plays of the safe term $\lambda f^{(o,o),o} . f (\lambda x^o . x)$ is not regular, see \cite{DBLP:journals/apal/Ong04}).

%Murawski showed the undecidability of program equivalence in $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations into a finitary $IA_4$ term \cite{murawski03program}. The term constructed being not safe, the proof cannot be transposed to the safe fragments. Hence the question remains of whether observational equivalence is decidable for the \emph{safe} fragments of these language.

%In \cite{Ong02}, one of us showed that observational equivalence for finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is undecidable. The proof consists in reducing the Queue-Halting problem to the observational equivalence of two $\ialgol_2 + Y_1$ terms. The same reduction is still valid in the safe fragment of $\ialgol_2 + Y_1$.
%Consequently, observational equivalence of safe $\ialgol_2 + Y_1$ is also undecidable.


\section{Further Work and Open Problems}

The nature of the safe $\lambda$-calculus is still not well known. Here is a list of open problems:
What is the categorical interpretation of the safe $\lambda$-calculus? Which proof system do we obtain by the Curry-Howard isomorphism? Does the safe $\lambda$-calculus characterise a complexity class the same way as the $\lambda$-calculus characterises the complexity class P \cite{DBLP:conf/tlca/LeivantM93}?
To which extend incrementally-justified strategy compose? Can we obtain a fully abstract model of safe PCF by imposing some constraint on O-moves (i.e.\ ``O-incremental-justification'')?

More generally, we would like to have a better understanding of the class of languages for which pointers are uniquely recoverable. We name this class PUR. These are good candidates of languages with decidable observational equivalence.
$\ialgol_2$ is an example of PUR-language which is  obtained by limiting the types of \ialgol\ to order $2$. Another example is \emph{Serially Re-entrant Idealized Algol} \cite{abramsky:mchecking_ia}, a version of \ialgol\ where multiple uses of arguments are allowed only if they do not overlap in time. 
We believe that a PUR language can be obtained by imposing the \emph{safety condition} on $\ialgol_3$.

\bibliographystyle{splncs}
\bibliography{../bib/higherorder,../bib/gamesem,../bib/lambdacalculus}


\section*{Appendix A -- Computation tree, Traversals and Correspondence}
\label{sec:correspondence}

In this section we adapt the notions of computation tree and
traversals over the computation tree introduced in \cite{OngLics2006} to the context of the $\lambda$-calculus
and we state the \emph{Correspondence Theorem} (Theorem \ref{thm:correspondence}).
The results of Sec. \ref{sec:gamesemaccount} are entirely based on this theorem.

We consider the simply typed $\lambda$-calculus without constants. Everything remains valid in the presence of
\emph{uninterpreted}\footnote{A constant $f$ is \emph{uninterpreted}
if the small-step semantics of the language does not contain any rule of the form $f \dots \rightarrow e$. $f$ can be regarded as a data constructor.}
constants since we can just consider them as free variables. Moreover there is no restriction on the order of these constants, contrary to \cite{OngLics2006} where constants need to be at most $1$ to guarantee that the structure generated is a tree.

In the following, we fix a simply typed term $M$ of type $T$ with variables in $\mathcal{V}$, a countable set of variables.
\subsection{Computation Tree}

Computation trees were proposed in \cite{OngLics2006} for the purpose of studying the infinite tree structures generated by higher-order grammars. The computation tree of a grammar is defined as the unravelling of a finite graph representing the long transform of a grammar. Similarly, we define the computation tree of a $\lambda$-term to be the abstract syntax tree of its $\eta$-long normal form.

\emph{Notation for labelled-trees:} We write $l(t_1, \ldots, t_n)$ to denote the tree with a root labelled $l$ and with $n$ children subtrees $t_1$, \ldots, $t_n$ for $
n \geq 0$.

\begin{definition}
The \defname{computation tree} $\tau(M)$ of $M$ is
a tree with labels in $ \mathcal{L} = \{ @ \} \union \mathcal{V} \union \{ \lambda x_1 \ldots x_n \ | \ x_1 ,\ldots, x_n \in \mathcal{V} \}$ defined from its $\eta$-normal form as follows:
\begin{eqnarray*}
  \mbox{for $n\geq 0$ and $s:o$, } \tau(\lambda x_1 \ldots x_n . s) &=& \lambda x_1 \ldots x_n(t) \mbox{\quad where $\tau(s) = \lambda(t)$}\\
  \mbox{for $m\geq 0$ and $x \in  \mathcal{V}$, } \tau( x s_1 \ldots s_m : o) &=&  \lambda (x(\tau(s_1),\ldots,\tau(s_m)))\\
  \mbox{for $m \geq 1$, } \tau((\lambda x.t) s_1 \ldots s_m :o) &=& \lambda (@(\tau(\lambda x.t),\tau(s_1),\ldots,\tau(s_m)))
\end{eqnarray*}
\end{definition}

Even-level nodes are $\lambda$-nodes. A single $\lambda$-node can represent several consecutive variable abstractions or it can just be
a \textsl{dummy lambda} if the corresponding subterm is of ground type.
Odd-level nodes are variable or application nodes.

We write $N$ for the set of nodes of $\tau$, $N_@$ for the set of @-labelled nodes,
$N_{var}$ for the set of variable nodes,
$N_{fv}$ for the subset of $N_{var}$ constituted of free-variable nodes and $r$ for the root of $\tau(M)$.
For $n \in N$, we write $\kappa(n)$ to denote the subterm of $\elnf{M}$
corresponding to the subtree of $\tau(M)$ rooted at $n$, in particular $\kappa(r) = \elnf{M}$.
The \defname{order} of a variable node $n$ labelled by $x$ of type $T$ 
is defined as $\ord{n} = \ord{T}$, the order of the root is $\ord{r} = \ord{\lambda \overline{x} . M}$ where $\overline{x}$ are the free variables of $M$ and for $n$ in $(N_\lambda \union N_@) \setminus \{ r \}$, $\ord{n} = \ord{\kappa(n)}$.


\subsection{Pointers and Justified Sequences of Nodes}

We say that a variable node $n$ labelled $x$ is bound by a node $m$, and $m$ is called the
\defname{binder} of $n$, if $m$ is the closest node in the path from $n$ to
the root such that $m$ is labelled $\lambda \overline{\xi}$ with $x\in \overline{\xi}$.

We define the \defname{enabling relation} on the set of nodes of the
computation tree as follows: $m$ enables $n$, written $m \vdash n$, if and only if
$n$ is bound by $m$ (we write $m \vdash_i n$ to precise that $n$ is the $i^{\sf th}$ variable bound by $m$),
or $m=r$ and $n$ is a free variable,
or $n$ is a $\lambda$-node and $m$ is its parent node.

For any set of nodes $S$ we write $S^{\upharpoonright r}$ for $\{ n \in S \ | \ r  \vdash^* n \}$ -- the subset of $S$ constituted of
nodes hereditarily enabled by $r$.
We call \defname{input-variables nodes} the elements of $N_{var}^{\upharpoonright r}$.

A \defname{justified sequence of nodes} is a sequence of
nodes with pointers such that each variable or $\lambda$-node $n$ different from the root
has a pointer to a node $m$ occurring before it the sequence such that $m \vdash n$.
We represent the pointer in the sequence as follows
\raisebox{0cm}[0.4cm]{$\rnode{m}{m} \ldots \rnode{n}{n} \link[nodesep=0.5pt]{20}{n}{m} \lnklabelc{i}$}.
where the label indicates that either $n$ is labelled with the $i$th
variable abstracted by the $\lambda$-node $m$ or that $n$ is the
$i^{\sf th}$ child of $m$.  Children nodes are numbered from $1$ onward except for @-nodes
where it starts from $0$. Abstracted variables are numbered from $1$ onward. The $i^{\sf th}$ child of $n$ is denoted by $n.i$.

We say that a node $n_0$ of a justified sequence is \defname{hereditarily justified} by $n_p$ if there are nodes $n_1, \ldots, n_{p-1}$ in
the sequence such that $n_i$ points to $n_{i+1}$ for all $i\in 0..p-1$.

The notion of \defname{P-view} $\pview{t}$ of a justified sequence of nodes $t$
is defined the same way as the P-view of a justified sequences of moves in Game Semantics:\footnote{
The equalities in the definition determine pointers implicitly. For instance in the second clause, if in the
left-hand side, $n$ points to some node in $s$ that is also present
in $\pview{s}$ then in the right-hand side, $n$ points to that
occurrence of the node in $\pview{s}$.}
$$\begin{array}{rclrcl}
\pview{\epsilon} &=&  \epsilon
& \pview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{lmd}{\lambda \overline{\xi}}} &=& \pview{s} \cdot \rnode{m2}{m} \cdot \rnode{lmd2}{\lambda \overline{\xi}}   \link[nodesep=1pt]{25}{lmd}{m}    \link[nodesep=1pt]{60}{lmd2}{m2}\\
\mbox{for $n \notin N_\lambda$, } \pview{s \cdot n }  &=&  \pview{s} \cdot n \qquad
& \pview{s \cdot r }  &=&  r
\end{array}$$

The O-view is defined as the dual notion of P-view.
We borrow the game semantic terminology: a justified sequences of nodes satisfies \emph{alternation} if for any
two consecutive nodes one is a $\lambda$-node and the other is not,
and \emph{P-visibility} if every variable node points to a node occurring in the P-view a that point.

\subsection{Computation Tree with Value-leaves}

We now add another ingredient to our computation trees that is not used in \cite{OngLics2006}.
We write $\mathcal{D}$ to denote the set of values of the base type $o$.
We add \defname{value-leaves} to $\tau(M)$ as follows:
for each value $v \in \mathcal{D}$ and for each node $n \in N$ we attach
the child leaf $v_n$ to $n$.
We write $V$ for the set of nodes and leaves of the computation tree.
For $\$$ ranging in $\{@, \lambda, var \}$, we write $V_\$$ to denote the set $N_\$ \union \{ v_n \ | \ n \in N_\$, v \in \mathcal{D} \}$.


Everything that we have defined can be lifted
to this new version of computation tree. A value-leaf has order $0$. The enabling relation $\vdash$ is
extended so that every leaf is enabled by its parent node.
A link going from a value-leaf $v_n$ to a node $n$ is labelled by $v$:
\raisebox{0cm}[0.4cm]{$\rnode{n}{n} \ldots \rnode{vn}{v_n} \link[nodesep=0.5pt]{25}{vn}{n} \lnklabelc{v}$}.
For the definition of P-view and visibility, value-leaves are treated as
$\lambda$-nodes if they are at odd level in the computation tree and
as variable nodes if there at a even level.

If there is an occurrence of a value-leaf $v_n$ in the sequence that points to $n$ we say that
$n$ is \defname{matched} by $v_n$. If there is no value-leaf in the sequence that points to $n$ we
say that $n$ is an \defname{unmatched node}.
The last unmatched node is called the \defname{pending node}.
A justified sequence of nodes is \defname{well-bracketed} if each value-leaf in the traversal points to the pending node at that point.
If $t$ is a traversal then we write $?(t)$ to denote the subsequence of $t$ consisting only of unmatched nodes.

\subsection{Traversals of the Computation Tree}
\label{subsec:traversal}

A \emph{traversal} is a justified sequence of nodes of the computation tree where each node
indicates a step that is taken during the evaluation of the term.
\begin{definition}
\label{def:traversal}
The set $\travset(M)$ of \defname{traversals} over $\tau(M)$ is defined by induction over the following rules.

\begin{description}
\item[{\bf (Empty)}] $\epsilon \in \travset(M)$.
\item[{\bf (Root)}] $ r \in \travset(M)$.
\item[{\bf (Lam)}] If $t \cdot \lambda \overline{\xi}$ is a traversal then so is
$t \cdot \lambda \overline{\xi} \cdot n$
where $n$ is $\lambda \overline{\xi}$'s child and points to the only occurrence of its enabler that is still present in $\pview{t \cdot \lambda \overline{\xi}}$.

\item[{\bf (App)}] If $t \cdot @$ is a traversal then so is $t \cdot \rnode{m}{@} \cdot \rnode{n}{n}\link[nodesep=0.5pt]{25}{n}{m} \lnklabelc{0}$.

\item[{\bf (InputVar$^{val}$)}] If $t_1 \cdot x \cdot t_2$ is a traversal
with $x \in N_{var}^{\upharpoonright r}$ and $?(t_1 \cdot x \cdot t_2)=?(t_1) \cdot x$ then so is
\raisebox{0cm}[0.4cm]{$t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot \rnode{xv}{v_x} \link[nodesep=0.5pt]{25}{xv}{x} \lnklabelc{v}$}
for all $v \in \mathcal{D}$.

\item[{\bf (InputVar)}] If $t_1 \cdot x \cdot t_2$ is a traversal with
$x \in N_{var}^{\upharpoonright r}$ and $?(t_1 \cdot x \cdot t_2)=?(t_1) \cdot x$ then so is
\raisebox{0cm}[0.4cm]{$t_1 \cdot \rnode{m}{x} \cdot t_2 \cdot \rnode{n}{n} \link[nodesep=0.5pt]{25}{n}{m} \lnklabelc{i}$}
for all $\lambda$-node $n$ whose parent occurs in $\oview{t_1 \cdot x}$, $n$ pointing to some occurrence of its parent node in $\oview{t_1 \cdot x}$.


\item[{\bf (Copycat$^@$)}]
  If $t \cdot \rnode{app}{@} \cdot \rnode{lz}{\lambda \overline{z}}  \ldots  \rnode{lzv}{v_{\lambda \overline{z}}}
              \link[nodesep=0.5pt]{30}{lzv}{lz} \lnklabelc{v}
              \link[nodesep=0.5pt]{40}{lz}{app} \lnklabelc{0}$
              is a traversal then so is
              \raisebox{0cm}[0.6cm]{$t \cdot \rnode{app}{@} \cdot \rnode{lz}{\lambda \overline{z}}  \ldots  \rnode{lzv}{v_{\lambda \overline{z}}} \cdot \rnode{appv}{v_@}
              \link[nodesep=0.5pt]{25}{lzv}{lz} \lnklabelc{v}
              \link[nodesep=0.5pt]{40}{lz}{app} \lnklabelc{0}
              \link[nodesep=0.5pt]{25}{appv}{app} \lnklabelc{v}$}.

\item[{\bf (Copycat$^\lambda$)}] If \raisebox{0cm}[0.4cm]{$t \cdot \lambda \overline{\xi} \cdot \rnode{x}{x}  \ldots   \rnode{xv}{v_x}
              \link[nodesep=0.5pt]{30}{xv}{x} \lnklabelc{v}$}
              is a traversal then so is
              \raisebox{0cm}[0.5cm]{$t \cdot \rnode{lmd}{\lambda \overline{\xi}} \cdot \rnode{x}{x}  \ldots  \rnode{xv}{v_x} \cdot
              \rnode{lmdv}{v_{\lambda \overline{\xi}}}
              \link[nodesep=0.5pt]{20}{xv}{x} \lnklabelc{v}
                \link[nodesep=0.5pt]{20}{lmdv}{lmd} \lnklabelc{v}$}.

\item[{\bf (Copycat$^{var}$)}] \raisebox{0cm}[0.4cm]{If $t \cdot y \cdot \rnode{lmd}{\lambda \overline{\xi}}
                   \ldots \rnode{lmdv}{v_{\lambda \overline{\xi}}} \link[nodesep=1pt]{30}{lmdv}{lmd} \lnklabelc{v}$}
                   is a traversal for some variable $y$ not in $N_{var}^{\upharpoonright r}$ then so is
        \raisebox{0cm}[0.6cm]{$t \cdot \rnode{y}{y}
            \cdot \rnode{lmd}{\lambda \overline{\xi}}
             \ldots
             \rnode{lmdv}{v_{\lambda \overline{\xi}}}
            \cdot \rnode{yv}{v_y}
                \link[nodesep=3pt]{25}{yv}{y} \lnklabelc{v}
                \link[nodesep=1pt]{25}{lmdv}{lmd} \lnklabelc{v}$}.
\item[{\bf (Var)}]
If  \raisebox{0cm}[0.5cm]{$t' \cdot \rnode{n}{n} \cdot
    \rnode{lx}{\lambda \overline{x}}  \ldots
    \rnode{x}{x_i}  \link[ncurv=0.6]{50}{x}{lx} \lnklabel{i}$} is a traversal for some variable $x_i$ not in $N_{var}^{\upharpoonright r}$ then
    so is
\raisebox{0cm}[0.6cm]{
    $t' \cdot \rnode{n}{n} \cdot
    \rnode{lx}{\lambda \overline{x}}  \ldots
    \rnode{x}{x_i} \cdot
    \rnode{letai}{\lambda \overline{\eta_i}}
    \link[ncurv=0.45]{45}{letai}{n} \lnklabelc{i}
    \link[ncurv=0.5]{45}{x}{lx} \lnklabelc{i}$}.
\end{description}
\end{definition}

\begin{wrapfigure}[7]{r}{3.8cm}
$ \rput[t](2cm,0.9cm)
{\tree[levelsep=3ex,treesep=0.5cm]{\lambda} {
    \tree{@}{
        \pstree[linestyle=dotted]{\TR{\lambda y}\arclabel{0} }{
            \tree{y}{
                \tree{\lambda \overline{\eta_1}}{\vdots}%\arclabel{1}
                \tree{\lambda \overline{\eta_i}}{\vdots}%\arclabel{i}
                \tree{\lambda \overline{\eta_n}}{\vdots}%\arclabel{n}
            }
        }
        \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}
			\arclabel{1}}{ \tree{x_i}{\TR{} \TR{}}}
}}}
$
\end{wrapfigure}
A traversal always starts by visiting the root and then continues by mainly following the structure of the tree.
The (Var) rule permits the traversal to jump across the computation tree. The idea is that after visiting a variable node $x$,
it can jump to the node corresponding to the subterm that would be substituted for $x$ if all the $\beta$-redexes occurring in the term were reduced.
The sequence \raisebox{0cm}[0.6cm]{$ \lambda \cdot
\rnode{app}{@}  \cdot
\rnode{ly}{\lambda y}  \ldots
\rnode{y}{y} \cdot
\rnode{lx}{\lambda \overline{x}}  \ldots
\rnode{x}{x_i} \cdot
\rnode{leta}{\lambda \overline{\eta_i} }  \ldots
\link[ncurv=1,nodesep=0.5pt]{25}{x}{lx}  \lnklabel{i}
\link[ncurv=1]{20}{leta}{y}  \lnklabelc{i}
\link[ncurv=1,nodesep=0.5pt]{25}{y}{ly}  \lnklabelc{1}
\link[ncurv=1]{20}{lx}{app}  \lnklabelc{1}$} is an example of traversal of the computation tree shown on the right.

\begin{proposition}
\label{prop:pviewtrav_is_path}
Let $t$ be a traversal. We have
(i) $t$ is a well-defined and well-bracketed justified sequence.
(ii) $?(t)$ is a well-defined justified sequence verifying alternation, P-visibility and O-visibility.
(iii) $\pview{?(t)}$ is the path in $\tau(M)$ from $r$ to the last node in $?(t)$.
\end{proposition}
This is the counterpart of proposition 6 from
\cite{OngHoMchecking2006}.

The \defname{reduction} of a traversal $t$ written $ t \upharpoonright r$, is the subsequence of $t$
obtained by keeping only the nodes that are hereditarily
justified by $r$. This has the effect of eliminating the ``internal nodes'' of the computation.

Application nodes are used to connect the operator and
the operand of an application in the computation tree but since they do not play
any role in the computation of the term, we can remove them from the traversals.
We write $t-@$ for the sequence of nodes with pointers obtained by
removing from $t$ all @-nodes and value-leaves of @-nodes,
any link pointing to an @-node being replaced by a link pointing to the immediate predecessor of @ in $t$.

We introduce the two notations $\travset(M)^{-@} = \{ t - @ \ | \  t \in \travset(M) \}$ and $\travset(M)^{\upharpoonright r} = \{ t  \upharpoonright r \ | \  t  \in \travset(M) \}$.
%\begin{remark}
%For $\beta$-normal terms, $\tau$ does not contain any @-node therefore all nodes are
%hereditarily justified by $r$ and $\travset(M)^{-@} \cong \travset(M) \cong  \travset(M)^{\upharpoonright r }$.
%\end{remark}

\begin{lemma}[View of a traversal reduction]
\label{lem:redtrav_trav}
If $M$ is in $\beta$-normal form then $\travset(M)^{-@} =\travset(M) = \travset(M)^{\upharpoonright r }$ and for all $t\in \travset(M)$:
\begin{itemize}
\item[(i)] $ \pview{?(t) \upharpoonright  r } = \pview{?(t)} \upharpoonright r$;
\item[(ii)] if the last node in $t$ is hereditarily justified by $r$ then $ \oview{?(t) \upharpoonright r } = \oview{?(t)}$.
\end{itemize}
\end{lemma}
In the safe $\lambda$-calculus without interpreted constants this lemma follows immediately from the fact that
$\travset(M) = \travset(M)^{\upharpoonright r }$. The lemma remains valid in the presence of interpreted constants provided that the traversal rules implementing the constants are \emph{well-behaved}.\footnote{A traversal rule is \defname{well-behaved} if it can be stated under the form
``$t = t_1\cdot n \cdot t_2 \in \travset \zand ?(t) = ?(t_1) \cdot x  \zand n \in N_{\Sigma}\union N_{var} \zand P(t) \zand m\in S(t) \imp
t_1\cdot \rnode{n}{n} \cdot t_2 \cdot \rnode{m}{m} \in \travset \link[nodesep=1pt]{26}{m}{n}$''
for some expression $P$ expressing a condition on $t$ and function $S$ mapping traversals of the form of $t$ to a subset of the children of $n$.}

\subsection{Relationship between Computation Tree and Game Arena}
We consider the well-bracketed game model of the simply typed $\lambda$-calculus.
We choose to represent strategies using ``prefix-closed set of plays''.
\footnote{In the literature, a strategy is commonly defined as a set of plays
closed by taking a prefix of \emph{even} length. However for the purpose of showing the correspondence with traversals, the ``prefix-closed'' version is more appropriate.}
We fix a term $\Gamma \vdash M : T$ and write $\sem{\Gamma \vdash M : T}$ for its strategy denotation.
The answer moves of a question $q$ are written $v_q$ where $v$ ranges in $\mathcal{D}$.

\begin{definition}[Mapping from nodes to moves]
\label{def:phi_psi mapping}
Let $q$ be a question move of $\sem{T}$ and $n \in N$ such that $n$ and $q$ are of type
$(A_1,\ldots,A_p,o)$.
Let $\{ q^1, \ldots, q^p \} \union \{  v_q \ | \ v \in \mathcal{D} \}$ be the set of moves enabled by $q$ where each $q^i$
is of type $A_i$. The function $\psi_M^{n,q}$ from $V^{\upharpoonright n}$ to $\sem{T}$ is defined as:
\begin{eqnarray*}
\psi^{n,q}_M &=& \{ n \mapsto q \} \union  \{ v_n \mapsto v_q \ | \ v \in \mathcal{D} \}\\
 &&\union \left\{
                \begin{array}{ll}
                  \emptyset, & \hbox{if $p=0$\ ;} \\
                  \Union_{m \in N | n \vdash_i m} \psi_M^{m, q^i}, & \hbox{if $p\geq1$ and $n\in N_{\lambda}$\ ;} \\
                  \Union_{i=1..p} \psi_M^{n.i, q^i}, & \hbox{if $p\geq1$ and $n\in N_{var}$\ .}
                \end{array}
              \right.
\end{eqnarray*}
Note that $\psi_M^{n,q}$ is only defined on nodes hereditarily enabled by $n$.
For any $n \in N$ let $A_n$ denote the type of $\kappa(n)$. We write $\psi_{\kappa(n)}$ for $\psi_{\kappa(n)}^{n,q}$ where $q$ denotes the initial move of $\sem{A_n}$. \footnote{Arenas involved in the game semantics of simply typed $\lambda$-calculus are trees.}


For a closed term $\vdash M : T$, the total function $\varphi_M$ from $V_\lambda \union V_{var}$ to $\sem{T} \uplus \biguplus_{n \in N'_@} \sem{A_n}$ is defined as $\varphi_M = \psi_M  \union \Union_{n \in N'_@} \psi_{\kappa(n)}$
where $N'_@$ denotes the set of children nodes of @-nodes.
For an open term $x_1 : X_1, \ldots, x_n : X_n \vdash M : T$, $\varphi_M$ is defined as
$\varphi_{\lambda x_1 \ldots x_n . M}$. When there is no ambiguity we omit the subscript in $\varphi_M$ and $\psi_M$.
\end{definition}
\begin{remark}
$\varphi$ maps $\lambda$-nodes to O-questions, variable nodes to
P-questions, value-leaves of $\lambda$-nodes to P-answers and
value-leaves of variable nodes to O-answers.
Moreover $\varphi$ maps nodes of a given order to moves of the same order.
\end{remark}
If $t = t_0 t_1 \ldots$ is a justified sequence
of nodes in $V_\lambda \union V_{var}$ then $\varphi(t)$ is defined
to be the sequence of moves $\varphi(t_0)\ \varphi(t_1) \ldots$
equipped with the pointers of $t$.

\begin{example}
Take $\lambda x . (\lambda g . g x) (\lambda y . y)$ with $x,y:o$ and $g:(o,o)$.
The diagram below represents the computation tree (middle), the arenas
$\sem{(o,o), o}$ (left), $\sem{o , o}$ (right), $\sem{o\rightarrow o}$ (rightmost)
and $\varphi = \psi \union \psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}} \union
\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}$
(dashed-lines).
$$\psset{levelsep=3.5ex}
\pstree{\TR[name=root]{\lambda x}}
{
    \pstree{\TR[name=App]{@}}
    {
            \pstree{\TR[name=lg]{\lambda g}}
                { \pstree{\TR[name=lgg]{g}}{
                        \pstree{\TR[name=lgg1]{\lambda}}
                        { \TR[name=lgg1x]{x}  } } }
            \pstree{\TR[name=ly]{\lambda y}}
                    {\TR[name=lyy]{y}}
    }
}
\rput(4.5cm,-1cm){
  \pstree{\TR[name=A1lx]{q_{\lambda x}}}
        { \TR[name=A1x]{q_x} }
}
\rput(-6cm,-1.5cm){
    \pstree{\TR[name=A2lg]{q_{\lambda g}}}
    {
        \pstree{\TR[name=A2g]{q_g}}
        {  \TR[name=A2g1]{q_{g_1}}   }
    }}
\rput(2.5cm,-1.5cm){
    \pstree{\TR[name=A3ly]{q_{\lambda y}}}
        { \TR[name=A3y]{q_y}
        }
}
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{A1lx} \mput*{\psi}
\ncarc{->}{lgg1x}{A1x}
\ncline{->}{lg}{A2lg} \mput*{\psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}}}
\ncline{->}{lgg}{A2g}
\ncline{->}{lgg1}{A2g1}
\ncline{->}{ly}{A3ly} \mput*{\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}}
\ncline{->}{lyy}{A3y}
$$
\end{example}




\subsection{The Correspondence Theorem}

In game semantics, strategy composition is achieved by performing a
CSP-like ``composition + hiding''. If the internal moves are not hidden
then we obtain an alternative semantics called \emph{interaction}
semantics in \cite{DBLP:conf/sas/DimovskiGL05} and \emph{revealed
semantics} in \cite{willgreenlandthesis}.
The \defname{revealed strategy} of a term $\Gamma \vdash M$, written $\intersem{\Gamma \vdash M}$, is obtained by uncovering\footnote{An algorithm 
that uniquely recovers hidden moves is given in Part II of \cite{hylandong_pcf}.} the
internal moves from $\sem{\Gamma \vdash M}$ that are generated by the composition with the evaluation map $ev$ at each @-node of the computation tree.
The standard semantics can be recovered from the interaction semantics by filtering out the internal moves.

In the simply typed $\lambda$-calculus, the set of traversals of the computation tree is isomorphic to the set of uncovered plays of the strategy
denotation (this is the counterpart of the ``Path-Traversal Correspondence'' of \cite{OngLics2006}). Moreover
the set of traversal reductions is isomorphic to the strategy denotation.
\begin{theorem}[The Correspondence Theorem]
\label{thm:correspondence}
\begin{eqnarray*}
(i) \  \varphi_M  &:& \travset(M)^{-@} \stackrel{\cong}{\longrightarrow} \intersem{\Gamma \vdash M} \\
(ii) \  \psi_M  &:& \travset(M)^{\upharpoonright r} \stackrel{\cong}{\longrightarrow} \sem{\Gamma \vdash M} \ .
\end{eqnarray*}
\end{theorem}

\begin{wrapfigure}[7]{r}{5.1cm}
\rput[t](2.5cm,0.8cm)
{
$\tree[levelsep=2.5ex,treesep=0.5cm]{ \Rnode{root} \lambda f z }
     {  \tree{@}
        {   \tree{\lambda g x}{
                  \tree{\Rnode{f}{f^{[1]}}}{
                            \tree{\Rnode{lmd}\lambda^{[2]}}
                            {\TR{x}}
                  }
                }
            \tree{ \lambda y }{\TR{y}}
            \tree{\lambda ^{[3]}}{
                \tree{\Rnode{f2}{f^{[4]}}} {
                \tree{\Rnode{lmd2}\lambda^{[5]}}{\TR{\Rnode{z}z}}
                }
            }
        }
     }
\hspace{1.1cm}
  \tree[levelsep=8ex,treesep=0.3cm]{ \Rnode{q0}q^0 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q2}q^1}}{\TR{\Rnode{q3}q^2}}
        \TR{\Rnode{q1}q^3}
        \TR{\Rnode{q4}q^4}
    }
\psset{nodesep=1pt,arrows=->,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q0} \aput*{:U}{\psi_M}
\ncarc[arcangle=-25]{->}{z}{q1}
\ncarc[arcangle=10]{->}{f}{q2}
\ncarc[arcangle=10]{->}{lmd}{q3}
\ncline{->}{f2}{q2}
\ncline{->}{lmd2}{q3}
$}
\end{wrapfigure}
%\begin{example}
\noindent \emph{Example:}
The term $\lambda f z . (\lambda g x . f x) (\lambda y. y) (f z)$ of type $(o,o),o, o$.
has for $\eta$-long normal form $\lambda f z . (\lambda g x . f x) (\lambda y. y) (\lambda . f z)$
giving the computation tree shown on the right.
The function $\psi_M$ is represented in dashed line. For clarity, only question moves are represented.
Take the traversal

 \raisebox{0cm}[0.75cm]{$
\rnode{q0}{\lambda f z} \
\rnode{n2}{@} \
\rnode{n3}{\lambda g x} \
\rnode{q2}{f^{[1]}} \
\rnode{q3}{\lambda^{[2]}} \
\rnode{q2b}{x} \
\rnode{q3b}{\lambda^{[3]}} \
\rnode{n8}{f^{[4]}} \
\rnode{n9}{\lambda^{[5]}} \
\rnode{q1}{z}
\link[ncurv=0.4]{50}{q2}{q0}
\link[ncurv=0.4]{50}{q3}{q2}
\link[ncurv=0.4]{43}{q2b}{n3}
\link[ncurv=0.4]{35}{q3b}{n2}
\link[ncurv=0.4]{30}{q1}{q0}
\link[ncurv=0.4]{35}{n3}{n2}
\link[ncurv=0.4]{30}{n8}{q0}
\link[ncurv=0.4]{45}{n9}{n8}$}. Its reduction
\raisebox{0cm}[0.6cm]{$
\rnode{q0}{\lambda f z} \
\rnode{q2}{f}^{[1]} \
\rnode{q3}{\lambda^{[2]}} \
\rnode{q2b}{f}^{[4]} \
\rnode{q3b}{\lambda^{[5]}} \
\rnode{q1}{z}
\link[ncurv=0.4]{50}{q2}{q0}
\link[ncurv=0.4]{50}{q3}{q2}
\link[ncurv=0.4]{50}{q2b}{q0}
\link[ncurv=0.4]{50}{q3b}{q2b}
\link[ncurv=0.4]{40}{q1}{q0}$}
is mapped by $\psi$ to the play
\raisebox{0cm}[0.5cm]{$
\rnode{q0}{q}^0\ \rnode{q2}{q}^1\ \rnode{q3}{q}^2\ \rnode{q2b}{q}^1\ \rnode{q3b}{q}^2\ \rnode{q1}{q}^3
\link[offset=-3pt]{50}{q2}{q0}
\link[offset=-3pt,ncurv=0.5]{50}{q2b}{q0}
\link[offset=-3pt]{50}{q3}{q2}
\link[offset=-3pt]{50}{q3b}{q2b}
\link[offset=-3pt,ncurv=0.4]{50}{q1}{q0}$} of
$\sem{M}$.
%\end{example}




\section*{Appendix B -- Proof of Theorem \ref{thm:safeincrejust} and \ref{thm:safepcfpincr}}
A binder node always occurs in the path from the bound node to the root.
We introduce a class of computation trees in which the binder node is uniquely determined by the node orders.
\begin{definition}
A computation tree is \defname{incrementally-bound} if for 
all variable node $x$, either
$x$ is \emph{bound} by the first $\lambda$-node in the path to the root with order $> \ord{x}$
or $x$ is a \emph{free variable} and all the $\lambda$-nodes in the path to the root except the root have order $\leq \ord{x}$.
\end{definition}

Using Lemma \ref{lem:redtrav_trav} we can show the following:
\begin{proposition} %[Incremental-binding vs P-incremental-justification]
\label{prop:incrbound_imp_incrjustified}
If $M$ is a $\beta$-normal term then
$\tau(M)$ is incrementally-bound if and only if $\sem{M}$
is P-incrementally-justified.
\end{proposition}

%\parpic(0.5cm,2cm)(5pt,0.75cm)[x]{ $\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$ }
%\parpic(0.5cm,1cm)(0.1pt,0.2cm)[r]{ $\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$ }
%\parpic(0.3cm,1cm)[r]{ \rput[t](0,0cm){$\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$} }
%%%  ah Latex... i hate you !!!
%\begin{floatingfigure}[r]{60mm}
%$%\rput[t](0cm,0cm)
%{\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
%\end{floatingfigure}

\begin{wrapfigure}[5]{r}{0.6cm}
$\rput[b](0.1cm,-1cm)
{\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
\end{wrapfigure}
\noindent \emph{Example:} %\begin{example}
Consider the $\beta$-normal term $f (\lambda y .x)$ where $x,y:o$ and $f:(o,o),o$. The figure on
the right represents the computation tree with the node orders given in exponent.
Node $x$ is not incrementally-bound therefore $\tau(f (\lambda y .x))$ is not incrementally-bound and
by Proposition \ref{prop:incrbound_imp_incrjustified}, $\sem{f (\lambda
y .x)}$ is not incrementally-justified (although $\sem{f}$ and $\sem{\lambda y. x}$ are).
%\end{example}

\begin{proposition} %[Safety and incremental-binding]
\label{prop:safe_imp_incrbound}
(i) If $M$ is safe then $\tau(M)$ is incrementally-bound.
(ii) Conversely, if $M$ is a \emph{closed} simply typed term and $\tau(M)$ is incrementally-bound then the $\eta$-normal form of $M$ is safe.
\end{proposition}

The hypothesis that $M$ is closed is necessary, for instance for $x,y:o$, $\tau(\lambda x y .x) = \tau(\lambda y . x)$
are incrementally-bound but $\lambda x y .x$ is safe and not $\lambda y . x$.

\begin{proof}
(i) Suppose that $M$ is safe. By Lemma \ref{lem:elnf_preserves_safety}
the $\eta$-normal form of $M$ is safe therefore $\tau(M)$ is the tree representation of a safe term.

In the safe $\lambda$-calculus, the variables in the context with the lowest order must be all abstracted
at once when using the abstraction rule. Since the computation
tree merges consecutive abstractions into a single node,
any variable $x$ occurring free in the subtree rooted at a node $\lambda \overline{\xi}$ different from the root
must have order greater or equal to $\ord{\lambda \overline{\xi}}$. Reciprocally, if a lambda node
$\lambda \overline{\xi}$ binds a variable node $x$ then
$\ord{\lambda \overline{\xi}} = 1+\max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Let $x$ be a bound variable node. Its binder occurs in the path from $x$
to the root, therefore, according to the previous observation, $x$ must be bound
by the first $\lambda$-node occurring in this path with order $>\ord{x}$. Let $x$ be a free variable node then $x$ is not bound by any of the $\lambda$-nodes occurring in the path to the root. Once again, by the previous observation, all
these $\lambda$-nodes except the root have order smaller than $\ord{x}$. Hence
$\tau$ is incrementally-bound.

(ii) Let $M$ be a closed term such that $\tau(M)$ is incrementally-bound.
We assume that $M$ is already in $\eta$-normal form.
We prove that $M$ is safe by induction on its structure. The base case $M =
\lambda \overline{\xi} . x$ for some variable $x$ is trivial.
\emph{Step case:} If $M = \lambda \overline{\xi} . N_1 \ldots N_p$.
Let $i$ range over $1..p$. We have $N_i \equiv \lambda \overline{\eta_i} . N'_i$ for some applicative term $N'_i$. By the
induction hypothesis, $\lambda \overline{\xi} . N_i = \lambda \overline{\xi} \overline{\eta_i} . N'_i$ is safe i.e. $\vdash \lambda \overline{\xi} \overline{\eta_i} . N'_i$
is a valid judgment of safe $\lambda$-calculus.
Such judgment can only be derived using the (abs) rule therefore $N'_i$ is necessarily safe. Let $z$ be a free variable of 
$N'_i$ not bound by $\lambda \overline{\eta_i}$ in $N_i$. Since $\tau(M)$ is incrementally-bound we have $\ord{z} \geq \ord{\lambda
\overline{\eta_1}} = \ord{N_i}$. Hence we can abstract the variables $\overline{\eta_1}$ using the (abs) rule thus $N_i$ is safe.
Finally we conclude $\vdash M = \lambda \overline{\xi} . N_1 \ldots N_p$ using the
rules (app) and (abs).
\qed
\end{proof}

\subsection{Proof of Theorem \ref{thm:safeincrejust}}
(i) Let $M$ be a safe simply typed term. By Lemma \ref{lem:safered_preserve_safety}, its $\beta$-normal form $M'$ is also safe. By Proposition \ref{prop:safe_imp_incrbound}(i), $\tau(M')$ is incrementally-bound and by Proposition
\ref{prop:incrbound_imp_incrjustified}, $\sem{M'}$ is an
incrementally-justified. Finally the soundness of the game model gives $\sem{M} = \sem{M'}$.
(ii) is a consequence of Lemma \ref{lem:safered_preserve_safety},
Proposition \ref{prop:incrbound_imp_incrjustified}  and 
\ref{prop:safe_imp_incrbound}(ii) and soundness of the game model.
\qed

\subsection{Proof of Theorem \ref{thm:safepcfpincr}}

The computation tree of a \pcf\ term is defined as the least upper-bound of
the chain of computation trees of its \emph{syntactic approximants} \cite{abramsky:game-semantics-tutorial}.
It is obtained by infinitely expanding terms that use the $Y$ combinator, for instance
$\tau(Y (\lambda f x. f x))$ is
the tree representation of the $\eta$-normal form of the infinite term
$(\lambda f x. f x) ((\lambda f x. f x) ((\lambda f x. f x)  (
\ldots$\ .


It is straightforward to define the traversal rules modeling the arithmetic constants of \pcf. Just as in the safe $\lambda$-calculus we had to remove @-nodes in order to reveal the game-semantic correspondence, in safe \pcf\ it is necessary to filter out the constant nodes from the traversals. The Correspondence Theorem for \pcf\ says that the interaction game semantics is isomorphic to the set of traversals disposed of these superfluous nodes. It is straightforward to show it for term approximants. The result is then lifted to any \pcf\ term by observing that the function $\travset^{\upharpoonright r}$ from the set of sets of justified sequences of nodes ordered by subset inclusion to the set of computation trees ordered by the approximation ordering
is continuous.

\pcf\ computation trees are incrementally-bound (Proposition \ref{prop:safe_imp_incrbound}) although they can be infinite.
Moreover the traversal rules for \pcf\ are \emph{well-behaved} hence lemma \ref{lem:redtrav_trav} still holds and the game-semantic analysis of safety remains valid for \pcf.


\end{document}
