% the LaTeX macro package from Springer-Verlag for Lecture Notes in
% Computer Science, version 2.2 for LaTeX2e
\documentclass{llncs}
\usepackage{amssymb}
\usepackage{pst-tree}
\usepackage{pstring}
\usepackage{wrapfig}
\usepackage[defblank]{paralist}
%\usepackage[all]{xy}
%\usepackage[compact]{titlesec} % saves even more space

\usepackage{picins}
%\usepackage{floatflt}
%

% highlight for definition names
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

% reduction, substitution
\newcommand\betared{\rightarrow_\beta}
\newcommand\betasred{\rightarrow_{\beta_s}}
\newcommand\betaredtr{\twoheadrightarrow_\beta} % transitive closure of the beta reduction
\newcommand\subst[2]{\left[ #1/#2 \right]}
\newcommand\captsubst[2]{\{#1/#2 \}}

% computation tree, eta normal form, traversals
\newcommand{\elnf}[1]{\lceil #1\rceil} % eta long normal form
\newcommand\travset{\mathcal{T}rv}

% lambda calculus
%\newcommand\mybot{\perp}
\newcommand{\encode}[1]{\overline{#1}} \newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{\dps #2}}
\newcommand\rulefex[3][5pt]{\frac{\dps
    #2}{\stackrel{\rule{0pt}{#1}}{\dps #3}}}
\newcommand\ord[1]{{\sf
    ord}(#1)} \newcommand\typear{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(#1)}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\nat{\mathbb{N}}


% game semantics
\newcommand{\sem}[1]{{[\![ #1 ]\!]}}
\newcommand{\intersem}[1]{{\langle\!\langle #1 \rangle\!\rangle}}

% logic
\newcommand\imp{\Longrightarrow}
\newcommand\zand{\wedge}
\newcommand\entail{\vdash}

% pcf and ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}
\newcommand\pcf{\textsf{PCF}}

% justified sequence of moves
\newcommand{\oview}[1]{\llcorner #1 \lrcorner}
\newcommand{\pview}[1]{\ulcorner #1 \urcorner}


% trees
\newcommand{\tree}[2][levelsep=3.5ex]{\pstree[levelsep=3.5ex,#1]{\TR{#2}}}
\newcommand{\arclabel}[1]{\mput*{\mbox{{\small $#1$}}}}
        \newcommand\mng[1]{{\mathopen{[\![}\,#1\,\mathclose{]\!]}}}


\definecolor{darkGreen}{rgb}{0.03,0.35,0.05}
\pstrSetArrowColor{darkGreen}

\begin{document}

\frontmatter          % for the preliminaries
\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{} % additional mark in the TOC

\mainmatter              % start of the contributions

\title{The Safe Lambda Calculus}

\titlerunning{The Safe Lambda Calculus} % abbreviated title (for
% running head)
%                                     also used for the TOC unless
%                                     \toctitle is used


\author{W.~Blum~~~~~~~~~~~C.-H.~L.~Ong}
%
\authorrunning{W. Blum \and C.-H.~L.~Ong}  % abbreviated author list (for
% running head)
%
% modified list of authors for the TOC (add the affiliations)
\tocauthor{W.~Blum (University of Oxford), C.-H.~L.~Ong (University of Oxford)}


\institute{Oxford University Computing Laboratory\\
Wolfson Building, Parks Road, Oxford OX1 3QD, ENGLAND\\
\email{{\fontfamily{cmr}\{}william.blum,luke.Ong{\fontfamily{cmr}\}}@comlab.ox.ac.uk }}

\maketitle              % typeset the title of the contribution

\pagestyle{empty}

% TLCA05:
%    Papers should not exceed 15 pages in Springer LNCS format.
%    An abstract (ASCII text) of no more than 150 words should be sent separately at least a weak before the paper submission deadline.

% LNCS:
%    The abstract should summarize the contents of the paper
%    using at least 70 and at most 150 words. It will be set in 9-point
%    font size and be inset 1.0 cm from the right and left margins.
%    There will be two blank lines before and after the Abstract. \dots

\begin{abstract}
  Safety is a syntactic condition of higher-order grammars that
  constrains occurrences of variables in the production rules
  according to their type-theoretic order. In this paper, we introduce
  the \emph{safe lambda calculus}, which is obtained by transposing
  (and generalising) the safety condition to the setting of the
  simply-typed lambda calculus. In contrast to the original definition
  of safety, our calculus does not constrain types (to be
  homogeneous). We show that in the safe lambda calculus, there is no
  need to rename bound variables when performing substitution, as
  variable capture is guaranteed not to happen.  We also propose an
  adequate notion of $\beta$-reduction that preserves safety.  In the
  same vein as Schwichtenberg's 1976 characterisation of the
  simply-typed lambda calculus, we show that the numeric functions
  representable in the safe lambda calculus are exactly the
  multivariate polynomials; thus conditional is not definable.
  Finally we give a game-semantic analysis of safety: We show that
  safe terms are denoted by \emph{P-incrementally justified
    strategies}. Consequently pointers in the game semantics of safe
  $\lambda$-terms are only necessary from order 4 onwards.
\end{abstract}

\section{Introduction}

\subsection*{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and
Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars. The
idea, however, goes back some twenty years to Damm \cite{Dam82} who
introduced an essentially equivalent\footnote{See de Miranda's
 thesis \cite{demirandathesis} for a proof.} syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
% Level-$n$ tree grammars as defined by Damm correspond exactly to a
% subset of safe level-$n$ grammars -- namely the safe complete grammars
% -- and every safe grammar corresponds to a safe complete one.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important. As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterisations:

\begin{itemize}
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe} grammars
  form an infinite hierarchy as $n$ varies over the natural numbers.
  The hierarchy gives an attractive classification of the
  semi-decidable languages: Levels 0, 1 and 2 of the hierarchy are
  respectively the regular, context-free, and indexed languages (in
  the sense of Aho \cite{Aho68}), although little is known about
  higher orders.

  Remarkably, for generating word languages, order-$n$ \emph{safe}
  grammars are equivalent to order-$n$ pushdown automata \cite{DG86},
  which are in turn equivalent to order-$n$ indexed grammars
  \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has been recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have decidable
    MSO theories.}.

  They have also generalised the equi-expressivity result due to Damm
  and Goerdt \cite{DG86} to an equivalence result with respect to
  generating trees: A tree is generated by an order-$n$ \emph{safe}
  grammar if and only if it is generated by an order-$n$ pushdown
  automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated\footnote{These are precisely the
    configuration graphs of higher-order pushdown systems.} by
  \emph{safe} grammars of every finite order are decidable. However,
  in a recent preprint \cite{hague-sto07}, Hague \emph{et al.} have
  shown that the MSO theories of graphs generated by order-$n$
  \emph{unsafe} grammars are undecidable, but deciding their modal
  mu-calculus theories is $n$-EXPTIME complete.
\end{itemize}

\subsection*{Overview}

In this paper, we aim to understand the safety condition in the
setting of the lambda calculus. Our first task is to transpose it to
the lambda calculus and pin it down as an appropriate sub-system of
the simply-typed theory. A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and cleaner
version where terms are no longer required to be homogeneously typed
(see Section~\ref{sec:safe} for a definition). The formation rules of
the calculus are designed to maintain a simple invariant: Variables
that occur free in a safe $\lambda$-term have orders no smaller than
that of the term itself.  We can now explain the sense in which the
safe lambda calculus is safe by establishing its salient property: No
variable capture can ever occur when substituting a safe term in
another. In other words, in the safe lambda calculus, it is
\emph{safe} to use capture-\emph{permitting} substitution when
performing $\beta$-reduction.

%[Numeric functions representable in the safe lambda calculus.]

There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable names
in the input term. Safe lambda calculus is thus cheaper to compute in
this na\"ive sense. Intuitively one would expect the safety constraint
to lower the expressivity of the simply-typed lambda calculus. Our
next contribution is to give a precise measure of the expressivity
deficit of the safe lambda calculus. An old result of Schwichtenberg
\cite{citeulike:622637} says that the numeric functions representable
in the simply-typed lambda calculus are exactly the multivariate
polynomials \emph{extended with the conditional function}.  In the
same vein, we show that the numeric functions representable in the
safe lambda calculus are exactly the multivariate polynomials.

Our last contribution is to give a game-semantic account of the safe
lambda calculus.
% Not much is known about the safe $\lambda$-calculus, and many problems
% remain to be studied concerning its computational power, the
% complexity classes that it characterises, its interpretation under the
% Curry-Howard isomorphism and its game-semantic characterisation. This
% paper is a contribution to the last problem.
%
% The difficulty in giving a game-semantic account of safety lies in the
% fact that it is a syntactic restriction whereas game semantics is
% syntax-independent. The solution consists in finding a particular
% syntactic representation of terms on which the plays of the game
% denotation can be represented.  To achieve this, we use ideas recently
% introduced by the second author \cite{OngLics2006}: a term is
% canonically represented by a certain abstract syntax tree of its
% $\eta$-long normal form referred as the \emph{computation tree}. This
% abstract syntax tree is specially designed to establish a
% correspondence with the game arena of the term. A computation is
% described by a justified sequence of nodes of the computation tree
% respecting some formation rules and called a
% \emph{traversal}. Traversals permit us to model $\beta$-reductions
% without altering the structure of the computation tree via
% substitution. A notable property is that \emph{P-views} (in the
% game-semantic sense) of traversals corresponds to paths in the
% computation tree.  We show that traversals are just representations of
% the uncovering of plays of the game-semantic denotation. We then
% define a \emph{reduction} operation which eliminates traversal nodes
% that are ``internal'' to the computation, this implements the
% counterpart of the hiding operation of game semantics. Thus, we obtain
% an isomorphism between the strategy denotation of a term and the set
% of reductions of traversals of its computation tree.
Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are denoted
by \emph{P-incrementally justified strategies}. In such a strategy,
pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically, a P-question always
points to the last pending O-question (in the P-view) of a greater
order. Consequently pointers in the game semantics of safe
$\lambda$-terms are only necessary from order 4 onwards. Finally we
prove that a $\eta$-long $\beta$-normal $\lambda$-term is \emph{safe}
if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.



% \subsection*{Related work}

% \noindent\emph{The safety condition for higher-order grammars}

% \smallskip

% \noindent We have mentioned the result of Knapik \emph{et al.}~\cite{KNU02} that
% infinite trees generated by \emph{safe} higher-order grammars have
% decidable MSO theories.  A natural question to ask is whether the
% \emph{safety condition} is really necessary.  This has then been
% partially answered by Aehlig \emph{et al.}
% \cite{DBLP:conf/tlca/AehligMO05} where it was shown that safety is not
% a requirement at level $2$ to guarantee MSO decidability. Also, for
% the restricted case of word languages, the same authors have shown
% \cite{DBLP:conf/fossacs/AehligMO05} that level $2$ safe higher-order
% grammars are as powerful as (non-deterministic) unsafe ones.  De
% Miranda's thesis \cite{demirandathesis} proposes a unified framework
% for the study of higher-order grammars and gives a detailed analysis
% of the safety constraint at level 2.

% More recently, one of us obtained a more general result and showed
% that the MSO theory of infinite trees generated by higher-order
% grammars of any level, \emph{whether safe or not}, is decidable
% \cite{OngLics2006}.  Using an argument based on innocent
% game-semantics, he establishes a correspondence between the tree
% generated by a higher-order grammar called \emph{value tree} and a
% certain regular tree called \emph{computation tree}. Paths in the
% value tree correspond to traversals in the computation tree.
% Decidability is then obtain by reducing the problem to the acceptance
% of the (annotated) computation tree by a certain alternating parity
% tree automaton.  The approach that we follow in
% Sec. \ref{sec:correspondence} uses many ingredients introduced in this
% paper.


% The equivalence of \emph{safe} higher-order grammars and higher-order
% deterministic push-down automata for the purpose of generating
% infinite trees \cite{KNU02} has its counterpart in the general (not
% necessarily safe) case: the forthcoming paper \cite{hague-sto07}
% establishes the equivalence of order-$n$ higher-order grammars and
% order-$n$ \emph{collapsible pushdown automata}. Those automata form a
% new kind of pushdown systems in which every stack symbol has a link to
% a stack situated somewhere below it and with an additional stack
% operation whose effect is to ``collapse'' a stack $s$ to the state
% indicated by the link from the top stack symbol.

% \medskip

% \noindent\emph{Computation trees and traversals}

% \smallskip

% \noindent In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph
% based on Lamping's graphs \cite{lamping} is introduced to represent
% $\lambda$-terms. The authors unify different notions of paths
% (regular, legal, consistent and persistent paths) that have appeared
% in the literature as ways to implement graph-based reduction of
% $\lambda$-expressions. We can regard a traversal as an alternative
% notion of path adapted to the graph representation of
% $\lambda$-expressions given by computation trees.

% The traversals of a computation tree provide a way to perform
% \emph{local computation} of $\beta$-reductions as opposed to a global
% approach where the $\beta$-reduction is implemented by performing
% substitutions. A notion of local computation of $\beta$-reduction has
% been investigated by Danos and Regnier
% \cite{DanosRegnier-Localandasynchronou} through the use of special
% graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The safe lambda calculus}
\label{sec:safe}
\subsection*{Higher-order safe grammars}
We first present the safety restriction as it was originally defined
\cite{KNU02}. We consider simple types generated by the grammar $A \,
::= \, o \; | \; A \typear A$. By convention, $\rightarrow$ associates
to the right. Thus every type can be written as $A_1 \typear \cdots
\typear A_n \typear o$, which we shall abbreviate to $(A_1, \cdots,
A_n, o)$ (in case $n = 0$, we identify $(o)$ with $o$). The
\emph{order} of a type is given by $\ord{o} = 0$ and $\ord{A \typear
  B} = \max(\ord{A}+1, \ord{B})$. We assume an infinite set of typed
variables. The order of a typed term or symbol is defined to be the
order of its type.

Recall that a (higher-order) \defname{grammar} is a tuple $\langle
\Sigma, \mathcal{N}, \mathcal{R}, S \rangle$, where $\Sigma$ is a
ranked alphabet (in the sense that each symbol $f \in \Sigma$ has an
arity $\mathit{ar}(f) \geq 0$) of terminals\footnote{Each $f \in
  \Sigma$ of arity $r \geq 0$ is assumed to have type $(\underbrace{o,
    \cdots, o}_r, o)$.}; $\mathcal{N}$ is a finite set of typed
non-terminals; $S$ is a distinguished ground-type symbol of
$\mathcal{N}$, called the start symbol; $\mathcal{R}$ is a finite set
of production (or rewrite) rules, one for each non-terminal $F : (A_1,
\ldots, A_n, o) \in \mathcal{N}$, of the form $ F z_1 \ldots z_m
\rightarrow e$ where each $z_i$ (called \emph{parameter}) is a
variable of type $A_i$ and $e$ is an applicative term of type $o$
generated from the symbols in $\Sigma \union \mathcal{N} \union \{z_1,
\ldots, z_m \}$. We say that the grammar is \emph{order-$n$} just in
case the order of the highest-order non-terminal is $n$.

The \defname{tree generated by a recursion scheme} $G$ is a possibly
infinite applicative term, but viewed as a $\Sigma$-labelled tree,
\emph{constructed from the terminals in $\Sigma$}, that is obtained by
unfolding the rewrite rules of $G$ \emph{ad infinitum}, replacing
formal by actual parameters each time, starting from the start symbol
$S$. See e.g.~\cite{KNU02} for a formal definition.

\parpic[r]{
%\small$\xymatrix@R-.8cm@C-.5cm{& g \ar@{-}[dl]
%    \ar@{-}[dr] & & \\
%    a & & g \ar@{-}[dl] \ar@{-}[dr] & \\
%    & a & & h \ar@{-}[d] \\
%    & & & h \ar@{-}[d]\\
%    & & & \vdots}$
$\tree[levelsep=3ex,nodesep=1pt,treesep=1cm,linewidth=0.5pt]{g}
{  \TR{a}
	\tree{g}{\TR{a} \tree{h}{\tree{h}{\vdots}}}
}$
}
\begin{example}\rm\label{eg:running}
  Let $G$ be the following order-2 recursion scheme:
% \[\begin{array}{ll}
% \begin{array}{rll}
% S & \rightarrow & H \, a\\
% H \, z & \rightarrow & F \, (g \,
% z)\\
% F \, \phi} & \rightarrow & \phi \, (\phi \, (F \, h))\\
% \end{array} & \qquad
% \begin{array}{l}
% \xymatrix@R-.8cm@C-.2cm{& g \ar@{-}[dl]
% \ar@{-}[dr] & & \\
% a & & g \ar@{-}[dl] \ar@{-}[dr] & \\
% & a & & h \ar@{-}[d] \\
% & & & h \ar@{-}[d] \\
% & & & \vdots}
% \end{array}
% \end{array}\]
\[\begin{array}{rll}
  S & \rightarrow & H \, a\\
  H \, z^o & \rightarrow & F \, (g \,
  z)\\
  F \, \phi^{(o, o)} & \rightarrow & \phi \, (\phi \, (F \, h))\\
\end{array}\]
where the arities of the terminals $g, h, a$ are $2, 1, 0$ respectively.
The tree generated by $G$ is defined by the infinite term $g \, a \, (g \, a \, (h \, (h \, (h \,
\cdots))))$.%  The only infinite \emph{path} in the
% tree is the node-sequence $\epsilon \cdot 2 \cdot 22 \cdot 221 \cdot
% 2211 \cdots$.

%(with the corresponding \textbfit{trace} $g \, g \, h \, h \, h \,
%\cdots \; \in \; \Sigma^\omega$).
\end{example}

A type $(A_1, \cdots, A_n, o)$ is said to be \defname{homogeneous} if
$\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$, and each $A_1$,
\ldots, $A_n$ is homogeneous \cite{KNU02}.  We reproduce the following
definition from \cite{KNU02}.

\begin{definition}[Safe grammar]\rm
  (We assume that all types are homogeneous.) A term of order $k > 0$
  is \emph{unsafe} if it contains an occurrence of a parameter of
  order strictly less than $k$, otherwise the term is \emph{safe}. An
  occurrence of an unsafe term $t$ as a subexpression of a term $t'$
  is \emph{safe} if it is in the context $\cdots (ts) \cdots$,
  otherwise the occurrence is \emph{unsafe}. A grammar is
  \defname{safe} if no unsafe term has an unsafe occurrence at a
  right-hand side of any production.
%   A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be
%   \defname{unsafe} if the righthand term $e$ has a subterm $t$ such
%   that
% \begin{enumerate}[(i)]
% \item $t$ occurs in an {\em operand} ({\it i.e.}~second) position of some
%   occurrence of the implicit application operator {\it i.e.}~$e$ has the
%   form $\cdots (s \, t) \cdots $ for some $s$
% \item $t$ contains an occurrence of a parameter $z_i$ (say) whose
%   order is less than that of $t$.
% \end{enumerate}
% A homogeneous grammar is said to be \defname{safe} if none of its
% rewrite rules is unsafe.
\end{definition}

\begin{example}\begin{inparaenum}[(i)] \item Take $\; H : ((o, o), o), \; f : (o, o, o)$; the
    following rewrite rules are unsafe (in each case we underline the
    unsafe subterm that occurs unsafely):
\[\begin{array}{rll}
G^{(o, o)} \, x & \quad \rightarrow \quad & H \, \underline{(f \, {x})} \\
F^{((o, o), o, o, o)} \, z \, x \, y & \quad \rightarrow \quad & f \, (F \, \underline{(F \, z
\, {y})} \, y \, (z \, x) ) \, x \\
\end{array}\]
\item The order-2 grammar defined in Example~\ref{eg:running} is
  unsafe.
\end{inparaenum}
% The
% reader is referred to the literature
% \cite{KNU02,demirandathesis,safety-mirlong2004}
% for details about the safety restriction for higher-order grammars.
\end{example}

\subsection*{Safety adapted to the lambda calculus}
We assume a set $\Xi$ of higher-order constants. 
We use sequents of the form $\Gamma \vdash_\Xi M : A$ to represent
terms-in-context where $\Gamma$ is the context and $A$ is the type of
$M$. For simplicity
we write $(A_1, \cdots, A_n, B)$ to mean $A_1 \typear \cdots \typear
A_n \typear B$, where $B$ is not necessarily ground.

\begin{definition}\rm
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus defined by induction over the
  following rules:
$$ \rulename{var} \ \rulef{}{x : A\vdash_\Xi x : A} \quad
\rulename{const} \ \rulef{}{\vdash_\Xi f : A} \quad f \in \Xi \quad
\rulename{wk} \ \rulef{\Gamma \vdash_\Xi s : A}{\Delta \vdash_\Xi s : A} \quad
\Gamma \subset \Delta$$
$$ \rulename{app} \ \rulef{\Gamma \vdash_\Xi s : (A_1,\ldots,A_n,B) \
  \Gamma \vdash_\Xi t_1 : A_1 \; \ldots \; \Gamma \vdash_\Xi t_n : A_n
} {\Gamma \vdash_\Xi s t_1 \ldots t_n : B} \ \ord{B} \sqsubseteq
\ord{\Gamma}$$
$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \vdash_\Xi s : B} {\Gamma \vdash_\Xi \lambda x_1 \ldots x_n . s :
  (A_1, \ldots ,A_n,B)} \ \ord{A_1, \ldots ,A_n,B} \sqsubseteq
\ord{\Gamma}$$ where $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y
\in \Gamma \}$ and ``$c \sqsubseteq S$'' means that $c$ is a
lower-bound of the set $S$. For convenience, we shall omit the
subscript from $\vdash_\Xi$ whenever the generator-set $\Xi$ is clear from
the context.

\noindent \item The sub-system that is defined by the same rules in
(i), such that all types that occur in them are homogeneous, is called
the \defname{homogeneous safe lambda calculus}.
\end{inparaenum}
\end{definition}

The first deviation from the standard definition of the simply-typed
lambda calculus is that the rules {\sf (app)} and {\sf (abs)}
respectively can perform multiple applications and abstract several
variables at once. (Of course this feature alone does not alter
expressivity.) Crucially, the side-conditions in the application rule
and abstraction rules require that variables in the typing context
have order no smaller than that of the term being formed.  We do not
impose any constraint on types. In particular, type-homogeneity as
used originally to define safe grammars \cite{KNU02} is not required
here. Another difference is that we allow $\Xi$-constants to have
arbitrary higher-order types.  % Thus our formulation
% of the safe lambda calculus is more general than the one proposed in
% the technical report \cite{safety-mirlong2004}. (It is possible to
% reconcile the two definitions by adding the further constraint that
% each type occurring in our rules is homogeneous and by restricting
% constants to at most order 1.)

First we note that when restricted to the homogeneously-typed
sub-system, the safe lambda calculus captures the original notion
of safety due to Knapik \emph{et al.} in the context of higher-order
grammar:

\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, \mathcal{R},
  S \rangle$ be a grammar and let $e$ be an applicative term generated
  from the symbols in $\mathcal{N} \cup \Sigma \cup \makeset{z_1^{A_1},
    \cdots, z_m^{A_m}}$.  A rule $F z_1 \ldots z_m \rightarrow e$ in
  $\mathcal{R}$ is safe if and only if $ z_1 : A_1, \cdots, z_m : A_m
  \vdash_{\Sigma \cup \mathcal{N}} e : o$ is a valid typing judgement
  of the \emph{homogeneous} safe lambda calculus.
\end{proposition}

\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y
))$ and $M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where
$x,y:o$ and $f:((o,o),o)$. The term $M_2$ is not safe because in the
subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{\lambda y . x} = 1$.  On the other hand, $M_1$
is safe.
%On the other hand, $M_1$ is safe as the following proof tree shows:
%$$
% \rulef{
%     \rulef{
%        \rulef{}{f \vdash f} {\sf(var)}
%        \
%        \rulef{
%             \rulef{
%                \rulef{
%                    \rulef{}{f \vdash f} {\sf(var)}
%                }
%                {f , x \vdash f } {\sf(wk)}
%                \
%                \rulef{
%                    \rulef{
%                        \rulef{}{y \vdash y} {\sf(var)}
%                    }
%                    {y \vdash \lambda y . y } {\sf(abs)}
%                }
%                {f , x \vdash \lambda y .y } {\sf(wk)}
%             }
%             {f , x \vdash f (\lambda y .y )} {\sf(app)}
%        }
%        { f  \vdash \lambda x . f (\lambda y .y )} {\sf(abs)}
%     }
%     {
%        f  \vdash f (\lambda x . f (\lambda y .y ))} {\sf(app)}
%     }
% { \vdash M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } {\sf(abs)}
%$$
\end{example}

It is easy to see that valid typing judgements of the safe lambda
calculus satisfy the following simple invariant:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \vdash M : A$ then every variable in $\Gamma$ occurring
free in $M$ has order at least $ord(M)$.
\end{lemma}

\emph{In what sense is the safe lambda calculus safe?} A basic idea
in the lambda calculus is that when performing $\beta$-reduction, one
must use capture-\emph{avoiding} substitution, which is standardly
implemented by renaming bound variables afresh upon each substitution.
In the safe lambda calculus, however, variable capture can never
happen (as the following lemma shows). Substitution can therefore be
implemented simply by capture-\emph{permitting} replacement, without
any need for variable renaming. In the following, we write
$M\captsubst{N}{x}$ to denote the capture-\emph{permitting}
substitution\footnote{This substitution is implemented by textually
  replacing all free occurrences of $x$ in $M$ by $N$ without
  performing variable renaming.  In particular for the abstraction
  case $(\lambda \overline{y} . P)\captsubst{N}{x}$ is defined as
  $\lambda \overline{y} . P\captsubst{N}{x}$ if $x\not\in
  \overline{y}$ and $\lambda \overline{y} . P$ elsewhere.} of $N$ for
$x$ in $M$.

\begin{lemma}[No variable capture]\label{lem:nvc}
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x:B \vdash M : A$ and $\Gamma \vdash  N : B$ are valid judgments of the safe lambda calculus.
\end{lemma}

\begin{proof}
  We proceed by structural induction. The variable, constant and
  application cases are trivial. For the abstraction case, suppose $M = \lambda \overline{y}. R$ where $\overline{y} = y_1
  \ldots y_p$. If $x \in \overline{y}$ then $M \captsubst{N}{x} = M$ and there is no variable capture.

 If $x \not\in \overline{y}$ then we have $M \captsubst{N}{x} = \lambda \overline{y} . R \captsubst{N}{x}$.  By the induction hypothesis there is no variable capture in $R \captsubst{N}{x}$.  Thus variable capture can only happen if the following two conditions are met: $x$ occurs freely in $R$, and some variable $y_i$ for $1 \leq i \leq p$ occurs freely in $N$. By Lemma \ref{lem:ordfreevar}, the latter condition  implies $\ord{y_i} \geq \ord{N} = \ord{x}$.  Since $x \not \in \overline{y}$, the former condition implies that $x$ occurs freely in the safe term $\lambda \overline{y}. R$
  therefore Lemma \ref{lem:ordfreevar} gives $ \ord{x} \geq
  \ord{\lambda \overline{y} . R} \geq 1+ \ord{y_i} > \ord{y_i}$ which  gives a contradiction. \qed
\end{proof}

\begin{remark}
  A version of the No-variable-capture Lemma also holds in safe
  grammars, as is implicit in (for example Lemma 3.2 of) the original
  paper \cite{KNU02}.
\end{remark}

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \vdash (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    x}) : (o,o)\] one should rename the bound variable $x$ with a fresh name to
  prevent the free occurrence of $x$ in the underlined term from
  capture during substitution. Consequently, by the previous lemma,
  the term is not safe. Indeed, it cannot be because $\ord{x} = 0 < 1
  = \ord{f x}$.
\end{example}

Note that safety does not capture the entire set of $\lambda$-terms
that satisfy the no-variable-capture property (in the sense of
Lemma~\ref{lem:nvc}). For instance the $\beta$-redex in $\lambda y^o
z^o. (\lambda x^o .y) z$ can be contracted using capture-permitting
substitution, even though the term is not safe.

\subsection*{Reductions and transformations preserving safety}

From now on we will use the standard notation $M\subst{N}{x}$ to
denote the substitution of $N$ for $x$ in $M$.  It is understood that,
provided that $M$ and $N$ are safe, this substitution is
capture-permitting.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x :B \vdash M : A$ and $\Gamma \vdash N : B$ then $\Gamma \vdash M[N/x] : A$.
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.


It is desirable to have an appropriate notion of reduction for our
calculus. However the standard $\beta$-reduction rule is not
adequate. Indeed, safety is not preserved by $\beta$-reduction as the
following example shows. Suppose that $w,x,y,z : o$ and $f : (o,o,o)
\in \Sigma$ then the safe term $(\lambda x y . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y . f z y}) w$ which is unsafe
since the underlined order-1 subterm contains a free occurrence of the
ground-type $z$. However if we perform one more reduction we obtain
the safe term $f z w$. This suggests an alternative notion of
reduction that performs simultaneous reduction of consecutive
$\beta$-redexes. In order to define this reduction we first introduce
the appropriate notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the safe lambda calculus, a redex is a
succession of several standard redexes:
\begin{definition}\rm
A \defname{safe redex} is a safe term with a derivation tree of the form:
$$   \rulef{
            \rulef{\rulef{\ldots}{\Gamma, \overline{x}:\overline{A} \vdash M : (A_{n+1}, \ldots, A_l, B)}}{\Gamma \vdash \lambda \overline{x} . M : (A_1, \ldots, A_l, B)} ({\sf abs })
            \quad
            \rulef{\ldots}{\Gamma \vdash N_1 :A_1}  \ \ldots \  \rulef{\ldots}{\Gamma \vdash N_l :A_l}
    }
    {
       \Gamma \vdash (\lambda \overline{x} . M) N_1 \ldots N_l : B
    } ({\sf app})
$$
for some $l,n\geq 1$ and where $\overline{x}$ and 
$\overline{x}:\overline{A}$ are abbreviations for $x_1 \ldots x_n$
and $x_1:A_1, \ldots, x_n : A_n$ respectively.
\end{definition}

In other words a safe redex is a safe term of the form $(\lambda
\overline{x} . M) N_1 \ldots N_l$ such that the variables
$\overline{x}$ are abstracted altogether by one instance of the
$(\sf{abs})$ rule and the term $(\lambda \overline{x} . M)$ is
applied to $N_1$, \ldots, $N_l$ by one instance of the $(\sf{app})$ rule. Thus $M$, the $N_i$'s and the redex itself are all safe terms.


We are now in a position to define a notion of reduction for safe terms.

\begin{definition}\rm
\label{dfn:safereduction} We use the
abbreviations $\overline{x} = x_1 \ldots x_n$,
$\overline{N} = N_1 \ldots N_l$.
The relation $\beta_s$ is defined on the set of safe redex as:
\begin{eqnarray*}
  \beta_s &=&
  \{  \ (\lambda \overline{x} . M) N_1 \ldots N_l \mapsto \lambda x_{l+1} \ldots x_n. M\subst{\overline{N}}{x_1 \ldots x_l} \mbox{, for $n> l$}
  \} \\
  &\cup&
  \{ \ (\lambda \overline{x}  . M) N_1 \ldots N_l \mapsto M\subst{N_1 \ldots N_n}{\overline{x}} N_{n+1} \ldots N_l
  \mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}
where $M\subst{R_1 \ldots R_k}{z_1 \ldots z_k}$ denotes the simultaneous substitution of $R_1$,\ldots,$R_k$ for $z_1, \ldots, z_k$ in $M$.  The
\defname{safe $\beta$-reduction}, written $\betasred$, is the
compatible closure of the relation $\beta_s$ with respect to the
formation rules of the safe lambda calculus.
\end{definition}

\noindent \emph{Remark:} The $\beta_s$-reduction is a multi-step
$\beta$-reduction {\it i.e.}~$\betared \subset \betasred \subset
\betaredtr$\ .


\begin{lemma}[$\beta_s$-reduction preserves safety]
\label{lem:safered_preserve_safety}
If $\Gamma \vdash s :A$ and $s \betasred t$ then $\Gamma \vdash t :A$.
\end{lemma}

\begin{proof}
  It suffices to show that the relation $\beta_s$ preserves safety.
Suppose that $s\ \beta_s\ t$ where $s$ is the 
safe-redex $(\lambda x_1 \ldots x_n . M) N_1
  \ldots N_l $ with $x_1 : B_1, \ldots, x_n: B_n$
and $M:C$.  W.l.o.g we can assume that the last rule   used to form the term $s$ is {\sf(app)} {\it i.e.}~not the weakening rule {\sf(wk)}, thus  we have $\Gamma = fv(s)$.

Suppose $n>l$ then $A = (B_{l+1}, \ldots, B_n, C)$. By Lemma \ref{lem:subst_preserve_safety} we have:
\begin{equation}
\Gamma, x_{l+1}:B_{l+1}, \ldots x_n :B_{n}\vdash M\subst{\overline{N}}{x_1 \ldots x_l} : C \label{jud:substsafe}\ .
\end{equation}

Since the term $s$ of type $A$ is safe, by Lemma \ref{lem:ordfreevar}, all variables in $\Gamma$ have order $\geq \ord{A}$. We can therefore apply the rule {\sf(abs)} on judgement (\ref{jud:substsafe}) to form $\Gamma \vdash t :A$.

Suppose $n \leq l$. The substitution lemma gives
$\Gamma \vdash M\subst{N_1 \ldots N_n}{\overline{x}} : C$ and using {\sf(app)} we can form $\Gamma \vdash t :A$.
  \qed
\end{proof}

In general, safety is not preserved by $\eta$-expansion; for instance we have
% $f:o,o \vdash f$ but $f:o,o \not \vdash \lambda x^o . f x$.
%This remark remains true for closed terms, for instance
$\vdash \lambda y^o z^o . y : (o,o,o)$ but
$\not \vdash \lambda x^o . (\lambda y^o z^o . y) x : (o,o,o)$.
However safety is preserved by $\eta$-reduction:

\begin{lemma}[$\eta$-reduction preserves safety]
  $\Gamma \vdash \lambda \varphi . s \varphi :A $ with $\varphi$ not
  occurring free in $s$ implies $\Gamma \vdash s :A$.
\end{lemma}
\begin{proof}
  Suppose $\Gamma \vdash \lambda \varphi . s \varphi :A$. If $s$ is an  abstraction then by construction of the safe term $\lambda \varphi . s \varphi$, $s$ is necessarily safe.  If $s = N_0 \ldots N_p$ with
  $p\geq 1$ then again, since $\lambda \varphi . N_0 \ldots N_p
  \varphi$ is safe, each of the $N_i$ is safe for $0 \leq i \leq p$
  and for any $z\in fv(\lambda \varphi . s \varphi)$, $\ord{z} \geq
  \ord{\lambda \varphi . s \varphi} = \ord{s}$. Since  $\varphi$ does not occur free in $s$ we have $fv(s) = fv(\lambda \varphi . s \varphi)$, thus we can use the application rule to form $fv(s) \vdash N_0 \ldots N_p : A$. The weakening rules permits us to conclude $\Gamma \vdash s :A$. \qed
\end{proof}



The $\eta$-long normal form (or simply $\eta$-long form) of a term
% (also called \emph{long reduced form}, \emph{$\eta$-normal form} and
% \emph{extensional form} in the literature
% \cite{DBLP:journals/tcs/JensenP76,DBLP:journals/tcs/Huet75,huet76})
is obtained by hereditarily $\eta$-expanding every subterm occurring
at an operand position. Formally the \defname{$\eta$-long form}
$\elnf{t}$ of a term $t: (A_1,\ldots,A_n,o)$ with $n \geq 0$ is
defined by cases according to the syntactic shape of $t$:
\begin{eqnarray*}
  \elnf{\lambda x . s } &=& \lambda x . \elnf{s} \\
  \elnf{x s_1 \ldots s_m } &=& \lambda \overline{\varphi} . x \elnf{s_1}\ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} \\
  \elnf{(\lambda x . s) s_1 \ldots s_p } &=& \lambda \overline{\varphi} . (\lambda x . \elnf{s}) \elnf{s_1} \ldots \elnf{s_p} \elnf{\varphi_1} \ldots \elnf{\varphi_n}
\end{eqnarray*}
where $m \geq 0$, $p\geq 1$, $x$ is a  variable or constant, $\overline{\varphi} = \varphi_1 \ldots \varphi_n$ and each $\varphi_i : A_i$ is a fresh variable.

%\begin{remark}
%  Converting a term to its $\eta$-long normal form does not introduce
%  new redex therefore the $\eta$-long normal form of $\beta$-normal
%  term is a $\beta$-normal term.
%\end{remark}

\begin{lemma}[$\eta$-long normalisation preserves safety]
\label{lem:elnf_preserves_safety}
If $\Gamma \vdash s :A$ then $\Gamma \vdash \elnf{s} :A$.
\end{lemma}
\begin{proof}

  First we observe that for any variable or constant $x:A$ we have $x:A
  \vdash \elnf{x} :A$. The proof is by induction on $\ord{x}$. It is true for the base case since
for any ground type variable $x$ we have $x = \elnf{x}$. Step
  case: $x:A$ with $A=(A_1, \ldots, A_n,o)$ and $n>0$. Let $\varphi_i:A_i$ be
  fresh variables for $1\leq i\leq n$. The (var) rules gives
  $\varphi_i :A_i \vdash \varphi_i : A_i$ and since $\ord{A_i} < \ord{x}$ the
  induction hypothesis gives $\varphi_i :A_i \vdash
  \elnf{\varphi_i} : A_i$. Using (wk) we obtain $x:A, \overline{\varphi} : \overline{A}
  \vdash \elnf{\varphi_i} :A_i$.  The application rule gives $x :A, \overline{\varphi} : \overline{A} \vdash x \elnf{\varphi_1} \ldots \elnf{\varphi_n}
  : o$ and the abstraction rule gives $ x :A \vdash \lambda
  \overline{\varphi} . x \elnf{\varphi_1} \ldots \elnf{\varphi_n} =
  \elnf{x} :A$.


We now prove the lemma by induction on $s$.
The base case is covered by the previous observation.
\emph{Step case:}
\begin{compactitem}
\item $s = x s_1 \ldots s_m$ with $x: (B_1, \ldots, B_m, A)$, $A = (A_1, \ldots, A_n, o)$ for some $m\geq 0$, $n>0$ and $s_i : B_i$ for $1 \leq i \leq
  m$.  Let $\varphi_i: A_i$ be fresh variables for $1\leq i \leq
  n$. By the previous observation we have $\varphi_i :A_i \vdash \elnf{\varphi_i} :A_i$, the weakening rule then gives us $\Gamma , \overline{\varphi} : \overline{A}
  \vdash \elnf{\varphi_i} : A_i$.  Since the judgement
  $\Gamma \vdash x s_1 \ldots s_m : A$ is formed using the {\sf (app)} rule, each $s_j$ must be safe for $1\leq j \leq m$, thus by the induction hypothesis we have $\Gamma \vdash \elnf{s_j} : B_j$ and by weakening we get $\Gamma, \overline{\varphi} :\overline{A} \vdash \elnf{s_j} : B_j$.  The {\sf(app)}
  rule then gives $\Gamma, \overline{\varphi} :\overline{A} \vdash x \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots \elnf{\varphi_n} : o$. Finally
  the {\sf (abs)} rule gives $\Gamma \vdash \lambda \overline{\varphi} . x
  \elnf{s_1} \ldots \elnf{s_m} \elnf{\varphi_1} \ldots
  \elnf{\varphi_n} = \elnf{s} : A$, the side-condition of {\sf (abs)} being verified since $\ord{\elnf{s}} = \ord{s}$.


\item $s = t s_0 \ldots s_m$ where $t$ is an abstraction. The $\eta$-normal form of $s$ is
$\elnf{s} = \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n}$ for some fresh variables $\varphi_1$,
  \ldots, $\varphi_n$. Again, we easily derive $\Gamma \vdash
 \lambda \overline{\varphi}. \elnf{t} \elnf{s_0} \ldots \elnf{s_m} \elnf{\varphi_1}
  \ldots \elnf{\varphi_n} : A$ with the induction hypothesis .

\item $s = \lambda \overline{\eta} . t $ where 
$\overline{\eta} : \overline{B}$ and $t:C$ is not an abstraction. By the induction hypothesis we have $\Gamma,
  \overline{\eta} : \overline{B} \vdash \elnf{t} : C$ and by the abstraction rule we conclude
  $\Gamma \vdash \lambda \overline{\eta} . \elnf{t} = \elnf{s} : A$.\qed
\end{compactitem}
\end{proof}

Note that in general the converse does not hold, for instance $\lambda
x^o . f^{(o,o,o)} x^o$ is unsafe although $\elnf{\lambda x . f x} =
\lambda x^o y^o . f x y$ is safe.

\subsection*{Numeric functions representable in the safe lambda calculus}

Natural numbers can be encoded into the simply-typed
lambda calculus using the Church Numerals: each $n\in\nat$ is
encoded into the term $\encode{n} = \lambda s z. s^n z$ of type $I =
((o,o),o,o)$ where $o$ is a ground type. In 1976 Schwichtenberg
\cite{citeulike:622637} showed the following:


\begin{theorem}[Schwichtenberg 1976]
The numeric functions representable by simply-typed $\lambda$-terms of
type $I\rightarrow \ldots \rightarrow I$ using the Church Numeral
encoding are exactly the multivariate polynomials \emph{extended with
the conditional function}.
\end{theorem}

If we limit ourselves to safe terms, the representable functions are
exactly the multivariate polynomials:
\begin{theorem}
\label{thm:polychar}
The functions representable by safe $\lambda$-expressions of type
$I\rightarrow \ldots \rightarrow I$ are exactly the multivariate
polynomials.
\end{theorem}

\begin{corollary}
The conditional operator $C:I\rightarrow I\rightarrow I \rightarrow I$ verifying  $C t y z \rightarrow_\beta y$  if $t \rightarrow_\beta \encode{0}$ and $C t y z \rightarrow_\beta z$ if $t \rightarrow_\beta \encode{n+1}$ is not definable in the safe simply-typed lambda calculus.
\end{corollary}
\begin{proof}
  Natural numbers are encoded using Church Numerals: $\encode{n} =
  \lambda s z. s^n z$.  Addition: For $n,m \in \nat$, $\encode{n+m} =
  \lambda \alpha^{(o,o)} x^o . (\encode{n} \alpha) (\encode{m} \alpha
  x)$. Multiplication: $\encode{n . m} = \lambda \alpha^{(o,o)}
  . \encode{n} (\encode{m} \alpha)$.  All these terms are safe and
  clearly any multivariate polynomial $P(n_1, \ldots, n_k)$ can be
  computed by composing the addition and multiplication terms as
  appropriate.

For the converse, let $U$ be a safe $\lambda$-term of type
$I\rightarrow I\rightarrow I$.  The generalisation to terms of type
$I^n \rightarrow I$ for $n>2$ is immediate (they correspond to
polynomials with $n$ variables). W.l.o.g we can
assume that $U = \lambda x y \alpha z. u$ where $u$ is a safe term of
ground type in $\beta$-normal form with $fv(u) \subseteq \{ x, y : I,
z :o, \alpha : o\rightarrow o \}$.

\emph{Notation:} Let $T$ be a set of terms of type $\tau \rightarrow \tau$ and $T'$ be a set of terms of type $\tau$ then $T \cdot T'$ denotes the set of terms $\{ s s' : \tau \ | \ s \in T \wedge s' \in T' \}$. We also define
$T^k \cdot T'$ recursively as follows:  $T^0 \cdot T' = T'$ and
for $k\geq 0$, $T^{k+1} \cdot T' = T \cdot (T^k \cdot T')$ ({\it i.e.}~$T^k \cdot T'$ denotes $\{ s_1( \ldots (s_k s'))  \ | \ s_1, \ldots, s_k \in T \wedge s' \in T' \}$). We define $T^+\cdot T' = \Union_{k > 0} T^k \cdot T'$ and
$T^*\cdot T' = (T^+\cdot T') \union T'$.
For two sets of terms $T$ and $T'$, we write $T =_\beta T'$ to express that any term of $T$ is $\beta$-convertible to some term $t'$ of $T'$ and reciprocally.

Let us write $\mathcal{N}^\tau$ for the set of $\beta$-normal terms of
type $\tau$ where $\tau$ ranges in $\{ o, o\rightarrow o, I \}$ and
with free variables in $\{ x,y:I, z:o, \alpha:o\rightarrow o\}$. We
write $\mathcal{A}^\tau$ for the subset of $\mathcal{N}^\tau$
consisting of applications only ({\it i.e.}~not abstractions).
Let $B$ be the set of terms of type $(o,o)$ defined by $B = \{ \alpha \} \union \{ \lambda a.b \ | \ b \in \{a,z\}, a \neq z \}$.
It is easy to see that the following equations hold:
\begin{eqnarray*}
\mathcal{A}^I &=& \{ x,y \} \\
\mathcal{N}^{(o,o)} &=& B \union \mathcal{A}^I \cdot
\mathcal{N}^{(o,o)} = (\mathcal{A}^I)^* \cdot B \\
\mathcal{A}^{(o,o)} &=& \{ \alpha \} \union (\mathcal{A}^I)^+ \cdot B \\
\mathcal{A}^o = \mathcal{N}^o &=& \{ z \} \union \mathcal{A}^{(o,o)} \cdot \mathcal{N}^o = (\mathcal{A}^{(o,o)})^* \cdot \{ z \}
\end{eqnarray*}
Hence $\mathcal{A}^o = \left( \{\alpha \} \union \{x,y\}^+ \cdot \left( \{\alpha \} \union \{\lambda a.b \ | \ b \in \{a,z\}, a \neq z \} \right) \right)^* \cdot \{ z \}$.
Since $u$ is safe, it cannot contain terms of the form $\lambda a . z$ with $a \neq z$ occurring at an operand position, therefore since $u$ belongs to $\mathcal{A}^o$ we have:
\begin{equation}
u \in \left( \{\alpha\} \union \{x,y\}^+ \cdot \{\alpha,
\underline{i} \} \right)^* \cdot \{ z \} \label{eqn:u}
\end{equation}
where $\underline{i}$ is the identity term of type $o\rightarrow o$.


We observe that $\encode{k} \underline{i} =_\beta \underline{i}$ for all $k \in \nat$ and for $l\geq 1$, for all $k_1, \ldots k_l \in \nat$,
$\encode{k_1}\ldots \encode{k_l} \alpha =_\beta
\encode{k_1\times \ldots \times k_l} \alpha$. Hence for all $m,n \in \nat$ we have:
\begin{equation}
\begin{array}{llr}
\{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} &=_\beta
\{ \underline{i} \} \union
\{ \encode{m^i n^j} \alpha \ |\ i+j \geq 1 \} \nonumber \\
&= \{ \encode{m^i n^j} \alpha \ |\ i,j \geq 0 \} & ( \mbox{since } \underline{i} = \encode{0} \alpha) \end{array}
\label{eqn:intermediate}
\end{equation}
therefore:
$$\begin{array}{llr}
u[\encode{m}, \encode{n}/x,y] &\in \left( \{ \alpha \} \union \{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} \right)^* \cdot \{ z \}  & \mbox{(by eq. \ref{eqn:u})} \\
&=_\beta \left( \{\alpha \} \union \{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \} \right)^* \cdot \{ z \} & \mbox{(by eq. \ref{eqn:intermediate})}  \\
&=_\beta \left\{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \right\}^* \cdot \{ z \} & \mbox{($\alpha z =_\beta \encode{1} \alpha z$)}
\end{array}$$

Furthermore, for all $m,n,r,i,j\in \nat$
we have $\encode{m^i n^j} \alpha (\alpha^r z) =_\beta
\alpha^{r + m^i n^j} z$,
hence $u[\encode{m} \encode{n}/x,y] =_\beta \alpha^{p(m,n)} z$ where $p(m,n) = \sum_{0\leq k \leq d} m^{i_k} n^{j_k}$ for some $i_k,j_k \geq 0$, $k \in\{ 0,..,d \}$ and $d\geq 0$.
Thus $U \encode{m} \encode{n} =_\beta \encode{p(m,n)}$. \qed
\end{proof}

For instance, the term $ C = \lambda F G H \alpha x . H (
\underline{\lambda y . G \alpha x} ) (F \alpha x)$ used by
Schwichtenberg \cite{citeulike:622637} to define the conditional
operator is unsafe since the underlined subterm is of order $1$,
occurs at an operand position and contains an occurrence of $x$ of
order $0$.


\section{A game-semantic account of safety}
\label{sec:gamesemaccount}
Our aim here is to characterise safety, which is a syntactic property,
by game semantics. Because of length restriction, we shall assume that
the reader is familiar with the basics of game semantics.  (For an
introduction, we recommend the survey paper
\cite{abramsky:game-semantics-tutorial}). Recall that a \emph{justified sequence} over
an arena is an alternating sequence of O-moves and P-moves such that
every move $m$, except the opening move, has a pointer to some earlier
occurrence of the move $m_0$ such that $m_0$ enables $m$ in the
arena. A \emph{play} is just a justified sequence that satisfies
Visibility and Well-Bracketing. A basic result in game semantics is
that $\lambda$-terms are denoted by \emph{innocent strategies}, which
are strategies that depends only on the \emph{P-view} of a play. The
main result (Theorem~\ref{thm:safeincrejust}) of this section is that
if a $\lambda$-term is safe, then its game semantics (is an innocent
strategy that) is \emph{P-incrementally justified}. In such a
strategy, pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically a P-question always
points to the last pending O-question (in the P-view) of a greater
order.

The proof of Theorem~\ref{thm:safeincrejust} depends on a
Correspondence Theorem (see the long version of this paper) that relates the strategy denotation of a $\lambda$-term $M$
to the set of \emph{traversals} over a certain abstract syntax tree of
the $\eta$-long form of $M$. In the parlance of game semantics,
traversals are just (concrete representations of) the
\emph{uncovering} (in the sense of Hyland and Ong
\cite{hylandong_pcf}) of plays in the strategy denotation.

The useful transference technique between plays and traversals was
originally introduced by one of us \cite{OngLics2006} for studying the
decidability of MSO theories of infinite structures generated by
higher-order grammars (in which the $\Sigma$-constants are at most
order 1, and \emph{uninterpreted}).
% In this setting, free variables are interpreted
% as constructors and therefore they do not have the ``full power'' of
% true free variables and are limited to order $1$ at most. Also,
% although the grammar can perform higher-order computations, the
% structure being studied is itself of ground type.
The long version of the paper presents an extension of this framework to the general case of the simply-typed lambda calculus with free variables of any order. A new traversal rule is introduced to handle nodes labelled with free variables. Also new nodes are added to the computation tree to account for the answer moves of the game semantics, thus enabling the framework to model languages with interpreted constants such as \pcf~(by adding traversal rules to handle constant nodes).

\subsection*{Incrementally-bound computation tree}

In \cite{OngLics2006} the computation tree of a grammar is defined as
the unravelling of a finite graph representing the long transform of a
grammar. Similarly we define the computation tree of a $\lambda$-term
as an abstract syntax tree of its $\eta$-long normal form.  We write
$l(t_1, \ldots, t_n)$ with $n \geq 0$ to denote the tree with a root
labelled $l$ with $n$ children subtrees $t_1$, \ldots, $t_n$.

\begin{definition}\rm
\label{dfn:comptree}
  The \defname{computation tree} $\tau(M)$ of a simply-typed term
  $\Gamma \vdash M:T$ with variable names in a countable set
  $\mathcal{V}$ is a tree with labels in $ \{ @ \} \union \mathcal{V}
  \union \{ \lambda x_1 \ldots x_n \ | \ x_1 ,\ldots, x_n \in
  \mathcal{V} \}$ defined from its $\eta$-long form as follows:
\begin{eqnarray*}
  \mbox{for $n\geq 0$ and $s:o$, } \tau(\lambda x_1 \ldots x_n . s) &=& \lambda x_1 \ldots x_n(t) \mbox{\quad where $\tau(s) = \lambda(t)$}\\
  \mbox{for $m\geq 0$ and $x \in  \mathcal{V}$, } \tau( x s_1 \ldots s_m : o) &=&  \lambda (x(\tau(s_1),\ldots,\tau(s_m)))\\
  \mbox{for $m \geq 1$, } \tau((\lambda x.t) s_1 \ldots s_m :o) &=& \lambda (@(\tau(\lambda x.t),\tau(s_1),\ldots,\tau(s_m)))
\end{eqnarray*}
\end{definition}

Even-level nodes are $\lambda$-nodes (the root is on level 0). A
single $\lambda$-node can represent several consecutive variable
abstractions or it can just be a \emph{dummy lambda} if the
corresponding subterm is of ground type.  Odd-level nodes are variable
or application nodes.

We write $r$ for the root of $\tau(M)$ and $N$, $N_@$, $N_\lambda$ and
$N_{var}$ for the set of nodes, @-labelled nodes, $\lambda$-nodes and
variable nodes respectively.  For $n \in N$, $\kappa(n)$ denotes the
subterm of $\elnf{M}$ corresponding to the subtree rooted at $n$, in
particular $\kappa(r) = \elnf{M}$.  The \defname{type} of a variable
node labelled $x$ is the type of $x$, the type of the root is
$(A_1,\ldots,A_p, T)$ where $x_1:A_1,\ldots, x_p:A_p$ are the free
variables of $M$ and the type of $n\in (N_\lambda \union N_@)
\setminus \{ r \}$ is the type of $\kappa(n)$. The \defname{order} of
a node is defined to be the order of its type.

We say that a variable node $n$ labelled $x$ is bound by a node $m$,
and $m$ is called the \defname{binder} of $n$, if $m$ is the closest
node in the path from $n$ to the root such that $m$ is labelled
$\lambda \overline{\xi}$ with $x\in \overline{\xi}$.
We introduce a class of computation trees in which the binder
node is uniquely determined by the nodes orders:
\begin{definition}\rm
  A computation tree is \defname{incrementally-bound} if for all
  variable node $x$, either $x$ is \emph{bound} by the first
  $\lambda$-node in the path to the root with order $> \ord{x}$ or $x$
  is a \emph{free variable} and all the $\lambda$-nodes in the path to
  the root except the root have order $\leq \ord{x}$.
\end{definition}

\begin{proposition} %[Safety and incremental-binding]
\label{prop:safe_imp_incrbound}
\begin{enumerate}[(i)]
\item If $M$ is safe then $\tau(M)$ is incrementally-bound.
\item Conversely, if $M$ is a \emph{closed} simply-typed term and $\tau(M)$
is incrementally-bound then the $\eta$-long form of $M$ is safe.
\end{enumerate}
\end{proposition}

The assumption that $M$ is closed is necessary. For instance for
$x,y:o$, the two identical computation trees $\tau(\lambda x y .x)$
and $\tau(\lambda y . x)$ are
incrementally-bound but $\lambda x y .x$ is safe and $\lambda y . x$
is not.


The \defname{order} of a question move $q$, written $\ord{q}$, is
defined as the length of the path from $q$ to its furthest leaf in the
arena minus 1.
%{\it i.e.}~height of the subarena rooted at $q$ minus 2.

\begin{definition}\rm
  A strategy $\sigma$ is said to be \defname{P-incrementally
    justified} if for any play $s \, q \in \sigma$ where $q$ is a
  P-question, $q$ points to the last unanswered O-question in $\pview{s}$ with
  order strictly greater than $\ord{q}$.
\end{definition}
\begin{example}
It is easy to check that copycat strategies, such as the identity strategy $id_A$ on the game $A$ or the evaluation map $ev_{A,B}$ of type $(A \Rightarrow B) \times A \typear B$, are all P-incrementally justified.\footnote{In such strategies, a P-move $m$ is justified as follows: either $m$ points to the preceding move in the P-view or the preceding move is of smaller order and $m$ is justified by the second last O-move in the P-view.}
\end{example}
%%%% the following example is wrong : ev is P-ij.
%
%\begin{example}
%Take the evaluation map $ev : (o^1 \Rightarrow o^2) \times o^3 \rightarrow o^4$ and the play $s = q^4 q^2 q^1 q^3 \in \sem{ev}$. We have $\ord{q^2} = 1 > \ord{q^1} = \ord{q^3} = 0$. Now $q^3$ points to $q^4$ but $q^2$ is the last unanswered O-question in $\pview{s}= s$ with order $>\ord{q^3}$, hence $\sem{ev}$ is not P-incrementally justified.
%\end{example}
Note that although the pointer is determined by the P-view, the choice of the move itself
can be based on the whole history of the play. Thus P-incremental justification does not imply innocence.


\begin{lemma}
  \label{lem:incrjustified_pointers_uniqu_recover} In P-incrementally
  justified strategies, pointers emanating from P-moves are
  superfluous {\it i.e.}~there is an algorithm that, given a play of the
  denotation, uniquely recovers the pointers from the underlying
  sequence of moves and from the pointers associated to the O-moves
  therein.
\end{lemma}

We write $\sem{\Gamma \vdash M : T}$ for the strategy 
denoting the term $\Gamma \vdash M : T$ in the game-semantic model.
The Correspondence Theorem
% and Lemma \ref{lem:redtrav_trav}
permits us to show the following:
\begin{proposition} % [Incremental-binding vs P-incremental justification]
\label{prop:incrbound_imp_incrjustified}
For a $\beta$-normal term $\Gamma \vdash M : T$,
$\tau(M)$ is incrementally-bound if and only if $\sem{\Gamma \vdash M : T}$
is P-incrementally justified.
\end{proposition}

% \parpic(0.5cm,2cm)(5pt,0.75cm)[x]{ $\tree{\lambda^3}{\tree{f^2}{
%       \tree{\lambda y^1}{ \TR{x^0} }}}$ }
%\parpic(0.5cm,1cm)(0.1pt,0.2cm)[r]{ $\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$ }
%\parpic(0.3cm,1cm)[r]{ \rput[t](0,0cm){$\tree{\lambda^3}{\tree{f^2}{
%        \tree{\lambda y^1}{ \TR{x^0} }}}$} }
%%%  ah Latex... i hate you !!!
%\begin{floatingfigure}[r]{60mm}
%$%\rput[t](0cm,0cm)
%{\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
%\end{floatingfigure}

%\begin{wrapfigure}[5]{r}{0.6cm}
% the next line must be commented out if and only if the paragraph appears at the top of the page (otherwise
% the figure in the margin is not positioned correctly):
%\rput[t](0.1cm,0.8cm)
% ${\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
%\end{wrapfigure}

\parpic[r]{
${\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
}
\noindent \emph{Example:} %\begin{example}
Consider the $\beta$-normal term $\Gamma \vdash f (\lambda y .x) : o$ where $y:o$ and $\Gamma = x:o, f:((o,o),o)$. The figure on the right represents its computation tree
with the node orders given in exponent.  Node $x$ is not
incrementally-bound therefore $\tau(f (\lambda y .x))$ is not
incrementally-bound and by Proposition
\ref{prop:incrbound_imp_incrjustified}, $\sem{\Gamma \vdash f (\lambda y .x) : o}$ is
not incrementally-justified (although $\sem{\Gamma \vdash f : ((o,o),o)}$ and $\sem{\Gamma \vdash \lambda
  y. x : (o,o)}$ are).
%\end{example}

Propositions \ref{prop:safe_imp_incrbound} and
\ref{prop:incrbound_imp_incrjustified} allow us to show the following (see long version of the paper):

\begin{theorem}[Safety and P-incremental justification]
\label{thm:safeincrejust}
\begin{enumerate}[(i)]
\item If $\Gamma \vdash M : T$ is safe then $\sem{\Gamma \vdash M : T}$ is P-incrementally justified.
\item If $\vdash M : T$ is a closed simply-typed term and $\sem{\vdash M : T}$ is P-incrementally justified then the $\eta$-long form of the $\beta$-normal form of $M$ is safe.
\end{enumerate}
\end{theorem}

Putting Theorem \ref{thm:safeincrejust}(i) and Lemma
\ref{lem:incrjustified_pointers_uniqu_recover} together gives:
\begin{proposition}
  \label{prop:safe_ptr_recoverable} In the game semantics of safe
  $\lambda$-terms, pointers emanating from P-moves are unnecessary
  {\it i.e.}~they are uniquely recoverable from the underlying sequences of
  moves and from O-moves' pointers.
\end{proposition}

% \begin{example} If justification pointers are omitted, the two
%   Kierstead terms from Example~\ref{ex:kierstead} have the same
%   denotation. In the safe lambda calculus the ambiguity disappears
%   since $M_1$ is safe whereas $M_2$ is not.
% \end{example}

In fact, as the last example highlights, pointers are entirely superfluous at 
order $3$ for safe terms. This is because for 
question moves in the first two levels of an arena, 
the associated pointers are uniquely recoverable thanks to 
the visibility condition. At the third level, the question moves are all P-moves therefore their associated pointers are uniquely recoverable by
P-incremental justification. This is not true anymore at order $4$:
Take the safe term $\psi:(((o^4,o^3),o^2),o^1) \vdash \psi (\lambda \varphi . \varphi a) : o^0$
for some constant $a:o$, where $\varphi:(o,o)$. Its strategy denotation contains plays whose underlying sequence of moves is $q_0 \, q_1 \, q_2 \, q_3 \, q_2 \, q_3 \, q_4$.
Since $q_4$ is an O-move, it is not constraint by 
P-incremental justification and thus $q_4$ can point to any of the two occurrences of $q_3$.\footnote{More generally,
a P-incrementally justified strategy can contain plays that are not O-incrementally justified since it must take into account any possible strategy incarnating its context, including those that are not P-incrementally justified.
In the given example, the version of the play which is not O-incrementally justified is involved in the strategy composition 
$\sem{ \vdash M_2 : (((o,o),o),o)} ; \sem{ \psi:(((o,o),o),o) \vdash \psi (\lambda \varphi . \varphi a):o}$ where $M_2$ denotes the unsafe Kierstead term.}

\subsection*{Safe PCF and Safe Idealised Algol}

\pcf\ is the simply-typed lambda calculus augmented with basic
arithmetic operators, if-then-else branching and a family of recursion
combinator $Y_A : ((A,A),A)$ for any type $A$.  We define \emph{safe}
\pcf\ to be \pcf\ where the application and abstraction rules are
constrained in the same way as the safe lambda calculus.  This
language inherits the good properties of the safe lambda calculus: No
variable capture occurs when performing substitution and safety is
preserved by the reduction rules of the small-step semantics of
\pcf. Using a \pcf\ version of the Correspondence Theorem we can prove
the following:
\begin{theorem}
\label{thm:safepcfpincr}
Safe PCF terms have P-incrementally justified denotations.
\end{theorem}

Similarly, we can define safe \ialgol\ to be safe \pcf\ augmented with
the imperative features of Idealized Algol (\ialgol\ for short)
\cite{Reynolds81}.  Adapting the game-semantic correspondence and
safety characterisation to \ialgol\ seems feasible although the
presence of the base type \iavar, whose game arena $\iacom^{\nat}
\times \iaexp$ has infinitely many initial moves, causes a mismatch
between the simple tree representation of the term and its game
arena. It may be possible to overcome this problem by replacing the
notion of computation tree by a ``computation directed acyclic
graph''.

The possibility of representing plays \emph{without some or all of
  their pointers} under the safety assumption suggests potential
applications in algorithmic game semantics. Ghica and McCusker
\cite{ghicamccusker00} were the first to observe that pointers are
unnecessary for representing plays in the game semantics of the
second-order finitary fragment of Idealized Algol ($\ialgol_2$ for
short). Consequently observational equivalence for this fragment can
be reduced to the problem of equivalence of regular expressions.  At
order $3$, although pointers are necessary, deciding observational
equivalence of $\ialgol_3$ is EXPTIME-complete
\cite{DBLP:journals/apal/Ong04,DBLP:conf/fossacs/MurawskiW05}. Restricting
the problem to the safe fragment of $\ialgol_3$ may lead to a lower
complexity.

% (note that it is unlikely to obtain the complexity PSPACE because the
% set of complete plays of the safe term $\lambda f^{(o,o),o} . f
% (\lambda x^o . x)$ is not regular \cite{DBLP:journals/apal/Ong04}).

% Murawski showed the undecidability of program equivalence in
% $\ialgol_i$ for $i\geq4$ by encoding Turing machine computations
% into a finitary $IA_4$ term \cite{murawski03program}. The term
% constructed being not safe, the proof cannot be transposed to the
% safe fragments. Hence the question remains of whether observational
% equivalence is decidable for the \emph{safe} fragments of these
% language.

%In \cite{Ong02}, one of us showed that observational equivalence for
% finitary second-order \ialgol\ with recursion ($\ialgol_2 + Y_1$) is
% undecidable. The proof consists in reducing the Queue-Halting
% problem to the observational equivalence of two $\ialgol_2 + Y_1$
% terms. The same reduction is still valid in the safe fragment of
% $\ialgol_2 + Y_1$.  Consequently, observational equivalence of safe
% $\ialgol_2 + Y_1$ is also undecidable.


\section{Further work and open problems}

The safe lambda calculus is still not well understood. Many basic
questions remain. What is a (categorical) model of the safe lambda
calculus? Does the calculus have interesting models?  What kind of
reasoning principles does the safe lambda calculus support, via the
Curry-Howard Isomorphism? Does the safe lambda calculus characterise a
complexity class, in the same way that the simply-typed lambda
calculus characterises the polytime-computable numeric functions
\cite{DBLP:conf/tlca/LeivantM93}?  Do incrementally-justified strategy
compose? Can we obtain a fully abstract model of safe PCF by suitably
constraining O-moves ({\it i.e.}~``O-incremental justification'')?

With a view to algorithmic game semantics and its applications, it
would be interesting to identify sublanguages of Idealised Algol whose
game semantics enjoy the property that pointers in a play are uniquely
recoverable from the underlying sequence of moves. We name this class
PUR. Observational equivalence for such PUR fragments are more likely to be
decidable. $\ialgol_2$ is the paradigmatic example of a
PUR-language. Another example is \emph{Serially Re-entrant Idealized
  Algol} \cite{abramsky:mchecking_ia}, a version of \ialgol\ where
multiple uses of arguments are allowed only if they do not ``overlap
in time''.  We believe that a PUR language can be obtained by imposing
the \emph{safety condition} on $\ialgol_3$. Murawski \cite{Murawski2003} has
shown that observational equivalence for $\ialgol_4$ is
undecidable. Is observational equivalence for \emph{safe} $\ialgol_4$
decidable?

%\bibliographystyle{splncs}
%\bibliographystyle{nat}
\bibliographystyle{abbrv}
\bibliography{../bib/higherorder,../bib/gamesem,../bib/lambdacalculus}

%\begin{thebibliography}{10}
%
%\bibitem{KNU02}
%Knapik, T., Niwi{\'n}ski, D., Urzyczyn, P.:
%\newblock Higher-order pushdown trees are easy.
%\newblock In: FOSSACS'02, Springer (2002)  205--222 LNCS Vol.~2303.
%
%\bibitem{Dam82}
%Damm, W.:
%\newblock The {IO-} and {OI}-hierarchy.
%\newblock TCS \textbf{20} (1982)  95--207
%
%\bibitem{demirandathesis}
%de~Miranda, J.G.:
%\newblock Structures generated by higher-order grammars and the safety
%  constraint.
%\newblock DPhil thesis, University of Oxford (2006)
%
%\bibitem{DG86}
%Damm, W., Goerdt, A.:
%\newblock An automata-theoretical characterization of the {OI}-hierarchy.
%\newblock {\em Information and Control} \textbf{71} (1986) 1--32
%
%\bibitem{Aho68}
%Aho, A.,:
%\newblock Indexed grammars - an extension of context-free grammars.
%\newblock {\em J. ACM} \textbf{15} (1968) 647--671
%
%\bibitem{Mas74}
%Maslov, A. N.:
%\newblock The hierarchy of indexed languages of an arbitrary level.
%\newblock {\em Soviet mathematics Doklady} \textbf{15} (1974) 1170--1174
%
%\bibitem{Mas76}
%Maslov, A. N.:
%\newblock Multilevel stack automata.
%\newblock {\em Problems of Information Transmission} \textbf{12} (1976) 38--43 1976.
%
%\bibitem{OngLics2006}
%Ong, C.-H.L.:
%\newblock On model-checking trees generating by higher-order recursion schemes.
%\newblock In: Proceedings of IEEE Symposium on Logic in Computer Science
%(2006)
%
%\bibitem{Cau02}
%Caucal, D.:
%\newblock On infinite terms having a decidable monadic theory.
%\newblock In {\em Proceedings of MFCS'02}. LNCS Volume 2420 (2002) 165--176
%
%\bibitem{safety-mirlong2004}
%Aehlig, K., de~Miranda, J.G., Ong, C.-H.L.:
%\newblock Safety is not a restriction at level 2 for string languages.
%\newblock Technical report, University of Oxford (2004)
%
%
%\bibitem{hague-sto07}
%Hague, M., Murawski, A.S., Ong, C.-H.L., Serre., O.:
%\newblock Collapsible pushdown automata and recursive schemes.
%\newblock (2006) 13 pages, preprint.
%
%
%
%\bibitem{citeulike:622637}
%Schwichtenberg, H.:
%\newblock Definierbare funktionen im lambda-kalkul mit typen.
%\newblock Archiv Logik Grundlagenforsch \textbf{17} (1976)  113--114
%
%\bibitem{Reynolds81}
%Reynolds, J.C.:
%\newblock The essence of algol.
%\newblock In de~Bakker, J.W., van Vliet, J.C., eds.: Algorithmic Languages.
%\newblock IFIP, North-Holland, Amsterdam (1981)  345--372
%
%\bibitem{ghicamccusker00}
%Ghica, D.R., McCusker, G.:
%\newblock Reasoning about idealized {\sc algol} using regular languages.
%\newblock In: Proceedings of ICALP 2000. Volume 1853 of LNCS.
%  (2000)  103--116
%
%\bibitem{DBLP:conf/fossacs/MurawskiW05}
%Murawski, A.S., Walukiewicz, I.:
%\newblock Third-order idealized algol with iteration is decidable.
%\newblock In Proceedings of FoSSaCS'05. (2005)  202--218
%
%\bibitem{DBLP:conf/tlca/LeivantM93}
%Leivant, D., Marion, J.Y.:
%\newblock Lambda calculus characterizations of poly-time.
%\newblock In Proceedings of TLCA. LNCS Volume 664. (1993)  274--288
%
%\bibitem{abramsky:mchecking_ia}
%Abramsky, S.:
%\newblock Semantics via game theory.
%\newblock In: Marktoberdorf International Summer School. (2001) Lecture slides.
%
%\bibitem{OngHoMchecking2006}
%Ong, C.-H.L.:
%\newblock On model-checking trees generated by higher-order recursion schemes
%  (technical report).
%\newblock Preprint, 55 pp (2006)
%
%\bibitem{DBLP:conf/sas/DimovskiGL05}
%Dimovski, A., Ghica, D.R., Lazic, R.:
%\newblock Data-abstraction refinement: A game semantic approach.
%\newblock In Proceedings of SAS. LNCS Volume 3672 (2005)  102--117
%
%\bibitem{willgreenlandthesis}
%Greenland, W.:
%\newblock Game Semantics for Region Analysis.
%\newblock PhD thesis, University of Oxford (2004)
%
%\bibitem{hylandong_pcf}
%Hyland, J.M.E., Ong, C.-H.L.:
%\newblock On full abstraction for {PCF}: {I, II, and III}.
%\newblock Information and Computation \textbf{163}(2) (2000)  285--408
%
%\bibitem{abramsky:game-semantics-tutorial}
%Abramsky, S., McCusker, G.:
%\newblock Game semantics.
%\newblock In Schwichtenberg, H., Berger, U., eds.: Logic and Computation:
%  Proceedings of the 1997 Marktoberdorf Summer School, Springer-Verlag (1998)
%  Lecture notes.
%
%\bibitem{DBLP:journals/apal/Ong04}
%Ong, C.-H.L.:
%\newblock An approach to deciding observational equivalence of Algol-like languages.
%\newblock Annals of Pure and Applied Logic \textbf{130} (2004)  124--171
%
%\bibitem{Murawski2003}
%Murawski, A.S.:
%\newblock On program equivalence in languages with ground-type references.
%\newblock \emph{Proceedings of LICS'03} (2003) 108--117
%\end{thebibliography}

\end{document}
\endinput


\section*{Appendix A -- Computation tree, traversals and correspondence}
\label{sec:correspondence}

In this section we adapt the notions of computation tree and
traversals over the computation tree originally introduced in
\cite{OngLics2006} to the context of the simply-typed
lambda calculus without constants. Everything remains valid in the
presence of \emph{uninterpreted}\footnote{A constant $f$ is
  \emph{uninterpreted} if the small-step semantics of the language
  does not contain any rule of the form $f \dots \rightarrow e$. $f$
  can be regarded as a data constructor.}  constants since we can just
consider them as free variables. Moreover there is no restriction on
the order of these constants, contrary to \cite{OngLics2006} where
constants need to be of order at most one. We will also state the
\emph{Correspondence Theorem} (Theorem \ref{thm:correspondence}) used
in Sec. \ref{sec:gamesemaccount}. 

In the following we fix a simply typed term 
$\Gamma \vdash M :T$ and we consider its computation tree $\tau(M)$ as defined in Def. \ref{dfn:comptree}.


\subsection{Pointers and justified sequences of nodes}

We define the \defname{enabling relation} on the set of nodes of the
computation tree as follows: $m$ enables $n$, written $m \vdash n$, if
and only if $n$ is bound by $m$ (we write $m \vdash_i n$ to precise
that $n$ is the $i^{\sf th}$ variable bound by $m$), or $m=r$ and $n$
is a free variable, or $n$ is a $\lambda$-node and $m$ is its parent
node.

For any set of nodes $S$ we write $S^{\upharpoonright r}$ for $\{ n
\in S \ | \ r \vdash^* n \}$ -- the subset of $S$ constituted of nodes
hereditarily enabled by $r$.  We call \defname{input-variables nodes}
the elements of $N_{var}^{\upharpoonright r}$.

A \defname{justified sequence of nodes} is a sequence of nodes with
pointers such that each variable or $\lambda$-node $n$ different
from the root has a pointer to a node $m$ occurring before it the
sequence such that $m \vdash n$.  We represent the pointer in the
sequence as follows \Pstr[0.4cm]{ (m){m} \ldots (n-m,45:i) n }.
  where the label indicates that either $n$ is labelled with the $i$th variable
abstracted by the $\lambda$-node $m$ or that $n$ is the $i^{\sf th}$
child of $m$.  Children nodes are numbered from $1$ onward except for
@-nodes where it starts from $0$. Abstracted variables are numbered
from $1$ onward. The $i^{\sf th}$ child of $n$ is denoted by $n.i$.

We say that a node $n_0$ of a justified sequence is
\defname{hereditarily justified} by $n_p$ if there are nodes $n_1,
\ldots, n_{p-1}$ in the sequence such that $n_i$ points to $n_{i+1}$
for all $i\in 0..p-1$.

The notion of \defname{P-view} $\pview{t}$ of a justified sequence of
nodes $t$ is defined the same way as the P-view of a justified
sequences of moves in Game Semantics:\footnote{ The equalities in the
  definition determine pointers implicitly. For instance in the second
  clause, if in the left-hand side, $n$ points to some node in $s$
  that is also present in $\pview{s}$ then in the right-hand side, $n$
  points to that occurrence of the node in $\pview{s}$.}
$$\begin{array}{rclrcl}
\pview{\epsilon} &=&  \epsilon
& \pview{\Pstr{ s \cdot (m) m \cdot \ldots \cdot (lmd-m,40){\lambda\overline{\xi}}
}}
 &=& \Pstr{
\pview{s} \cdot (m2) m \cdot (lm2-m2,50) {\lambda \overline{\xi}} } \\
\mbox{for $n \notin N_\lambda$, } \pview{s \cdot n }  &=&  \pview{s} \cdot n \qquad
& \pview{s \cdot r }  &=&  r
\end{array}$$

The O-view of $s$, written $\oview{s}$, is defined
dually. We borrow the game semantic terminology: A justified sequences of nodes satisfies
\emph{alternation} if for any two consecutive nodes one is a
$\lambda$-node and the other is not, and \emph{P-visibility} if every
variable node points to a node occurring in the P-view a that point.

\subsection{Computation tree with value-leaves}

We now add another ingredient to the computation tree that was not originally used in \cite{OngLics2006}.  We write $\mathcal{D}$ to denote the set
of values of the base type $o$.  We add \defname{value-leaves} to
$\tau(M)$ as follows: For each value $v \in \mathcal{D}$ and for each
node $n \in N$ we attach the child leaf $v_n$ to $n$.  We write $V$
for the set of nodes and leaves of the computation tree.  For $\$$
ranging in $\{@, \lambda, var \}$, we write $V_\$$ to denote the set
$N_\$ \union \{ v_n \ | \ n \in N_\$, v \in \mathcal{D} \}$.


Everything that we have defined can be lifted to this new version of
computation tree. A value-leaf has order $0$. The enabling relation
$\vdash$ is extended so that every leaf is enabled by its parent
node. A link going from a value-leaf $v_n$ to a node $n$ is labelled
by $v$: \Pstr[0.4cm]{ (n) n \ldots (vn-n,35:v){v_n} }. For the
definition of P-view and visibility, value-leaves are treated as
$\lambda$-nodes if they are at an odd level in the computation tree,
and as variable nodes if they are at an even level.

We say that a node $n$ is \defname{matched} by $v_n$
if there is an occurrence of $v_n$ in the sequence that points to $n$,
otherwise we say that $n$ is \defname{unmatched}.
The last unmatched node is called the \defname{pending node}.  A justified sequence of nodes is
\defname{well-bracketed} if each value-leaf occurring in it is justified by the pending node at that point.  If $t$ is a traversal then we write
$?(t)$ to denote the subsequence of $t$ consisting only of unmatched
nodes.

\subsection{Traversals of the computation tree}
\label{subsec:traversal}

A \emph{traversal} is a justified sequence of nodes of the computation tree where each node
indicates a step that is taken during the evaluation of the term.
\begin{definition}\rm
\label{def:traversal}
The set $\travset(M)$ of \defname{traversals} over $\tau(M)$ is defined by induction over the following rules.

\begin{description}
\item[{\bf (Empty)}] $\epsilon \in \travset(M)$.
\item[{\bf (Root)}] $ r \in \travset(M)$.
\item[{\bf (Lam)}] If $t \cdot \lambda \overline{\xi}$ is a traversal then so is
$t \cdot \lambda \overline{\xi} \cdot n$
where $n$ is $\lambda \overline{\xi}$'s child and if $n$ is a variable node then it points to the only\footnote{This is justified {\it a posteriori} by the fact that P-views are paths in the computation tree.} occurrence of its enabler that is still present in $\pview{t \cdot \lambda \overline{\xi}}$.

\item[{\bf (App)}] If $t \cdot @$ is a traversal then so is \Pstr[0.4cm]{t \cdot (m) @  \cdot (n-m,40:0) n}.

\item[{\bf (InputVar$^{val}$)}] If $t_1 \cdot x \cdot t_2$ is a traversal
with $x \in N_{var}^{\upharpoonright r}$ and $?(t_1 \cdot x \cdot
t_2)=?(t_1) \cdot x$ then so is \Pstr[0.4cm]{t_1 \cdot (x){x} \cdot
t_2 \cdot (xv-x,38:v){v_x} } for all $v \in \mathcal{D}$.

\item[{\bf (InputVar)}] If $t_1 \cdot x \cdot t_2$ is a traversal with
  $x \in N_{var}^{\upharpoonright r}$ and $?(t_1 \cdot x \cdot
  t_2)=?(t_1) \cdot x$ then so is $t_1 \cdot x \cdot t_2 \cdot n$ for any
  $\lambda$-node $n$ whose parent occurs in $\oview{t_1 \cdot x}$, $n$
  pointing to some occurrence of its parent node in $\oview{t_1 \cdot x}$.


\item[{\bf (Copycat$^@$)}]
  If \Pstr{t \cdot (app){@} \cdot (lz-app,60:0){\lambda \overline{z}}  \ldots  (lzv-lz,60:v){v}_{\lambda \overline{z}} } is a traversal then so is
\Pstr[0.6cm]{t \cdot (app){@} \cdot (lz-app,60){\lambda
\overline{z}} \ldots  (lzv-lz,60:v){v}_{\lambda \overline{z}} \cdot
(appv-app,45:v){v}_@}.

\item[{\bf (Copycat$^\lambda$)}] If \Pstr[0.4cm]{t \cdot \lambda \overline{\xi} \cdot (x){x}  \ldots   (xv-x,50:v){v}_x}
is a traversal then so is \Pstr[0.5cm]{t \cdot (lmd){\lambda
\overline{\xi}} \cdot (x){x}  \ldots  (xv-x,50:v){v}_x  \cdot
(lmdv-lmd,30:v){v}_{\lambda \overline{\xi}} }.

\item[{\bf (Copycat$^{var}$)}] If \Pstr[0.4cm]{t \cdot y \cdot (lmd){\lambda \overline{\xi}}
\ldots (lmdv-lmd,50:v){v}_{\lambda \overline{\xi}} } is a traversal
for some variable $y$ not in $N_{var}^{\upharpoonright r}$ then so
is \Pstr[0.6cm]{t \cdot (y){y} \cdot (lmd){\lambda \overline{\xi}}
\ldots (lmdv-lmd,30:v){v}_{\lambda \overline{\xi}}  \cdot
(vy-y,50:v){v}_y }.

\item[{\bf (Var)}]
If \Pstr[0.5cm]{t' \cdot (n){n} \cdot
    (lx){\lambda \overline{x}}  \ldots
    (x-lx,50:i){x_i} } is a traversal for some variable $x_i$ not in $N_{var}^{\upharpoonright r}$ then
so is
\Pstr[0.6cm]{
t' \cdot (n){n} \cdot
    (lx){\lambda \overline{x}}  \ldots
    (x-lx,30:i){x_i}  \cdot
    (letai-n,40:i){\lambda \overline{\eta_i}}
     }.
\end{description}
\end{definition}

\begin{wrapfigure}[7]{r}{3.8cm}
$
% The next line must be commented out if and only if the paragraph appears at the top of the page (otherwise the vertical position of the figure in the margin is not correct)
\rput[t](1.75cm,0.9cm)
{\tree[levelsep=3ex,treesep=0.5cm]{\lambda} {
    \tree{@}{
        \pstree[linestyle=dotted]{\TR{\lambda y}\arclabel{0} }{
            \tree{y}{
                \tree{\lambda \overline{\eta_1}}{\vdots}%\arclabel{1}
                \tree{\lambda \overline{\eta_i}}{\vdots}%\arclabel{i}
                \tree{\lambda \overline{\eta_n}}{\vdots}%\arclabel{n}
            }
        }
        \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}
            \arclabel{1}}{ \tree{x_i}{\TR{} \TR{}}}
}}}
$
\end{wrapfigure}
A traversal always starts by visiting the root. Then it mainly
follows the structure of the tree. The (Var) rule permits to jump
across the computation tree. The idea is that after visiting a
variable node $x$, a jump is allowed to the node corresponding to
the subterm that would be substituted for $x$ if all the
$\beta$-redexes occurring in the term were reduced. The sequence
\Pstr[0.7cm]{\lambda \cdot (app) @  \cdot (ly) {\lambda y}  \ldots
(y-ly,35:1) y  \cdot (lx-app,38:1) {\lambda \overline{x}} \ldots
(x-lx,30:i) {x_i} \cdot (leta-y,40:i) {\lambda \overline{\eta_i} }
\ldots}
 is an example of traversal of the computation tree shown on the right.

\begin{proposition}[counterpart of proposition 6 from \cite{OngHoMchecking2006}]
\label{prop:pviewtrav_is_path}
Let $t$ be a traversal. Then
\begin{enumerate}[(i)]
\item $t$ is a well-defined and well-bracketed justified sequence.
\item $?(t)$ is a well-defined justified sequence verifying alternation, P-visibility and O-visibility.
\item $\pview{?(t)}$ is the path in $\tau(M)$ from $r$ to the last node in $?(t)$.
\end{enumerate}
\end{proposition}

The \defname{reduction} of a traversal $t$ written $ t \upharpoonright
r$, is the subsequence of $t$ obtained by keeping only the nodes that
are hereditarily justified by $r$. This has the effect of eliminating
the ``internal nodes'' of the computation.

Application nodes are used to connect the operator and the operand of
an application in the computation tree but since they do not play any
role in the computation of the term, we can remove them from the
traversals.  We write $t-@$ for the sequence of nodes-with-pointers
obtained by removing from $t$ all @-nodes and value-leaves of @-nodes,
any link pointing to an @-node being replaced by a link pointing to
the immediate predecessor of @ in $t$.

We introduce the two notations $\travset(M)^{-@} = \{ t - @ \ | \  t \in \travset(M) \}$ and $\travset(M)^{\upharpoonright r} = \{ t  \upharpoonright r \ | \  t  \in \travset(M) \}$.
\begin{remark}
Clearly if $M$ is $\beta$-normal then $\tau$ does not contain any @-node therefore all nodes are
hereditarily justified by $r$ and we have $\travset(M)^{-@} = \travset(M) = \travset(M)^{\upharpoonright r }$.
\end{remark}

\begin{lemma}[View of a traversal reduction]
\label{lem:redtrav_trav}
If $M$ is in $\beta$-normal form then for all $t\in \travset(M)$ we have $ \pview{?(t) \upharpoonright  r } = \pview{?(t)} \upharpoonright r$.
\end{lemma}
In the safe lambda calculus without interpreted constants this
lemma follows immediately from the fact that $\travset(M) =
\travset(M)^{\upharpoonright r }$. This remains valid in the presence of interpreted constants provided that the traversal rules
implementing the constants are \emph{well-behaved}.\footnote{A
traversal rule is \defname{well-behaved} if it can be stated under the
form ``$t = t_1\cdot n \cdot t_2 \in \travset \zand ?(t) = ?(t_1)
\cdot n \zand n \in N_{\Sigma}\union N_{var} \zand P(t) \zand m\in
S(t) \imp\ $\Pstr{ t_1\cdot (n){n} \cdot t_2 \cdot (m-n,25){m} \in \travset}'' for some expression $P$
expressing a condition on $t$ and function $S$ mapping traversals of the form of $t$ to a subset of the children of $n$.}

\subsection{Computation trees and arenas}
We consider the well-bracketed game model of the simply-typed
lambda calculus.  We choose to represent strategies using
``prefix-closed set of plays''.
\footnote{In the literature, a strategy is commonly defined as a set of plays
closed by taking a prefix of \emph{even} length. However for the purpose of showing the correspondence with traversals, the ``prefix-closed'' version is more appropriate.}
We fix a term $\Gamma \vdash M : T$ and write $\sem{\Gamma \vdash M : T}$ for its strategy denotation.
The answer moves of a question $q$ are written $v_q$ where $v$ ranges in $\mathcal{D}$.

\begin{definition}[Mapping from nodes to moves]\rm
\label{def:phi_psi mapping}
Let $q$ be a question move of $\sem{T}$ and $n \in N$ such that $n$
and $q$ are of type $(A_1,\ldots,A_p,o)$.  Let $\{ q^1, \ldots, q^p \}
\union \{ v_q \ | \ v \in \mathcal{D} \}$ be the set of moves enabled
by $q$ where each $q^i$ is of type $A_i$. The function $\psi_M^{n,q}$
from $V^{\upharpoonright n}$ to $\sem{T}$ is defined as:
\begin{eqnarray*}
\psi^{n,q}_M &=& \{ n \mapsto q \} \union  \{ v_n \mapsto v_q \ | \ v \in \mathcal{D} \}\\
 &&\union \left\{
                \begin{array}{ll}
                  \emptyset, & \hbox{if $p=0$\ ;} \\
                  \Union_{m \in N | n \vdash_i m} \psi_M^{m, q^i}, & \hbox{if $p\geq1$ and $n\in N_{\lambda}$\ ;} \\
                  \Union_{i=1..p} \psi_M^{n.i, q^i}, & \hbox{if $p\geq1$ and $n\in N_{var}$\ .}
                \end{array}
              \right.
\end{eqnarray*}
Note that $\psi_M^{n,q}$ is only defined on nodes hereditarily enabled
by $n$.  For any $n \in N$ let $A_n$ denote the type of
$\kappa(n)$. We write $\psi_{\kappa(n)}$ for $\psi_{\kappa(n)}^{n,q}$
where $q$ denotes the initial move of $\sem{A_n}$. \footnote{Arenas
involved in the game semantics of simply-typed lambda calculus are
trees.}


For a closed term $\vdash M : T$, the total function $\varphi_M$ from
$V_\lambda \union V_{var}$ to $\sem{T} \uplus \biguplus_{n \in N'_@}
\sem{A_n}$ is defined as $\varphi_M = \psi_M \union \Union_{n \in
N'_@} \psi_{\kappa(n)}$ where $N'_@$ denotes the set of children nodes
of @-nodes.  For an open term $x_1 : X_1, \ldots, x_n : X_n \vdash M :
T$, $\varphi_M$ is defined as $\varphi_{\lambda x_1 \ldots x_n
. M}$. When there is no ambiguity we omit the subscript in $\varphi_M$
and $\psi_M$.
\end{definition}
\begin{remark}
$\varphi$ maps $\lambda$-nodes to O-questions, variable nodes to
P-questions, value-leaves of $\lambda$-nodes to P-answers and
value-leaves of variable nodes to O-answers.
Moreover $\varphi$ maps nodes of a given order to moves of the same order.
\end{remark}
If $t = t_0 t_1 \ldots$ is a justified sequence
of nodes in $V_\lambda \union V_{var}$ then $\varphi(t)$ is defined
to be the sequence of moves $\varphi(t_0)\ \varphi(t_1) \ldots$
equipped with the pointers of $t$.

\begin{example}
Take $\lambda x . (\lambda g . g x) (\lambda y . y)$ with $x,y:o$ and $g:(o,o)$.
The diagram below represents the computation tree (middle), the arenas
$\sem{(o,o), o}$ (left), $\sem{o , o}$ (right), $\sem{o\rightarrow o}$ (rightmost)
and $\varphi = \psi \union \psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}} \union
\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}$
(dashed-lines).
$$\psset{levelsep=3.5ex}
\pstree{\TR[name=root]{\lambda x}}
{
    \pstree{\TR[name=App]{@}}
    {
            \pstree{\TR[name=lg]{\lambda g}}
                { \pstree{\TR[name=lgg]{g}}{
                        \pstree{\TR[name=lgg1]{\lambda}}
                        { \TR[name=lgg1x]{x}  } } }
            \pstree{\TR[name=ly]{\lambda y}}
                    {\TR[name=lyy]{y}}
    }
}
\rput(4.5cm,-1cm){
  \pstree{\TR[name=A1lx]{q_{\lambda x}}}
        { \TR[name=A1x]{q_x} }
}
\rput(-6cm,-1.5cm){
    \pstree{\TR[name=A2lg]{q_{\lambda g}}}
    {
        \pstree{\TR[name=A2g]{q_g}}
        {  \TR[name=A2g1]{q_{g_1}}   }
    }}
\rput(2.5cm,-1.5cm){
    \pstree{\TR[name=A3ly]{q_{\lambda y}}}
        { \TR[name=A3y]{q_y}
        }
}
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{A1lx} \mput*{\psi}
\ncarc{->}{lgg1x}{A1x}
\ncline{->}{lg}{A2lg} \mput*{\psi_{\lambda g.g x}^{\lambda g, q_{\lambda g}}}
\ncline{->}{lgg}{A2g}
\ncline{->}{lgg1}{A2g1}
\ncline{->}{ly}{A3ly} \mput*{\psi_{\lambda y.y}^{\lambda y, q_{\lambda y}}}
\ncline{->}{lyy}{A3y}
$$
\end{example}


\subsection{The Correspondence Theorem}

In game semantics, strategy composition is achieved by performing a
CSP-like ``composition + hiding''. If the internal moves are not
hidden then we obtain an alternative semantics called
\defname{revealed semantics} in \cite{willgreenlandthesis} and
\emph{interaction} semantics in \cite{DBLP:conf/sas/DimovskiGL05}.
The revealed semantics of a term $\Gamma \vdash M :T$, written
$\intersem{\Gamma \vdash M : T}$, is obtained by uncovering\footnote{An
  algorithm that uniquely recovers hidden moves is given in Part II of
  \cite{hylandong_pcf}.}  the internal moves from $\sem{\Gamma \vdash
  M : T}$ that are generated by the composition with the evaluation map
$ev$ at each @-node of the computation tree.  The inverse operation consists in filtering out the internal moves.

In the simply-typed lambda calculus, the set $\travset(M)$ of
traversals of the computation tree is
isomorphic to the set of uncovered plays of the strategy denotation
(this is the counterpart of the ``Path-Traversal Correspondence'' of
\cite{OngLics2006}). Moreover the set of traversal reductions is
isomorphic to the strategy denotation.

\begin{theorem}[The Correspondence Theorem]
\label{thm:correspondence}
\begin{eqnarray*}
(i)~\varphi_M  &: \travset(M)^{-@} \stackrel{\cong}{\longrightarrow} \intersem{\Gamma \vdash M :T} \\
(ii)~\psi_M  &: \travset(M )^{\upharpoonright r} \stackrel{\cong}{\longrightarrow} \sem{\Gamma \vdash M : T} \ .
\end{eqnarray*}
\end{theorem}

\begin{example}
Take $M = \lambda f z . (\lambda g x . f x)
(\lambda y. y) (f z) : ((o,o),o, o)$.  The figure below represents the computation tree (left tree), the arena $\sem{((o,o),o, o)}$ (right tree) and $\psi_M$ (dashed line). (Only question moves are shown for clarity.)  The justified sequence of nodes $t$ defined hereunder is an example of traversal:

\begin{tabular}{lp{6.3cm}}
$\tree[levelsep=2.5ex,treesep=0.3cm]{ \Rnode{root}{\lambda f z} }
     {  \tree{@}
        {   \tree{\lambda g x}{
                  \tree{\Rnode{f}{f^{[1]}}}{
                            \tree{\Rnode{lmd}{\lambda^{[2]}}}
                            {\TR{x}}
                  }
                }
            \tree{ \lambda y }{\TR{y}}
            \tree{\lambda ^{[3]}}{
                \tree{\Rnode{f2}{f^{[4]}}} {
                \tree{\Rnode{lmd2}{\lambda^{[5]}}}{\TR{\Rnode{z}{z}}}
                }
            }
        }
     }
\hspace{1cm}
  \tree[levelsep=8ex,treesep=0.3cm]{ \Rnode{q0}q^0 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q1}{q^1}}}{\TR{\Rnode{q2}{q^2}}}
        \TR{\Rnode{q3}q^3}
        \TR{\Rnode{q4}q^4}
    }
\psset{nodesep=1pt,arrows=->,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q0} \mput*{\psi_M}
\ncarc[arcangle=-25]{->}{z}{q3}
\ncarc[arcangle=10]{->}{f}{q1}
\ncarc[arcangle=10]{->}{lmd}{q2}
\ncline{->}{f2}{q1}
\ncline{->}{lmd2}{q2}$
\hspace{0.3cm}
&
\begin{asparablank}
  \item  \Pstr[0.8cm]{
t = (n){\lambda f z} \
(n2){@} \
(n3-n2,60){\lambda g x} \
(n4-n,45){f^{[1]}} \
(n5-n4,45){\lambda^{[2]}} \
(n6-n3,45){x} \
(n7-n2,35){\lambda^{[3]}} \
(n8-n,35){f^{[4]}} \
(n9-n8,45){\lambda^{[5]}} \
(n10-n,35){z}
}

\item \Pstr[0.9cm]{
t\upharpoonright r = (n){\lambda f z} \
(n4-n,50){f}^{[1]} \
(n5-n4,60){\lambda}^{[2]} \
(n8-n,45){f}^{[4]} \
(n9-n8,60){\lambda}^{[5]} \
(n10-n,40){z}}
\item
\Pstr[0.8cm]{ {\psi_M(t\upharpoonright r) =\ } (n){q^0}\
(n4-n,60){q^1}\ (n5-n4,60){q^2}\ (n8-n,45){q^1}\ (n9-n8,60){q^2}\
(n10-n,38){q^3} \in \sem{M}\ .}
\end{asparablank}
\end{tabular}
\end{example}



\section*{Appendix B -- Proof of Theorem \ref{thm:safeincrejust} and \ref{thm:safepcfpincr}}

\subsection{Proof of Proposition \ref{prop:safe_imp_incrbound}}
  (i) Suppose that $M$ is safe. By Lemma
  \ref{lem:elnf_preserves_safety} the $\eta$-long form of $M$ is safe
  therefore $\tau(M)$ is the tree representation of a safe term.

In the safe lambda calculus, the variables in the context with the
lowest order must be all abstracted at once when using the abstraction
rule. Since the computation tree merges consecutive abstractions into
a single node, any variable $x$ occurring free in the subtree rooted
at a node $\lambda \overline{\xi}$ different from the root must have
order greater or equal to $\ord{\lambda
  \overline{\xi}}$. Reciprocally, if a lambda node $\lambda
\overline{\xi}$ binds a variable node $x$ then $\ord{\lambda
  \overline{\xi}} = 1+\max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Let $x$ be a bound variable node. Its binder occurs in the path from
$x$ to the root, therefore, according to the previous observation, $x$
must be bound by the first $\lambda$-node occurring in this path with
order $>\ord{x}$. Let $x$ be a free variable node then $x$ is not
bound by any of the $\lambda$-nodes occurring in the path to the
root. Once again, by the previous observation, all these
$\lambda$-nodes except the root have order smaller than
$\ord{x}$. Hence $\tau$ is incrementally-bound.

(ii) Let $M$ be a closed term such that $\tau(M)$ is
incrementally-bound.  We assume that $M$ is already in $\eta$-long
form.  We prove that $M$ is safe by induction on its structure. The
base case $M = \lambda \overline{\xi} . x$ for some variable $x$ is
trivial.  \emph{Step case:} If $M = \lambda \overline{\xi} . N_1
\ldots N_p$.  Let $i$ range over $1..p$. We have $N_i \equiv \lambda
\overline{\eta_i} . N'_i$ for some non-abstraction term $N'_i$. By the induction hypothesis, $\lambda \overline{\xi} . N_i = \lambda \overline{\xi} \overline{\eta_i} . N'_i$ is a safe closed term, and consequently $N'_i$ is necessarily safe. Let $z$ be a free variable
of $N'_i$ not bound by $\lambda \overline{\eta_i}$ in $N_i$. Since
$\tau(M)$ is incrementally-bound we have $\ord{z} \geq \ord{\lambda
  \overline{\eta_1}} = \ord{N_i}$, thus we can abstract the variables $\overline{\eta_1}$ using the {\sf (abs)} which shows that $N_i$ is safe.  Finally
we conclude $\vdash M = \lambda \overline{\xi} . N_1 \ldots N_p : T$ using
the rules {\sf (app)} and {\sf (abs)}.  \qed

\subsection{Proof of Theorem \ref{thm:safeincrejust}}
(i) Let $M$ be a safe simply-typed term. By Lemma
\ref{lem:safered_preserve_safety}, its $\beta$-normal form $M'$ is
also safe. By Proposition \ref{prop:safe_imp_incrbound}(i), $\tau(M')$
is incrementally-bound and by Proposition
\ref{prop:incrbound_imp_incrjustified}, $\sem{M'}$ is an
incrementally-justified. Finally the soundness of the game model gives
$\sem{M} = \sem{M'}$.  (ii) is a consequence of Lemma
\ref{lem:safered_preserve_safety}, Proposition
\ref{prop:incrbound_imp_incrjustified} and
\ref{prop:safe_imp_incrbound}(ii) and soundness of the game model.
\qed

\subsection{Proof of Theorem \ref{thm:safepcfpincr}}

The computation tree of a \pcf\ term is defined as the least
upper-bound of the chain of computation trees of its \emph{syntactic approximants} \cite{abramsky:game-semantics-tutorial}.  It is
obtained by infinitely expanding the $Y$ combinator,
for instance $\tau(Y (\lambda f x. f x))$ is the tree representation
of the $\eta$-long form of the infinite term $(\lambda f x. f x)
 ((\lambda f x. f x) ((\lambda f x. f x) ( \ldots$


It is straightforward to define the traversal rules modeling the
arithmetic constants of \pcf. Just as in the safe lambda calculus
we had to remove @-nodes in order to reveal the game-semantic
correspondence, in safe \pcf\ it is necessary to filter out the
constant nodes from the traversals. The Correspondence Theorem for
\pcf\ says that the interaction game semantics is isomorphic to the
set of traversals disposed of these superfluous nodes. It is
trivial to show it for term approximants. The result is then
lifted to any \pcf\ term by observing that the function
$\travset^{\upharpoonright r}$ from the set of computation trees ordered by the approximation ordering to the set of sets of justified sequences of nodes ordered by subset inclusion is continuous.

Computation trees of Safe \pcf\ terms are incrementally-bound.
Moreover the traversal rules for \pcf\ are \emph{well-behaved} hence
lemma \ref{lem:redtrav_trav} still holds and the game-semantic
analysis of safety remains valid for \pcf.


\end{document}
