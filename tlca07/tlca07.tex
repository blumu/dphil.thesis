% the LaTeX macro package from Springer-Verlag for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
\documentclass{llncs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pst-tree}
\usepackage[all]{xy}
\usepackage{stmaryrd}
\usepackage{picins}


% reduction, substitution
\newcommand\defeq{\stackrel{\textsf{def}}{=}}
\newcommand\betared{\rightarrow_\beta}
\newcommand\betaredtr{\twoheadrightarrow_\beta} % transitive closure of the beta reduction
\newcommand\betasred{\rightarrow_{\beta_s}}
\newcommand\betasredO{\rightarrow_{\beta_s^1}}
\newcommand\betasredT{\rightarrow_{\beta_s^2}}
\newcommand\subst[2]{\left[ #1/#2 \right]}
\newcommand\captsubst[2]{\{#1/#2 \}}

% computation tree, eta normal form, traversals
\newcommand\aux[1]{\lceil #1\rceil}
\newcommand\etanf[1]{\eta_{\sf nf}(#1)}
\newcommand\etabetanf[1]{\eta\beta_{\sf nf}(#1)}
\newcommand\travset{\mathcal{T}rav}

% lambda calculus
%\newcommand\bot{\perp}
\newcommand\typar{\Rightarrow}
\newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{#2}}
\newcommand\rulefex[3][5pt]{\frac{\dps #2}{\stackrel{\rule{0pt}{#1}}{#3}}}
\newcommand\axiomf[1]{\frac{\dps}{#1}}
\newcommand\funto{\longrightarrow}
\newcommand\ord[1]{{\sf ord}(#1)}
\newcommand\order[1]{{\sf order}(#1)}
\newcommand{\typear}{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(#1)}}
\newcommand\textbfit[1]{{\bf\em #1}\index{#1}}
\newcommand\blambda{\hbox{\boldmath $\lambda$}}
\newcommand\lterm[2]{{\blambda{#1}.{#2}}}
\newcommand\terms[2]{{\cal T}^{#1}(#2)}
\newcommand{\funsp}{\rightarrow}
\newcommand\seq[2]{{{#1} \vdash {#2}}}

% semantics
\newcommand{\lsem}{[\![} % \llbracket
\newcommand{\rsem}{]\!]} % \rrbracket
\newcommand{\sem}[1]{{\lsem #1 \rsem}}
\newcommand{\intersem}[1]{{\langle\!\langle #1 \rangle\!\rangle}}

%set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\sthat{\ | \ }  % ``such that'' for set defined by comprehension
\newcommand\nat{\mathbb{N}}


%%% game semantics
\newcommand\natbf{\mathbf{N}}
\newcommand\zset{\mathbb{Z}}
\newcommand\eval{\Downarrow}
\newcommand\obspre{\sqsubseteq}
\newcommand\obseq{\approx}
\newcommand\intercomp{\fatsemi{^\|}}

% trees
\newcommand{\SubTree}[2][]{\Tr[ref=t]{\pstribox[#1]{#2}}}
\newcommand{\SubTreeE}[2][]{\Tr[ref=t]{\pstribox[#1]{#2}}}
\def\dedge{\ncline[linestyle=dashed]}
\def\dotedge{\ncline[linestyle=dotted]}
\def\valueedge{\ncline[linestyle=dashed,linewidth=0.5pt]}
\newcommand{\TRV}[1][edge=\valueedge]{\TR[edge=\valueedge,#1]}
\newcommand{\tree}[2][levelsep=4ex]{\pstree[levelsep=4ex,#1]{\TR{#2}}}

% logic
\newcommand\imp{\Rightarrow}
\newcommand\zand{\wedge}
\newcommand\entail{\vdash}

% ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\ialgolmnew{\ialgol-$\{\ianew\}$}
\newcommand\iaseqcom{$\tt{seq_{com}}$}
\newcommand\iaseqexp{$\tt{seq_{exp}}$}
\newcommand\iaseq{\texttt{seq}}
\newcommand\iaskip{\texttt{skip}}
\newcommand\iaderef{\texttt{deref}}
\newcommand\iaassign{\texttt{assign}}
\newcommand\iadone{\texttt{done}}
\newcommand\iarun{\texttt{run}}
\newcommand\iawrite{\texttt{write}}
\newcommand\iaread{\texttt{read}}
\newcommand\iaok{\texttt{ok}}
\newcommand\iamkvar{\texttt{mkvar}}
\newcommand\ianew{\texttt{new}}
\newcommand{\ianewin}[1]{\texttt{new}\ #1\ \texttt{in}}
\newcommand\iabool{\texttt{bool}}
\newcommand\iawhile{\texttt{while}}
\newcommand\iado{\texttt{do}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}

%pcf
\newcommand\pcf{\textsf{PCF}}
\newcommand\pcfcond{\texttt{cond}}
\newcommand\pcfsucc{\texttt{succ}}
\newcommand\pcfpred{\texttt{pred}}

%% justified sequence of moves
\newcommand{\oview}[1]{\llcorner #1 \lrcorner}
\newcommand{\pview}[1]{\ulcorner #1 \urcorner}

% back pointer using psttricks
\newcommand{\bkptr}[2][nodesep=0pt]{\ncarc[offset=-2pt,nodesep=0pt,ncurv=1,arcangleA=-#2, arcangleB=-#2,#1]{->}}
\newcommand{\bklabel}[1]{\mput*{\mbox{{\tiny $#1$}}}}
\newcommand{\bklabelb}[1]{\mput{\mbox{\tiny $#1$}}}
\newcommand{\bklabelc}[1]{\Bput[1pt]{\mbox{{\tiny $#1$}}}}
\newcommand\treelabel[1]{\mput*{\mbox{{\small $#1$}}}}



\begin{document}

\frontmatter          % for the preliminaries
\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{} % additional mark in the TOC

\mainmatter              % start of the contributions

\title{The Safe $\lambda$-Calculus}

\titlerunning{The Safe $\lambda$-Calculus}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used


\author{William Blum\inst{1} \and C.-H. Luke Ong\inst{2}}
%
\authorrunning{William Blum et al.}   % abbreviated author list (for running head)
%
%%%% modified list of authors for the TOC (add the affiliations)
\tocauthor{William Blum (University of Oxford), C.-H. Luke Ong (University of Oxford)}


\institute{Oxford University Computing Laboratory\\ Wolfson Building, Parks Road, Oxford, OX1 3QD, ENGLAND\\
\email{william.blum@comlab.ox.ac.uk\inst{1} luke.ong@comlab.ox.ac.uk\inst{2}} }

\maketitle              % typeset the title of the contribution

\pagestyle{empty}

% TLCA05:
%    Papers should not exceed 15 pages in Springer LNCS format.
%    An abstract (ASCII text) of no more than 150 words should be sent separately at least a weak before the paper submission deadline.

% LNCS:
%    The abstract should summarize the contents of the paper
%    using at least 70 and at most 150 words. It will be set in 9-point
%    font size and be inset 1.0 cm from the right and left margins.
%    There will be two blank lines before and after the Abstract. \dots

\begin{abstract}
The \emph{safety condition} has been introduced in \cite{KNU02} as a syntactic
restriction for higher-order grammars that constrains occurrences
of variables in the grammar equations according to their order.
When transposed to the $\lambda$-calculus, the safety condition gives rise to the \emph{Safe $\lambda$-calculus}, a
strict sub-language of the $\lambda$-calculus (\cite{safety-mirlong2004}).

We present a new version of Safe $\lambda$-calculus and give a game-semantic
account of it. In particular we show that pointers are superfluous in the plays
of the game denotation of safe terms.
\end{abstract}

\section{Introduction}

\subsection{Background}

The \emph{Safety restriction} has been introduced in by Knapik, Niwi{\'n}ski and Urzyczyn in \cite{KNU02}
for the purpose of studying infinite trees generated by higher-order grammars.
It is very similar to the ``restriction of derived types'' which was introduced
by Damm in \cite{Dam82} however the formulation differs.
Safety is a syntactic restriction for higher-order grammars that
constrains the occurrences of the variables in the grammar
equations according to their order. Safety imposes a further restriction called \emph{homogeneity} on the type of the grammar equations.
The formal definition is intricate and seems a bit odd but the Safety restriction has important algorithmic impacts.

In particular, the authors of \cite{KNU02} proved that the Monadic Second
Order (MSO) theory of the term tree generated by a safe recursion
scheme of any order is decidable\footnote{In fact it has been shown
recently in \cite{OngLics2006} that it is also true for unsafe
recursion schemes.}. They also give the following nice automata-theoretic characterization of safety:
an infinite term is generated by a \emph{safe} higher-order grammar if and only if
it is generated by a level-$n$ pushdown automaton.


When transposed to the $\lambda$-calculus, the safety condition
gives rise to the \emph{Safe $\lambda$-calculus}, a strict
sub-language of the $\lambda$-calculus. A first version appeared in
the technical report \cite{safety-mirlong2004}. We propose a more
general and simpler version where term types are not required to be
homogeneous. A noteworthy feature of the Safe
$\lambda$-calculus is that no variable capture can occur when
performing substitution and therefore it is unnecessary to rename
variables when computing $\beta$-reductions.

Little is known about the Safe $\lambda$-calculus and there are many
problems that have yet to be studied concerning its
computational power, the complexity classes that it characterises,
its interpretation under the Curry-Howard isomorphism and its
game-semantic characterisation. This paper contributes to give an
answer to the last problem.


The difficulty in giving a game-semantic account of Safety lies in
the fact that it is a syntactic restriction whereas Game Semantics
is by essence a syntax-independent semantics. The solution consists
in finding a particular syntactical representation of terms on which
the plays of the game denotation can be represented.
To achieve this, we use ideas recently introduced in \cite{OngLics2006}: a term
is canonically represented by the abstract syntax tree of its
$\eta$-long normal form, referred as the \emph{computation tree}. A
computation is described by a justified sequence of nodes of the
computation tree respecting some formation rules and called a
\emph{traversal}. Traversals permit us to model $\beta$-reductions
without altering the structure of the computation tree via
substitution. A notable property is that \emph{P-view} (in the game-semantic sense) of traversals
corresponds to paths in the computation tree.

These notions permit us to establish a correspondence between the game semantics of a term and
the syntactic representation given by its computation tree.
More precisely, we show that traversals are just representations of the
uncovering of plays of the strategy denoting the term.
Then by defining an appropriate \emph{reduction} operation which eliminates traversal
nodes that are ``internal'' to the computation, we obtain an
isomorphism between the strategy denotation of a term and the set of
reductions of traversals of its computation tree.



Using that correspondence and after introducing the notion of \emph{incrementally-justified
strategies}, we are able to show that $\beta$-normal terms are \emph{safe} if and only if
their strategy denotation is incrementally-justified.
A consequence of this is that pointers in the game semantics of safe simply-typed terms can be recovered uniquely from the underlying sequences of moves.

\vspace{1cm}

\subsection{Related work}

\subsubsection{Safety}

De Miranda's forthcoming thesis \cite{demirandathesis} proposes a unified framework for the study of higher-order grammars. The thesis contains a detailed analysis of the safety constraint at level 2. It shows that, when restricted to word languages, safe level $2$ higher-order grammars are as powerful as (non-deterministic) unsafe ones. It also shows that at level $2$, safety is not a requirement to guarantee MSO decidability. The reader is referred to it for a full account of the Safety condition for higher-order grammars.


As we mentioned before, Knapik \emph{et al.} showed in \cite{KNU02} that infinite trees generated by \emph{safe} higher-order grammars
have decidable MSO theories. In \cite{OngLics2006}, Ong generalized the result to any higher-order grammar, whether safe or not.
Using an argument based on innocent game-semantics, he establishes a correspondence between the tree generated by a higher-order grammar called \emph{value tree} and a certain regular tree called \emph{computation tree}. Paths in the value tree correspond to traversals in the computation tree. Decidability is then obtain by reducing the problem to the acceptance of the (annotated) computation tree by a certain alternating parity tree automaton (APT). The approach that we follow in section \ref{sec:correspondence} uses many ingredients introduced in this paper.


\subsubsection{Computation trees and traversals}

In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph based on
Lamping's graphs \cite{lamping} is introduced to represent
$\lambda$-terms. The authors unify different notions of paths
(regular, legal, consistent and persistent paths) that have appeared
in the literature as ways to implement graph-based reduction of
lambda-expressions. We can regard a traversal as an alternative
notion of path adapted to the graph representation of
$\lambda$-expressions given by computation trees.

Traversals of a computation tree provide a way
to perform \emph{local computation} of $\beta$-reductions as opposed
to a global approach where the $\beta$-reduction is implemented by
performing substitutions. A notion of local computation of
$\beta$-reduction has been investigated in
\cite{DanosRegnier-Localandasynchronou} through the use of special
graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The Safe $\lambda$-calculus}
We consider simple types generated by the grammar $A
\, ::= \, o \; | \; A \funsp A$. Any type different from the ground
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \funsp \cdots \funsp A_n \funsp o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the arity of $T$, written $arity(T)$, is
defined to be $n$.
The order of a type is defined by $\ord{o} = 0$ and
$\ord{A \funsp B} = \max(\ord{A}+1, \ord{B})$.

The \textbf{Safe $\lambda$-Calculus} is a sub-system of the simply-typed $\lambda$-calculus formally defined by the definition that follows.
We use a set of sequents of the form $\Gamma \vdash M : A$ to represent
terms-in-context where $\Gamma$ is the context (a typed-alphabet) and $A$ is the type. We assume that a set
of higher-order constants $\Sigma$ is given.

\begin{definition}[The Safe $\lambda$-calculus]
We call \emph{safe term} any simply-typed lambda term that is typable using the following
formation rules:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{const} \   \rulef{}{\vdash f : A} \quad f \in \Sigma
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash s : A}{\Delta \vdash s : A} \quad \Gamma \subset \Delta$$

$$ \rulename{app} \  \rulef{\Gamma \vdash s : (A_1,\ldots,A_n,B)
                                        \ \Gamma \vdash t_1 : A_1
                                        \  \ldots\  \Gamma \vdash t_n : A_n }
                                   {\Gamma  \vdash s t_1 \ldots t_n : B}
                                    \
                                   \ord{B} \sqsubseteq \ord{\Gamma}$$

$$ \rulename{abs} \   \rulef{\Gamma, x_1 : A_1 \ldots x_n : A_n \vdash s : B}
                                   {\Gamma  \vdash \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \
                                   \ord{A_1, \ldots ,A_n,B} \sqsubseteq \ord{\Gamma}$$

where in the side-conditions, $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$ and $c \sqsubseteq S$ is a notation for
``$c$ is a lower-bound for $S$''.
\end{definition}

The first deviation from the standard definition of the simply-typed $\lambda$-calculus is the possibility to perform multiple applications at a time using the {\sf (app)} rule and similarly to abstract several variables at a time using the {\sf (abs)} rule.
Of course, this change does not alter the expressivity. However, at the same time, there is an additional condition
which constrains the possible occurrences of variables within a term. More precisely, the side-condition in the application rule and abstraction rules ensures that all variables in the context of the term being formed have order greater than the order of the term itself.



Note that there is no specific constraint on the term type. In particular, the type-homogeneity constraint that is used
in the definition of safe higher-order grammars in \cite{KNU02} is not required here.\footnote{ We say that a type is homogeneous
if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with $\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$ and
each $A_1$, \ldots, $A_n$ is homogeneous.} Another difference is that we allow $\Sigma$-constants to be of any higher-order types whereas
\cite{KNU02} focuses on the restricted case of first-order $\Sigma$-constants.
In these regards, our formulation of the Safe $\lambda$-calculus differs from the one proposed in \cite{safety-mirlong2004}.
It is possible to reconcile the two definitions by adding the further constraint that each type occurring in our rules is homogeneous, we then obtain a calculus equivalent to the one of \cite{safety-mirlong2004}.




\begin{example}[Kierstead terms]
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y ))$ and
$M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where $x,y:o$ and $f:((o,o),o)$.
$M_2$ is not safe because in the subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which is smaller than $\ord{\lambda y . x} = 1$.
On the other hand, $M_1$ is safe as the following proof tree shows:
$$
 \rulef{
     \rulef{
        \rulef{}{f \vdash f} {\sf(var)}
        \
        \rulef{
             \rulef{
                \rulef{
                    \rulef{}{f \vdash f} {\sf(var)}
                }
                {f , x \vdash f } {\sf(wk)}
                \
                \rulef{
                    \rulef{
                        \rulef{}{y \vdash y} {\sf(var)}
                    }
                    {y \vdash \lambda y . y } {\sf(abs)}
                }
                {f , x \vdash \lambda y .y } {\sf(wk)}
             }
             {f , x \vdash f (\lambda y .y )} {\sf(app)}
        }
        { f  \vdash \lambda x . f (\lambda y .y )} {\sf(abs)}
     }
     {
        f  \vdash f (\lambda x . f (\lambda y .y ))} {\sf(app)}
     }
 { \vdash M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } {\sf(abs)}
$$
\end{example}

The following lemma is an immediate consequence of the definition:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \vdash M : A$ then every variable in $\Gamma$ occurring free in $M$ has order at least $ord(M)$.
\end{lemma}




In the simply typed $\lambda$-calculus, it is necessary to rename
variables when performing substitution on an abstraction in order to
avoid possible variable capture. As a consequence, in order to
implement substitution one needs to have access to an unbound number
of variable names.
In the Safe $\lambda$-Calculus, however, variable capture never happens as the following lemma shows.
Hence substitution can implemented naively by capture-permitting replacement, avoiding any need for variable renaming.


Let us write $M\captsubst{N}{x}$ to denote the capture-permitting substitution of $N$ for $x$ in $M$. This substitution is implemented
by textually replacing all free occurrences of $x$ in $M$ by $N$ without performing variable renaming.
In particular for the abstraction case we have:
$$(\lambda \overline{y} . P)\captsubst{N}{x} = \left\{
                                                 \begin{array}{ll}
                                                   \lambda \overline{y} . P\captsubst{N}{x} , & \hbox{if $x\not\in \overline{y}$;} \\
                                                   \lambda \overline{y} . P, & \hbox{if $x\in y$.}
                                                 \end{array}
                                               \right.
$$

\begin{lemma}[No variable capture]
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x \vdash M$ and $\Gamma \vdash  N$ are valid judgments of the Safe $\lambda$-calculus.
\end{lemma}

\begin{proof}
We prove the result by induction. The variable, constant and
application cases are trivial. For the abstraction case, suppose $M
= \lambda \overline{y} : \overline{A}. P$ where $\overline{y} = y_1
\ldots y_p$. If $x \in \overline{y}$ then $M \subst{N}{x} = M$ and there is no variable capture.
Suppose that $x \not\in \overline{y}$ then the capture-permitting substitution gives:
$$M \captsubst{N}{x} = \lambda \overline{y} . P \captsubst{N}{x} \ .$$


By the induction hypothesis there is no variable capture in $P \captsubst{N}{x}$.
Hence variable capture can only happen when for some $i \in 1..p$, the variable $y_i$
occurs freely in $N$ and $x$ occurs freely in $P$. Lemma \ref{lem:ordfreevar} gives:
$$ \ord{y_i} \geq \ord{N} = \ord{x} \ .$$

Since $x \not \in \overline{y}$ and $x$ occurs freely in $P$, $x$ also occurs freely in the safe term
$\lambda \overline{y}. P$ therefore by lemma \ref{lem:ordfreevar} we have:
$$ \ord{x} \geq \ord{\lambda y_1 \ldots y_p . T} \geq 1+ \ord{y_i} > \ord{y_i}$$
which, together with the previous equation, gives a contradiction.
\end{proof}

From now on we will use the standard notation $M\subst{N}{x}$ do denote the substitution of $N$ for $x$ in $M$.
It is understood that, provided that $M$ and $N$ are safe, this substitution
is implemented by the capture-permitting substitution $M\captsubst{N}{x}$.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x \vdash M$ and $\Gamma \vdash N$ then $\Gamma \vdash M[N/x]$.
\end{lemma}
\begin{proof}
An easy proof by an induction on the structure of the safe term $M$.
\end{proof}


It is desirable to have an appropriate notion of reduction for our calculus. However the standard $\beta$-reduction rule is not adequate. Indeed, Safety is not preserved by $\beta$-reduction as the following example shows. Suppose that $x,y,z,y : o$ and $\varphi : (o,o,o)$ then the safe term $(\lambda x y . \varphi x y) z w$ $\beta$-reduces to $(\underline{\lambda y . \varphi z y}) w$ which is unsafe since the underline order-1 subterm  contains a free occurrence of variable $z$ of ground type. However if we perform one more reduction we obtain the safe term
$\varphi z w$. This suggests an alternative notion of reduction that performs simultaneous reduction of consecutive $\beta$-redexes. In order to define this reduction we first introduce an appropriate notion of redex.

In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the Safe
lambda calculus, a redex is a succession of several standard redexes:
\begin{definition}[Safe redex]
We call \emph{safe redex} a safe term whose derivation tree has the following form:
$$   \rulef{
            \rulef{\rulef{\vdots}{\Gamma, \overline{x}\vdash M}}{\Gamma \vdash \lambda \overline{x} . M} (\sf{abs})
            \quad
            \rulef{\vdots}{\Gamma \vdash N_1}  \ \ldots \  \rulef{\vdots}{\Gamma \vdash N_l}
    }
    {
       \Gamma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
    } (\sf{app})
$$
where $\overline{x}$ denotes the list of variables $x_1\ldots x_n$.
\end{definition}

In other words a safe redex is a safe term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such that
the variable $\overline{x}$ are abstracted altogether by one occurrence of the rule $(\sf{abs})$ and the terms $(\lambda \overline{x} . M)$, $N_1$, \ldots, $N_l$ are applied together at once using the $(\sf{app})$ rule
(and consequently each $N_i$ must be safe).



We are now in a position to define a notion of reduction for safe terms.

\begin{definition}[Safe reduction $\beta_s$] \
\label{dfn:safereduction} The following
abbreviations are used $\overline{x} = x_1 \ldots x_n$,
$\overline{N} = N_1 \ldots N_l$, and when $n\geq l$, $\overline{x_L}
= x_1 \ldots x_l$, $\overline{x_R} = x_{l+1} \ldots x_n$.
\begin{itemize}
\item The relation $\beta_s$ is defined on the set of safe redex as follows:
\begin{eqnarray*}
\beta_s &=&
\{  \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}}  \\
&& \mbox{ where $(\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ is a safe redex such that $n> l$}
\} \\
&\cup&
\{ \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l  \\
&& \mbox{ where $(\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ is a safe redex such that $n\leq l$}
\} \ .
\end{eqnarray*}

\item
The safe $\beta$-reduction, written $\betasred$, is the closure of
the relation $\beta_s$ by compatibility with the formation rules of
the Safe $\lambda$-Calculus.
\end{itemize}
\end{definition}

\noindent \emph{Remark:} The $\beta_s$-reduction is a multi-step $\beta$-reduction i.e. $\betared \subset \betasred \subset \betaredtr$.


\begin{lemma}[$\beta_s$ reduction preserves safety]
\label{lem:homoh_safered_preserve_safety}
If $\Gamma \vdash s$ and $s \betasred t$ then $t$ is safe.
\end{lemma}

\begin{proof}
It suffices to show that the relation $\beta_s$ preserves safety.
Consider the safe-redex $ s \equiv (\lambda x_1 \ldots x_n . M) N_1 \ldots N_l $ such that
$s\ \beta_s\ t$ for some simply-typed term $t$.
Without lose of generality we can assume that the last rule used to form the term $s$ is {\sf(app)} i.e. not the weakening rule
{\sf(wk)}. Hence we have $\Gamma = fv(s)$.

By lemma \ref{lem:subst_preserve_safety}, $T\subst{\overline{N}}{\overline{x_L}}$ is safe.
By lemma \ref{lem:ordfreevar}, all variables in $\Gamma$ have order greater than $\ord{s} = \ord{t}$. Therefore
if $n>l$ then we can use the {\sf(abs)} rule to form $\Gamma \vdash t \equiv \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}}$
and if $n \leq l$ we can use the {\sf(app)} rule to form $\Gamma \vdash t \equiv  T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l$.
\end{proof}


\subsection{Safe $\lambda$-calculus and Safe Higher-order grammars}
It is possible to show equivalence of the $\lambda$-calculus formulation of Safety and the
safety restriction for higher-order grammars from \cite{KNU02}.
\begin{definition}[Higher-order grammar]
A \emph{higher-order grammar} is a tuple $G =
\langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$, where
\begin{itemize}
\item $\Sigma$ is a ranked alphabet of terminals of order at most 1,
\item $V$ is a finite set of typed variables,
\item $\mathcal{N}$ is a finite set of non-terminals,
\item $S$ a distinguished symbol of $\mathcal{N}$ of ground type, called the start symbol,
\item $\mathcal{R}$ is a finite set of production rules, one for each $F : (A_1, \ldots, A_n, o) \in N$, of the form
    $$ F z_1 \ldots z_m \rightarrow e$$
where $z_i$ is a variable of type $A_i$ and $e$ is an applicative
term of type $o$ in $\mathcal{N}(\Sigma \union \mathcal{N} \union
\{z_1 \ldots z_m \} )$. The $z_i$s are called the \emph{parameters}
of the rule.
\end{itemize}
\end{definition}
The order of a rewrite rule is the order of the non-terminal symbol
appearing on the left hand side of the rule. The order of a grammar
is the highest order of its non-terminals.
The grammar is homogenous if the non-terminals in $\mathcal{N}$ have all homogeneous types.


The original notion of safety introduced in \cite{KNU02} is defined as follows:
\begin{definition}[Safe higher-order grammars]
  A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be \emph{unsafe} if $e$ has a subterm $t$ such that:
  \begin{enumerate}
    \item $t$ occurs in an operand position in $e$,
    \item $t$ is of order $k>0$,
    \item $t$ contains a parameter of order strictly less than $k$.
  \end{enumerate}
An homogeneous grammar is \emph{safe} if all its production rules are safe.
\end{definition}


The equivalence of this definition of Safety and the formulation via the Homogeneous $\lambda$-calculus is shown in \cite{demirandathesis}:
\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$ be a grammar.
A rule $F z_1 \ldots z_m \rightarrow e$ in $\mathcal{R}$ is safe if and only if
$ z_1 \ldots z_m \vdash r : o$
is a valid typing judgement (without abstraction) of the \emph{homogeneous} Safe $\lambda$-calculus.
\end{proposition}


The reader is referred to \cite{KNU02,demirandathesis,safety-mirlong2004}
for details about the safety restriction for higher-order grammars.









\section{Computation tree and traversals}
\label{sec:correspondence}

In this section we introduce the notion of computation tree of a simply-typed term and
define traversals over the computation tree. These two notions were firstly introduced in \cite{OngLics2006}. Here they
are adapted to the context of the $\lambda$-calculus.

We then prove the \emph{Correspondence Theorem} (theorem \ref{thm:correspondence}), a result similar to the ``Path-Traversal Correspondence'' theorem of \cite{OngLics2006}. We will make use of this result in the next section in order to obtain
a game-semantic characterisation of the Safe $\lambda$-Calculus.

In the following, we work in the general setting of the simply-typed
$\lambda$-calculus extended with a fixed set $\Sigma$ of
higher-order constants.


\subsection{$\eta$-long normal form and computation tree}


The $\eta$-long normal form appeared in
\cite{DBLP:journals/tcs/JensenP76} and
\cite{DBLP:journals/tcs/Huet75} under the names \emph{long reduced
form} and \emph{$\eta$-normal form} respectively. It was then
investigated in \cite{huet76} under the name \emph{extensional
form}.

The $\eta$-expansion of a term $M$ of type $(A_1,\ldots,A_n,o)$ is
$\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots \varphi_l$
where the $\varphi_i:A_i$ are fresh variables. The $\eta$-normal
form of a term is obtained by hereditarily $\eta$-expanding every
subterm occurring at an operand position.

\begin{definition}[$\eta$-long normal form]
A simply-typed term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a $\Sigma$-constant or an abstraction.
The $\eta$-long normal form of a term $M$, written $\aux{M}$ or sometimes $\etanf{M}$,
is defined as follows:
\begin{align*}
\aux{\lambda x . s } &= \lambda x . \aux{s} \\
\aux{\alpha s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &= \lambda \overline{\varphi} . \alpha \aux{s_1}\ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
& \mbox{with $m,n\geq0$}\\
\aux{(\lambda x . s) s_1 \ldots s_m : (A_1,\ldots,A_n,o) } &= \lambda \overline{\varphi} . (\lambda x . \aux{s}) \aux{s_1} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
& \mbox{with $m\geq 1,n\geq0$}
\end{align*}
where $x$ and each $\varphi_i : A_i$ are variables and $\alpha$ is
either a variable or a constant.
\end{definition}

\begin{remark}
\begin{itemize}
\item For $n=0$, the first clause in the definition becomes:
$\aux{x s_1 \ldots s_m : o} = \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m}.$
The \textsl{dummy lambda} $\lambda .$ is kept deliberately as it will play an important role in the
game-semantic correspondence.

\item A term in $\eta$-normal form is either an abstraction or it is of ground type and can be written uniquely as
$s_0 s_1 \ldots s_m : 0$ where $m\geq0$,  $s_0$ is a variable, a constant or an abstraction and each of the $s_j$ for $j\in 1..m$ is in $\eta$-normal form.
\end{itemize}
\end{remark}

Our version of the $\eta$-long normal form is defined for any simply-typed term, not only for $\beta$-normal terms.
Moreover converting a term to its $\eta$-long normal form does not introduce new redex and therefore
the $\eta$-long normal form of $\beta$-normal term is a $\beta$-normal term.


Computation trees were proposed in \cite{OngHoMchecking2006} for the purpose of studying the infinite tree structures
generated by higher-order grammars. The computation tree of a grammar is defined as the unravelling of a finite graph representing the long transform of a grammar. In the context of the $\lambda$-calculus, we define the computation tree of a $\lambda$-term to be the abstract syntax tree of its $\eta$-long normal form.

\emph{Notation:} We introduce the following notations for labelled-trees: $[l](t_1, \ldots, t_n)$ denotes the tree whose root is labelled by $l$ and has $n$ children subtrees $t_1$, \ldots, $t_n$. Single node trees are written $[l]$ for some label $l$. If $t = [l](t')$, i.e. the root has a single child, then $t^-$ denotes the tree $t'$ (the tree obtained after deleting the root).

\begin{definition}[Computation tree]
Let $L$ be the following set of node labels:
$$ L = \Sigma \union \{ @ \} \union \{ x : x \mbox { is a variable} \}
\union \{ \lambda \overline{x} : \overline{x} = x_1 \ldots x_n \mbox { is a list of variables.} \}
  $$

For terms in $\eta$-normal form, we define the $L$-labelled tree $\tau$ as follows:
\begin{eqnarray*}
  \tau(\lambda x_1 \ldots x_n . s) &=& [\lambda x_1 \ldots x_n](\tau(s)^{-}) \\
    && \mbox{for $n\geq0$ and some term $s$ that is not an abstraction \ ;} \\
  \tau( \alpha s_1 \ldots s_m : o) &=& [ \lambda ]([\alpha](\tau(s_1),\ldots,\tau(s_m))) \\
    && \mbox{for $m\geq0$ and some variable or constant $\alpha$ \ ;} \\
  \tau((\lambda x.s_0) s_1 \ldots s_n :o) &=& [\lambda] ([@](\tau(\lambda x.s),\tau(s_1),\ldots,\tau(s_m))) ) \\
    && \mbox{for $n \geq 1$ \ .}
\end{eqnarray*}

The \emph{computation tree} of a simply-typed term $M$, written $\tau(M)$, is defined as $\tau(\etanf{M})$.
\end{definition}

The nodes (and leaves) of the tree are of three kinds:
\begin{itemize}
\item $\lambda$-nodes labelled $\lambda \overline{x}$ representing several consecutive variable abstractions,
\item application nodes labelled @,
\item variable or constant nodes labelled by some constant or variable $\alpha$.
\end{itemize}
Suppose that a term $M$ has been fixed, then we abbreviate $\tau(M)$ into $\tau$  and we write
$N$ for the set of nodes of $\tau$, $N_\Sigma$ for the set of $\Sigma$-labelled nodes,
$N_@$ for the set of @-labelled nodes, $N_{var}$ for the set of variable nodes and
$N_{fv}$ for the subset of $N_{var}$ constituted of free-variable nodes.


Clearly, each subtree of the computation tree $\tau(M)$ represents a subterm of $\aux{M}$.
There is a function $\kappa$ defined on $N$ that maps each node $n \in N$ to the subterm of $\aux{M}$ corresponding to the subtree of $\tau(M)$ rooted at $n$.
In particular if $\tau(M) = [r](\ldots)$ then we have $\kappa(r) = \aux{M}$.

\begin{definition}[Node order]
\label{def:nodeorder}
The node-order function $\textsf{ord}$ is defined on nodes as follows:
\begin{eqnarray*}
\ord{n} =& \\
&\left\{
  \begin{array}{ll}
    \ord{T}, & \hbox{if $n$ is a variable or constant of type $T$;} \\
    1 + \max_{z\in \overline{\xi}\union fv(M)} \ord{z}, & \hbox{if $n$ is labelled $\lambda \overline{\xi}$ and is the root of $\tau(M)$;} \\
    1 + \max_{z\in \overline{\xi}} \ord{z}, & \hbox{if $n$ is labelled $\lambda \overline{\xi}$ and is not the root;} \\
    0, & \hbox{if $n$ is labelled @.}
  \end{array}
\right.
\end{eqnarray*}
\end{definition}

\noindent Some remarks:
\begin{itemize}
\item in a computation tree, nodes at even level are $\lambda$-nodes and nodes at odd level are either application nodes,
variable or constant nodes;

\item for any ground type variable or constant $\alpha$, $\tau(\alpha) = \tau(\lambda . \alpha) =  [\lambda]([\alpha])$;

\item for any higher-order variable or constant $\alpha : (A_1,\ldots,A_p,o)$, the computation tree $\tau(\alpha)$ is of the form
$ [\lambda](
        [\alpha]([\lambda \overline{\xi_1}](\ldots), \ldots, [\lambda \overline{\xi_p}](\ldots))
        )
$;

\item for any computation tree of the form $[\lambda \overline{\varphi}]([n]( \ldots ))$ we have $\ord{\kappa(n)}=0$.
\end{itemize}







\subsection{Pointers and justified sequence of nodes}

\begin{definition}[Binder]
Let $n$ be a variable node of the computation tree labelled $x$. We
say that a node $n$ is bound by the node $m$, and $m$ is called the
binder of $n$, if $m$ is the closest node in the path from $n$ to
the root of the tree such that $m$ is labelled $\lambda
\overline{\xi}$ with $x\in \overline{\xi}$.
\end{definition}

\begin{definition}[Enabling]
The enabling relation $\vdash$ is defined on the set of nodes of the
computation tree. We write $m \vdash n$ and we say that $m$ enables
$n$ if and only if
\begin{itemize}
\item $n$ is a bound variable node and $m$ is the binder of $n$,
\item or $n$ is a free variable node and $r$ is the root of the computation tree,
\item or $n$ is a $\lambda$-node and $m$ is the parent node of $n$.
\end{itemize}
\end{definition}

We call \emph{input-variable} a variable that is hereditarily justified by the root of the computation tree.
Free variables and variables bound by the root are example of input-variables.

\begin{definition}[Justified sequence of nodes]
A \emph{justified sequence of nodes} is a sequence of
nodes of the computation tree $\tau(M)$ with pointers attached to the nodes. A node $n$ in the sequence
that is either a variable node or a lambda-node different from the root of the computation tree
has a pointer to a node $m$ occurring before $n$ in the sequence such that $m \vdash n$.
If $n$ points to $m$ then we say that $m$ \emph{justifies} $n$ and we represent the pointer in the sequence as follows:
$$\rnode{m}{m} \cdot \ldots \cdot \rnode{n}{n} \bkptr[nodesep=1pt]{40}{n}{m}$$
\end{definition}
Note that justified sequences are also defined for open terms:
occurrences of nodes in $N_{fv}$ must point to an occurrence of the
root of the computation tree.


A pointer is sometime labeled with an index $i$: if $m$ is a
$\lambda$-node then it indicates that $n$ is labelled with the $i$th
variable abstracted in $m$; otherwise it indicates that $n$ is the
$i$th child of $m$. A pointer in a justified sequence of nodes has
therefore one of the following forms: \vspace{2pt}
$$
\rnode{m}{r} \cdot \ldots \cdot \rnode{n}{z} \bkptr[nodesep=1pt]{40}{n}{m}
\hspace{1.5cm}
\rnode{m}{\lambda \overline{\xi}} \cdot \ldots \cdot \rnode{n}{\xi_i} \bkptr[nodesep=1pt]{40}{n}{m} \bklabel{i}
\hspace{1.5cm}
\rnode{m}{@ } \cdot \ldots \cdot \rnode{n}{\lambda \overline{\eta}} \bkptr[nodesep=1pt]{40}{n}{m} \bklabel{j}
\hspace{1.5cm}
\rnode{m}{\alpha } \cdot \ldots \cdot \rnode{n}{\lambda \overline{\eta}} \bkptr[nodesep=1pt]{40}{n}{m} \bklabel{k}
$$
where $r$ denotes the root of $\tau(M)$, $z \in N_{fv}$, $\xi_1,
\ldots \xi_n$ are bound variables, $\alpha \in N_{\Sigma} \union
N_{var}$, $i \in 1..n$, $j$ ranges from $0$ to the number of
children nodes of @ minus 1 and $k \in 1 ..arity(\alpha)$.

The following numbering conventions are used:
\begin{itemize}
\item the first child of a @-node is numbered $0$,
\item the first child of a variable or constant node is numbered $1$,
\item variables in $\overline{\xi}$ are numbered from $1$ onward ($\overline{\xi} = \xi_1, \ldots \xi_n$).
\end{itemize}
We use the notation $n.i$ to denote the $i$th child of node $n$.
We write $s = t$ to denote that the justified sequences $t$ and $s$
have same nodes \emph{and} pointers.

We say that a node $n_0$ of a justified sequence is hereditarily justified by $n_p$ if there are nodes $n_1, n_2, \ldots n_{p-1}$ in
the sequence such that for all $i\in 0..p-1$, $n_i$ points to $n_{i+1}$.

If $N$ is a set of nodes and $s$ a justified sequence of nodes then
we write $s \upharpoonright N$ to denote the subsequence of $s$
obtained by keeping only the nodes that are hereditarily
justified by nodes in $N$. This subsequence is also a justified
sequence of nodes. If $n$ denotes a node of $\tau(M)$ we
abbreviate $s \upharpoonright \{ n \}$ into $ s\upharpoonright n$.

The notions of P-view and O-view of justified sequences of nodes
are defined the same way as their game-semantic counterparts for justified sequences of moves.
\begin{definition}[P-view]
The P-view of a justified sequence of nodes $t$ of $\tau$, written $\pview{t}$, is defined as follows: \footnote{
The equalities in the definition determine pointers implicitly. For instance in the second clause, if in the
left-hand side, $n$ points to some node in $s$ that is also present
in $\pview{s}$ then in the right-hand side, $n$ points to this
occurrence of the node in $\pview{s}$.}
\begin{align*}
\pview{\epsilon} &=  \epsilon
& \pview{s \cdot n }  &=  \pview{s} \cdot n  \\
\pview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{lmd}{\lambda \overline{\xi}}} &= \pview{s} \cdot \rnode{m2}{m} \cdot \rnode{lmd2}{\lambda \overline{\xi}}   \bkptr[nodesep=1pt]{30}{lmd}{m}    \bkptr[nodesep=1pt]{60}{lmd2}{m2}
& \pview{s \cdot r }  &=  r
\end{align*}
where $r$ is the root of the tree $\tau$ and $n$ ranges over
non-lambda nodes (i.e. $N_\Sigma \union N_@ \union N_{var}$).
\end{definition}

The O-view is defined to be the dual notion of P-view.
We borrow the game semantic terminology to qualify justified sequences of nodes:
$s$ satisfies \emph{alternation} if for any two consecutive nodes in $s$, one is a $\lambda$-node
and the other is not; \emph{P-visibility} if every variable node in $s$ points to a node occurring in the P-view a that point; \emph{O-visibility} if every lambda node in $s$ points to a node occurring in the O-view a that point.

\subsection{Adding value-leaves to the computation tree}
\label{sec:adding_value_leaves}

We now add leaves to the computation tree that has been defined in the previous section.
These leaves, called \emph{value-leaves}, are attached to the nodes of the computation tree. Each
value-leaf corresponds to a possible value of the base type $o$.
We write $\mathcal{D}$ to denote the set of values of the base type
$o$. The values leaves are added as follows: every 
node $n \in \tau(M)$ has a child leaf denoted by $v_n$ for each possible value $v \in \mathcal{D}$.

Everything that we have defined for computation tree can be lifted
to this new version of computation tree. The node order of a
value-leaf is defined to be $0$. The enabling relation $\vdash$ is
extended so that every leaf is enabled by its parent node. The
definition of justified sequence does not change.
When representing a link in a justified sequence going from a value-leaf $v_n$ to a node $n$,
we label the link with $v$:
$$
\rnode{n}{n} \cdot \ldots \cdot \rnode{vn}{v_n} \bkptr[nodesep=1pt]{40}{vn}{n} \bklabel{v}
$$


For the definition
of P-view, O-view and visibility, value-leaves are treated as
$\lambda$-nodes if they are at odd level in the computation tree and
as variable nodes if there at a even level.

From now the term ``computation tree'' refers to this extended
definition.
\vspace{10pt}

Let $n$ be a node of a justified sequence of nodes.
If there is an occurrence of a value-leaf $v_n$ in the sequence that points to $n$ we say that
$n$ is \emph{matched} by $v_n$. If there is no value-leaf in the sequence that points to $n$ we
say that $n$ is an \emph{unmatched node}.
The last unmatched node is called the \emph{pending node}.
A justified sequence of nodes is \emph{well-bracketed} if
each value-leaf in the traversal points to the pending node at that point.

If $t$ is a traversal then we write $?(t)$ to denote the subsequence
of $t$ consisting only of unmatched nodes.

\subsection{Traversal of the computation tree}
\label{subsec:traversal} We first define traversals for computation
tree of simply-typed $\lambda$-terms with no interpreted constants.
We will then we show how to extend the definition to the general
setting of $\lambda$-calculus augmented with interpreted constants.

\subsubsection{Traversals for simply-typed $\lambda$-terms}
Intuitively, a \emph{traversal} is a justified sequence of nodes of the computation tree where each node
indicates a step that is taken during the evaluation of the term.

\begin{definition}[Traversals for pure simply-typed $\lambda$-terms]
\label{def:traversal}
Let $M$ be a term of the simply-typed $\lambda$-calculus with no constants.
We define the set $\travset(M)$ of traversals over the computation tree $\tau(M)$ to be the set
of justified sequences of nodes generated by the rules given below.
A \emph{maximal-traversal} is a traversal that cannot be
extended by any rule.

\emph{Initialization rules}
\begin{itemize}
\item ($\epsilon$) The empty sequence of node $\epsilon$ is a traversal.
\item (Root) The length 1 sequence $r$, where $r$ is denotes the root of $\tau(M)$, is a traversal.
\end{itemize}

\emph{Structural rules}
\begin{itemize}
\item (Lam) Suppose that $t \cdot \lambda \overline{\xi}$ is a traversal and $n$ is the only child node of $\lambda \overline{\xi}$ in
the computation tree then
$$t \cdot \lambda \overline{\xi} \cdot n$$
is also a traversal
where $n$ points to the (only) occurrence of its enabler in $\pview{t \cdot \lambda \overline{\xi}}$.
In particular, if $n$ is a free variable node then $n$ points to the first node of $t$.

\item (App) If $t \cdot @$ is a traversal then so is
$$t \cdot \rnode{m}{@} \cdot
\rnode{n}{n} \bkptr[nodesep=1pt]{60}{n}{m} \bklabelc{0}
$$

i.e. the next visited node is the $0$th child node of @ : the
node corresponding to the operator of the application.
\end{itemize}

\emph{Input-variable rules}
\begin{itemize}
\item (InputVar$^0$) If $t = t_1 \cdot x \cdot t_2$ is a traversal where
$x$ is the pending node in $t$ (i.e. $?(t_2)=\epsilon$)
and $x$ is a ground-type input-variable then for any $v \in \mathcal{D}$ the following is a traversal
$$t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot \rnode{xv}{v_x}
\bkptr[nodesep=1pt]{40}{xv}{x} \bklabelc{v}$$


\item (InputVar$^{\geq 1}$)
If $t = t_1 \cdot x \cdot t_2$ is a traversal where
$x$ is the pending node in $t$ (i.e. $?(t_2)=\epsilon$)
and $x$ is a higher-order input-variable then the following is a traversal:
$$t_1 \cdot \rnode{m}{x} \cdot t_2 \cdot
\rnode{n}{n} \bkptr[nodesep=1pt]{40}{n}{m} \bklabelc{i} \qquad
\mbox{ for } 1 \leq i \leq arity(x).$$
Moreover for any $v\in \mathcal{D}$ the sequence $t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot
\rnode{xv}{v_x} \bkptr[nodesep=1pt]{40}{xv}{x} \bklabelc{v}$ is also a traversal.
\end{itemize}

\emph{Copy-cat rules}
\begin{itemize}
  \item (CCAnswer-@)
  If $t \cdot \rnode{app}{@} \cdot \rnode{lz}{\lambda \overline{z}} \cdot \ldots \cdot \rnode{lzv}{v_{\lambda \overline{z}}}
              \bkptr[nodesep=1pt]{30}{lzv}{lz} \bklabelc{v}
              \bkptr[nodesep=1pt]{40}{lz}{app} \bklabelc{0}$
              is a traversal then so is:
              $t \cdot \rnode{app}{@} \cdot \rnode{lz}{\lambda \overline{z}} \cdot \ldots \cdot \rnode{lzv}{v_{\lambda \overline{z}}} \cdot \rnode{appv}{v_@}
              \bkptr[nodesep=1pt]{30}{lzv}{lz} \bklabelc{v}
              \bkptr[nodesep=1pt]{40}{lz}{app} \bklabelc{0}
              \bkptr[nodesep=1pt]{30}{appv}{app} \bklabelc{v}$.


  \item (CCAnswer-$\lambda$) If $t \cdot \lambda \overline{\xi} \cdot \rnode{x}{x} \cdot \ldots \cdot  \rnode{xv}{v_x}
              \bkptr[nodesep=1pt]{30}{xv}{x} \bklabelc{v}$
              is a traversal then so is:
              $t \cdot \rnode{lmd}{\lambda \overline{\xi}} \cdot \rnode{x}{x} \cdot \ldots \cdot \rnode{xv}{v_x} \cdot
              \rnode{lmdv}{v_{\lambda \overline{\xi}}}
              \bkptr[nodesep=1pt]{20}{xv}{x} \bklabelc{v}
                \bkptr[nodesep=1pt]{20}{lmdv}{lmd} \bklabelc{v}$.

     \item (CCAnswer-var) If $t \cdot y \cdot \rnode{lmd}{\lambda \overline{\xi}}
                   \cdot \ldots
                   \cdot \rnode{lmdv}{v_{\lambda \overline{\xi}}} \bkptr[nodesep=1pt]{30}{lmdv}{lmd} \bklabelc{v}$ is a traversal,
                   where $y$ is a non input-variable node, then the following is also a traversal:
        $$t \cdot \rnode{y}{y}
            \cdot \rnode{lmd}{\lambda \overline{\xi}}
            \cdot \ldots
            \cdot \rnode{lmdv}{v_{\lambda \overline{\xi}}}
            \cdot \rnode{yv}{v_y}
                \bkptr[nodesep=3pt]{35}{yv}{y} \bklabelc{v}
                \bkptr[nodesep=1pt]{30}{lmdv}{lmd} \bklabelc{v}.$$


\item (Var)
If $t \cdot x_i$ is a traversal where $x_i$ is not an input-variable,
then the rule (Var) permits to visit the node corresponding to the subterm that would be substituted
for $x_i$ if all the $\beta$-redexes occurring in $M$ were reduced.

The binding node $\lambda \overline{x}$ necessarily occur previously
in the traversal. Since $x$ is not hereditarily justified by the
root, $\lambda \overline{x}$ is not the root of the tree and
therefore its justifier $p$ - which is also its parent node - occurs
immediately before itself it in the traversal. We do a case analysis
on $p$:

    \begin{itemize}
    \item Suppose $p$ is an @-node then $\lambda \overline{x}$ is necessarily the first child node of $p$
    and $p$ has exactly $|\overline{x}| + 1$ children nodes:
    $$\pstree[levelsep=7ex]{\TR{\stackrel{\vdots}{@^{[p]}}}}
    {   \pstree[linestyle=dotted,levelsep=4ex]{\TR{\lambda \overline{x}}\treelabel{0}}
            {\TR{x_i }}
        \tree{\lambda \overline{\eta_1}}{\vdots}\treelabel{1}
        \TR[edge=\dotedge]{}
        \tree{\lambda \overline{\eta_i}}{\vdots}\treelabel{i}
        \TR[edge=\dotedge]{}
        \tree{\lambda \overline{\eta_{|x|}}}{\vdots}\treelabel{|x|}
    }
    $$
    In that case, the next step of the traversal is a jump to $\lambda \overline{\eta_i}$ -- the $i$th child of
    @ -- which corresponds to the subterm that would be substituted for $x_i$ if the $\beta$-reduction was
    performed:
    \vspace{0.3cm}
    $$t' \cdot \rnode{n}{@^{[p]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}} \cdot \ldots
    \bkptr[ncurv=0.45]{45}{mi}{n} \bklabel{i}
    \bkptr[ncurv=0.6]{50}{x}{lx} \bklabel{i} \in \travset(M)
    $$

    \item Suppose $p$ is variable node $y$, then
    necessarily the node $\lambda \overline{x}$ has been added to the traversal $t_{\leq y}$ using the (Var) rule.
    Therefore $y$ is substituted by the term $\kappa(\lambda \overline{x})$ during the evaluation of the term
    and we have $\ord{y} = \ord{\lambda \overline{x}}$.

    Consequently, during reduction, the variable $x_i$ is substituted by the subterm represented by
    $\lambda \overline{\eta_i}$ -- the $i$th child node of $y$.
    Hence the following justified sequence is also a traversal:
    \vspace{0.2cm}
    $$t' \cdot \rnode{n}{y^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}} \cdot \ldots
    \bkptr[ncurv=0.6]{50}{x}{lx} \bklabel{i}
    \bkptr[ncurv=0.5]{50}{mi}{n} \bklabel{i}$$
    \end{itemize}
\end{itemize}
Note that a traversal always starts with the root of the tree.
\end{definition}

\begin{remark}
Our notions of computation tree and traversal differ slightly from
\cite{OngLics2006}.

The first difference concerns the treatment of uninterpreted constants. In our setting, there is no special treatment for them since we just regard them as being free variables. Consequently, there is no restriction on the order of these constants. This differs with \cite{OngLics2006} which deals with computations generating tree structures and therefore requires the order of higher-order constants to be at most $1$.

Secondly we have introduced copy-cat rules that permit to visit the
value-leaves of the computation tree. The presence of value-leaves
is necessary to model free variables as well as the interpreted
constants present in extensions of the $\lambda$-calculus such as
\pcf\ or \ialgol.
\end{remark}

\begin{example}
Consider the following computation tree:
$$\tree{\lambda}
{
    \tree{@}
    {
        \pstree[levelsep=8ex,linestyle=dotted]{\TR{\lambda y}\treelabel{0} }
        {
            \pstree[levelsep=8ex]{\TR{y}}
            {
                \tree{\lambda \overline{\eta_1}}{\vdots} \treelabel{1}
                \TR[edge=\dotedge]{}
                \tree{\lambda \overline{\eta_i}}{\vdots}\treelabel{i}
                \TR[edge=\dotedge]{}
                \tree{\lambda \overline{\eta_n}}{\vdots}\treelabel{n}
            }
        }
        \pstree[levelsep=6ex,linestyle=dotted]{\TR{\lambda \overline{x}}\treelabel{1}}{ \tree{x_i}{\TR{} \TR{} } }
    }
}
$$
An example of traversal of this tree is:
\vspace{0.3cm}
$$ \lambda \cdot
\rnode{app}{@}  \cdot
\rnode{ly}{\lambda y} \cdot \ldots \cdot
\rnode{y}{y} \cdot
\rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
\rnode{x}{x_i} \cdot
\rnode{leta}{\lambda \overline{\eta_i} } \cdot \ldots
\bkptr[ncurv=0.6,nodesep=0]{40}{x}{lx}  \bklabel{i}
\bkptr[ncurv=0.5]{50}{leta}{y}  \bklabel{i}
\bkptr[ncurv=0.6,nodesep=0]{40}{y}{ly}  \bklabel{1}
\bkptr[ncurv=0.5]{50}{lx}{app}  \bklabel{1}$$
\end{example}

\subsubsection{Traversals for interpreted constants}

\begin{definition}[Well-behaved traversal rule]
\label{def:wellbehaved_traversal}
A traversal rule is \emph{well-behaved} if it can be stated under the following form:
$$\rulef{t = t_1\cdot n \cdot t_2 \in \travset \quad ?(t_2) = \epsilon \quad P(t)}
  { \stackrel{  \rule{0pt}{3pt} }{t' = t_1\cdot \rnode{n}{n} \cdot t_2 \cdot \rnode{m}{m} \in \travset} }
   \bkptr[nodesep=1pt]{35}{m}{n}
    \ m\in S(t)
   $$
such that:
\begin{enumerate}
  \item $n$ is a variable or a constant node;
  \item $P$ expresses some condition on $t$;
  \item $S(t)$ is some subset of $E(n)$, the set of children $\lambda$-nodes and value-leaves of $n$.
  If $S(t)$ has more than one element then the rule is non-deterministic.
\end{enumerate}
\end{definition}
Note that if $t$ is well-bracketed then $t'$ is also well-bracketed
and if $?(t)$ satisfies alternation (resp. visibility) then so does $?(t')$.


The rules (InputVar$^0$) and (InputVar$^{\geq1}$) are two examples of
non-deterministic well-behaved traversal rules for which
$S(t)$ is exactly the set of all children-nodes and value-leaves of $n$:
$S(t) = \{ n.i \ |\ i \in 1..arity(n) \} \union  \{ v_n \ | \ v \in \mathcal{D} \} $.


In the presence of higher-order interpreted constants, additional rules must be specified to indicate how
the constant nodes should be traversed in the computation tree. These rules
are specific to the language that is being studied (for instance \pcf\ or \ialgol).

From now on, we consider a simply-typed $\lambda$-calculus language extended with
higher-order interpreted constants for which some constant traversal rules have been defined
and we take the following condition as a prerequisite:
\begin{center}
  \textbf{Condition (WB) :} the constant traversal rules are well-behaved.
\end{center}


\subsubsection{Some properties of traversals}

\begin{proposition}
\label{prop:pviewtrav_is_path}
Let $t$ be a traversal. Then:
\begin{itemize}
\item[(i)] $t$ is a well-defined and well-bracketed justified sequence;
\item[(ii)] $?(t)$ is a well-defined justified sequence verifying alternation, P-visibility and O-visibility;
\item[(iii)] $\pview{?(t)}$ is a path in the computation tree going from the root to the last node in $?(t)$.
\end{itemize}
\end{proposition}
This is the counterpart of proposition 6 from
\cite{OngHoMchecking2006} which is proved by induction on the
traversal rules. This proof can be easily adapted to take into
account the constant rules (using the assumption that constants
rules are well-behaved) and the presence of value-leaves in the
traversal.



\begin{definition}[Traversal reduction]
Let $r$ be the root of the computation tree. We say that the
justified sequence of nodes \emph{$s$ is a reduction of the
traversal $t$} just when $s = t \upharpoonright r$.
\end{definition}

Since @-nodes and $\Sigma$-constants do not have pointer, the
reduction of traversal contains only nodes in $N_\lambda \union
N_{var}$.


\begin{lemma}[View of a traversal reduction]
\label{lem:redtrav_trav} Let $M$ be a term in $\beta$-normal form,
$r$ be the root of $\tau(M)$ and $t$ be a traversal of $\tau(M)$. We
have
\begin{itemize}
\item[(i)] $ \pview{?(t) \upharpoonright  r } = \pview{?(t)} \upharpoonright r$;
\item[(ii)] if the last node in $t$ is hereditarily justified by $r$ then $ \oview{?(t) \upharpoonright r } = \oview{?(t)}$.
\end{itemize}
\end{lemma}
The proof is by an easy induction.

\begin{lemma}[Traversal of $\beta$-normal terms]
\label{lem:betaeta_trav}
Let $M$ be a $\beta$-normal term, $r$ be the root of the tree $\tau(M)$,
$t$ be a traversal of $\tau(M)$ and $n$ a node occurring in $t$, then
$r$ does not hereditarily justify $n$ if and only if $n$ is
hereditarily justified by some node in $N_\Sigma$.
\end{lemma}


\section{Game semantics of simply-typed $\lambda$-calculus with $\Sigma$-constants}
\label{sec:assumptions}


We are working in the general setting of an applied simply-typed $\lambda$-calculus with a given set of higher-order constants $\Sigma$.
The operational semantics of these constants is given by certain reduction rules.
We assume that a fully abstract model of the calculus is provided by mean of a category of well-bracketed games.
A strategy will be represented by a prefix-closed set instead of an ``even length
prefix''-closed set. In practice this means that we replace the set
of plays $\sigma$ by $\sigma \union \textsf{dom}(\sigma)$. This
permits to avoid considerations on the parity of the length of
traversals when we show the correspondence between traversals and
game semantics. We write $\sem{\Gamma \vdash M : A}$ for the strategy denoting the simply-typed term
$\Gamma \vdash M : A$ and $\prefset(S)$ to denote the
prefix-closure of the set $S$.


The main result that we will prove in this section is called the
\emph{Correspondence Theorem} (theorem \ref{thm:correspondence}). It
states that traversals over the computation tree are just
representations of the uncovering of plays in the
strategy-denotation of the term. Hence there is an isomorphism
between the strategy denotation of a term and its revealed game
denotation (i.e. its strategy denotation where internal moves are
not hidden after composition). This theorem permits us to explore
the effect that a given syntactic restriction has on the strategy
denotating a term.

To really make use of the Correspondence Theorem, it will be
necessary to restate it in the standard game-semantic framework in
which internal moves are hidden. For that purpose, we will define a
\emph{reduction} operation on traversals responsible of eliminating
the ``internal nodes'' of the computation. This leads to a
correspondence between the standard game denotation of a term and
the set of reductions of traversals over its computation tree.
Fortunately, the reduction process preserves the good properties of
traversals. This is guaranteed by the facts that the P-view of the
reduction of a traversal is equal to the reduction of the P-view of
the traversal, and the O-view of a traversal is the same as the
O-view of its reduction (lemma \ref{lem:redtrav_trav}). \vspace{8pt}


\subsection{Relationship between computation trees and arenas}

\subsubsection{Example}
Consider the following term $M \equiv \lambda f z . (\lambda g x . f (f x)) (\lambda y. y) z$ of type $(o \typear o) \typear o \typear o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f (f x)) (\lambda y. y) (\lambda .z)$.

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

The figure below represents the computation tree (left) and the
arena (right). The dashed line defines a partial function $\varphi$
from the set of nodes in the computation tree to the set of moves.
For simplicity, we now omit answers moves when representing arenas.
$$
\tree{ \Rnode{root} {\lambda f z w}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}
                { \tree{\Rnode{f}{f^{[6]}}}{  \tree{\Rnode{lmd}\lambda^{[7]}}{ \tree{\Rnode{f2}{f^{[8]}}} {\tree{\Rnode{lmd2}\lambda^{[9]}}{\TR{x^{[10]}}}}}  }
                }
            \tree{\lambda y ^{[4]}}{\TR{y}}
            \tree{\lambda ^{[5]}}{\TR{\Rnode{z}z}}
        }
    }
\hspace{3cm}
  \tree[levelsep=12ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
        \TR{\Rnode{q5}q^5}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{z}{q2}
\ncline{->}{f}{q3}
\ncline{->}{lmd}{q4}
\ncline{->}{f2}{q3}
\ncline{->}{lmd2}{q4}
$$

Consider the justified sequence of moves $s \in \sem{M}$:
\vspace{0.2cm}
 $$s =
\rnode{q1}{q}^1\ \rnode{q3}{q}^3\ \rnode{q4}{q}^4\ \rnode{q3b}{q}^3\ \rnode{q4b}{q}^4\ \rnode{q2}{q}^2
\bkptr[offset=-3pt]{60}{q3}{q1}
\bkptr[offset=-3pt,ncurv=0.5]{60}{q3b}{q1}
\bkptr[offset=-3pt]{60}{q4}{q3}
\bkptr[offset=-3pt]{60}{q4b}{q3b}
\bkptr[offset=-3pt,ncurv=0.5]{60}{q2}{q1}
\in \sem{M}$$

There is a corresponding justified sequence of nodes in the computation tree:
\vspace{0.5cm}
$$r =
\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z}
\bkptr[ncurv=1]{60}{q3}{q1}
\bkptr[ncurv=1]{60}{q4}{q3}
\bkptr[ncurv=0.5]{75}{q3b}{q1}
\bkptr[ncurv=1]{50}{q4b}{q3b}
\bkptr[ncurv=0.4]{80}{q2}{q1}$$
such that $s_i = \varphi(r_i)$ for all $i < |s|$.

The sequence $r$ is in fact the reduction of the following
traversal: \vspace*{1cm}
$$t = \rnode{q1}{\lambda f
z} \cdot \rnode{n2}{@^{[2]}} \cdot \rnode{n3}{\lambda g x^{[3]}}
\cdot \rnode{q3}{f}^{[6]} \cdot \rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f}^{[8]} \cdot \rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{n8}{x^{[10]}} \cdot \rnode{n9}{\lambda^{[5]}} \cdot
\rnode{q2}{z} \bkptr[ncurv=0.6]{60}{q3}{q1}
\bkptr[ncurv=1]{60}{q4}{q3} \bkptr[ncurv=0.4]{75}{q3b}{q1}
\bkptr[ncurv=0.8]{70}{q4b}{q3b} \bkptr[ncurv=0.4]{80}{q2}{q1}
\bkptr[ncurv=0.4]{60}{n3}{n2} \bkptr[ncurv=0.4]{60}{n8}{n3}
\bkptr[ncurv=0.4]{60}{n9}{n2}.
$$

By representing side-by-side the computation tree and the type arena of a term in $\eta$-normal form we have observed
that some nodes of the computation tree can be mapped to question moves of the arena.
In the next section, we show how to define this mapping in a systematic manner.

\subsubsection{Formal definition}

Let us establish precisely the relationship between arenas of the
game semantics and the computation trees. Let $\Gamma \vdash M : A$
be a term in $\eta$-long normal form. The computation tree $\tau(M)$
is represented by a pair $(V,E)$ where $V$ is the set of vertices of
the trees and $E$ is the edges relation. $V = N \union L$ where $N$
is the set of nodes and $L$ is the set of value-leaves.

The relation $E \subseteq V \times V$ gives the parent-child relation on the vertices of the tree.
$E = E_n \union E_l$ where $E_n \subseteq N \times N$ gives the node-node parent relation and $E_l \subseteq N \times L$ gives the node-leaf parent relation.
We write $L_\$$ for $E_l(N_\$)$
and $V_\$$  for $N_\$ \union L_\$$ where $\$$ ranges over $\{@, var, \Sigma, fv \}$.


Let $\mathcal{D}$ be the set of values of the base type $o$. If $n$
is a node in $N$ then the value-leaves in
$E_l(n)$ attached to the node $n$ are written $v_n$ where $v$ ranges in $\mathcal{D}$.
Similarly, if $q$ is a question in $\sem{A}$ then the answer moves
enabled by $q$ are written $v_q$ where $v$ ranges in $\mathcal{D}$.

If $A$ is an arena and $q$ is a move in $A$ then we write $A_q$ to
denote the subarena of $A$ rooted at $q$.

\begin{definition}[Relation between the arena and the computation tree]
\label{def:phi_procedure}
We consider the computation tree of a simply-typed-term.
For any arena $A$, we define a function $f_A(n,q)$ taking two parameters:
a node $n$ of the computation tree and a question move $q$ of the arena $A$
such that $q$ and $n$ have the same type.
$f_A(n,q)$ returns a partial function from $V$ to $A$. It is defined as follows:
\noindent
\begin{itemize}
\item[case 1] If $n$ is an order $0$ $\lambda$-node (i.e. labelled $\lambda$) or a ground type variable node then
        $$f_A(n,q) = \{ n \mapsto q \} \quad \union \quad  \{ v_n \mapsto v_q \ | \ v \in \mathcal{D} \}$$

\item[case 2] If $n$ is a $\lambda$-node labelled $\lambda \overline{\xi} = \lambda \xi_1 \ldots \xi_p$ with $p\geq 1$ then
    the computation tree and the arena $A_q$ have the following form
    (value-leaves and answer moves are not represented for simplicity):
    $$ \tree[levelsep=6ex]{ \Rnode{r}\lambda \overline{\xi}  ^{[n]}}
        {
            \tree[levelsep=6ex]{\alpha}
            {   \TR{\ldots} \TR{\ldots} \TR{\ldots}
            }
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^p}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    For each of the abstracted variable $\xi_i$ there exists a corresponding question move $q^i$ of the same order
    in the arena.  $f_A(n,q)$ maps each free occurrence of a variable $\xi_i$ to the corresponding move $q^i$:
    $$
    f_A(n,q) =  \{ n \mapsto q \} \quad  \union \quad  \{ v_n \mapsto v_q \ | \ v \in \mathcal{D} \}
                      \quad \union \quad  \Union_{\stackrel{\displaystyle m \in N | n \vdash m}{\displaystyle m \mbox{ labelled } \xi_i}} f_A( m, q^i)
    $$

\item[case 3] If $n$ is a variable node labelled with a higher-order variable $x$ of type $(A_1|\ldots|A_m|o)$ then the computation tree and the arena $A_q$
have the following form:
    $$\tree[levelsep=6ex]{\Rnode{r}{x^{[n]}}}
        {   \tree{\TR{\lambda \overline{\eta}_1}}{\vdots} \TR{\ldots}
        \tree{\TR{\lambda \overline{\eta}_m }}{\vdots}
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{\Rnode{q1}{q^1}}{\TR{} \TR{} }
            \tree[linestyle=dotted]{\Rnode{q2}{q^2}}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{\Rnode{qm}{q^m}}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    $f_A(n,q)$ maps each child node of $n$ to the corresponding question move $q^i$ of the same type
    in the arena $A_q$:
    $$f_A(n,q) =
         \{ n \mapsto q \} \quad \union\quad \{ v_n \mapsto v_q \ | \ v \in \mathcal{D}   \} \quad\union\quad     \Union_{i=1..m} f_A( \lambda \overline{\eta}_i, q^i)
    $$
\end{itemize}

Note that $f_A(n,q)$ is only a partial function from $V$ to $A$ since it is defined only
on nodes that are hereditarily justified by the root \emph{and} not hereditarily justified by a free variable node.
In other words, $f_A(n,q)$ is undefined on nodes that are hereditarily justified by $N_{fv} \union N_@ \union N_\Sigma$.
\end{definition}

Suppose $\Gamma \vdash M  : T$ is a simply-typed term and $N$ denotes the set of nodes of the computation tree.
We write $\mathcal{M}_M$ to denote the following disjoint union of arenas:
$$\mathcal{M}_M = \sem{\Gamma \rightarrow T} \quad \uplus \quad  \biguplus_{n \in E_n \relimg{N_@ \union N_\Sigma} } \sem{type(\kappa(n))}.$$

Moves in $\mathcal{M}_M$ are implicitly tagged so it is possible to recover the arena in which they belong.


\begin{definition}[Total mapping from nodes to moves]
Let $\Gamma \vdash M : T$ be a simply-typed term
with $\Gamma = x_1:X_1 \ldots x_p : X_p$.
We write $q_{\sem{\Gamma}}^1$, \ldots, $q_{\sem{\Gamma}}^p$ to denote the initial question moves of the
component $\Gamma$ of the arena $\sem{\Gamma \rightarrow T}$ and $q^0_A$ to denote the single initial question of any arena $A$
(arenas involved in the game semantics of pure simply-typed $\lambda$-calculus have only one root).
$r$ denotes the root of the computation tree.

We define the total function $\varphi_M : V_\lambda \union V_{var} \rightarrow \mathcal{M}_M$ as follows:
\begin{align*}
\varphi_M =
        f_{\sem{\Gamma \rightarrow T}}(r, q^0_{\sem{\Gamma \rightarrow T}}) \quad
    & \union \quad
    \Union_{n \in N_{fv} | n \mbox{ {\small labelled} } x_i }  f_{\sem{\Gamma \rightarrow T}}(n, q^i_{\sem{\Gamma}} ) \\
    & \union \quad
        \Union_{n \in E_n \relimg{N_@ \union N_\Sigma}}  f_{\sem{type(\kappa(n))}}(n, q^0_{\sem{type(\kappa(n))}} )
\end{align*}
When there is no ambiguity we just write $\varphi$ instead of $\varphi_M$.
\end{definition}

Nodes of $\tau(M)$ are either hereditarily justified by the root, by
a @-node or by a $\Sigma$-node, therefore $\varphi_M$ is totally
defined on $V_\lambda \union V_{var} = V\setminus (V_@ \union
V_\Sigma)$.

\begin{example}
Consider the term $\lambda x . (\lambda g . g x) (\lambda y . y)$ with $x,y:o$ and $g:(o,o)$.
The diagram below represents the computation tree (middle), the arenas
$\sem{(o,o)\rightarrow o}$ (left), $\sem{o \rightarrow o}$ (right), $\sem{o\rightarrow o}$ (rightmost)
and the function $\varphi = f(\lambda x, q_{\lambda x}) \union f(\lambda g, q_{\lambda g}) \union f(\lambda y, q_{\lambda y})$
(dashed-lines).
$$
\psset{levelsep=4ex}
\pstree{\TR[name=root]{\lambda x}}
{
    \pstree{\TR[name=App]{@}}
    {
            \pstree{\TR[name=lg]{\lambda g}}
                { \pstree{\TR[name=lgg]{g}}{
                        \pstree{\TR[name=lgg1]{\lambda}}
                        { \TR[name=lgg1x]{x}  } } }
            \pstree{\TR[name=ly]{\lambda y}}
                    {\TR[name=lyy]{y}}
    }
}
\rput(5cm,-1cm){
  \pstree{\TR[name=A1lx]{q_{\lambda x}}}
        { \TR[name=A1x]{q_x} }
}
\rput(-6cm,-1.5cm){
    \pstree{\TR[name=A2lg]{q_{\lambda g}}}
    {
        \pstree{\TR[name=A2g]{q_g}}
        {  \TR[name=A2g1]{q_{g_1}}   }
    }}
\rput(2.5cm,-1.5cm){
    \pstree{\TR[name=A3ly]{q_{\lambda y}}}
        { \TR[name=A3y]{q_y}
        }
}
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{A1lx} \mput*{f(\lambda x, q_{\lambda x})}
\ncarc{->}{lgg1x}{A1x}
\ncline{->}{lg}{A2lg} \mput*{f(\lambda g, q_{\lambda g})}
\ncline{->}{lgg}{A2g}
\ncline{->}{lgg1}{A2g1}
\ncline{->}{ly}{A3ly} \mput*{f(\lambda y, q_{\lambda y})}
\ncline{->}{lyy}{A3y}
$$
\end{example}

The following properties are immediate consequences of the definition of the procedure $f$:
\begin{property} \
\label{proper:phi_conserve_order}
\begin{itemize}
\item[(i)] $\varphi$ maps $\lambda$-nodes to O-questions, variable nodes to
P-questions, value-leaves of $\lambda$-nodes to P-answers and
value-leaves of variable nodes to O-answers;
\item[(ii)] $\varphi$ maps nodes of a given order to moves of the same order.
\end{itemize}
\end{property}
By extension, the function $\varphi$ is also defined on justified
sequences of nodes: if $t = t_0 t_1 \ldots$ is a justified sequence
of nodes in $V_\lambda \union V_{var}$ then $\varphi(t)$ is defined
to be the following sequence of moves:
$$\varphi(t) = \varphi(t_0)\ \varphi(t_1)\  \varphi(t_2) \ldots$$
where the pointers of $\varphi(t)$ are defined to be exactly those
of $t$.

\begin{property}
\label{proper:phi_pview} Let $t$ be a justified sequence of nodes. The following properties hold:
\begin{itemize}
\item[(ii)] the P-view of $\varphi(t)$ and the P-view of $t$ are computed
identically: the set of indices of elements that must be removed
from both sequences in order to obtain their P-view is the same;
\end{itemize}
where $?(\varphi(t))$ denotes the set of unanswered questions in the
justified sequence of moves $\varphi(t)$ and $?(t)$ denotes the set
of unmatched nodes in the justified sequence of nodes $t$ (see the
definition in section \ref{sec:adding_value_leaves}).
\end{property}


\subsection{Interaction game semantics}
\label{sec:interaction_semantics}

In game semantics, strategy composition is achieved by performing a
CSP-like ``composition + hiding''. It is possible to define an
alternative semantics where the internal moves are not hidden when
performing composition. This semantics is named \emph{interaction}
semantics in \cite{DBLP:conf/sas/DimovskiGL05} and \emph{revealed
semantics} in \cite{willgreenlandthesis}.

Since in the interaction semantics internal moves of the computation are preserved, the denotation of a term depends on its 
syntactical structure. Consequently the model is not fully abstract. However this semantics will prove to be useful to identify
a correspondence between the game semantics of a term and the traversals of its computation tree.

A play of the interaction semantics, called an \emph{uncovered play}, is a play containing internal moves.
The moves are implicitly tagged so that it is possible to retrieve in which component
of which arenas the move belongs to. Note that a same move can belong to different arenas.

A \emph{revealed strategy} is a composition of several standard strategies where
certain internal moves are not hidden. It can be formally defined as a set
of uncovered plays.

We define a revealed strategy using an expression involving the usual operators found in the standard game semantics (promotion, abstraction
tensor product, pairing, composition) with the addition of a family of special operators called \emph{uncovered-composition} written 
$;^U$ for some set of indices $U$ and defined as follows.
Let $\sigma : A \multimap B_0 \times \ldots \times B_l$ and $\mu : B_0 \times
\ldots \times B_l \multimap C$ be two interaction strategies.
The uncovered-composition of $\sigma$ and $\mu$, written $\sigma ;^U \mu$ for some $U$, is defined as
the set of uncovered plays obtained by performing the usual composition of $\sigma$ and $\mu$
while ignoring and copying the internal moves from arenas in
$\sem{A \multimap B_0 \times \ldots \times B_l}$ and $\sem{B_0 \times
\ldots \times B_l \multimap C}$ and preserving internal
moves produced by the composition that are played in some component $B_k$ for $k \in U$.

There may be several revealed strategies denoting a term $M$ depending on the internal nodes that we wish to hide when
composing the constituting subterms of $M$. We now fix a unique revealed strategy computed from the $\eta$-normal
form of a term.

\begin{definition}[Revealed denotation of a term]
\label{dfn:interactionstrategy_ofterms}
The \emph{revealed game denotation of $M$} or \emph{revealed
strategy of $M$} written $\intersem{\Gamma \vdash M : A}$ is the
revealed strategy defined by structural induction on the computation
tree $\tau(M)$ as follows:

Let $\overline{\xi} = \xi_1 : Y_1, \ldots \xi_n : Y_n$.
Let $z$ be a variable ranging in $\Gamma \union \overline{\xi}$. If $z\in \Gamma$ then $\pi_{z}$ denotes
the $i^{th}$ projection copycat strategy $\pi_i : \sem{\Gamma \union \overline{\xi}} \rightarrow \sem{X_i}$. If $z = \xi_j$ then
$\pi_{z}$ denotes the $(n+j)^{th}$ projection $\pi_{n+j} : \sem{\Gamma \union \overline{\xi}} \rightarrow \sem{Y_j}$.
\begin{eqnarray*}
 \intersem{\Gamma \vdash \lambda \overline{\xi} . z } &=& \Lambda^n(\pi_{z})  \\
 \intersem{\Gamma \vdash \lambda \overline{\xi} . z N_1 \ldots N_p} &=& \Lambda^n(\langle \pi_z, \intersem{\Gamma \vdash N_1 : A_1}, \ldots, \intersem{\Gamma \vdash N_p : A_p}  \rangle \fatsemi ^{1..p} ev^p) \\
\intersem{\Gamma \vdash \lambda \overline{\xi}. f N_1 \ldots N_p} &=& \langle \intersem{\Gamma \vdash N_1}, \ldots, \intersem{\Gamma \vdash N_p} \rangle \fatsemi^{0..p-1} \sem{f} \\
 \intersem{\Gamma \vdash \lambda \overline{\xi} . N_0 \ldots N_p} &=& \Lambda^n(\langle \intersem{\Gamma \vdash N_0 : A_0}, \ldots, \intersem{\Gamma \vdash N_p : A_p}  \rangle \fatsemi^{0..p} ev^p)
\end{eqnarray*}
where $\Gamma \vdash N_0 : (A_1,\ldots,A_p,B)$, $\Gamma \vdash z : (A_1,\ldots,A_p,B)$, $\Gamma \vdash N_k : A_k$ for $k\in 1..p$,
$f : (A_1,\ldots,A_p,B) \in \Sigma$ and $ev^p$ denotes the evaluation strategy with $p$ parameters.
\end{definition}
Note that we only keep the internal
moves that are produced when composing two subterms of the computation tree that are joined by an @-node.
This means that when computing the strategy of
$y N_1 \ldots N_p$ where $y$ is a variable, we keep the internal moves of $N_1$, \ldots, $N_p$, but
we omit the internal moves produced by the copy-cat projection strategy denoting $y$.



\begin{example}
Consider the term $\lambda x . (\lambda f . f x) (\lambda y . y)$ in $\eta$-long normal form.
Its revealed strategy is $\langle \sem{ x:X \vdash \lambda f . f
x} , \sem{ x:X \vdash \lambda y . y} \rangle \fatsemi^{\{0,1\}} ev_2$.
\end{example}


\subsubsection{From interaction semantics to standard semantics and vice-versa}

In the standard semantics, given two strategies $\sigma : A \rightarrow B$, $\tau : B \rightarrow C$ and
a sequence $s \in \sigma \fatsemi \tau$, it is possible to (uniquely) recover the internal moves. The uncovered sequence is written
${\bf u}(s, \sigma, \tau)$. The algorithm to obtain this unique uncovering is given in part II of \cite{hylandong_pcf}.
Given a term $M$, we can completely uncover the internal moves of a
sequence $s\in\sem{M}$ by performing the uncovering recursively at
every @-node of the computation tree. This operation is called
\emph{full-uncovering with respect to $M$}.

Conversely, the standard semantics can be recovered from the
interaction semantics by filtering out the internal moves.


\subsection{The correspondence theorem for the pure simply-typed $\lambda$-calculus}
In this section, we establish a
connection between the interaction semantics of a simply-typed term without constants ($\Sigma = \emptyset$)
and the traversals of its computation tree.

\subsubsection{Removing @-nodes from traversals}

It was necessary to introduce application nodes (labelled @) in order to connect the operator and
the operand of an application in the computation tree. The presence of @-nodes has also
another advantage: it ensures that the lambda-nodes are all at even
level in the computation tree so that traversals respect Alternation.

However, application nodes do not play any role in the computation of the term, and therefore
they can be removed from the traversals. In fact it is
necessary to filter them out in order to establish the
correspondence with the interaction semantics.

\begin{definition}[Filtering @-nodes in traversals]
\label{dfn:appnode_filter}
Let $t$ be a traversal of $\tau(M)$.
We write $t-@$ for the sequence of nodes with pointers obtained by
\begin{itemize}
\item removing from $t$ all @-nodes and value-leaves of a @-node;
\item replacing any link pointing to an @-node by a link pointing to the immediate predecessor of @ in $t$.
\end{itemize}

Suppose $u = t-@$ is a sequence of nodes obtained by applying the
previously defined transformation on the traversal $t$, then $t$ can
be partially recovered from $u$ by reinserting the @-nodes as
follows. For each @-node @ in the computation tree with parent node
denoted by $p$, we perform the following operations:
\begin{enumerate}
\item replace every occurrence of the pattern $p \cdot n$, where $n$ is a $\lambda$-nodes,
by $p \cdot @ \cdot n$;
\item replace any link in $u$ starting from a $\lambda$-node and pointing to $p$ by a link pointing to the inserted @-node;
\item if there is an occurrence in $u$ of a value-leaf $v_p$ pointing to $p$ then insert a value-leaf $v_@$
immediately before $v_p$ and make it points to the node immediately
following $p$ (which is also the $@$-node that we inserted in 1).
\end{enumerate}
We write $u+@$ for this second transformation.
\end{definition}
These transformations are well-defined although $t-@$ is not necessarily a proper justified sequence of nodes.

\begin{lemma}
\label{lem:minus_at_plus_at}
For any traversal $t$ we have $(t-@)+@ \sqsubseteq t$ and if $t$ does not end with an @-node then
$(t-@)+@ = t$.
\end{lemma}

Let $M$ be a term and $r$ be the root of $\tau(M)$. We introduce the following notations:
\begin{eqnarray*}
\travset(M)^{-@} &=& \{ t - @ \ | \  t \in \travset(M) \} \\
\travset(M)^{\upharpoonright r} &=& \{ t  \upharpoonright r \ | \  t  \in \travset(M) \} .
\end{eqnarray*}

The computation tree of a $\beta$-normal
term does not contain any @-node and therefore all the nodes are
hereditarily justified by the root. Therefore if $M$ is a $\beta$-normal term 
then $t = t \upharpoonright r = t - @$ for any $t \in \travset(M)$. 
Hence we have the following lemma:
\begin{lemma}
Let $M$ be a pure simply-typed $\beta$-normal term and $r$ be the root of $\tau(M)$. We have:
$$\travset(M)^{-@} \cong \travset(M) \cong  \travset(M)^{\upharpoonright r } \ .$$
\end{lemma}

\subsubsection{The correspondence theorem}
We state the correspondence theorem for the pure simply-typed $\lambda$-calculus without constants ($\Sigma = \emptyset$).
The result extends immediately to the simply-typed $\lambda$-calculus with \emph{uninterpreted} constants by
considering constants as being free variables.
We use the cartesian closed category of games as a model of the simply-typed $\lambda$-calculus. We write $\sem{\Gamma \vdash M : A}$ for the strategy denoting the simply-typed term $\Gamma \vdash M : A$.
\begin{proposition}
\label{prop:rel_gamesem_trav} Let $\Gamma \vdash M : T$ be a term of
the pure simply-typed $\lambda$-calculus and $r$ be the root of
$\tau(M)$. We have:
\begin{itemize}
\item[(i)]  $\varphi_M(\travset(M)^{-@}) = \intersem{M}$
\item[(ii)] $\varphi_M(\travset(M)^{\upharpoonright r}) = \sem{M}$.
\end{itemize}
\end{proposition}


\begin{remark} Let us give the intuition of the proof.
    We start by reducing the problem to the case of closed terms only. Then the proof proceeds by induction on the structure of the computation tree.
    It is straightforward to prove the result for term that are abstraction of a single variable.
    Now consider an application $M$ with the following computation tree $\tau(M)$:
    $$ \tree[levelsep=4ex]{\lambda \overline{\xi}}
        { \tree[levelsep=4ex]{@}
            {   \TR{\tau(N_0)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$

    A traversal of $\tau(M)$ proceeds as follows: it starts at the root $\lambda \overline{\xi}$ of the tree $\tau(M)$ (rule
    (Root)), it then passes the node @ (rule (Lam)).
    After this initialization part, it proceeds by traversing the term $N_0$ (rule (App)).
    At some point, while traversing $N_0$, some variable $y_i$ bound by the root of $N_0$ is visited. The traversal
    of $N_0$ is interrupted and there is a jump (rule (Var)) to the root of $\tau(N_i)$. The process goes on by traversing $\tau(N_i)$.
    When traversing $N_i$, if the traversal encounters a variable bound by the root of $\tau(N_i)$ then the traversal of $N_i$ is interrupted and
    the traversal of $N_0$ resumes.  This schema is repeated until the traversal of $\tau(N_0)$ is completed\footnote{Since we are considering
    simply-typed terms, the traversal does indeed terminate. However this will not be true anymore in the \pcf\ case.}.

    The traversal of $M$ is therefore made of an initialization part followed by an interleaving of a traversal of $N_0$ and
    several traversals of $N_i$ for $i=1..p$. This schema is reminiscent of the way the evaluation copycat map $ev$ works in game semantics.

    The key idea is that every time the traversal pauses the traversal of a subterm and switches to another one,
    the jump is permitted by one of the four copycat rules (Var), (CCAnswer-@), (CCAnswer-$\lambda$) or (CCAnswer-var).
    We show by (a second) induction that these copycat rules defines exactly what the copycat strategy $ev$ performs on sets of moves.

%    In the game semantics, the evaluation map (a copy-cat strategy) copies this opening move to an initial move $m_0$ in the game
%    $B_0$ and the game continues in $B_0$. We reflect this in the traversal : we make $t$ follow
%    the ``script'' given by the traversal $t^0_{m_0}$.
%    The rule (App) allow us to initiate this simulation  by visiting the  first move in $t^0_{m_0}$: the root of $\tau(N_0)$.
%
%    This simulation continues until it reaches a node $\alpha_0$ which is hereditarily justified by the root
%    $\tau(N_0)$: $\alpha_0$ is present in the reduction of traversal of $t^0_{m_0}$ therefore $\varphi_{N_0}(\alpha_0)$ is an un-hidden move played in $A_0$.
%
%    In the game semantics this corresponds to a move played in a component $A_k$ for some $k\in 1..p$ of
%    of the game $B_0$ in which case the evaluation map copies the move to an initial move $m_1$ in the corresponding component $B_k$.
%
%    To reflect this the traversal now opens up a new thread and simulates the traversal $t^k_{m_1}$.  Again, this simulation stops when we reach a node
%    $\alpha_1$ in $t^k_{m_1}$ which is hereditarily justified by the root of $\tau(N_k)$: $\alpha_1$ must be present in the reduction of traversal
%    of $t^k_{m_1}$ therefore $\varphi_{N_k}(\alpha_1)$ is an un-hidden move played in $A_k$.
%    In the game semantics, this move $\alpha$ is copied back to the component $B_k$ of the game $B_0$.
%
%    The traversal now resumes the simulation of $t^0_{m_0}$. And the process goes continuously.
\end{remark}

The following theorem establishes a correspondence between the game-denotation of a
term and the set of traversals of its computation tree:

\begin{theorem}[The Correspondence Theorem]
\label{thm:correspondence}
 For any pure simply-typed term $\Gamma \vdash M$,
$\varphi_M$ defines a bijection from $\travset(M)^{\upharpoonright
r}$ to $\sem{M}$ and a bijection from $\travset(M)^{-@}$ to
$\intersem{M}$:
\begin{eqnarray*}
 \varphi_M  &:& \travset(\Gamma \vdash M)^{\upharpoonright r} \stackrel{\cong}{\longrightarrow} \sem{\Gamma \vdash M} \\
 \varphi_M  &:& \travset(\Gamma \vdash M)^{-@} \stackrel{\cong}{\longrightarrow} \intersem{\Gamma \vdash M}
\end{eqnarray*}

Moreover if $M$ is in $\beta$-normal form and $s$ is a
\emph{maximal} play then  $t$ is a \emph{maximal} traversal.
\end{theorem}

The following diagram recapitulates the main results of this section:
$$
\xymatrix @C=6pc{
                                           & \travset(M)^{-@} \ar@/_/[dl]_{+@}  \ar[r]^{\varphi_M}_\cong & \intersem{M} \ar@/_/[dd]_{\_ \upharpoonright \sem{\Gamma\rightarrow T}} \\
\travset(M) \ar@/_/[ur]_{-@}^{} \ar[dr]^{\_ \upharpoonright r}  \\
                                           & \travset(M)^{\upharpoonright r} \ar[r]^{\varphi_M}_\cong & \sem{M} \ar@/_/[uu]^{\cong}_{\mbox{full uncovering}}
}
$$




\section{Game-semantic characterisation of safety}

Safety has been defined as a syntactical constraint. Since Game
Semantics is by essence syntax-independent, it seems difficult at
first sight to characterise Safety in a game-semantic manner.
However, with the help of the tools developed in the previous
chapter and using the Correspondence Theorem, we can interpret plays
of a strategy as sequences of nodes of some AST of the term.
Therefore it is now possible to investigate the impact of the Safety
restriction on Game Semantics.


The main theorem of this section (theorem
\ref{thm:safe_ptr_recoverable}) states that pointers in a play of
the strategy denotation of a safe term can be uniquely recovered
from the underlying sequence of moves. The proof is in several
steps. We start by introducing the notion of
\emph{incrementally-justified strategies} and prove that for plays
of such strategies, pointers can be reconstructed uniquely from the
underlying sequences of moves. We then introduce the notion of
\emph{incrementally-bound computation trees} and prove that
incremental-binding coincides with incremental-justification
(proposition \ref{prop:incrbound_imp_incrjustified}). Finally, we
show that safe simply-typed terms in $\beta$-normal form have
incrementally-bound computation trees, consequently the pointers in
their game denotation are superfluous.


The first section of this chapter is concerned only with the pure
Safe $\lambda$-Calculus without interpreted constants. In the next
section we extend the result by taking into account the interpreted
constants of \pcf\ and \ialgol. We define the language Safe \ialgol\
(resp. Safe \pcf) to be the fragment of \ialgol\ (resp. \pcf) where
the application and abstraction rules are constrained the same way
as in the Safe $\lambda$-Calculus. We show that Safe \pcf\ terms are
denoted by incrementally-justified strategies and we give the key
elements for a possible extension of the result to Safe Idealized
Algol.

\section{Safe $\lambda$-Calculus}
We now consider the Safe $\lambda$-Calculus without interpreted
constants. Our aim is to prove that pointers in the game semantics
of safe terms can be uniquely recovered.

\begin{definition}[Incrementally-justified strategy]
A strategy $\sigma : A$ is said to be \emph{incrementally-justified}
if for any sequence of moves $s q \in P_A$ where $q$ is a question
move in $M_A$ we have:
\begin{eqnarray*}
s q \in \sigma \wedge |s| \mbox{ even } &\implies& \parbox[t]{8cm}{$q$ points to the last P-move in $\oview{?(s)}$ with order strictly greater than $\ord{q}$;} \\
s q \in \sigma \wedge |s| \mbox{ odd } &\implies&
\parbox[t]{8cm}{$q$  points to the last O-move in $\pview{?(s)}$
with order strictly greater than $\ord{q}$.}
\end{eqnarray*}
\end{definition}

\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} Pointers are
superfluous for incrementally-justified strategies.
\end{lemma}

\begin{example}
The denotation of the evaluation map $ev$ is not
incrementally-justified. Indeed consider the play $s = q_0 q_1 q_2
q_3 \in \sem{ev}$ shown on the diagram below:
$$\begin{array}{cccccccc}
(A & \implies & B) & \times  & A & \stackrel{ev}{\longrightarrow} & B \\
&&&&&& q_0 \\
&& q_1 \\
 q_2 \\
 &&&&q_3
\end{array}$$
The order of the moves are as follows:  $\ord{q_3} = \ord{A}$,
$\ord{q_2} = \ord{A}$, $\ord{q_1} = \max( 1+\ord{A}, \ord{B})$ and
$\ord{q_0} = 1 + \ord{q_1}$. The last O-move in $?(\pview{s})= s$
with order strictly greater than $\ord{q_3}$ is $q_1$.
 But since $q_3$ points to $q_0$, $\sem{ev}$ is not incrementally-justified.
\end{example}


In a computation tree a binder node always occurs in the path from
the bound node to the root. We now introduce a class of computation
tree in which binder nodes can be uniquely recovered from the order
of the nodes. We write $[n_1,n_2]$ to denote the path from node
$n_1$ to node $n_2$ if it exists and $]n_1,n_2]$ for the sequence of
nodes obtained by removing $n_1$ from $[n_1,n_2]$.

\begin{definition}[Incrementally-bound computation tree]
A variable node $x$ of a computation tree is said to be
\emph{incrementally-bound} if either:
\begin{enumerate}
\item $x$ is \emph{bound} by the first $\lambda$-node in the path to the root that has
order strictly greater than $\ord{x}$. Formally:
\begin{align*}
 x \mbox{ bound by } n \quad \imp & \quad n \in [r,x] \wedge \ord{n} > \ord{x} \\
                                  & \wedge \forall \lambda\mbox{-node } n' \in ]n,x] . \ord{n'} \leq \ord{x} \ ;
\end{align*}

\item $x$ is a \emph{free variable} and all the $\lambda$-nodes in the path to the root except the root have order
smaller or equal to $\ord{x}$. Formally:
$$ x \mbox{ free } \quad \imp \quad  \forall \lambda\mbox{-node } n' \in ]r,x] . \ord{n'} \leq \ord{x}$$
\end{enumerate}
where $r$ denotes the root of the computation tree.

A computation tree is said to be \emph{incrementally-bound} if all
the variable nodes are incrementally-bound.
\end{definition}

\begin{proposition}[Incremental-binding coincides with incremental-justification] \
\label{prop:incrbound_imp_incrjustified}
\begin{enumerate}
\item[(i)] A term in $\beta$-normal form with an incrementally-bound computation tree is denoted by an incrementally-justified strategy.
\item[(ii)] Reciprocally, in the pure $\lambda$-calculus ($\Sigma=\emptyset$), if a term is denoted by an incrementally-justified strategy then the computation tree of its $\beta$-normal is incrementally-bound.
\end{enumerate}
\end{proposition}

\begin{proof}
Let $\Gamma \vdash M : A$ be a simply-typed term in $\beta$-normal
form and $r$ denotes the root of $\tau(M)$.

\noindent (i) Suppose that $\tau(M)$ is incrementally-bound.
Consider a justified sequence of move $s \in \sem{\Gamma \vdash M}$
ending with a question move $q$ (note that $q$ is also the last
question in $?(s)$). By proposition \ref{prop:rel_gamesem_trav},
there is a traversal $t$ of $\tau(M)$ such that $\varphi_{M}(t
\upharpoonright r) = s$. We assume that the last node $n$ of $t$ is
hereditarily justified by $r$ (otherwise we replace $t$ by its
longest prefix verifying this condition). Then $n$ is also the last
node in $?(t \upharpoonright r)$ and $t \upharpoonright r$.

\begin{itemize}
\item If $|s|$ is even then $q$ is a P-move:
\begin{itemize}
\item Suppose that $n$ is a variable node $x$ bound by a node $m$ occurring in $t$.
Since $M$ is in $\beta$-normal form, lemma \ref{lem:redtrav_trav}(i)
gives: $ \pview{?(t \upharpoonright r)} = \pview{?(t)}
\upharpoonright  r$. By proposition \ref{prop:pviewtrav_is_path},
$\pview{?(t)} = [r,n]$ and because $\tau(M)$ is incrementally-bound,
$m$ is the last $\lambda$-node in $[r,n]$ of order strictly greater
than $\ord{n}$. Since $n$ is hereditarily justified by the root, so
is $m$ and therefore $m$ occurs in $\pview{?(t \upharpoonright r)}$.
But $\pview{?(t \upharpoonright r)}$ is a subsequence of
$\pview{?(t)}$ therefore $m$ is also the last $\lambda$-node in
$\pview{?(t \upharpoonright  r)}$ that has order strictly greater
than $\ord{n}$.

By property \ref{proper:phi_pview} (ii), the P-view of $?(s)$ and
the P-view of $?(t \upharpoonright r)$ are computed similarly and
have the same pointers. This means that node $n$ and  move $q$ both
point to the same position in the justified sequence
$\pview{?(t\upharpoonright r)}$ and $\pview{?(s)}$ respectively.

Finally, since $\varphi$ maps nodes of a given order to moves of the
same order (property \ref{proper:phi_conserve_order}), $q$ must
point to the last O-move in $\pview{?(s)}$ whose order is strictly
greater than $\ord{q}$.


\item If $n$ is a free variable node $x$ then $n$ is enabled by the root which is the first node in $t$.
By definition of $\varphi$, $\varphi(n) = x$ must be a move enabled
by the initial move $q_0 = \varphi(r)$ in the arena $\sem{\Gamma
\rightarrow A}$. Therefore $\ord{q_0} > \ord{x}$. Since the
computation tree is incrementally-bound, all the $\lambda$-nodes in
$]r,n]$ have order smaller than $\ord{n}$. Therefore by the
correspondence theorem, all the O-moves in $\pview{?(s)}$ have order
smaller than $\ord{x}$.
\end{itemize}



\item If $|s|$ is odd then $q$ is an O-move:

$M$ is in $\beta$-normal form and $t$ is a traversal of $\tau(M)$
whose last node $n$ is hereditarily justified by $r$. Therefore by
lemma \ref{lem:redtrav_trav} (ii), $ \oview{?(t \upharpoonright r)}
= \oview{?(t)}$.

A lambda-node always points to its parent node in the computation
tree. For terms in $\beta$-normal form, this parent node must be a
variable node of order strictly greater than $\ord{n}$.

By inspecting the formation rules for traversals (definition
\ref{def:traversal}) we remark that a lambda-node occurring in a
traversal always points to the last node with order strictly greater
that $\ord{n}$ in the O-view of the sequence of unmatched nodes at
that point (there are just two cases, $n$ points either to the
preceding node or to the third previous node in $\oview{?(t)}$).

Similarly, as in the P-move case, we conclude that $q$ points to the
last question move in $\oview{?(s)}$ of order strictly greater than
$\ord{q}$.
\end{itemize}

\noindent (ii) Suppose that $M$ is $\beta$-normal and the strategy
$\sem{M}$ is incrementally-justified. Let $x$ be a variable node of
$\tau(M)$. Since $M$ is $\beta$-normal, by lemma
\ref{lem:betaeta_trav}, $x$ is either hereditarily justified by the
root $r$ or by a constant in $N_\Sigma$. In the pure simply-typed
$\lambda$-calculus we have $\Sigma=\emptyset$, therefore $x$ is
hereditarily justified by $r$.


We remark that for terms in $\beta$-normal form, every variable node
occurring in the computation tree can be visited by some traversal
i.e. there exists a traversal of the form $t \cdot x$ in
$\travset(M)$. The correspondence theorem gives $\varphi((t \cdot x)
\upharpoonright r) = \varphi((t \upharpoonright r) \cdot x) \in
\sem{M}$. Since $\sem{M}$ is incrementally-justified, $\varphi(x)$
must point to the last move in $\pview{?(\varphi(t \upharpoonright
r))}$ with order strictly greater than $\ord{\varphi(x)}$.
Consequently $x$ points to the last node in $\pview{?(t
\upharpoonright r)}$ with order strictly greater than $\ord{x}$. We
have:
\begin{align*}
\pview{?(t \upharpoonright r)} &= \pview{?(t) \upharpoonright r} = \pview{?(t)} \upharpoonright r & (\mbox{by lemma \ref{lem:redtrav_trav}}) \\
& = \pview{?(t)} & (\mbox{$M$ is a $\beta$-nf and $N_\Sigma = \emptyset$}) \\
& = [r,x[ & (\mbox{by proposition \ref{prop:pviewtrav_is_path}}).
\end{align*}
Therefore if $x$ is a bound variable node then it is bound by the
last $\lambda$-node in $[r,x[$ with order strictly greater than
$\ord{x}$ and if $x$ is a free variable then it points to $r$ and
therefore all the $\lambda$-node in $]r,x[$ have order smaller than
$\ord{x}$. Hence $\tau(M)$ is incrementally-bound.
\end{proof}


\parpic[r]{
    \psset{levelsep=4ex}
    \pstree{\TR{$\lambda x^3$}}{\pstree{\TR{$f^2$}}{ \pstree{\TR{$\lambda y^1$}}{ \TR{$x^0$} }}}
}

\begin{example}
Consider the $\beta$-normal term $\lambda
x . f (\lambda y .x)$ where $x,y:o$ and $f:(o,o),o$. The figure on
the right represents the computation tree with the order of each
node in the exponent part. Since node $x$ of order $0$ is not bound
by the order 1 node $\lambda y$, $\tau(M)$ is not
incrementally-bound and by proposition
\ref{prop:incrbound_imp_incrjustified} $\sem{\lambda x . f (\lambda
y .x)}$ is not incrementally-justified. Similarly we can check that
the denotation of $f (\lambda y .x)$ is not incrementally-justified
whereas $\lambda y. x$ has an incrementally-justified denotation.
Also for any higher-order variable $x:A$, the computation tree
$\tau(x)$ is incrementally-bound, therefore the projection
strategies $\pi_i$ are incrementally-justified. From these examples
we observe that application does not preserve
incremental-justification: $\sem{f}$ and $\sem{\lambda y. x}$ are
incrementally-justified whereas $\sem{f (\lambda y .x)}$ is not.
\end{example}

\begin{example}
In order to distinguish the terms $M_1 = \lambda f . f
(\lambda x . f (\lambda y .y ))$ and $M_2 = \lambda f . f (\lambda x
. f (\lambda y .x ))$ we have to keep the pointers in the plays of
strategies. However, if we limit ourselves to the safe
$\lambda$-Calculus then the ambiguity disappears because $M_1$ is
safe whereas $M_2$ is not (in the subterm $f (\lambda y . x)$, the
free variable $x$ has the same order as $y$ but $x$ is not
abstracted together with $y$).
\end{example}



\begin{lemma}[Safe terms have incrementally-bound computation trees]
\label{lem:safe_imp_incrbound} Let $\Gamma \vdash M$ be a
simply-typed term.
\begin{itemize}
\item[(i)] If $M$ is a safe term then $\tau(M)$ is incrementally-bound ;
\item[(ii)] reciprocally, if $M$ is \emph{closed} and $\tau(M)$ is incrementally-bound then the $\eta$-normal form of $M$ is safe.
\end{itemize}
\end{lemma}
\begin{proof}
(i) Suppose that $M$ is safe. The safety property is preserved after
taking the $\eta$-normal form, therefore $\etanf{M}$ is also safe.
Hence $\tau(M)$ is the tree representation of a safe term.

When applying the abstraction rule in the Safe $\lambda$-Calculus,
the variables in the lowest partition (smallest order) of the
context must all be abstracted together. Moreover in the computation
tree, consecutive abstractions are merged into a single node,
therefore the safety of $\etanf{M}$ implies that for each
$\lambda$-node $\lambda \overline{\xi}$, any variable $x$ occurring
free in $\kappa(\lambda \overline{\xi})$ has order greater or equal
to $\ord{\lambda \overline{\xi}}$. Reciprocally, if a lambda node
$\lambda \overline{\xi}$ binds a variable node $x$ then
$\ord{\lambda \overline{\xi}} = 1+\max_{z\in\overline{\xi}} \ord{z}
> \ord{x}$.

Let $x$ be a bound variable node. In a computation tree, a binder
node always occurs in the path from the bound node to the root,
therefore, according to the previous observation, $x$ must be bound
by the first $\lambda$-node occurring in $[r,x]$ with order strictly
greater than $\ord{x}$. Similarly, let $x$ be a free variable node
in $\tau$ then $x$ is not bound by any of the $\lambda$-nodes
occurring in $[r,x]$. Once again, by the previous observation, all
these $\lambda$-nodes have order smaller than $\ord{x}$. Hence
$\tau$ is incrementally-bound.

(ii) We assume that $M$ is already in $\eta$-normal form. Suppose
$M$ is closed and $\tau(M)$ is incrementally-bound, we prove that
$M$ is safe by induction on its structure: \emph{Base case:} $M =
\lambda \overline{\xi} . \alpha$ for some variable or constant
$\alpha$. This term is obviously safe.

\emph{Step case:} If $M = \lambda \overline{\xi} . N_1 \ldots N_p$.
Let $i$ range over $1..p$. $N_i$ can be written $\lambda
\overline{\eta_i} . N'_i$ where $N'_i$ is not an abstraction. By the
induction hypothesis, $\lambda \overline{\xi} . N_i = \lambda
\overline{\xi} \overline{\eta_i} . N'_i$ is safe. We observe from
the formation rules of Safe $\lambda$-Calculus that the typing
judgment for $\lambda \overline{\xi} \overline{\eta_i} . N'_i$ can
only be derived using the (abs) rule on the term $N'_i$. Hence
$N'_i$ is necessarily safe. Let $z$ be a variable occurring free in
$N'_i$. Since $M$ is closed, $z$ is either bound by $\lambda
\overline{\eta_1}$ or $\lambda \overline{\xi}$. If it is bound by
$\lambda \overline{\xi}$ then because $\tau(M)$ is
incrementally-bound we have $\ord{z} \geq \ord{\lambda
\overline{\eta_1}} = \ord{N_i}$. Hence we can abstract the variables
$\overline{\eta_1}$ using the (abs) rule and we obtain that $N_i$ is
safe.

Because $M$ is in $\eta$-normal form, the application $N_1 \ldots
N_p$ is total (i.e. $N_1$ is a function taking $p-1$ parameters and
it is applied to $p-1$ arguments), therefore since the $N_i$s are
safe, by the (app) rule of the Safe $\lambda$-Calculus $N_1 \ldots
N_p$ is also safe. Finally, using the (abs) rule we conclude that $M
= \lambda \overline{\xi} . N_1 \ldots N_p$ is safe.
\end{proof}

Note that the hypothesis that $M$ is closed in (ii) is necessary.
For instance, the two terms $\lambda x y .x$ and $\lambda y . x$,
where $x,y:o$, have (isomorphic) incrementally-bound computation
trees. However $\lambda x y .x$ is safe whereas $\lambda y . x$ is
not.



Putting proposition \ref{prop:incrbound_imp_incrjustified} and lemma
\ref{lem:safe_imp_incrbound} together we obtain a game-semantic
characterisation of safe terms:
\begin{corollary}[Incrementally-justified strategies characterise closed safe terms]
Let $M$ be a closed pure simply-typed term (with no constants) then
$\sem{M}$  is incrementally-justified  if and only the $\eta$-normal form of the
$\beta$-normal form of $M$ is safe.
\end{corollary}



\begin{theorem}[Pointers are superfluous for safe terms]
\label{thm:safe_ptr_recoverable} Pointers in the game semantics of
safe terms are uniquely recoverable.
\end{theorem}
\begin{proof}
Let $M$ be a safe simply-typed term. The $\beta$-normal form of $M$
denoted by $M'$ is also safe. By lemma \ref{lem:safe_imp_incrbound}
(i), $\tau(M')$ is incrementally-bound and by proposition
\ref{prop:incrbound_imp_incrjustified}, $\sem{M'}$ is an
incrementally-justified strategy. By lemma
\ref{lem:incrjustified_pointers_uniqu_recover}, the pointers in
$\sem{M'}$ are uniquely recoverable. Finally, the soundness of the
game model gives $\sem{M} = \sem{M'}$.
\end{proof}


\section{Safe \pcf}

\subsection{Definition}
Safe \pcf\ is \pcf\ where the application and abstraction rules are restricted the same
way as in the Safe $\lambda$-Calculus. The formation rules are those of the Safe $\lambda$-calculus augmented with the following rules:
$$ \rulename{num} \rulef{}{\Gamma \vdash n :\texttt{exp}}
\qquad \rulename{succ} \rulef{\Gamma \vdash M:\texttt{exp} }{\Gamma
\vdash \texttt{succ}\ M:\texttt{exp}} \qquad \rulename{pred}
\rulef{\Gamma \vdash M:\texttt{exp} }{\Gamma \vdash \texttt{pred}\
M:\texttt{exp}}$$
$$
\rulename{cond} \rulef{\Gamma \vdash M : \texttt{exp} \qquad \Gamma
\vdash N_1 : \texttt{exp} \qquad \Gamma \vdash N_2 : \texttt{exp}
}{\Gamma \vdash \texttt{cond}\ M\ N_1\ N_2} \qquad  \rulename{rec}
\rulef{\Gamma \vdash M : A\rightarrow A }{ \Gamma \vdash Y_A M :
A}$$

\subsection{Small-step semantics of Safe \pcf}
The operational semantics of \ialgol\ can be defined using a small-step semantics.
The reduction rules of the small-step semantics are of the form $s,e
\rightarrow s',e'$ where $s$ and $s'$ denotes the stores and $e$ and
$e'$ denotes \ialgol\ expressions. The reduction rules for \pcf\ constants are:
\begin{align*}
\pcfsucc\ n &\rightarrow n+1 &                   \pcfcond\ 0\ N_1 N_2 &\rightarrow N_1 \\
\pcfpred\ 0 &\rightarrow 0   &                   \pcfcond\ n+1\ N_1 N_2 &\rightarrow N_2 \\
\pcfpred\ n+1 &\rightarrow n &                   Y\ M &\rightarrow M (Y M)
\end{align*}

Safe \pcf\ inherits the good properties of the Safe $\lambda$-Calculus, in particular
no variable capture occurs when performing substitution on a safe term
and safety is preserved by reduction.
A natural question to ask is whether we can extend the game-semantics characterization result
to safe \pcf.


\subsection{Correspondence}
In this section, we show how to extend the results obtained for the
Safe $\lambda$-Calculus to the \pcf\ fragment of Safe \ialgol.

The $Y$ combinator needs a special treatment. In order to deal with
it, we follow the idea of \cite{abramsky:game-semantics-tutorial}:
we consider the sublanguage $\pcf_1$ of \pcf\ in which the only
allowed use of the $Y$ combinator is in terms of the form $Y(
\lambda x:A .x )$ for some type $A$. We will write $\Omega_A$ to
denote the non-terminating term $Y(\lambda x:A .x)$ for a given type
$A$.

We introduce the \emph{syntactic approximants} to $Y_A M$:
\begin{eqnarray*}
Y^0_A M &=& \Gamma \vdash \Omega_A : A\\
Y^{n+1}_A M &=& M( Y^n M )
\end{eqnarray*}
For any \pcf\ term $M$ and natural number $n$, we define $M_n$ to be
the $\pcf_1$ term obtained from $M$ by replacing each subterm of the
form $Y N$ with $Y^n N_n$. We have $\sem{M} = \Union_{n\in\omega}
\sem{M_n}$ (\cite{abramsky:game-semantics-tutorial}, lemma 16).


\subsubsection{Computation tree}

We would like to define a unique computation tree for terms that use
the $Y$ combinator.

Let us first define the computation tree for $\pcf_1$ terms. We
introduce a special $\Sigma$-constant $\bot$ representing the
non-terminating computation of ground type $\Omega_o$. Given any
type $A = (A_1, \ldots, A_n, o)$, the computation tree
$\tau(\Omega_A)$ is defined to be the tree representation of
$\lambda x_1:A_1 \ldots x_n:A_n . \bot$. The computation tree of a
$\pcf_1$ term is then computed inductively in the standard way.

We now introduce a partial order on the set of computation trees.

A \emph{tree} $t$ is a labelling function $t:T\rightarrow L$ where
$T$, called the domain of $t$ and written $dom(t)$, is a non-empty
prefix-closed subset of some free monoid $X^*$ and $L$ denotes the
set of possible labels. Intuitively, $T$ represents the structure of
the tree (the set of all paths) and $t$ is the labelling function
mapping paths to labels. Trees can be ordered using the
\emph{approximation ordering} defined in \cite{KNU02}, section 1: we
write $t' \sqsubseteq t$ if the tree $t'$ is obtained from $t$ by
replacing some of its subtrees by $\bot$. Formally:
$$t' \sqsubseteq t \quad \iff dom(t') \subseteq dom(t) \wedge \forall  w \in dom(t'). (t'(w) = t(w) \vee t'(w) = \bot).$$
The set of all trees together with the approximation ordering is a
complete partial order.

We now consider a strict subset of the set of all trees: the set of
computation trees. A computation tree is a tree which represents the
$\eta$-normal form of some (potentially infinite) \pcf\ term. In
other words a tree is a computation tree if it can be written
$\tau(M)$ for some infinite \pcf\ term $M$. The set $L$ of labels is
constituted of the $\Sigma$-constants, @, the special constant
$\bot$, variables and abstractions of any sequence of variables. We
will write $(CT, \sqsubseteq)$ to denote the set of computation
trees ordered by the approximation ordering $\sqsubseteq$ defined
above. $(CT, \sqsubseteq)$ is also a complete partial order.

It is easy to check that the sequence of computation trees
$(\tau(M_n))_{n\in\omega}$ is a chain. We can therefore define the
computation tree of a \pcf\ term $M$ to be the least upper-bound of
the chain of computation trees of its approximants:
$$\tau(M) = \Union_{n\in\omega}(\tau(M_n))_{n\in\omega}.$$

In other words, we construct the computation tree by expanding
infinitely any subterm of the form $Y M$. For instance consider the
term $M = Y (\lambda f x. f x)$ where $f:(o,o)$ and $x:o$. Its
computation tree $\tau(M)$ is defined recursively as
$$\tau(M) = \tree{\lambda y}{
                \tree{@}{
                   \tree{\lambda f x} {\TR{x}}
                   \TR{\tau(M)} \TR{y}
                }
            }
$$
which is a tree representation of the $\eta$-normal form of the infinite term
$$(\lambda f x. f x) ((\lambda f x. f x) ((\lambda f x. f x)  (
\ldots \ .$$

The remaining operators of \ialgol\ are treated as standard
constants and the corresponding computation tree is constructed from
the $\eta$-normal form of the term in the standard way. For instance
the diagram below shows the computation tree for $\pcfcond\ b\ x\ y$
(left) and $\lambda x . 5$ (right):
$$
\tree{\lambda b x y}
     {  \tree{\pcfcond}
        {   \tree{\lambda} {\TR{b}}
            \tree{\lambda} {\TR{x}}
            \tree{\lambda} {\TR{y}}
        }
    }
\hspace{2cm} \tree{\lambda x}{  \TR{5} }
$$
The node labelled $5$ has, like any other node, children
value-leaves which are not represented on the diagram above for
simplicity.

\subsubsection{Traversal}

New traversal rules accompany the additional constants of \ialgol.
There is one additional rule for natural number constants:
\begin{itemize}
\item (Nat) If $t \cdot n$ is a traversal where $n$ denotes a node labelled with some numeral constant $i\in \nat$ then
            $t \cdot \rnode{n}{n} \cdot \rnode{in}{i_n} \bkptr[nodesep=0pt]{40}{in}{n}$
            is also a traversal where $i_n$ denotes the value-leaf of $m$ corresponding to the value $i\in \nat$.
\end{itemize}

\noindent The traversals rules for \pcfpred\ and \pcfsucc\ are
defined similarly. For instance, the rules for \pcfsucc\ are:
\begin{itemize}
\item (Succ) If $t \cdot \pcfsucc$ is a traversal and $\lambda$ denotes the only child node of \pcfsucc\ then
$t \cdot \rnode{succ}{\pcfsucc} \cdot \rnode{l}{\lambda}
\bkptr[nodesep=1pt]{60}{l}{succ} \bklabel{1}$ is also a traversal.

\item (Succ') If
$t_1 \cdot \rnode{succ}{\pcfsucc} \cdot \rnode{l}{\lambda} \cdot t_2
\cdot \rnode{lv}{i_{\lambda}} \bkptr[nodesep=1pt]{60}{l}{succ}
\bklabel{1} \bkptr[nodesep=1pt]{40}{lv}{l}$ is a traversal for some
$i \in \nat$ then $t_1 \cdot \rnode{succ}{\pcfsucc} \cdot
\rnode{l}{\lambda} \cdot t_2 \cdot \rnode{lv}{i_{\lambda}} \cdot
\rnode{succv}{(i+1)_{\pcfsucc}} \bkptr[nodesep=1pt]{60}{l}{succ}
\bklabel{1} \bkptr[nodesep=1pt]{25}{succv}{succ}
\bkptr[nodesep=1pt]{40}{lv}{l} $ is also a traversal.
\end{itemize}

\noindent In the computation tree, nodes labelled with \pcfcond\
have three children nodes numbered from $1$ to $3$ corresponding to
the three parameters of the operator \pcfcond. The traversal rules
are:
\begin{itemize}
\item (Cond-If) If $t_1 \cdot \pcfcond$ is a traversal and $\lambda$ denotes the first child of \pcfcond\ then
$t_1 \cdot \rnode{cond}{\pcfcond} \cdot \rnode{l}{\lambda}
\bkptr[nodesep=1pt]{60}{l}{cond} \bklabel{1}$ is also a traversal.

\item (Cond-ThenElse) If
$t_1 \cdot \rnode{cond}{\pcfcond} \cdot \rnode{l}{\lambda} \cdot t_2
\cdot \rnode{lv}{i_{\lambda}} \bkptr[nodesep=1pt]{60}{l}{cond}
\bklabel{1} \bkptr[nodesep=1pt]{40}{lv}{l}$ then $t_1 \cdot
\rnode{cond}{\pcfcond} \cdot \rnode{l}{\lambda} \cdot t_2 \cdot
\rnode{lv}{i_{\lambda}} \cdot \rnode{condthenelse}{\lambda}
\bkptr[nodesep=1pt]{60}{l}{cond} \bklabel{1}
\bkptr[nodesep=1pt]{40}{lv}{l}
\bkptr[nodesep=1pt]{35}{condthenelse}{cond} \bklabelc{2+[i>0]} $ is
also a traversal.



\item (Cond') If
$t_1 \cdot \rnode{cond}{\pcfcond} \cdot t_2 \cdot \rnode{l}{\lambda}
\cdot t_3 \cdot \rnode{lv}{i_{\lambda}}
\bkptr[nodesep=1pt]{40}{l}{cond} \bklabel{k}
\bkptr[nodesep=1pt]{40}{lv}{l}$ for $k=2$ or $k=3$ then $t_1 \cdot
\rnode{cond}{\pcfcond} \cdot t_2 \cdot \rnode{l}{\lambda} \cdot t_3
\cdot \rnode{lv}{i_{\lambda}} \cdot \rnode{condv}{i_{\pcfcond}}
\bkptr[nodesep=1pt]{40}{l}{cond} \bklabel{k}
\bkptr[nodesep=1pt]{40}{lv}{l} \bkptr[nodesep=1pt]{20}{condv}{cond}
$ is also a traversal.
\end{itemize}
It is easy to verify that these traversal rules are all well-behaved
and therefore condition (WB) of section \ref{subsec:traversal} is
met. This completes the definition of traversal for the \pcf\ subset
of \ialgol.


\subsubsection{Removing $\Sigma$-nodes from the traversals}

To establish the correspondence with the interaction semantics, we
need to remove the superfluous nodes from the traversals. These
nodes are the @-nodes and the constant nodes. We will use the
operation $-@$ (definition \ref{dfn:appnode_filter}) to filter out
the @-nodes and we introduce a similar operation $-\Sigma$ to
eliminate the $\Sigma$-nodes.

\begin{definition}[Hiding $\Sigma$-constants in the traversals]
Let $t$ be a traversal of $\tau(M)$. We write $t-\Sigma$ for the
sequence of nodes with pointers obtained by
\begin{itemize}
\item removing from $t$ all nodes labelled with a $\Sigma$-constant or value-leaf justified by a $\Sigma$-constant,
\item replacing any link pointing to a $\Sigma$-constant $f$
by a link pointing to the predecessor of $f$ in $t$.
\end{itemize}

Suppose $u = t-\Sigma$ is a sequence of nodes obtained by applying
the previously defined transformation on the traversal $t$, then $t$
can be partially recovered from $u$ by reinserting the
$\Sigma$-nodes as follows. For each $\Sigma$-node $f$, where $p$
denotes the parent node of $f$, do the following:
    \begin{enumerate}
    \item replace every occurrence of the pattern $p \cdot n$ in $u$ where
    $n$ is a $\lambda$-node by $p \cdot f \cdot n$;

    \item replace any link in $u$ starting from a $\lambda$-node and pointing to $p$ by a link pointing to the inserted node $f$;

    \item for each occurrence in $u$ of a value-leaf $v_p$ pointing to $p$, add the value-leaf $v_f$
    immediately before $v_p$. The links of $v_f$ points to the node immediately following $p$.
    \end{enumerate}
We write $u+\Sigma$ for this second transformation.
\end{definition}
These transformations are well-defined since in a traversal, a
$\Sigma$-node $f$ always follows immediately its parent
$\lambda$-node $p$, and an occurrence of a value-node $v_p$ always
follows immediately a value-node $v_f$. In other words, if $f$
occurs in $t$ then $t$ must be a prefix of a traversal of the
following form for some $v \in \mathcal{D}$:
$$ \ldots \cdot \rnode{p}{p} \cdot \rnode{f}{f} \cdot \ldots \cdot \rnode{vf}{v_f} \cdot \rnode{vp}{v_p} \cdot \ldots
\bkptr[offset=-4pt]{20}{vf}{f} \bkptr[offset=-4pt]{20}{vp}{p}
$$

Remark: $t-\Sigma$ is not a proper traversal since it does not
satisfy alternation. It is not a proper justified sequence either
since after removing a $\Sigma$-node $f$, any $\lambda$-node
justified by $f$ will become justified by the parent of $f$ which is
also a $\lambda$-node.

The following lemma follows directly from the definition:
\begin{lemma}
\label{lem:minus_sig_plus_sig} For any traversal $t$ we have
$(t-\Sigma)+\Sigma \sqsubseteq t$ and if $t$ does not end with an
$\Sigma$-node or a value-leaf of a $\Sigma$-node then
$(t-\Sigma)+\Sigma = t$.
\end{lemma}

The operations $-@$ and $-\Sigma$ are commutative: $(t-@)-\Sigma =
(t-\Sigma)-@$. We write $t^*$ to denote $(t-@)-\Sigma$ i.e. the
sequence obtained from $t$ by removing all the @-nodes as well as
the constant nodes together with their associated value-leaves. We
introduce the notation $\travset(M)^{*} = \{ t^* \ | \  t \in
\travset(M) \}$.

\subsubsection{Correspondence theorem}
We would like to prove the counterpart of proposition
\ref{prop:rel_gamesem_trav} in the context of the simply-typed
$\lambda$-calculus \emph{with interpreted \pcf\ constants}. The game
model of the language \pcf\ is given by the category $\mathcal{C}_b$
of well-bracketed strategies. Hence the well-bracketing assumption
stated in section \ref{sec:assumptions} is satisfied.

We first prove that $\travset^{\upharpoonright r}$ is continuous.
\begin{lemma}
\label{lem:travred_continuous} Let $(S,\subseteq)$ denote the set of
sets of justified sequences of nodes ordered by subset inclusion.
The function $\travset^{\upharpoonright r} : (CT,\sqsubseteq)
\rightarrow (S,\subseteq)$ is continuous.
\end{lemma}


\begin{proposition}
Let $\Gamma \vdash M : T$ be a \pcf\ term and $r$ be the root of
$\tau(M)$. Then:
\begin{align*}
(i)  \quad\varphi_M(\travset(M)^*) = \intersem{M},  \\
(ii) \quad \varphi_M(\travset(M)^{\upharpoonright r}) = \sem{M}.
\end{align*}
\end{proposition}


\subsubsection{Example: \pcfsucc}

Consider the term $M = \pcfsucc\ 5$ whose computation tree is
represented below. The value-leaves are also represented on the
diagram, they are the vertices attached to their parent node with a
dashed line.
$$
\psmatrix[colsep=3ex,rowsep=2ex]
\lambda^0 \\
\pcfsucc & 0 & 1 & \ldots \\
\lambda^1 & 0 & 1 & \ldots \\
5 & 0 & 1 & \ldots \\
  & 0 & 1 & \ldots
\endpsmatrix
\ncline{1,1}{2,1} \ncline{2,1}{3,1} \ncline{3,1}{4,1}
\valueedge{1,1}{2,2} \valueedge{1,1}{2,3} \valueedge{1,1}{2,4}
\valueedge{2,1}{3,2} \valueedge{2,1}{3,3} \valueedge{2,1}{3,4}
\valueedge{3,1}{4,2} \valueedge{3,1}{4,3} \valueedge{3,1}{4,4}
\valueedge{4,1}{5,2} \valueedge{4,1}{5,3} \valueedge{4,1}{5,4}
$$

The following sequence of nodes is a traversal of $\tau(M)$:
\vspace{18pt}
$$ t = \rnode{l0}{\lambda^0} \cdot \rnode{succ}{\pcfsucc} \cdot \rnode{l1}{\lambda^1} \cdot \rnode{c5}{5} \cdot \rnode{55}{5_5} \cdot \rnode{5l1}{5_{\lambda^1}} \cdot \rnode{6succ}{6_\pcfsucc} \cdot \rnode{6l0}{6_{\lambda^0}}.
\bkptr[offset=-4pt]{20}{6l0}{l0} \bkptr[offset=-4pt]{20}{5l1}{l1}
\bkptr[offset=-4pt]{20}{55}{c5} \bkptr[offset=-4pt]{20}{6succ}{succ}
$$
The subsequences $t^*$ and $t \upharpoonright r$ are given by:
$$
t^* = \rnode{l0}{\lambda^0} \cdot \rnode{l1}{\lambda^1} \cdot
\rnode{5l1}{5_{\lambda^1}} \cdot \rnode{6l0}{6_{\lambda^0}}.
\bkptr[offset=-4pt]{20}{6l0}{l0} \bkptr[offset=-4pt]{20}{5l1}{l1}
\bkptr[offset=-4pt]{20}{l1}{l0} \qquad  \mbox{ and } \qquad t
\upharpoonright r = \rnode{l0}{\lambda^0} \cdot
\rnode{6l0}{6_{\lambda^0}}. \bkptr[offset=-4pt]{20}{6l0}{l0}
$$
We have $\varphi(t^*) = q_0 \cdot q_5 \cdot 5_{q_5} \cdot 5_{q_0}$
and $\varphi(t\upharpoonright r) = q_0 \cdot 5_{q_0}$ where $q_0$
and $q_5$ denote the roots of two flat arenas over $\nat$. These two
sequences of moves correspond to some play of the interaction
semantics and the standard semantics respectively. The interaction
play is represented below:
$$\begin{array}{ccccc}
  \textbf{1} & \stackrel{5}{\multimap} & !\nat & \stackrel{\pcfsucc}{\multimap} & \nat \\
&&&&  \rnode{q0}{q_0} \\
&&  \rnode{q5}{q_5} \\
&&  \rnode{a5}{5_{q_5}} \\
&&&&  \rnode{a6}{6_{q_0}}
\end{array}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{a5}{q5}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=210]{->}{a6}{q0}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{q5}{q0}
$$

\subsubsection{Another example : \pcfcond}

Consider the term $M = \lambda x y . \pcfcond\ 1\ x\ y$. Its
computation tree is represented below (without the value-leaves):
    $$ \tree{\lambda x y}
       {
          \tree{\pcfcond}
          {
            \tree{\lambda^1}{ \TR{0} }
            \tree{\lambda^2}{ \TR{x} }
            \tree{\lambda^3}{ \TR{y} }
          }
      }
    $$
For any value $v \in\mathcal{D}$ the following sequence of nodes is
a traversal of $\tau(M)$: \vspace{18pt}
$$ t = \rnode{lxy}{\lambda x y} \cdot \rnode{cond}{\pcfcond} \cdot \rnode{l1}{\lambda^1} \cdot \rnode{1}{1} \cdot \rnode{11}{1_1}
    \cdot \rnode{l2}{\lambda^2} \cdot \rnode{x}{x} \cdot \rnode{vx}{v_x}  \cdot \rnode{vl2}{v_{\lambda^2}} \cdot \rnode{vcond}{v_{\pcfcond}}
    \cdot \rnode{vlxy}{v_{\lambda x y}}.
\bkptr[offset=-4pt]{20}{vlxy}{lxy}
\bkptr[offset=-4pt]{20}{vcond}{cond}
\bkptr[offset=-4pt]{20}{vl2}{l2} \bkptr[offset=-4pt]{20}{vx}{x}
\bkptr[offset=-4pt]{20}{x}{vxy} \bkptr[offset=-4pt]{20}{l2}{cond}
\bkptr[offset=-4pt]{20}{11}{1} \bkptr[offset=-4pt]{20}{l1}{cond}
$$
The subsequences $t^*$ and $t \upharpoonright r$ are given by:
\vspace{13pt}
$$
t^* =  t = \rnode{lxy}{\lambda x y} \cdot
        \rnode{l1}{\lambda^1} \cdot
        \rnode{l2}{\lambda^2} \cdot
        \rnode{x}{x} \cdot
        \rnode{vx}{v_x}  \cdot
        \rnode{vl2}{v_{\lambda^2}} \cdot
        \rnode{vlxy}{v_{\lambda x y}}
\bkptr[offset=-4pt]{20}{vlxy}{lxy} \bkptr[offset=-4pt]{20}{vl2}{l2}
\bkptr[offset=-4pt]{20}{vx}{x} \bkptr[offset=-4pt]{20}{x}{vxy}
\bkptr[offset=-4pt]{20}{l2}{lxy} \bkptr[offset=-4pt]{20}{l1}{lxy}
\qquad  \mbox{ and } \qquad t \upharpoonright r =
\rnode{lxy}{\lambda x y} \cdot \rnode{x}{x} \cdot \rnode{vx}{v_x}
\cdot \rnode{vlxy}{v_{\lambda x y}}.
\bkptr[offset=-4pt]{20}{vlxy}{lxy} \bkptr[offset=-4pt]{20}{vx}{x}
\bkptr[offset=-4pt]{20}{x}{vxy}
$$
The sequence of moves $\varphi(t^*)$ corresponds to some play of the
interaction semantics and the sequence $\varphi(t\upharpoonright r)$
is a play of the standard semantics obtained by hiding the internal
moves of $\varphi(t^*)$. The interaction play $\varphi(t^*)$ is
represented below:
$$\begin{array}{ccccccccccc}
!\nat & \otimes & !\nat & \stackrel{ \langle \sem{1}, \pi_1,
\pi_2\rangle }{\multimap} & !\nat & \otimes & !\nat & \otimes &
!\nat
& \stackrel{ \pcfcond}{\multimap} & \nat \\
&&&&&&&&&&  \rnode{q0}{q_0} \\
&&&&  \rnode{qa}{q_a} \\
&&&&  \rnode{1}{1} \\
&&&&&&  \rnode{qb}{q_b} \\
  \rnode{qx}{q_x} \\
  \rnode{vqx}{v_{q_x}} \\
&&&&&&  \rnode{vqb}{v_{q_b}} \\
&&&&&&&&&& \rnode{vq0}{v_{q_0}}
\end{array}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{vq0}{q0}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{vqb}{qb}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{vqx}{qx}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{qx}{qb}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=90,angleB=180]{->}{qb}{q0}
\nccurve[nodesep=2pt,ncurv=0.9,angleA=180,angleB=180]{->}{1}{qa}
\ncarc[nodesep=2pt,ncurv=0.9,angleA=90,angleB=180]{->}{qa}{q0}
$$


\subsubsection{Game characterisation of safe terms}

A difficulty arises because of the presence of the Y combinator :
computation trees of \pcf\ terms are potentially infinite. Despite
this particularity, lemma \ref{lem:safe_imp_incrbound} still holds
in the \pcf\ setting:
\begin{lemma}[Safe terms have incrementally-bound computation tree]
\label{lem:pcf_safe_imp_incrbound} If $\Gamma \vdash M$ is a safe
\pcf\ term then $\tau(M)$ is incrementally-bound.
\end{lemma}


\begin{theorem}[Pointers are superfluous for Safe \pcf]
Pointers in the game denotation of safe \pcf\ terms are uniquely
recoverable.
\end{theorem}
\begin{proof}
Since condition (WB) is verified, lemma \ref{lem:redtrav_trav} holds
in the Safe \pcf\ setting. Therefore proposition
\ref{prop:incrbound_imp_incrjustified}(i) also holds: terms in
$\beta$-nf with an incrementally-bound computation tree are denoted
by incrementally-justified strategies.

Safety is preserved by reduction, therefore by lemma
\ref{lem:pcf_safe_imp_incrbound} and soundness of the game
denotation, any Safe \pcf\ term must be denoted by an
incrementally-justified strategy.

Hence pointers are superfluous in the game denotation of safe \pcf\
terms.
\end{proof}


%%%%%%%%%%%%%%%%%%%%

%\begin{theorem}[Correspondence theorem]
%\label{thm:corresp} The set of traversals of the computation tree is
%isomorphic to the set of uncovered plays of the game denotation of
%the term.
%\end{theorem}

%\begin{theorem}[Game-semantic characterisation of safety]
%\label{thm:gamesem_charact} Safe simply-typed terms in
%$\beta$-normal form have incrementally-bound computation trees.
%Reciprocally, a closed term in $\eta$-long normal form with an
%incrementally-bound computation trees is safe.
%\end{theorem}

%\begin{cor}
%\label{cor:safeptrrecover} The pointers in the game semantics of
%safe simply-typed terms can be recovered uniquely from the
%underlying sequences of moves.
%\end{cor}

\section{Further work}

\subsection{Extension to Safe Idealized Algol}

Safe \ialgol\  is Safe \pcf\ augmented with the constants of Idealized Algol
\cite{Reynolds81} as well as a family of combinators $Y_A$ for every
type $A$. There are some difficulties caused by the presence of the two new
base types \iavar\ and \iacom however, it seems that the correspondence with game semantics and the game-semantic characterisation
of safety can easily be adapted to full Safe \textsf{IA}.


\subsubsection{Computation DAG}
In \pcf, arenas have a single initial move, therefore they can be
regarded as trees. In \ialgol, on the other hand, the base type
\iavar\ is represented by the infinite product of games
$\iacom^{\nat} \times \iaexp$ which has an infinite number of
initial moves. In order to preserve the relationship established
between arenas and computation trees, we need to accommodate the
definition of computation tree to reflect this property. The
consequence is that in \ialgol, ``computation trees'' become
``computation directed acyclic graphs (DAG)'': a computation DAG may
have (possibly infinitely) many roots and two nodes of a given level
can share children at the next level.

A term of type \iavar\ has a computation DAG with an infinite number
of root $\lambda$-nodes. Suppose that $M$ is a term of type \iavar,
then the computation DAG for $\lambda \overline{\xi} . M$ is
obtained by relabelling the root $\lambda$-nodes $\lambda^r$,
$\lambda^{w_0}$, $\lambda^{w_1}$, $\lambda^{w_2}$, \ldots into
$\lambda^r \overline{\xi}$, $\lambda^{w_0} \overline{\xi}$,
$\lambda^{w_1} \overline{\xi}$, $\lambda^{w_2} \overline{\xi}$,
\ldots. For a term $M$  of type \iaexp\ or \iacom, the computation
DAG for $\lambda \overline{\xi} . M$ is computed in the same way as
in the Safe $\lambda$-Calculus.



\subsection{Open problems}

The nature of the Safe $\lambda$-Calculus is still not well known. We propose the following possible
roadmap for further research:
\begin{enumerate}
\item prove or disprove that observational equivalence is decidable for Safe \ialgol;
\item find a categorical interpretation of the Safe $\lambda$-Calculus;
\item study the proof theory obtained by the Curry-Howard isomorphism and determine whether it has nice properties that can be helpful in theorem proving;
\item in \cite{DBLP:conf/tlca/LeivantM93}, the $\lambda$-calculus is used to
give several characterisations of the complexity class P. We would
like to investigate whether, by following similar techniques, we can
obtain a characterisation of a different complexity class using the
Safe $\lambda$-Calculus.
\end{enumerate}


More generally, we would like to study the class of languages for
which pointers are uniquely recoverable. We name this class PUR for
``Pointer Uniquely Recoverable''.

We proved that Safe $\lambda$-Calculus is a PUR-language. Another
example is the Serially Re-entrant Idealized Algol (SRIA) proposed
by Abramsky  in \cite{abramsky:mchecking_ia}. This language allows
multiple occurrences or uses of arguments, as long as they do not
overlap in time. In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of Safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to Safe \ialgol. SRIA and Safe \ialgol\ are therefore two
different examples of languages with pointer-less game semantics.

Finitary $\ialgol_2$ is also an example of PUR-language for which
observational equivalence is decidable. Decidability of observational equivalence is a very
appealing property which has immediate applications in the domain of
program verification. Intuitively, PUR-languages seem to be good
candidates of languages for which observational equivalence is
decidable. It would be interesting to discover classes of PUR
languages having this appealing property.

Another possible way to generate PUR-languages may be to constrain
the types of an existing language. In \cite{DBLP:conf/tlca/Joly01},
a notion of ``complexity'' is defined for $\lambda$-terms. It is
proved that a type $T$ can be generated from a finite set of
combinators if and only if there is a constant bounding the
complexity of every closed normal $\lambda$-term of type $T$;
consequently, the only inhabited finitely generated types are the
type of rank $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = (o^k \rightarrow o) \rightarrow o$. We know that imposing the
first of these two type restrictions to Finitary \ialgol\ leads to a
PUR language. Is it also the case when imposing the second type
restriction?




\bibliographystyle{splncs}
\bibliography{../transfer/higherorder,../transfer/gamesem,../transfer/modelchecking,../transfer/proganalys}

\end{document}
