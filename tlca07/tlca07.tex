% the LaTeX macro package from Springer-Verlag for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
\documentclass{llncs}
\usepackage{amssymb}
\usepackage{pst-tree}
\usepackage[all]{xy}
%\usepackage{picins}
\usepackage{wrapfig}
\usepackage{floatflt}



% used for definitions
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

% reduction, substitution
\newcommand\betared{\rightarrow_\beta}
\newcommand\betasred{\rightarrow_{\beta_s}}
\newcommand\betaredtr{\twoheadrightarrow_\beta} % transitive closure of the beta reduction
\newcommand\subst[2]{\left[ #1/#2 \right]}
\newcommand\captsubst[2]{\{#1/#2 \}}

% computation tree, eta normal form, traversals
\newcommand\aux[1]{\lceil #1\rceil}
\newcommand\travset{\mathcal{T}rav}

% lambda calculus
%\newcommand\bot{\perp}
\newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{#2}}
\newcommand\ord[1]{{\sf ord}(#1)}
\newcommand\typear{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(#1)}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\nat{\mathbb{N}}


% game semantics
\newcommand{\sem}[1]{{[\![ #1 ]\!]}}
\newcommand{\intersem}[1]{{\langle\!\langle #1 \rangle\!\rangle}}

% logic
\newcommand\imp{\Longrightarrow}
\newcommand\zand{\wedge}
\newcommand\entail{\vdash}

% pcf and ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}
\newcommand\pcf{\textsf{PCF}}

% justified sequence of moves
\newcommand{\oview}[1]{\llcorner #1 \lrcorner}
\newcommand{\pview}[1]{\ulcorner #1 \urcorner}

% back pointer using psttricks
\newcommand{\bkptr}[2][nodesep=0pt]{\ncarc[linewidth=0.4pt,offset=-2pt,nodesep=0pt,ncurv=1,arcangleA=-#2, arcangleB=-#2,#1]{->}}
\newcommand{\bklabel}[1]{\mput*{\mbox{{\tiny $#1$}}}}
\newcommand{\bklabelc}[1]{\Bput[1pt]{\mbox{{\tiny $#1$}}}}
\newcommand\treelabel[1]{\mput*{\mbox{{\small $#1$}}}}

% trees
\newcommand{\tree}[2][levelsep=3.5ex]{\pstree[levelsep=3.5ex,#1]{\TR{#2}}}


\begin{document}

\frontmatter          % for the preliminaries
\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{} % additional mark in the TOC

\mainmatter              % start of the contributions

\title{The Safe $\lambda$-Calculus}

\titlerunning{The Safe $\lambda$-Calculus}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used


\author{William Blum\inst{1} \and C.-H. Luke Ong\inst{2}}
%
\authorrunning{William Blum et al.}   % abbreviated author list (for running head)
%
% modified list of authors for the TOC (add the affiliations)
\tocauthor{William Blum (University of Oxford), C.-H. Luke Ong (University of Oxford)}


\institute{Oxford University Computing Laboratory\\ Wolfson Building, Parks Road, Oxford, OX1 3QD, ENGLAND\\
\email{william.blum@comlab.ox.ac.uk\inst{1} luke.ong@comlab.ox.ac.uk\inst{2}} }

\maketitle              % typeset the title of the contribution

\pagestyle{empty}

% TLCA05:
%    Papers should not exceed 15 pages in Springer LNCS format.
%    An abstract (ASCII text) of no more than 150 words should be sent separately at least a weak before the paper submission deadline.

% LNCS:
%    The abstract should summarize the contents of the paper
%    using at least 70 and at most 150 words. It will be set in 9-point
%    font size and be inset 1.0 cm from the right and left margins.
%    There will be two blank lines before and after the Abstract. \dots

\begin{abstract}
The \emph{safety condition} has been introduced in \cite{KNU02} as a syntactic
restriction for higher-order grammars that constrains occurrences
of variables in the grammar equations according to their order.
When transposed to the $\lambda$-calculus, the safety condition gives rise to the \emph{Safe $\lambda$-calculus}, a
strict sub-language of the $\lambda$-calculus (\cite{safety-mirlong2004}).

We present a new version of Safe $\lambda$-calculus and give a game-semantic
account of it. In particular we show that pointers are superfluous in the plays
of the game denotation of safe terms.
\end{abstract}


\section{Introduction}

\subsection{Background}

The \emph{Safety restriction} has been introduced in by Knapik, Niwi{\'n}ski and Urzyczyn in \cite{KNU02}
for the purpose of studying infinite trees generated by higher-order grammars.
It is very similar to the ``restriction of derived types'' which was introduced
by Damm in \cite{Dam82} however the formulation differs.
Safety is a syntactic restriction for higher-order grammars that
constrains the occurrences of the variables in the grammar
equations according to their order. Safety imposes a further restriction called \emph{homogeneity} on the type of the grammar equations.
The formal definition is intricate and seems a bit odd but the Safety restriction has important algorithmic impacts.

In particular, the authors of \cite{KNU02} proved that the Monadic Second
Order (MSO) theory of the term tree generated by a safe recursion
scheme of any order is decidable\footnote{In fact it has been shown
recently in \cite{OngLics2006} that it is also true for unsafe
recursion schemes.}. They also give the following nice automata-theoretic characterisation of safety:
an infinite term is generated by a \emph{safe} higher-order grammar if and only if
it is generated by a level-$n$ pushdown automaton.


When transposed to the $\lambda$-calculus, the safety condition
gives rise to the \emph{Safe $\lambda$-calculus}, a strict
sub-language of the $\lambda$-calculus. A first version appeared in
the technical report \cite{safety-mirlong2004}. We propose a more
general and simpler version where term types are not required to be
homogeneous. A noteworthy feature of the Safe
$\lambda$-calculus is that no variable capture can occur when
performing substitution and therefore it is unnecessary to rename
variables when computing $\beta$-reductions.

Little is known about the Safe $\lambda$-calculus and there are many
problems that have yet to be studied concerning its
computational power, the complexity classes that it characterises,
its interpretation under the Curry-Howard isomorphism and its
game-semantic characterisation. This paper contributes to give an
answer to the last problem.


The difficulty in giving a game-semantic account of Safety lies in
the fact that it is a syntactic restriction whereas Game Semantics
is by essence a syntax-independent semantics. The solution consists
in finding a particular syntactical representation of terms on which
the plays of the game denotation can be represented.
To achieve this, we use ideas recently introduced in \cite{OngLics2006}: a term
is canonically represented by the abstract syntax tree of its
$\eta$-long normal form, referred as the \emph{computation tree}. A
computation is described by a justified sequence of nodes of the
computation tree respecting some formation rules and called a
\emph{traversal}. Traversals permit us to model $\beta$-reductions
without altering the structure of the computation tree via
substitution. A notable property is that \emph{P-view} (in the game-semantic sense) of traversals
corresponds to paths in the computation tree.

These notions permit us to establish a correspondence between the game semantics of a term and
the syntactic representation given by its computation tree.
We show that traversals are just representations of the
uncovering of plays of the strategy denoting the term.
Then by defining an appropriate \emph{reduction} operation which eliminates traversal
nodes that are ``internal'' to the computation, we obtain an
isomorphism between the strategy denotation of a term and the set of
reductions of traversals of its computation tree.

Using that correspondence and after introducing the notion of \emph{incrementally-justified
strategies}, we are able to show that $\beta$-normal terms are \emph{safe} if and only if
their strategy denotation is incrementally-justified.
A consequence of this is that pointers in the game semantics of safe simply typed terms can be recovered uniquely from the underlying sequences of moves.

\subsection{Related Work}

\subsubsection{Safety}

De Miranda's forthcoming thesis \cite{demirandathesis} proposes a unified framework for the study of higher-order grammars. The thesis contains a detailed analysis of the safety constraint at level 2. It shows that, when restricted to word languages, safe level $2$ higher-order grammars are as powerful as (non-deterministic) unsafe ones. It also shows that at level $2$, safety is not a requirement to guarantee MSO decidability. The reader is referred to it for a full account of the Safety condition for higher-order grammars.


As we mentioned before, Knapik \emph{et al.} showed in \cite{KNU02} that infinite trees generated by \emph{safe} higher-order grammars
have decidable MSO theories. In \cite{OngLics2006}, Ong generalized the result to any higher-order grammar, whether safe or not.
Using an argument based on innocent game-semantics, he establishes a correspondence between the tree generated by a higher-order grammar called \emph{value tree} and a certain regular tree called \emph{computation tree}. Paths in the value tree correspond to traversals in the computation tree. Decidability is then obtain by reducing the problem to the acceptance of the (annotated) computation tree by a certain alternating parity tree automaton (APT). The approach that we follow in section \ref{sec:correspondence} uses many ingredients introduced in this paper.


\subsubsection{Computation trees and traversals}

In \cite{DBLP:conf/lics/AspertiDLR94}, a notion of graph based on
Lamping's graphs \cite{lamping} is introduced to represent
$\lambda$-terms. The authors unify different notions of paths
(regular, legal, consistent and persistent paths) that have appeared
in the literature as ways to implement graph-based reduction of
lambda-expressions. We can regard a traversal as an alternative
notion of path adapted to the graph representation of
$\lambda$-expressions given by computation trees.

Traversals of a computation tree provide a way
to perform \emph{local computation} of $\beta$-reductions as opposed
to a global approach where the $\beta$-reduction is implemented by
performing substitutions. A notion of local computation of
$\beta$-reduction has been investigated in
\cite{DanosRegnier-Localandasynchronou} through the use of special
graphs called ``virtual nets'' that embed the lambda-calculus.


\section{The Safe $\lambda$-Calculus}
We consider simple types generated by the grammar $A
\, ::= \, o \; | \; A \typear A$. Any type different from the ground
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \typear \cdots \typear A_n \typear o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the arity of $T$, written $arity(T)$, is
defined to be $n$.
The order of a type is defined by $\ord{o} = 0$ and
$\ord{A \typear B} = \max(\ord{A}+1, \ord{B})$.

The \textbf{Safe $\lambda$-Calculus} is a sub-system of the simply typed $\lambda$-calculus formally defined by the definition that follows.
We use a set of sequents of the form $\Gamma \vdash M : A$ to represent
terms-in-context where $\Gamma$ is the context (a typed-alphabet) and $A$ is the type. We assume that a set
of higher-order constants $\Sigma$ is given.

\begin{definition}[The Safe $\lambda$-calculus]
We call \emph{safe term} any simply typed lambda term that is typable using the following
formation rules:
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{const} \   \rulef{}{\vdash f : A} \quad f \in \Sigma
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash s : A}{\Delta \vdash s : A} \quad \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash s : (A_1,\ldots,A_n,B)
                                        \ \Gamma \vdash t_1 : A_1
                                        \  \ldots\  \Gamma \vdash t_n : A_n }
                                   {\Gamma  \vdash s t_1 \ldots t_n : B}
                                    \
                                   \ord{B} \sqsubseteq \ord{\Gamma}$$
$$ \rulename{abs} \   \rulef{\Gamma, x_1 : A_1 \ldots x_n : A_n \vdash s : B}
                                   {\Gamma  \vdash \lambda x_1 \ldots x_n . s : (A_1, \ldots ,A_n,B)} \
                                   \ord{A_1, \ldots ,A_n,B} \sqsubseteq \ord{\Gamma}$$
where in the side-conditions, $\ord{\Gamma}$ denotes the set $\{ \ord{y} : y \in \Gamma \}$ and $c \sqsubseteq S$ is a notation for
``$c$ is a lower-bound for $S$''.
\end{definition}

The first deviation from the standard definition of the simply typed $\lambda$-calculus is the possibility to perform multiple applications at a time using the {\sf (app)} rule and similarly to abstract several variables at a time using the {\sf (abs)} rule.
Of course this single change would not alter expressivity if there were not at the same time the additional condition
constraining the occurrences of variables within a term:  the side-condition in the application rule and abstraction rules ensures that all variables in the context of the term being formed have order greater than the order of the term itself.



Note that there is no specific constraint on the term type. In particular, the type-homogeneity constraint that is used
in the definition of safe higher-order grammars in \cite{KNU02} is not required here.\footnote{ We say that a type is homogeneous
if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with $\ord{A_1} \geq \ord{A_2}\geq \cdots \geq \ord{A_n}$ and
each $A_1$, \ldots, $A_n$ is homogeneous.} Another difference is that we allow $\Sigma$-constants to be of any higher-order types whereas
\cite{KNU02} focuses on the restricted case of first-order $\Sigma$-constants.
In these regards, our formulation of the Safe $\lambda$-calculus differs from the one proposed in \cite{safety-mirlong2004}.
It is possible to reconcile the two definitions by adding the further constraint that each type occurring in our rules is homogeneous, we then obtain a calculus equivalent to the one of \cite{safety-mirlong2004}.




\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y ))$ and
$M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where $x,y:o$ and $f:((o,o),o)$.
$M_2$ is not safe because in the subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which is smaller than $\ord{\lambda y . x} = 1$.
On the other hand, $M_1$ is safe as the following proof tree shows:
$$
 \rulef{
     \rulef{
        \rulef{}{f \vdash f} {\sf(var)}
        \
        \rulef{
             \rulef{
                \rulef{
                    \rulef{}{f \vdash f} {\sf(var)}
                }
                {f , x \vdash f } {\sf(wk)}
                \
                \rulef{
                    \rulef{
                        \rulef{}{y \vdash y} {\sf(var)}
                    }
                    {y \vdash \lambda y . y } {\sf(abs)}
                }
                {f , x \vdash \lambda y .y } {\sf(wk)}
             }
             {f , x \vdash f (\lambda y .y )} {\sf(app)}
        }
        { f  \vdash \lambda x . f (\lambda y .y )} {\sf(abs)}
     }
     {
        f  \vdash f (\lambda x . f (\lambda y .y ))} {\sf(app)}
     }
 { \vdash M_1 = \lambda f . f (\lambda x . f (\lambda y .y )) } {\sf(abs)}
$$
\end{example}

The following lemma is an immediate consequence of the definition:
\begin{lemma}
\label{lem:ordfreevar}
If $\Gamma \vdash M : A$ then every variable in $\Gamma$ occurring free in $M$ has order at least $ord(M)$.
\end{lemma}




In the simply typed $\lambda$-calculus, it is necessary to rename
variables when performing substitution on an abstraction in order to
avoid possible variable capture. As a consequence, in order to
implement substitution one needs to have access to an unbound number
of variable names.
In the Safe $\lambda$-Calculus, however, variable capture never happens as the following lemma shows.
Hence substitution can implemented naively by capture-permitting replacement, avoiding any need for variable renaming.


Let us write $M\captsubst{N}{x}$ to denote the capture-permitting substitution of $N$ for $x$ in $M$. This substitution is implemented
by textually replacing all free occurrences of $x$ in $M$ by $N$ without performing variable renaming.
In particular for the abstraction case we have:
$$(\lambda \overline{y} . P)\captsubst{N}{x} = \left\{
                                                 \begin{array}{ll}
                                                   \lambda \overline{y} . P\captsubst{N}{x} , & \hbox{if $x\not\in \overline{y}$;} \\
                                                   \lambda \overline{y} . P, & \hbox{if $x\in y$.}
                                                 \end{array}
                                               \right.
$$

\begin{lemma}[No variable capture]
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x \vdash M$ and $\Gamma \vdash  N$ are valid judgments of the Safe $\lambda$-calculus.
\end{lemma}

\begin{proof}
We prove the result by induction. The variable, constant and
application cases are trivial. For the abstraction case, suppose $M
= \lambda \overline{y} : \overline{A}. P$ where $\overline{y} = y_1
\ldots y_p$. If $x \in \overline{y}$ then $M \subst{N}{x} = M$ and there is no variable capture.
Suppose that $x \not\in \overline{y}$ then the capture-permitting substitution gives:
$$M \captsubst{N}{x} = \lambda \overline{y} . P \captsubst{N}{x} \ .$$


By the induction hypothesis there is no variable capture in $P \captsubst{N}{x}$.
Hence variable capture can only happen when for some $i \in 1..p$, the variable $y_i$
occurs freely in $N$ and $x$ occurs freely in $P$. Lemma \ref{lem:ordfreevar} gives:
$$ \ord{y_i} \geq \ord{N} = \ord{x} \ .$$

Since $x \not \in \overline{y}$ and $x$ occurs freely in $P$, $x$ also occurs freely in the safe term
$\lambda \overline{y}. P$ therefore by lemma \ref{lem:ordfreevar} we have:
$$ \ord{x} \geq \ord{\lambda y_1 \ldots y_p . T} \geq 1+ \ord{y_i} > \ord{y_i}$$
which, together with the previous equation, gives a contradiction.
\qed
\end{proof}

From now on we will use the standard notation $M\subst{N}{x}$ do denote the substitution of $N$ for $x$ in $M$.
It is understood that, provided that $M$ and $N$ are safe, this substitution
is implemented by the capture-permitting substitution $M\captsubst{N}{x}$.


\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserve_safety}
If $\Gamma, x \vdash M$ and $\Gamma \vdash N$ then $\Gamma \vdash M[N/x]$.
\end{lemma}
This is proved by an easy induction on the structure of the safe term $M$.


It is desirable to have an appropriate notion of reduction for our calculus. However the standard $\beta$-reduction rule is not adequate. Indeed, Safety is not preserved by $\beta$-reduction as the following example shows. Suppose that $x,y,z,y : o$ and $\varphi : (o,o,o)$ then the safe term $(\lambda x y . \varphi x y) z w$ $\beta$-reduces to $(\underline{\lambda y . \varphi z y}) w$ which is unsafe since the underline order-1 subterm  contains a free occurrence of variable $z$ of ground type. However if we perform one more reduction we obtain the safe term
$\varphi z w$. This suggests an alternative notion of reduction that performs simultaneous reduction of consecutive $\beta$-redexes. In order to define this reduction we first introduce an appropriate notion of redex.

In the simply typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. In the Safe
lambda calculus, a redex is a succession of several standard redexes:
\begin{definition}[Safe redex]
We call \emph{safe redex} a safe term whose derivation tree has the following form:
$$   \rulef{
            \rulef{\rulef{\vdots}{\Gamma, \overline{x}\vdash M}}{\Gamma \vdash \lambda \overline{x} . M} (\sf{abs})
            \quad
            \rulef{\vdots}{\Gamma \vdash N_1}  \ \ldots \  \rulef{\vdots}{\Gamma \vdash N_l}
    }
    {
       \Gamma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
    } (\sf{app})
$$
where $\overline{x}$ denotes the list of variables $x_1\ldots x_n$.
\end{definition}

In other words a safe redex is a safe term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$ such that
the variable $\overline{x}$ are abstracted altogether by one occurrence of the rule $(\sf{abs})$ and the terms $(\lambda \overline{x} . M)$, $N_1$, \ldots, $N_l$ are applied together at once using the $(\sf{app})$ rule
(and consequently each $N_i$ must be safe).



We are now in a position to define a notion of reduction for safe terms.

\begin{definition}[Safe reduction $\beta_s$] \
\label{dfn:safereduction} The following
abbreviations are used $\overline{x} = x_1 \ldots x_n$,
$\overline{N} = N_1 \ldots N_l$, and when $n\geq l$, $\overline{x_L}
= x_1 \ldots x_l$, $\overline{x_R} = x_{l+1} \ldots x_n$.
\begin{itemize}
\item The relation $\beta_s$ is defined on the set of safe redex as follows:
\begin{eqnarray*}
\beta_s &=&
\{  \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}} \mbox{, for $n> l$}
\} \\
&\cup&
\{ \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l
\mbox{, for $n\leq l$} \} \ .
\end{eqnarray*}

\item
The safe $\beta$-reduction, written $\betasred$, is the closure of
the relation $\beta_s$ by compatibility with the formation rules of
the Safe $\lambda$-Calculus.
\end{itemize}
\end{definition}

\noindent \emph{Remark:} The $\beta_s$-reduction is a multi-step $\beta$-reduction i.e. $\betared \subset \betasred \subset \betaredtr$\ .


\begin{lemma}[$\beta_s$ reduction preserves safety]
\label{lem:homoh_safered_preserve_safety}
If $\Gamma \vdash s$ and $s \betasred t$ then $\Gamma \vdash t$.
\end{lemma}

\begin{proof}
It suffices to show that the relation $\beta_s$ preserves safety.
Consider the safe-redex $ s \equiv (\lambda x_1 \ldots x_n . M) N_1 \ldots N_l $ such that
$s\ \beta_s\ t$ for some simply typed term $t$.
Without lose of generality we can assume that the last rule used to form the term $s$ is {\sf(app)} i.e. not the weakening rule
{\sf(wk)}. Hence we have $\Gamma = fv(s)$.

By lemma \ref{lem:subst_preserve_safety}, $T\subst{\overline{N}}{\overline{x_L}}$ is safe.
By lemma \ref{lem:ordfreevar}, all variables in $\Gamma$ have order greater than $\ord{s} = \ord{t}$. Therefore
if $n>l$ then we can use the {\sf(abs)} rule to form $\Gamma \vdash t \equiv \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}}$
and if $n \leq l$ we can use the {\sf(app)} rule to form $\Gamma \vdash t \equiv  T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l$.
\qed
\end{proof}


\subsection{Safe $\lambda$-Calculus and Safe Higher-order Grammars}
It is possible to show equivalence of the $\lambda$-calculus formulation of Safety and the
safety restriction for higher-order grammars from \cite{KNU02}.
\begin{definition}[Higher-order grammar]
A \emph{higher-order grammar} is a tuple $G =
\langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$, where
\begin{itemize}
\item $\Sigma$ is a ranked alphabet of terminals of order at most 1,
\item $V$ is a finite set of typed variables,
\item $\mathcal{N}$ is a finite set of non-terminals,
\item $S$ a distinguished symbol of $\mathcal{N}$ of ground type, called the start symbol,
\item $\mathcal{R}$ is a finite set of production rules, one for each $F : (A_1, \ldots, A_n, o) \in N$, of the form
$ F z_1 \ldots z_m \rightarrow e$
where $z_i$ is a variable of type $A_i$ and $e$ is an applicative
term of type $o$ in $\mathcal{N}(\Sigma \union \mathcal{N} \union
\{z_1 \ldots z_m \} )$. The $z_i$s are called the \emph{parameters}
of the rule.
\end{itemize}
\end{definition}
The order of a rewrite rule is the order of the non-terminal symbol
appearing on the left hand side of the rule. The order of a grammar
is the highest order of its non-terminals.
The grammar is homogenous if the non-terminals in $\mathcal{N}$ have all homogeneous types.


The original notion of safety is defined in \cite{KNU02} as follows:
\begin{definition}[Safe higher-order grammars]
  A rewrite rule $F z_1 \ldots z_m \rightarrow e$ is said to be \emph{unsafe} if $e$ has a subterm $t$ such that:
  \begin{enumerate}
    \item $t$ occurs in an operand position in $e$,
    \item $t$ is of order $k>0$,
    \item $t$ contains a parameter of order strictly less than $k$.
  \end{enumerate}
An homogeneous grammar is \emph{safe} if all its production rules are safe.
\end{definition}


The equivalence of this definition of Safety and the formulation via the Homogeneous $\lambda$-calculus is shown in \cite{demirandathesis}:
\begin{proposition} Let $G = \langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$ be a grammar.
A rule $F z_1 \ldots z_m \rightarrow e$ in $\mathcal{R}$ is safe if and only if
$ z_1 \ldots z_m \vdash r : o$
is a valid typing judgement (without abstraction) of the \emph{homogeneous} Safe $\lambda$-calculus.
\end{proposition}


The reader is referred to \cite{KNU02,demirandathesis,safety-mirlong2004}
for details about the safety restriction for higher-order grammars.









\section{Computation tree, Traversals and Correspondence}
\label{sec:correspondence}

In this section we introduce the notion of computation tree of a term and
define traversals over the computation tree. These notions were firstly introduced in \cite{OngLics2006}. We adapt
them to the context of the $\lambda$-calculus and we state the \emph{Correspondence Theorem} (Theorem \ref{thm:correspondence}).
We will make use of this result in the next section when we study the Game Semantics of Safety.

In the following, we consider the general setting of the simply typed
$\lambda$-calculus extended with a fixed set $\Sigma$ of
higher-order constants.


\subsection{Computation Tree}

The $\eta$-long normal form of a term is obtained by hereditarily $\eta$-expanding every
subterm occurring at an operand position.
It appeared in \cite{DBLP:journals/tcs/JensenP76} and
\cite{DBLP:journals/tcs/Huet75} under the names \emph{long reduced
form} and \emph{$\eta$-normal form} respectively. It was then
investigated in \cite{huet76} under the name \emph{extensional form}.

\begin{definition}[$\eta$-long normal form]
A simply typed term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a $\Sigma$-constant or an abstraction.
The $\eta$-long normal form of $M$ written $\aux{M}$ is defined as follows:
\begin{eqnarray*}
\aux{\lambda x . s } &=& \lambda x . \aux{s} \\
\aux{\alpha s_1 \ldots s_p : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . \alpha \aux{s_1}\ldots \aux{s_p} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{(\lambda x . s) s_1 \ldots s_m : (A_1,\ldots,A_n,o) } &=& \lambda \overline{\varphi} . (\lambda x . \aux{s}) \aux{s_1} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n}
\end{eqnarray*}
where $n,p \geq 0$, $m\geq1$, $x$ is a variable, $\alpha$ is
either a variable or a constant and each $\varphi_i : A_i$ is a fresh variable.
\end{definition}

\begin{remark}
Converting a term to its $\eta$-long normal form does not introduce new redex and therefore
the $\eta$-long normal form of $\beta$-normal term is a $\beta$-normal term.
\end{remark}

Computation trees were proposed in \cite{OngLics2006} for the purpose of studying the infinite tree structures generated by higher-order grammars. The computation tree of a grammar is defined as the unravelling of a finite graph representing the long transform of a grammar. Similarly, we define the computation tree of a $\lambda$-term to be the abstract syntax tree of its $\eta$-long normal form.

\emph{Notation for labelled-trees:} We write $[l](t_1, \ldots, t_n)$ to denote the tree with a root labelled $l$ and with $n$ children subtrees $t_1$, \ldots, $t_n$. We write $[l]$ for the single node tree labelled $l$. If $t = [l](t')$, i.e. the root has a single child, then $t^-$ denotes the tree $t'$ (the tree obtained after deleting the root).


\begin{definition}[Computation tree]
Let $\mathcal{V}$ denotes the countable set of variables. We fix a set of node labels
$ L = \Sigma \union \{ @ \} \union \mathcal{V} \union \{ \lambda x_1 \ldots x_n : x_1 ,\ldots, x_n \in \mathcal{V} \}$.


The \emph{computation tree} of a simply typed term $M$ written $\tau(M)$ is
a $L$-labelled tree defined from its $\eta$-normal form as follows:
\begin{eqnarray*}
  \mbox{for $n\geq0$, } \tau(\lambda x_1 \ldots x_n . s) &=& [\lambda x_1 \ldots x_n](\tau(s)^{-}) \\
  \mbox{for $m\geq0$, } \tau( \alpha s_1 \ldots s_m : o) &=& [ \lambda ]([\alpha](\tau(s_1),\ldots,\tau(s_m)))\\
  \mbox{for $m \geq 1$, } \tau((\lambda x.s_0) s_1 \ldots s_m :o) &=& [\lambda] ([@](\tau(\lambda x.s),\tau(s_1),\ldots,\tau(s_m)))
\end{eqnarray*}
where $s$ is not an abstraction and $\alpha$ is a variable or a constant.
\end{definition}

At even levels there are the $\lambda$-nodes. A single $\lambda$-node can represent several consecutive variable abstractions or it can just be
a \textsl{dummy lambda} if the corresponding subterm is of ground type.
At odd levels, there are the variable and constant nodes and the application nodes labelled @.

We say that a node $n$ is bound by the node $m$, and $m$ is called the
\defname{binder} of $n$, if $m$ is the closest node in the path from $n$ to
the root of the tree such that $m$ is labelled $\lambda
\overline{\xi}$ with $x\in \overline{\xi}$.


We now fix a term $M$. We abbreviate $\tau(M)$ into $\tau$ and we write
$N$ for the set of nodes of $\tau$, $N_\Sigma$ for the set of $\Sigma$-labelled nodes,
$N_@$ for the set of @-labelled nodes, $N_{var}$ for the set of variable nodes and
$N_{fv}$ for the subset of $N_{var}$ constituted of free-variable nodes.

For $n \in N$, we write $\kappa(n)$ to denote the subterm of $\aux{M}$
corresponding to the subtree of $\tau$ rooted at $n$.
In particular if $\tau = [r](\ldots)$ then $\kappa(r) = \aux{M}$.

The \defname{order} of the root node is $\ord{\lambda \overline{x} . M}$ where $\overline{x} = fv(M)$ and for
a node $n$ different from the root, $\ord{n} = \ord{\kappa(n)}$.


\subsection{Pointers and Justified Sequence of Nodes}

We define the \defname{enabling relation} on the set of nodes of the
computation tree as follows: $m$ enables $n$, written $m \vdash n$, if and only if
$n$ is a variable node bound by $m$ (we write $m \vdash_i n$ to precise that $n$ is the $i^{\sf th}$ variable bound by $m$),
or $n$ is a free variable node and $m$ is the root of the computation tree,
or $n$ is a $\lambda$-node and $m$ is its parent node.

We call \defname{input-variable} a variable that is hereditarily justified by the root of the computation tree.
Free variables and variables bound by the root are example of input-variables.

A \defname{justified sequence of nodes} is a sequence of
nodes with pointers such that each variable node $n$ lambda-node $n$ different from the root
has a pointer to a node $m$ occurring before it the sequence such that $m \vdash n$.
We represent the pointer in the sequence as follows
\raisebox{0cm}[0.6cm]{$\rnode{m}{m} \cdot \ldots \cdot \rnode{n}{n} \bkptr[nodesep=1pt]{35}{n}{m} \bklabel{i}$}.
where the label indicates either that $n$ is labelled with the $i$th
variable abstracted by the $\lambda$-node $m$ or that $n$ is the
$i^{\sf th}$ child of $m$.  We use the following numbering conventions: the first child of a @-node is numbered $0$,
the first child of a variable or constant node is numbered $1$ and variables in $\overline{\xi}$ are numbered from $1$ onward
($\overline{\xi} = \xi_1 \ldots \xi_n$). The $i^{\sf th}$ child of $n$ is denoted by $n.i$.

We say that a node $n_0$ of a justified sequence is \defname{hereditarily justified} by $n_p$ if there are nodes $n_1, n_2, \ldots n_{p-1}$ in
the sequence such that $n_i$ points to $n_{i+1}$ for all $i\in 0..p-1$.

The notion of \defname{P-view} of a justified sequence of nodes $t$
is defined the same way as the P-view of a justified sequences of moves in Game Semantics:\footnote{
The equalities in the definition determine pointers implicitly. For instance in the second clause, if in the
left-hand side, $n$ points to some node in $s$ that is also present
in $\pview{s}$ then in the right-hand side, $n$ points to this
occurrence of the node in $\pview{s}$.}
$$\begin{array}{rclrcl}
\pview{\epsilon} &=&  \epsilon
& \pview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{lmd}{\lambda \overline{\xi}}} &=& \pview{s} \cdot \rnode{m2}{m} \cdot \rnode{lmd2}{\lambda \overline{\xi}}   \bkptr[nodesep=1pt]{30}{lmd}{m}    \bkptr[nodesep=1pt]{60}{lmd2}{m2}\\
\pview{s \cdot n }  &=&  \pview{s} \cdot n \qquad
& \pview{s \cdot r }  &=&  r
\end{array}$$


%\begin{align*}
%\pview{\epsilon} &=&  \epsilon
%& \pview{s \cdot n }  &=&  \pview{s} \cdot n  \\
%\pview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{lmd}{\lambda \overline{\xi}}} &=& \pview{s} \cdot \rnode{m2}{m} \cdot \rnode{lmd2}{\lambda \overline{\xi}}   \bkptr[nodesep=1pt]{30}{lmd}{m}    \bkptr[nodesep=1pt]{60}{lmd2}{m2}
%& \pview{s \cdot r }  &=&  r
%\end{align*}
where $r$ is the root of the tree $\tau$ and $n$ ranges over non-lambda nodes.


The O-view is defined to be the dual notion of P-view.
We borrow the game semantic terminology to qualify justified sequences of nodes:
$s$ satisfies \emph{alternation} if for any two consecutive nodes in $s$, one is a $\lambda$-node
and the other is not and \emph{P-visibility} if every variable node in $s$ points to a node occurring in the P-view a that point.

\subsection{Computation Tree with Value-leaves}
\label{sec:adding_value_leaves}

We now add \defname{value-leaves} to the computation tree. Each
value-leaf corresponds to a possible value of the base type $o$.
We write $\mathcal{D}$ to denote the set of values of the base type
$o$. The values leaves are added as follows: every
node $n \in \tau(M)$ has a child leaf denoted by $v_n$ for each possible value $v \in \mathcal{D}$.

Everything that we have defined for computation tree can be lifted
to this new version of computation tree. A value-leaf has order $0$. The enabling relation $\vdash$ is
extended so that every leaf is enabled by its parent node.
A link going from a value-leaf $v_n$ to a node $n$ is labelled by $v$:
\raisebox{0cm}[0.6cm]{$\rnode{n}{n} \cdot \ldots \cdot \rnode{vn}{v_n} \bkptr[nodesep=1pt]{40}{vn}{n} \bklabel{v}$}.
For the definition of P-view and visibility, value-leaves are treated as
$\lambda$-nodes if they are at odd level in the computation tree and
as variable nodes if there at a even level.

If there is an occurrence of a value-leaf $v_n$ in the sequence that points to $n$ we say that
$n$ is \emph{matched} by $v_n$. If there is no value-leaf in the sequence that points to $n$ we
say that $n$ is an \emph{unmatched node}.
The last unmatched node is called the \emph{pending node}.
A justified sequence of nodes is \emph{well-bracketed} if each value-leaf in the traversal points to the pending node at that point.

If $t$ is a traversal then we write $?(t)$ to denote the subsequence of $t$ consisting only of unmatched nodes.

\subsection{Traversals of the Computation Tree}
\label{subsec:traversal}

A \emph{traversal} is a justified sequence of nodes of the computation tree where each node
indicates a step that is taken during the evaluation of the term.
\begin{definition}[Traversals]
\label{def:traversal}
For a simply typed $\lambda$-term $M$ without interpreted constants,
the set $\travset(M)$ of \defname{traversals} over $\tau(M)$ is defined by induction over the following rules.

\noindent {(\bf Empty)} The empty sequence $\epsilon$ is a traversal.

\noindent {\bf (Root)} The length 1 sequence constituted of the root of $\tau(M)$ is a traversal.

\noindent {\bf (Lam)} If $t \cdot \lambda \overline{\xi}$ is a traversal then so is
$t \cdot \lambda \overline{\xi} \cdot n$
where $n$ is the only child of $\lambda \overline{\xi}$ and $n$ points to the only occurrence of its enabler in $t$ that is still present in $\pview{t \cdot \lambda \overline{\xi}}$.

\noindent {\bf (App)} If $t \cdot @$ is a traversal then so is $t \cdot \rnode{m}{@} \cdot \rnode{n}{n} \bkptr[nodesep=1pt]{60}{n}{m} \bklabelc{0}$.

\noindent {\bf (InputVar$^0$)} If $t = t_1 \cdot x \cdot t_2$ is a traversal where
$x$ is the pending node in $t$ (i.e. $?(t_2)=\epsilon$)
and $x$ is a ground-type input-variable then for any $v \in \mathcal{D}$,
\raisebox{0cm}[0.6cm]{$t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot \rnode{xv}{v_x}
\bkptr[nodesep=1pt]{40}{xv}{x} \bklabelc{v}$} is also a traversal.

\noindent {\bf (InputVar$^{\geq 1}$)} If $t = t_1 \cdot x \cdot t_2$ is a traversal where
$x$ is the pending node in $t$ (i.e. $?(t_2)=\epsilon$)
and $x$ is a higher-order input-variable then
for $1 \leq i \leq arity(x)$, \raisebox{0cm}[0.6cm]{$t_1 \cdot \rnode{m}{x} \cdot t_2 \cdot
\rnode{n}{n} \bkptr[nodesep=1pt]{40}{n}{m} \bklabelc{i}$} is a traversal
and for $v\in \mathcal{D}$, \raisebox{0cm}[0.6cm]{$t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot
\rnode{xv}{v_x} \bkptr[nodesep=1pt]{40}{xv}{x} \bklabelc{v}$} is a traversal.

\noindent {\bf (CCAnswer-@)}
  If $t \cdot \rnode{app}{@} \cdot \rnode{lz}{\lambda \overline{z}}  \ldots  \rnode{lzv}{v_{\lambda \overline{z}}}
              \bkptr[nodesep=1pt]{30}{lzv}{lz} \bklabelc{v}
              \bkptr[nodesep=1pt]{40}{lz}{app} \bklabelc{0}$
              is a traversal then so is
              \raisebox{0cm}[0.6cm]{$t \cdot \rnode{app}{@} \cdot \rnode{lz}{\lambda \overline{z}}  \ldots  \rnode{lzv}{v_{\lambda \overline{z}}} \cdot \rnode{appv}{v_@}
              \bkptr[nodesep=1pt]{25}{lzv}{lz} \bklabelc{v}
              \bkptr[nodesep=1pt]{40}{lz}{app} \bklabelc{0}
              \bkptr[nodesep=1pt]{25}{appv}{app} \bklabelc{v}$}.

\noindent {\bf (CCAnswer-$\lambda$)} If \raisebox{0cm}[0.5cm]{$t \cdot \lambda \overline{\xi} \cdot \rnode{x}{x}  \ldots   \rnode{xv}{v_x}
              \bkptr[nodesep=1pt]{30}{xv}{x} \bklabelc{v}$}
              is a traversal then so is
              \raisebox{0cm}[0.6cm]{$t \cdot \rnode{lmd}{\lambda \overline{\xi}} \cdot \rnode{x}{x}  \ldots  \rnode{xv}{v_x} \cdot
              \rnode{lmdv}{v_{\lambda \overline{\xi}}}
              \bkptr[nodesep=1pt]{20}{xv}{x} \bklabelc{v}
                \bkptr[nodesep=1pt]{20}{lmdv}{lmd} \bklabelc{v}$}.

\noindent {\bf (CCAnswer-var)} If \raisebox{0cm}[0.5cm]{$t \cdot y \cdot \rnode{lmd}{\lambda \overline{\xi}}
                   \ldots \rnode{lmdv}{v_{\lambda \overline{\xi}}} \bkptr[nodesep=1pt]{30}{lmdv}{lmd} \bklabelc{v}$} is a traversal,
                   where $y$ is a non input-variable node, then so is
        \raisebox{0cm}[0.6cm]{$t \cdot \rnode{y}{y}
            \cdot \rnode{lmd}{\lambda \overline{\xi}}
             \ldots
             \rnode{lmdv}{v_{\lambda \overline{\xi}}}
            \cdot \rnode{yv}{v_y}
                \bkptr[nodesep=3pt]{25}{yv}{y} \bklabelc{v}
                \bkptr[nodesep=1pt]{25}{lmdv}{lmd} \bklabelc{v}$}.

\noindent {\bf (Var)}
If  \raisebox{0cm}[0.5cm]{$t' \cdot \rnode{n}{n} \cdot
    \rnode{lx}{\lambda \overline{x}}  \ldots
    \rnode{x}{x_i}  \bkptr[ncurv=0.6]{50}{x}{lx} \bklabel{i}$} is a traversal where $x_i$ is not an input-variable then so is
\raisebox{0cm}[0.6cm]{
    $t' \cdot \rnode{n}{n} \cdot
    \rnode{lx}{\lambda \overline{x}}  \ldots
    \rnode{x}{x_i} \cdot
    \rnode{letai}{\lambda \overline{\eta_i}}
    \bkptr[ncurv=0.45]{45}{letai}{n} \bklabelc{i}
    \bkptr[ncurv=0.5]{45}{x}{lx} \bklabelc{i}$}.
\end{definition}

\begin{wrapfigure}[7]{r}{4.3cm}
$\rput[t](2.1cm,1cm){\tree{\lambda} {
    \tree{@}{
        \pstree[linestyle=dotted]{\TR{\lambda y}\treelabel{0} }{
            \tree{y}{
                \tree{\lambda \overline{\eta_1}}{\vdots}% \treelabel{1}
                \tree{\lambda \overline{\eta_i}}{\vdots}%\treelabel{i}
                \tree{\lambda \overline{\eta_n}}{\vdots}%\treelabel{n}
            }
        }
        \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}\treelabel{1}}{ \tree{x_i}{\TR{} \TR{} } }
    }
}}$
\end{wrapfigure}

A traversal always starts by visiting the root and then continues by mainly following the structure of the tree.
The (Var) rule permits the traversal to jump across the computation tree. The idea is that after visiting a variable node $x$,
it can jump to the node corresponding to the subterm that would be substituted for $x$ if all the $\beta$-redexes occurring in the term were reduced.
For example the sequence \raisebox{0cm}[0.5cm]{$ \lambda \cdot
\rnode{app}{@}  \cdot
\rnode{ly}{\lambda y} \cdot \ldots \cdot
\rnode{y}{y} \cdot
\rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
\rnode{x}{x_i} \cdot
\rnode{leta}{\lambda \overline{\eta_i} } \cdot \ldots
\bkptr[ncurv=0.6,nodesep=0]{40}{x}{lx}  \bklabel{i}
\bkptr[ncurv=0.5]{50}{leta}{y}  \bklabel{i}
\bkptr[ncurv=0.6,nodesep=0]{40}{y}{ly}  \bklabel{1}
\bkptr[ncurv=0.5]{50}{lx}{app}  \bklabel{1}$} is a traversal of the computation tree shown on the right.

\begin{remark}
There is no special treatment for uninterpreted constants since we can just regard them as free variables.
Consequently, there is no restriction on the order of these constants. This differs from \cite{OngLics2006} which deals
with computations generating tree structures and therefore requires the order of constants to be at most $1$.
Another difference is the presence of value-leaves in the computation trees.
\end{remark}

\begin{proposition}
\label{prop:pviewtrav_is_path}
Let $t$ be a traversal. Then:
\begin{itemize}
\item[(i)] $t$ is a well-defined and well-bracketed justified sequence;
\item[(ii)] $?(t)$ is a well-defined justified sequence verifying alternation, P-visibility and O-visibility;
\item[(iii)] $\pview{?(t)}$ is a path in the computation tree going from the root to the last node in $?(t)$.
\end{itemize}
\end{proposition}
This is the counterpart of proposition 6 from
\cite{OngHoMchecking2006} which is proved by induction on the
traversal rules.

The \defname{reduction} of a traversal $t$ written $ t \upharpoonright r$,
where $r$ is the root of the computation tree, is the subsequence of $t$
obtained by keeping only the nodes that are hereditarily
justified by $r$. This subsequence is also a justified sequence of nodes.
The effect of this operation is to eliminate the ``internal nodes'' of the computation.

Application nodes were necessary to connect the operator and
the operand of an application in the computation tree. However, they do not play
any role in the computation of the term, and therefore
they can be removed from the traversals.
We write $t-@$ for the sequence of nodes with pointers obtained by
removing from $t$ all @-nodes and value-leaves of @-nodes,
any link pointing to an @-node being replaced by a link pointing to the immediate predecessor of @ in $t$.

We introduce the notations $\travset(M)^{-@} = \{ t - @ \ | \  t \in \travset(M) \}$ and $\travset(M)^{\upharpoonright r} = \{ t  \upharpoonright r \ | \  t  \in \travset(M) \}$ where $r$ denotes the root of $\tau(M)$.
\begin{remark}
The computation tree of a $\beta$-normal term does not contain any @-node, therefore all the nodes are
hereditarily justified by the root and we have $\travset(M)^{-@} \cong \travset(M) \cong  \travset(M)^{\upharpoonright r }$.
\end{remark}





\begin{lemma}[View of a traversal reduction]
\label{lem:redtrav_trav} Let $M$ be a term in $\beta$-normal form,
$r$ be the root of $\tau(M)$ and $t$ be a traversal of $\tau(M)$. We
have
\begin{itemize}
\item[(i)] $ \pview{?(t) \upharpoonright  r } = \pview{?(t)} \upharpoonright r$;
\item[(ii)] if the last node in $t$ is hereditarily justified by $r$ then $ \oview{?(t) \upharpoonright r } = \oview{?(t)}$.
\end{itemize}
\end{lemma}
The proof is by an easy induction.


\subsection{Relationship between Computation Tree and Game Arena}
We still work the general setting of the simply typed $\lambda$-calculus augmented with a set of higher-order constants $\Sigma$.
We assume that the language is equipped with a fully abstract model of well-bracketed games.
We choose the ``prefix-closed set of plays'' representation for strategies.
\footnote{In the literature, a strategy is commonly defined as a set of plays
closed by taking a prefix of \emph{even} length. However for the purpose of showing the correspondence with traversals, the ``prefix-closed'' version is more appropriate.}


We fix a term $\Gamma \vdash M : T$ and write $\sem{\Gamma \vdash M : T}$ for its strategy denotation.
The computation tree $\tau(M)$ is represented by a pair $(V,E)$ where $V$ is the set of vertices of
the trees and $E \subseteq V \times V$ is the parent-child relation. We have $V = N \union L$ where $N$ is the set of nodes and $L$ is the set of value-leaves.
We write $V_\$$  for $N_\$ \union (E(N_\$) \inter L) $ where $\$$ ranges over $\{@, var, \Sigma, fv \}$.

The elements of $E(n) \inter L$, the set value-leaves attached to the node $n$, are
written $v_n$ where $ v$ ranges over the set $\mathcal{D}$ of values of the base type $o$.
Similarly, the answer moves of a question $q$ are written $v_q$ where $v$ ranges in $\mathcal{D}$.

\begin{definition}[Partial map from nodes to moves]
\label{def:phi_procedure}
Let $A$ by an arena, $q$ a question move of $A$ and $n$ a node of $\tau$ such that $n$ and $q$ are of type
$(A_1,\ldots,A_p,o)$.
We have $\vdash( q ) = \{ q^1, \ldots, q^p \} \union \{  v_q \ | \ v \in \mathcal{D} \}$ where each $q^i$ corresponds to
the parameter type $A_i$. The (partial) function $f_A^{n,q}$ from $V$ to $A$ is defined as:
\begin{eqnarray*}
f_A^{n,q} &= \{ n \mapsto q \} \union  \{ v_n \mapsto v_q \ | \ v \in \mathcal{D} \} \union f'^{n,q}_{A} \\
f'^{n,q}_A &= \left\{
                \begin{array}{ll}
                  \emptyset, & \hbox{if $p=0$;} \\
                  \Union_{m \in N | n \vdash_i m} f_A^{m, q^i}, & \hbox{if $p\geq1$ and $n\in N_{\lambda}$;} \\
                  \Union_{i=1..p} f_A^{n.i, q^i}, & \hbox{if $p\geq1$ and $n\in N_{var}$.}
                \end{array}
              \right.
\end{eqnarray*}
Note that $f_A^{n,q}$ is undefined on nodes hereditarily justified by $N_{fv} \union N_@ \union N_\Sigma$.
\end{definition}


\begin{definition}[Total map from nodes to moves]
We write $q^0_A$ to denote the initial question of an arena $A$.\footnote{Arenas involved in the game semantics of pure simply typed $\lambda$-calculus have a single root.}
Let $r$ denote the root of $\tau(M)$.
For a closed term $\emptyset \vdash M : T$, the total function $\varphi_M$ from $V_\lambda \union V_{var}$ to $\sem{T} \uplus \biguplus_{n \in N \inter E \relimg{N_@ \union N_\Sigma} } \sem{type(\kappa(n))}$ is defined as:
$$
\varphi_M = f_{\sem{T}}^{r, q^0_{\sem{T}}}
\quad \union \quad
        \Union_{n \in N \inter E \relimg{N_@ \union N_\Sigma}}  f_{\sem{type(\kappa(n))}}^{n, q^0_{\sem{type(\kappa(n))}}}
$$

For an open term $x_1 : X_1, \ldots, x_n : X_n \vdash M : T$, the function $\varphi_M$ is defined as
$\varphi_{\lambda x_1 \ldots x_n . M}$. When there is no ambiguity we just write $\varphi$ instead of $\varphi_M$.
\end{definition}

\begin{example}
Consider the term $\lambda x . (\lambda g . g x) (\lambda y . y)$ with $x,y:o$ and $g:(o,o)$.
The diagram below represents the computation tree (middle), the arenas
$\sem{(o,o), o}$ (left), $\sem{o , o}$ (right), $\sem{o\rightarrow o}$ (rightmost)
and the function $\varphi = f_\sem{o , o}^{\lambda x, q_{\lambda x}} \union f_\sem{(o,o),o}^{\lambda g, q_{\lambda g}} \union f_\sem{o , o}^{\lambda y, q_{\lambda y}}$
(dashed-lines).
$$\psset{levelsep=3.5ex}
\pstree{\TR[name=root]{\lambda x}}
{
    \pstree{\TR[name=App]{@}}
    {
            \pstree{\TR[name=lg]{\lambda g}}
                { \pstree{\TR[name=lgg]{g}}{
                        \pstree{\TR[name=lgg1]{\lambda}}
                        { \TR[name=lgg1x]{x}  } } }
            \pstree{\TR[name=ly]{\lambda y}}
                    {\TR[name=lyy]{y}}
    }
}
\rput(5cm,-1cm){
  \pstree{\TR[name=A1lx]{q_{\lambda x}}}
        { \TR[name=A1x]{q_x} }
}
\rput(-6cm,-1.5cm){
    \pstree{\TR[name=A2lg]{q_{\lambda g}}}
    {
        \pstree{\TR[name=A2g]{q_g}}
        {  \TR[name=A2g1]{q_{g_1}}   }
    }}
\rput(2.5cm,-1.5cm){
    \pstree{\TR[name=A3ly]{q_{\lambda y}}}
        { \TR[name=A3y]{q_y}
        }
}
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{A1lx} \mput*{f(\lambda x, q_{\lambda x})}
\ncarc{->}{lgg1x}{A1x}
\ncline{->}{lg}{A2lg} \mput*{f(\lambda g, q_{\lambda g})}
\ncline{->}{lgg}{A2g}
\ncline{->}{lgg1}{A2g1}
\ncline{->}{ly}{A3ly} \mput*{f(\lambda y, q_{\lambda y})}
\ncline{->}{lyy}{A3y}
$$
\end{example}

\begin{remark}
$\varphi$ maps $\lambda$-nodes to O-questions, variable nodes to
P-questions, value-leaves of $\lambda$-nodes to P-answers and
value-leaves of variable nodes to O-answers.
Moreover $\varphi$ maps nodes of a given order to moves of the same order.
\end{remark}
If $t = t_0 t_1 \ldots$ is a justified sequence
of nodes in $V_\lambda \union V_{var}$ then $\varphi(t)$ is defined
to be the sequence of moves $\varphi(t_0)\ \varphi(t_1) \ldots$
equipped with the pointers of $t$.

\subsection{Interaction Semantics}
\label{sec:interaction_semantics}

In game semantics, strategy composition is achieved by performing a
CSP-like ``composition + hiding''. If the internal moves are not hidden
then we obtain an alternative semantics called \emph{interaction}
semantics in \cite{DBLP:conf/sas/DimovskiGL05} and \emph{revealed
semantics} in \cite{willgreenlandthesis}.
The \defname{revealed strategy} of a term $\Gamma \vdash M$, written $\intersem{\Gamma \vdash M}$, is obtained by uncovering\footnote{In Part II of \cite{hylandong_pcf} an algorithm is described that
uniquely recover the moves hidden during composition.} the
internal moves from $\sem{\Gamma \vdash M}$ that are generated by the composition with the evaluation map $ev$ at each @-node of the computation tree.
The standard semantics can be recovered from the interaction semantics by filtering out the internal moves.


\subsection{The Correspondence Theorem}

In the pure simply typed $\lambda$-calculus without constants\footnote{To handle the case of a $\lambda$-calculus with \emph{uninterpreted} constants, it suffices to
consider constants as being free variables.} we have the following theorem which
states that the set of traversals of the computation tree is isomorphic to the set of uncovered plays of the strategy
denotation of the term.
\begin{theorem}[The Correspondence Theorem]
\label{thm:correspondence}
\begin{eqnarray*}
 \varphi_M  &:& \travset(M)^{\upharpoonright r} \stackrel{\cong}{\longrightarrow} \sem{\Gamma \vdash M} \\
 \varphi_M  &:& \travset(M)^{-@} \stackrel{\cong}{\longrightarrow} \intersem{\Gamma \vdash M} \ .
\end{eqnarray*}
\end{theorem}
This theorem is the counterpart of the ``Path-Traversal Correspondence'' of \cite{OngLics2006}.

\begin{example}
Consider the term $M \equiv \lambda f z . (\lambda g x . f x) (\lambda y. y) (f z)$ of type $(o,o),o, o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f x) (\lambda y. y) (\lambda . f z)$.
The figure below represents the computation tree (left) and the
arena (right). The partial function $\varphi_M$
is represented in dashed line. For clarity we omit answers moves when representing arenas.
$$
\tree{ \Rnode{root} {\lambda f z}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}{ 
                  \tree{\Rnode{f}{f^{[6]}}}{  
                            \tree{\Rnode{lmd}\lambda^{[7]}}
                            {\TR{x^{[8]}}}  
                  }
                }
            \tree{ \lambda y ^{[4]}  }{\TR{y}}
            \tree{\lambda ^{[5]}}{
                \tree{\Rnode{f2}{f^{[9]}}} {
                \tree{\Rnode{lmd2}\lambda^{[10]}}{\TR{\Rnode{z}z^{[11]}}}
                }
            }
        }
     }
\hspace{3cm}
  \tree[levelsep=11ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
        \TR{\Rnode{q5}q^5}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{z}{q2}
\ncline{->}{f}{q3}
\ncline{->}{lmd}{q4}
\ncline{->}{f2}{q3}
\ncline{->}{lmd2}{q4}
$$

The traversal \raisebox{0cm}[0.6cm]{$\rnode{q1}{\lambda f
z} \cdot \rnode{n2}{@^{[2]}} \cdot \rnode{n3}{\lambda g x^{[3]}}
\cdot \rnode{q3}{f}^{[6]} \cdot \rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f}^{[8]} \cdot \rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{n8}{x^{[10]}} \cdot \rnode{n9}{\lambda^{[5]}} \cdot
\rnode{q2}{z}
\bkptr[ncurv=0.6]{50}{q3}{q1}
\bkptr[ncurv=1]{50}{q4}{q3}
\bkptr[ncurv=0.4]{75}{q3b}{q1}
\bkptr[ncurv=0.8]{70}{q4b}{q3b}
\bkptr[ncurv=0.4]{65}{q2}{q1}
\bkptr[ncurv=0.4]{50}{n3}{n2}
\bkptr[ncurv=0.4]{50}{n8}{n3}
\bkptr[ncurv=0.4]{50}{n9}{n2}$} has for reduction \raisebox{0cm}[0.8cm]{$\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f}^{[6]} \cdot \rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f}^{[8]} \cdot \rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z} \bkptr[ncurv=1]{60}{q3}{q1} \bkptr[ncurv=1]{60}{q4}{q3} \bkptr[ncurv=0.5]{75}{q3b}{q1} \bkptr[ncurv=1]{50}{q4b}{q3b}
\bkptr[ncurv=0.4]{80}{q2}{q1}$} which
$\varphi$ maps to the play
\raisebox{0cm}[0.6cm]{$\rnode{q1}{q}^1\ \rnode{q3}{q}^3\ \rnode{q4}{q}^4\ \rnode{q3b}{q}^3\ \rnode{q4b}{q}^4\ \rnode{q2}{q}^2
\bkptr[offset=-3pt]{60}{q3}{q1}
\bkptr[offset=-3pt,ncurv=0.5]{60}{q3b}{q1}
\bkptr[offset=-3pt]{60}{q4}{q3}
\bkptr[offset=-3pt]{60}{q4b}{q3b}
\bkptr[offset=-3pt,ncurv=0.5]{60}{q2}{q1}$} of
$\sem{M}$.
\end{example}

\section{Game-semantic Characterisation of the Safe $\lambda$-Calculus}

Game Semantics being by essence syntax-independent, it seems vain to look for a
game-semantic account of a syntactical constraint such as Safety.
But thanks to the Correspondence Theorem, we can interpret plays of a strategy as
sequences of nodes of some AST of the term, thus
the impact of the Safety restriction on Game Semantics can be revealed.

\begin{definition}[Incrementally-justified strategy]
A strategy $\sigma$ is said to be \emph{incrementally-justified}
if for any play $s q \in \sigma$ where $q$ is a question
move we have:
\begin{eqnarray*}
s q \in \sigma \wedge |s| \mbox{ even } &\imp& \parbox[t]{8cm}{$q$ points to the last P-move in $\oview{?(s)}$ with order strictly greater than $\ord{q}$;} \\
s q \in \sigma \wedge |s| \mbox{ odd } &\imp&
\parbox[t]{8cm}{$q$  points to the last O-move in $\pview{?(s)}$
with order strictly greater than $\ord{q}$.}
\end{eqnarray*}
where $?(s)$ denotes the subsequence of $s$ consisting of the unanswered questions.
\end{definition}

\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} Pointers are
superfluous for incrementally-justified strategies.
\end{lemma}

\begin{example}
Consider the evaluation map $ev : (A^1 \Rightarrow B^2) \times  A^1 \rightarrow B^1$.
The play $s = q_0^{B^1} q_1^{B^2} q_2^{A^1} q_3^{A^2}$ is in $\sem{ev}$. We have $\ord{q_3} = \ord{A}$,
$\ord{q_2} = \ord{A}$, $\ord{q_1} = \max( 1+\ord{A}, \ord{B})$ and
$\ord{q_0} = 1 + \ord{q_1}$. Since the last O-move in $?(\pview{s})= s$
with order strictly greater than $\ord{q_3}$ is $q_1$ and $q_3$ points to $q_0$, $\sem{ev}$ is not incrementally-justified.
\end{example}

A binder node always occurs in the path from the bound node to the root.
We now introduce a class of computation tree in which the binder node is uniquely determined by the node orders.
\begin{definition}[Incrementally-binding]
A variable node $x$ of a computation tree is said to be
\emph{incrementally-bound} if either:
\begin{enumerate}
\item $x$ is \emph{bound} by the first $\lambda$-node in the path to the root that has
order strictly greater than $\ord{x}$.
\item $x$ is a \emph{free variable} and all the $\lambda$-nodes in the path to the root except the root have order
smaller or equal to $\ord{x}$.
\end{enumerate}
A computation tree is said to be \emph{incrementally-bound} if all
the variable nodes are incrementally-bound.
\end{definition}


\begin{proposition}[Incremental-binding and incremental-justification]
\label{prop:incrbound_imp_incrjustified}
\begin{enumerate}
\item[(i)] A term in $\beta$-normal form with an incrementally-bound computation tree is denoted by an incrementally-justified strategy.
\item[(ii)] Reciprocally, in the $\lambda$-calculus without interpreted constants, if a term is denoted by an incrementally-justified strategy then the computation tree of its $\beta$-normal is incrementally-bound.
\end{enumerate}
\end{proposition}

%\parpic(0.5cm,2cm)(5pt,0.75cm)[x]{ $\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$ }
%\parpic(0.5cm,1cm)(0.1pt,0.2cm)[r]{ $\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$ }
%\parpic(0.3cm,1cm)[r]{ \rput[t](0,0cm){$\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}$} }
%%%  ah Latex... i hate you !!!
%\begin{floatingfigure}[r]{60mm}
%$%\rput[t](0cm,0cm)
%{\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
%\end{floatingfigure}

\begin{wrapfigure}[5]{r}{0.6cm}
$\rput[b](0.1cm,-1cm)
{\tree{\lambda^3}{\tree{f^2}{ \tree{\lambda y^1}{ \TR{x^0} }}}}$
\end{wrapfigure}
\noindent \emph{Example:} %\begin{example}
Consider the $\beta$-normal term $f (\lambda y .x)$ where $x,y:o$ and $f:(o,o),o$. The figure on
the right represents the computation tree with the node orders given in exponent.
Node $x$ is not incrementally-bound therefore $\tau$ is not incrementally-bound and
by proposition \ref{prop:incrbound_imp_incrjustified}, $\sem{f (\lambda
y .x)}$ is not incrementally-justified (although $\sem{f}$ and $\sem{\lambda y. x}$ are).
%\end{example}

\begin{lemma}[Safety and incremental-binding]
\label{lem:safe_imp_incrbound}
The computation tree of a a safe simply typed term is incrementally-bound.
Reciprocally, a \emph{closed} simply typed term with an incrementally-bound computation tree has a safe $\eta$-normal form.
\end{lemma}

Note that the hypothesis that $M$ is closed in (ii) is necessary.
For instance, the two terms $\lambda x y .x$ and $\lambda y . x$,
where $x,y:o$, have (isomorphic) incrementally-bound computation
trees. However $\lambda x y .x$ is safe whereas $\lambda y . x$ is
not.



Putting proposition \ref{prop:incrbound_imp_incrjustified} and lemma
\ref{lem:safe_imp_incrbound} together we obtain:
\begin{corollary}[Safety and incremental-justification]
A closed closed simply typed term without constants has an
incrementally-justified denotation if and only the $\eta$-normal form of
its $\beta$-normal form is safe.
\end{corollary}

\begin{theorem}
\label{thm:safe_ptr_recoverable} Pointers in the game semantics of
Safe $\lambda$-terms (without interpreted constants) are uniquely recoverable from the underlying sequences of moves.
\end{theorem}
\begin{proof}
Let $M$ be a safe simply typed term. Its $\beta$-normal form $M'$
is also safe. By lemma \ref{lem:safe_imp_incrbound}
(i), $\tau(M')$ is incrementally-bound and by proposition
\ref{prop:incrbound_imp_incrjustified}, $\sem{M'}$ is an
incrementally-justified strategy. By lemma
\ref{lem:incrjustified_pointers_uniqu_recover}, the pointers in
$\sem{M'}$ are uniquely recoverable. Finally, the soundness of the
game model gives $\sem{M} = \sem{M'}$.
\qed
\end{proof}

\begin{example} If justification pointers are omitted, the two Kierstead terms from example \ref{ex:kierstead} have
the same donation. In the Safe $\lambda$-Calculus the ambiguity disappears since $M_1$ is safe whereas $M_2$ is not.
\end{example}


\section{Safe \pcf}

\pcf\ is the $\lambda$-calculus augmented with integer constants of ground type, first-order arithmetic operators, if-then-else branching
and a family of recursion combinator $Y_A : (A \typear A) \typear A$ for any type $A$.
Safe \pcf\ is \pcf\ where the application and abstraction rules are restricted as in the Safe $\lambda$-Calculus.
It inherits the good properties of the Safe $\lambda$-Calculus: no variable capture occurs when performing substitution on a safe term and Safety is preserved by the reduction rules of the small-step semantics of \pcf\ constants.

It is possible to extend the game-semantics characterisation result to Safe \pcf.
To handle the $Y$ combinators, we use \emph{syntactic approximants} \cite{abramsky:game-semantics-tutorial}.
We define the computation tree of a \pcf\ term $M$ to be the least upper-bound of
the chain of computation trees of its approximants.
In other words, the computation tree is obtained by expanding
infinitely any subterm of the form $Y M$. For instance the computation tree
of $M = Y (\lambda f x. f x)$ where $f:(o,o)$ and $x:o$ is
the tree representation of the $\eta$-normal form of the infinite term
$(\lambda f x. f x) ((\lambda f x. f x) ((\lambda f x. f x)  (
\ldots$.


It is straightforward to define the traversal rules modeling the arithmetic constants of \pcf.
Just as in the Safe $\lambda$-calculus we had to remove @-nodes in order to reveal the
game-semantic correspondence, in Safe \pcf\ it is necessary to filter out the constant nodes from the traversals. The Correspondence Theorem for \pcf\ says that the interaction game semantics is isomorphic to the set of traversals disposed of these superfluous nodes. It is straightforward to show it for term approximants. The result is then lifted to any \pcf\ term by observing that the
function $\travset^{\upharpoonright r} : (CT,\sqsubseteq) \rightarrow (S,\subseteq)$ is continuous, where
$(S,\subseteq)$ denotes the set of sets of justified sequences of nodes ordered by subset inclusion
and $(CT,\sqsubseteq)$ denotes the set of computation trees ordered by the approximation ordering.


Although \pcf\ computation trees can be infinite, lemma \ref{lem:safe_imp_incrbound} still holds:
Safe \pcf\ computation trees are incrementally-bound.
Moreover since \pcf\ traversal rules are \emph{well-behaved}
\footnote{A traversal rule is \defname{well-behaved} if it can be stated under the form
``$t = t_1\cdot n \cdot t_2 \in \travset \zand ?(t_2) = \epsilon \zand n \in N_{var}\union N_{\Sigma} \zand P(t) \zand m\in S(t) \imp
t_1\cdot \rnode{n}{n} \cdot t_2 \cdot \rnode{m}{m} \in \travset \bkptr[nodesep=1pt]{26}{m}{n}$''
for some expression $P$ expressing a condition on $t$ and  function $S$ mapping traversals of the form of $t$ to a subset of $E(n)$ (the set of children of $n$).}, lemma \ref{lem:redtrav_trav} remains true in the presence of
constants and therefore the game-semantic analysis of safety remains valid for \pcf:
\begin{theorem}
Pointers in the game denotation of Safe PCF terms are uniquely recoverable.
\end{theorem}


\section{Further Work}

\subsection{Extension to Safe Idealized Algol}

Safe \ialgol\ is Safe \pcf\ augmented with the constants of Idealized Algol
\cite{Reynolds81}. It seems that the correspondence with game semantics and the game-semantic characterisation
of safety can easily be adapted to full Safe \textsf{IA}
although there are some difficulties caused by the presence of the base type \iavar. Indeed the game arena for \iavar, $\iacom^{\nat} \times \iaexp$, has an infinite number of
initial moves. Consequently the simple tree representation of the term does not permit to establish a game semantics correspondence.
Instead we have to use ``computation directed acyclic graphs (DAG)'': a computation DAG can
have infinitely many roots and two nodes at a given level can share children at the next level.
A term of type \iavar\ will then be represented by a computation DAG with an infinite number of root $\lambda$-nodes.

\subsection{Open Problems}

The nature of the Safe $\lambda$-Calculus is still not well known. Let us list some open problems:
\begin{enumerate}
\item Is observational equivalence decidable for Safe \ialgol?
\item What is the categorical interpretation of the Safe $\lambda$-Calculus?
\item Which proof do we obtain by the Curry-Howard isomorphism?
\item The complexity class P can be characterised by the $lambda$-calculus \cite{DBLP:conf/tlca/LeivantM93}
Does the Safe $\lambda$-Calculus characterise a complexity class in the
similar fashion?
\end{enumerate}

More generally, it would be nice to have a better understanding of the class of languages for
which pointers are uniquely recoverable. We name this class PUR for
``Pointer Uniquely Recoverable''.

The Serially Re-entrant Idealized Algol (SRIA) proposed
by Abramsky  in \cite{abramsky:mchecking_ia}
is another example of PUR language. This language allows
multiple occurrences or uses of arguments, as long as they do not
overlap in time. In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms are Serially Re-entrant whereas one of them is safe.
Conversely, SRIA is not a sublanguage of Safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to Safe \ialgol.

Another possible way to generate PUR-languages consists in constraining
the types of a language. For instance Finitary $\ialgol$ limited to order $2$ types is a PUR-language for which
observational equivalence is decidable. Decidability of observational equivalence is a very
appealing property which has immediate applications in the domain of
program verification. PUR-languages seem to be good
candidates of languages with decidable observational equivalence.
It would be interesting to discover classes of PUR
languages having this appealing property.

\bibliographystyle{splncs}
\begin{thebibliography}{10}
\bibitem{KNU02}
Knapik, T., Niwi{\'n}ski, D., Urzyczyn, P.:
\newblock Higher-order pushdown trees are easy.
\newblock In: FOSSACS'02, Springer (2002)  205--222 LNCS Vol.~2303.

\bibitem{safety-mirlong2004}
Aehlig, K., de~Miranda, J.G., Ong, C.H.L.:
\newblock Safety is not a restriction at level 2 for string languages.
\newblock Technical report, University of Oxford (2004)

\bibitem{Dam82}
Damm, W.:
\newblock The {IO-} and {OI}-hierarchy.
\newblock TCS \textbf{20} (1982)  95--207

\bibitem{OngLics2006}
Ong, C.H.L.:
\newblock On model-checking trees generating by higher-order recursion schemes.
\newblock In: Proceedings of IEEE Symposium on Logic in Computer Science.,
  Computer Society Press (2006) Extended abstract.

\bibitem{demirandathesis}
de~Miranda, J.G.:
\newblock Structures generated by higher-order grammars and the safety
  constraint.
\newblock Forthcoming, University of Oxford (2006)

\bibitem{DBLP:conf/lics/AspertiDLR94}
Asperti, A., Danos, V., Laneve, C., Regnier, L.:
\newblock Paths in the lambda-calculus.
\newblock In: LICS, IEEE Computer Society (1994)  426--436

\bibitem{lamping}
Lamping, J.:
\newblock An algorithm for optimal lambda calculus reduction.
\newblock In: POPL '90: Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on
  Principles of programming languages, New York, NY, USA, ACM Press (1990)
  16--30

\bibitem{DanosRegnier-Localandasynchronou}
Danos, V., Regnier, L.:
\newblock Local and asynchronous beta-reduction (an analysis of girard's
  execution formula).
\newblock In Vardi, M., ed.: Proceedings of the Eighth Annual IEEE Symp. on
  Logic in Computer Science, {LICS} 1993, IEEE Computer Society Press (1993)
  296--306

\bibitem{DBLP:journals/tcs/JensenP76}
Jensen, D.C., Pietrzykowski, T.:
\newblock Mechanizing {\it mega}-order type theory through unification.
\newblock Theor. Comput. Sci. \textbf{3}(2) (1976)  123--171

\bibitem{DBLP:journals/tcs/Huet75}
Huet, G.P.:
\newblock A unification algorithm for typed lambda-calculus.
\newblock Theor. Comput. Sci. \textbf{1}(1) (1975)  27--57

\bibitem{huet76}
Huet, G.P.:
\newblock R{\'e}solution d'{\'e}quations dans des langages d'ordre
  1,2,...,$\omega$.
\newblock Th{\`e}se de doctorat es sciences math{\'e}matiques, Universit{\'e}
  Paris VII (1976)

\bibitem{OngHoMchecking2006}
Ong, C.H.L.:
\newblock On model-checking trees generating by higher-order recursion schemes
  (technical report).
\newblock Preprint, 42 pp (2006)

\bibitem{DBLP:conf/sas/DimovskiGL05}
Dimovski, A., Ghica, D.R., Lazic, R.:
\newblock Data-abstraction refinement: A game semantic approach.
\newblock In Hankin, C., Siveroni, I., eds.: SAS. Volume 3672 of Lecture Notes
  in Computer Science., Springer (2005)  102--117

\bibitem{willgreenlandthesis}
Greenland, W.:
\newblock Game Semantics for Region Analysis.
\newblock PhD thesis, University of Oxford (2004)

\bibitem{hylandong_pcf}
Hyland, J.M.E., Ong, C.H.L.:
\newblock On full abstraction for {PCF}: {I, II, and III}.
\newblock Information and Computation \textbf{163}(2) (2000)  285--408

\bibitem{abramsky:game-semantics-tutorial}
Abramsky, S., McCusker, G.:
\newblock Game semantics.
\newblock In Schwichtenberg, H., Berger, U., eds.: Logic and Computation:
  Proceedings of the 1997 Marktoberdorf Summer School, Springer-Verlag (1998)
  Lecture notes.

\bibitem{Reynolds81}
Reynolds, J.C.:
\newblock The essence of algol.
\newblock In de~Bakker, J.W., van Vliet, J.C., eds.: Algorithmic Languages.
\newblock IFIP, North-Holland, Amsterdam (1981)  345--372

\bibitem{DBLP:conf/tlca/LeivantM93}
Leivant, D., Marion, J.Y.:
\newblock Lambda calculus characterizations of poly-time.
\newblock In Bezem, M., Groote, J.F., eds.: TLCA. Volume 664 of Lecture Notes
  in Computer Science., Springer (1993)  274--288

\bibitem{abramsky:mchecking_ia}
Abramsky, S.:
\newblock Semantics via game theory.
\newblock In: Marktoberdorf International Summer School. (2001) Lecture slides.

\end{thebibliography}


\section*{Appendix : Proof of Lemma \ref{lem:safe_imp_incrbound}}
(i) Suppose that $M$ is safe. The safety property is preserved after
taking the $\eta$-normal form, therefore $\tau(M)$ is the tree representation of a safe term.

In the Safe $\lambda$-Calculus, the variables in the context with the the lowest order must be all abstracted
at once when using the abstraction rule. Since the computation
tree merges consecutive abstractions into a single node,
any variable $x$ occurring free in the subtree rooted at a $\lambda$-node $\lambda \overline{\xi}$ different from the root
must have order greater or equal to $\ord{\lambda \overline{\xi}}$. Reciprocally, if a lambda node
$\lambda \overline{\xi}$ binds a variable node $x$ then
$\ord{\lambda \overline{\xi}} = 1+\max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Let $x$ be a bound variable node. Its binder occurs in the path from $x$
to the root, therefore, according to the previous observation, $x$ must be bound
by the first $\lambda$-node occurring in this path with order strictly
greater than $\ord{x}$. Let $x$ be a free variable node then $x$ is not bound
by any of the $\lambda$-nodes occurring in the path to the root. Once again, by the previous observation, all
these $\lambda$-nodes except the root have order smaller than $\ord{x}$. Hence
$\tau$ is incrementally-bound.

(ii) Let $M$ be a closed term such that $\tau(M)$ is incrementally-bound.
We assume that $M$ is already in $\eta$-normal form.
We prove that $M$ is safe by induction on its structure. The base case $M =
\lambda \overline{\xi} . \alpha$ for some variable or constant
$\alpha$ is trivial.
\emph{Step case:} If $M = \lambda \overline{\xi} . N_1 \ldots N_p$.
Let $i$ range over $1..p$. $N_i$ can be written $\lambda
\overline{\eta_i} . N'_i$ where $N'_i$ is not an abstraction. By the
induction hypothesis, $\lambda \overline{\xi} . N_i = \lambda
\overline{\xi} \overline{\eta_i} . N'_i$ is safe.
Hence $\vdash \lambda \overline{\xi} \overline{\eta_i} . N'_i$
is a valid judgment of Safe $\lambda$-Calculus.
But this judgment can only be derived using the (abs) rule on the term $N'_i$. Hence
$N'_i$ is necessarily safe. Let $z$ be a variable occurring free in
$N'_i$. Since $M$ is closed, $z$ is either bound by $\lambda
\overline{\eta_1}$ or $\lambda \overline{\xi}$. If it is bound by
$\lambda \overline{\xi}$ then because $\tau(M)$ is
incrementally-bound we have $\ord{z} \geq \ord{\lambda
\overline{\eta_1}} = \ord{N_i}$. Hence in both case we can abstract the variables
$\overline{\eta_1}$ using the (abs) rule which shows that $N_i$ is safe.

Each of the $N_i$s are safe and $N_1 \ldots N_p$ is of type $o$ therefore
by the (app) rule we have $\overline{\xi} \vdash N_1 \ldots N_p$. Finally, using the (abs) rule we conclude
with the judgement $\vdash M = \lambda \overline{\xi} . N_1 \ldots N_p$.
\qed

\end{document}
