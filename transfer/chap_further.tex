\chapter{Further possible developments}

In the previous chapter, we have given an account of the game
semantics of Safe $\lambda$-Calculus. However the nature of this
calculus is still not well known. We propose the following possible
roadmap for further research:
\begin{enumerate}
\item prove or disprove that observational equivalence is decidable for Safe \ialgol;
\item find a categorical interpretation of the Safe $\lambda$-Calculus;
\item study the proof theory obtained by the Curry-Howard isomorphism and determine whether it has nice properties that can be helpful in theorem proving;
\item In \cite{DBLP:conf/tlca/LeivantM93}, the $\lambda$-calculus is used to
give several characterisations of the complexity class P. We would
like to investigate whether, by following similar techniques, we can
obtain a characterisation of a different complexity class using the
Safe $\lambda$-Calculus.
\end{enumerate}


In a more general direction of research, we would like to study the
class of languages for which pointers are uniquely recoverable. We
name this class PUR for ``Pointer Uniquely Recoverable''.

We proved that Safe $\lambda$-Calculus is a PUR-language. Another
example is the Serially Re-entrant Idealized Algol (SRIA) proposed
by Abramsky  in \cite{abramsky:mchecking_ia}. This language allows
multiple occurrences or uses of arguments, as long as they do not
overlap in time. In the game semantics denotation of a SRIA term
there is at most one pending occurrence of a question at any time.
Each move has therefore a unique justifier and consequently
justification pointers may be ignored. Safe \ialgol\ is not a
sublanguage of SRIA. One reason for this is that none of the two
Kierstead terms $\lambda f . f (\lambda x . f (\lambda y .y ))$ and
$\lambda f . f (\lambda x . f (\lambda y .x ))$ are Serially
Re-entrant whereas the first one is safe. Conversely, SRIA is not a
sublanguage of Safe \ialgol\ since the term $\lambda f g. f (\lambda
x . g (\lambda y .x ))$ where $f,g:((o,o),o)$ belongs to SRIA but
not to Safe \ialgol. SRIA and Safe \ialgol\ are therefore two
different examples of languages with pointer-less game semantics.

Finitary $\ialgol_2$ is also an example of PUR-language for which
observational equivalence is decidable. As we indicated in the first
chapter, decidability of observational equivalence is a very
appealing property which has immediate applications in the domain of
program verification. Intuitively, PUR-languages seem to be good
candidates of languages for which observational equivalence is
decidable. It would be interesting to discover classes of PUR
languages having this appealing property.

Another possible way to generate PUR-languages might be to constrain
the types of an existing language. In \cite{DBLP:conf/tlca/Joly01},
a notion of ``complexity'' is defined for $\lambda$-terms. It is
proved that a type $T$ can be generated from a finite set of
combinators if and only if there is a constant bounding the
complexity of every closed normal $\lambda$-term of type $T$;
consequently, the only inhabited finitely generated types are the
type of rank $\leq 2$ and the types $(A_1, A_2, \ldots, A_n, o)$
such that for all $i = 1..n$: $A_i = o$ , $A_i = o \rightarrow o$ or
$A_i = o^k \rightarrow o \rightarrow o$.

We know that imposing the first of these two type restrictions to
Finitary \ialgol\ leads to a PUR language. Is is also the case when
imposing the second type restriction?
