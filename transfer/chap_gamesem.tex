\chapter{Game semantics}
\section{Semantics of programming languages}

Before the introduction of game semantics in the 1990s, there were
many approaches to define models for programming languages that we classify into different categories.
Among them there is axiomatic, operational and denotational semantics.

Operational semantics gives a meaning to a program by describing the
behaviour of a machine executing the program. It is defined formally by giving
a state transition system.

Axiomatic semantics defined the behaviour of the program
with axioms and is used to prove program correctness by static analysis of
the code of the program.

The denotational semantics approach consists in mapping a program to a mathematical structure
having good properties such as compositionality. This mapping is achieved by structural induction
on the syntax of the program.

In the 1990s, a new kind of semantics called game semantics has been
introduced for modeling programming languages. In game semantics,
the meaning of a program is given by a strategy in a two-player
game. The two players are the Opponent, representing the
environment, and the Proponent, representing the system.


\subsection{Model for PCF}

\todomargin{To develop...}

The problem of the Full Abstraction for PCF goes back to the 1970s.

Scott gave a model for PCF based on domain theory \citep{scott93}.

The Scott domain based model of PCF is not fully abstract, i.e.
there exist two PCF terms which are observationally equivalent but
their domain denotation is different. This is a consequence of the
fact that the parallel-or operator defined by the following truth
table is not definable as a PCF term:

\begin{center}
\begin{tabular}{l|lll}
p-or  & $\bot$ & tt & ff \\ \hline
$\bot$ & $\bot$ & tt & $\bot$\\
tt & tt & tt & tt\\
ff & $\bot$ & tt & ff\\
\end{tabular}
\end{center}

The undefinability of this term can be exploited to prove that the
model is not fully abstract. It is possible to create two terms that
behave the same except when the parameter is a term computing p-or.
Since p-or is not definable in PCF, these two terms will in fact be
equivalent.

It is possible to patch PCF by adding the operator $p-or$, the
resulting language ``PCF+p-or'' is fully-abstracted by Scott domain
theoretic model \citep{DBLP:journals/tcs/Plotkin77}. However the language we are now dealing with is
strictly more powerful than PCF, it has some parallel execution
power that PCF has not.

Also, we may want to get rid of the undefinable elements (like p-or)
by strengthening the conditions on the function used in the model (a
condition stronger than strictness and continuity) but unfortunately
this approach did not succeed.

Hence the problem remains: is there any fully abstract model for
PCF?

Solutions to the full abstraction problem for PCF have eventually
been discovered in the 1990s by three different independent research
groups: Ambramsky, Jagadeesan and Malacaria \citep{abramsky94full},
Hyland and Ong \citep{hylandong_pcf} and Nickau. There are all based
on game semantics.


\section{Games}

\label{sec:catgames}

We introduce here the notion of game that will be used in the following section to give a model of the programming languages
PCF and Idealized Algol. The definitions are taken from \cite{abramsky:game-semantics, hylandong_pcf, abramsky94full}.

\subsection{Basic definition}

The games we are interested in are two-players games. The players are named O for Opponent and P for Proponent.

The game played by O and P is constraint by something called \emph{arena}. The arena defines the possible moves of the game.
By analogy with board games, the arena represents the board and the rules that tell how players can make their moves
on the board\footnote{In fact there is an analogy more appropriate than board games which illustrates
well the notion of game that we are exposing here: dialog games.
In these games one person (O) interviews another person (P) while
P tries to answer the initial O-question by possibly asking O some precisions about its initial question.}.


More formally, the arena can be seen as a forest of trees whose nodes are possible questions and leaves are possible answers.
The arena is partitioned into two kinds of moves: the moves that can be played by P and the ones that can be played by O.
A move is either a question to the other player or an answer to a question previously asked by the other player.

Each move of the game must be justified by another move that has already been played by the other player. This justification relation
is induced by the edges of the forest arena. Moreover, an answer must always be justified by the question that it answers and a question
is always justified by another question.

\begin{dfn}[Arena]
An arena is a structure $\langle M, \lambda, \vdash \rangle$ where:
\begin{itemize}
\item $M$ is the set of possible moves;
\item $(M,\vdash)$ is a forest of trees;

\item $\lambda : M \rightarrow \{ O, P\} \times \{Q, A\}$ is a labeling functions indicating whether a given move
    is a question or an answer and whether it can be played by O or by P.

    $\lambda = [\lambda^{OP},\lambda^{QA}]$ where $\lambda^{OP} : M \rightarrow  \{ O, P\}$
    and $\lambda^{QA} : M \rightarrow  \{ Q, A\}$.

    \begin{itemize}
    \item If $\lambda^{OP} (m) = O$, we call $m$ and O-move otherwise $m$ is a P-move.
    $\lambda^{QA} (m) = Q$ indicates that $m$ is a question otherwise $m$ is an answer.

    \item For any leaf $l$ of the tree $(M,\vdash)$, $\lambda^{QA} (l) = A$ and for any node
    $n \in (M,\vdash)$, $\lambda^{QA} (n) = Q$.
    \end{itemize}

\item The forest of tree $(M,\vdash)$ respect the following condition:
    \begin{itemize}
    \item[(e1)] The roots are O-moves: for any root $r$ of $(M,\vdash)$, $\lambda^{OP} (r) = O$.
    \item[(e2)] Answers are enabled by questions: $m \vdash n  \zand \lambda^{QA}(n) = A \imp \lambda^{QA}(m) = Q$.
    % Or more succinctly, if we note $\dashv$ the relation $\vdash^-1$: $\lambda^{QA} \left( \dashv( (\lambda^{QA})^{-1}(\{A\}) ) \right) = \{ O \}$
    \item[(e3)] A player move must be justified by a move played by the other player:
         $m\vdash n \imp \lambda^{OP}(m) \neq \lambda^{OP}(n)$.
    \end{itemize}
\end{itemize}
\end{dfn}

For commodity we write the set $\{O,P\} \times \{Q,A\}$ as $\{OQ,OA,PQ,PA\}$.
$\overline{\lambda}$ denotes the labeling function $\lambda$ with the question and answer swapped. For instance:
$$\overline{\lambda(m)} = OQ \iff \lambda(m) = PQ$$

The roots of the forest of tree $(M,\vdash)$ are the \emph{initial moves}.


Once the arena has been defined, the bases of the game are set and the players have something to play with.
We now need to describe the state of the game, for that purpose
we introduced \emph{justified sequences of moves}. Sequence of moves are used to record the history of all the moves that have been
played.

\begin{dfn}[Justified sequence of moves]
A justified sequence is a sequence of moves $s$ together with an associated sequence of pointers. Any
move $m$ in the sequence that is not initial has as pointer that points to a previous move $n$ that justifies it (i.e. $n \vdash m$).
\end{dfn}


A justified sequence has two particular subsequences which will be of particular interest later on when we
introduce strategies. These subsequences are called the P-view and the O-view of the sequence.
The idea is that a view describes the local context of the game. Here is the formal definition:

\begin{dfn}[View]
Given a justified sequence of moves $s$. We define the proponent view (P-view) noted $\pview{s}$ by induction:
\begin{align*}
\pview{\epsilon} &= \epsilon \\
\pview{s \cdot m} &= \pview{s} \cdot \ m && \mbox{ if $m$ is a P-move} \\
\pview{s \cdot m} &= m && \mbox{ if $m$ is initial (O-move) } \\
\pview{ s \cdot \rnode{m}{m} \cdot t \cdot \rnode{n}{n} \bkptra{50}{n}{m} } &=
 \pview{s} \cdot \rnode{mm}{m} \cdot \rnode{nn}{n} \bkptra{70}{nn}{mm} && \mbox{ if $n$ is a non initial O-move }
\end{align*}
The O-view $\oview{s}$ is defined similarly:
\begin{align*}
\oview{\epsilon} &= \epsilon \\
\oview{s \cdot m} &= \oview{s} \cdot \ m && \mbox{ if $m$ is a O-move} \\
\oview{ s \cdot \rnode{m}{m} \cdot t \cdot \rnode{n}{n} \bkptra{50}{n}{m} } &=
 \pview{s} \cdot \rnode{mm}{m} \cdot \rnode{nn}{n} \bkptra{70}{nn}{mm} && \mbox{ if $n$ is a P-move }
\end{align*}
\end{dfn}

In fact not all justified sequences will be of interest for the games that we will use.
We call \emph{legal position} any justified sequence
verifying two additional conditions: alternation and visibility.

\begin{dfn}[Legal position]
A legal position is a justified sequence of move $s$ respecting the following constraint:
\begin{itemize}
\item Alternation: For any subsequence $m \cdot n$ of $s$, $\lambda^{OP}(m) \neq \lambda^{OP}(n)$.
\item Visibility: For any subsequence $t m$ of $s$, if $m$ is a P-move then $m$ points to a move in $\pview{s}$
and if $m$ is a O-move then $m$ points to a move in $\oview{s}$.
\end{itemize}

The set of legal position of an arena $A$ is noted $L_A$.
\end{dfn}

We say that a move $n$ is hereditarily justified by a move $m$ if there is a sequence of move
$m_1, \ldots, m_q$ such that:
$$ m \vdash m_1 \vdash m_2 \vdash \ldots m_q \vdash n$$

Suppose that $n$ is an occurrence of a move in the sequence $s$ then we note
$s \upharpoonright n$ the subsequence of $s$ containing all the moves hereditarily justified by $n$.
Similarly, $s \upharpoonright I$ denotes the
subsequence of $s$ containing all the moves hereditarily justified by the moves in $I$.

\begin{dfn}[Game]
A game is a structure $\langle M, \lambda, \vdash, P \rangle$ such that
\begin{itemize}
\item $ \langle M, \lambda, \vdash \rangle$ is an arena.
\item $P$, called the set of valid positions, is
    \begin{itemize}
    \item a non-empty prefix closed subset of the set of legal position
    \item closed by hereditary filtering: if $I$ is the set of initial moves of $s$ then
        $$ s \in P \imp s\upharpoonright I \in P$$
    \end{itemize}
\end{itemize}
\end{dfn}

\subsection{Game construction}
tensor product, implication, product

\subsection{Strategy}
During a game, a player may have several choices for his next move.
To decide which moves to make, the player refers to the state of the game.
This state is given by the position of the game, in other words
the history of all the moves already played.

A strategy is therefore based on the history of the game.

\begin{dfn}[Strategy]
A strategy for player P on a given game $\langle M, \lambda, \vdash, P \rangle$ is a
non-empty set of even-length positions from $P$ such that:
\begin{enumerate}
\item $sab \in \sigma \imp s \in \sigma$
\item $sab, sac \in \sigma \imp b = c$
\end{enumerate}
\end{dfn}

The idea is that the presence of the even-length sequence $s a b$ in $\sigma$ tells the player
P that whenever the game is in position $s a$ it must play the move $b$.
The second condition in the definition requires that this choice of move is deterministic
(i.e. there is a function $f$ from the set of odd length position to the set of moves $M$
 such that $f(s a) =b$). The first condition ensures that the strategy $\sigma$ consider only
position that the strategy itself could have led to.


Composition of strategy

Strategy constraints:
\begin{description}
\item[innocence]


\item[well-bracketing]
We take the definition given in \cite{abramsky:game-semantics} where
the well-bracketing condition is a condition on P-answers only and where there is no constraint on O-answers.
In fact this choice is harmless and the full-abstraction results that we will state in the next section
still hold if we assume well-bracketing of O-answers.

\end{description}


\subsection{Categorical interpretation of games}

categories $\mathcal{C}$, $\mathcal{C}_i$, $\mathcal{C}_b$, $\mathcal{C}_{ib}$

\subsection{Arena of order at most 2}

The height of the arena is the length of the longest sequence of moves
$m_1 \ldots m_h$ in $M$ such that $m_1 \vdash m_2 \vdash \ldots \vdash m_h$.

The order of an arena $\langle M, \lambda, \vdash \rangle$ is defined to be
$h-2$ where $h$ is the height of the forest of trees $(M, \vdash)$.


\begin{lem}[Pointers are superfluous up to order 2]
Let $A$ be the arena of order at most 2. Let $s$ be a justified sequence of moves in the arena $A$ satisfying
 alternation, visibility and well-bracketing then
the pointers of the sequence $s$ can be reconstructed uniquely.
\end{lem}



\begin{proof}
In the graphic representation of the arena, we display the sub-arena by decreasing order of sub-arena order.
It is safe to do so since in the definition of the forest of tree of an arena, the children nodes
are not ordered.

Let $A$ be an arena of order 2. We assume that $A$ has only one root. The arena $A$ has therefore the following shape:
\begin{center}
\
  \pstree[levelsep=6ex]
    { \TR{$q$} }
    {
\SubTree{$T_1$} \SubTree[linestyle=none]{$\ldots$} \SubTree{$T_n$}
    \TR{$a_1$} \TR{$a_2$} \TR{\ldots} }
\end{center}

where each triangle $T_i$ represents an arena of order 0 or 1.

We will see that the following proof can easily be adapted to take into account the general case of forest arenas (multiple roots).

We note $I_k$ for $k=0$ or $1$, the set of indices $i$ such that the arena $T_i$ has order $k$:
$$I_k = \{ i \in 1.. n\ |\ \order{T_i} = k \}$$

Here is a graphic representation of the arenas $T_i$ for $i \in I_0$ and $T_j$ for $j \in I_1$:
\begin{center}
\
  \pstree[levelsep=6ex]
    {\TR{$q^i$}}
    { \TR{$a_1^i$} \TR{$a_2^i$} \TR{\ldots} }
\hspace{2cm}
  \pstree[levelsep=6ex]
    { \TR{$p^j$} }
    {
      \pstree[levelsep=6ex]
        { \TR{$q^j$} }
        { \TR{$a_1^j$} \TR{$a_2^j$} \TR{\ldots} }
      \TR{$b_1^j$} \TR{$b_2^j$} \TR{\ldots}
    }
\end{center}


\input{proof.tex}

\end{proof}


\subsection{Pointer-less strategies}
\label{subsec:ptrless_strat}

Up to order 2, the semantics of PCF terms is entirely defined by
pointer-less strategies. In other words, the pointers can be
uniquely reconstructed from any non justified sequence of moves
satisfying the visibility and well-bracketing condition.

At level 3 however, pointers cannot be omitted. There is an example
in \cite{abramsky:game-semantics} to illustrate this. Consider the
following two terms of type $((\nat \typar \nat) \typar \nat) \typar
\nat$:

$$M_1 = \lambda f . f (\lambda x . f (\lambda y .y ))$$
$$M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$$

We assign tags to the types in order to identify in which arena the
questions are asked: $((\nat^1 \typar \nat^2) \typar \nat^3) \typar
\nat^4$. Consider now the following pointer-less sequence of moves
$s = q^4 q^3 q^2 q^3 q^2 q^1$. It is possible to retrieve the
pointers of the first five moves but there is an ambiguity for the
last move: does it point to the first or second occurrence of $q^2$
in the sequence $s$?

Note that the visibility condition does not eliminate the ambiguity,
since the two occurrences of $q^2$ both appear in the P-view at that
point (after recovering the pointers of $s$ up to the second last
move we get:
$$s = \rnode{q4}{q}^4
\rnode{q3}{q}^3
\rnode{q2}{q}^2
\rnode{q3b}{q}^3
\rnode{q2b}{q}^2
\rnode{q1}{q}^1
\bkptrc{q3}{q4}
\bkptrc{q2}{q3}
\bkptrc[ncurv=0.6]{q3b}{q4}
\bkptrc{q2b}{q3b}$$

 therefore the P-view of $s$ is $s$ itself.)

In fact these two different possibilities correspond to two
different strategies. Suppose that the link goes to the first
occurrence of $q^2$ then it means that the proponent is requesting
the value of the variable $x$ bound in the subterm $\lambda x . f (
\lambda y. ... )$. If P needs to know the value of $x$, this is
because P is in fact following the strategy of the subterm $\lambda
y . x$. And the entire play is part of the strategy $\sem{M_2}$.

Similarly, if the link points to the second occurrence of $q^2$ then
the play belongs to the strategy $\sem{M_1}$.

\section{PCF}
\subsection{The syntax of the language}
PCF is a simply-type $\lambda$-calculus with the following
additions: integer constants  (of ground type), first-order
arithmetic operators, if-then-else branching, and the recursion
combinator $Y_A : (A\rightarrow A)\rightarrow A$ for any type $A$.

The types of PCF are given by the following grammar:
$$ T ::= \texttt{exp}\ |\ T \rightarrow T$$

The following grammar gives the structure of terms:
\begin{eqnarray*}
 M ::= x\ |\ \lambda x :A . M \ |\ M M \ |\ \\
\ |\ n \ |\ \texttt{succ } M \ |\  \texttt{pred } M \\
\ |\ \texttt{cond } M M M \ |\ \texttt{Y}_A\ M
\end{eqnarray*}

where $x$ ranges over a set of countably many variables and $n$
ranges over the set of natural numbers.

Terms are generated according to the formation rules given in table
\ref{tab:pcf_formrules} where the judgement is of the form $ \Gamma  \vdash M : A$.

\begin{table}[htbp]
$$ (var) \rulef{}{x_1:A_1, x_2:A_2, \ldots x_n : A_n  \vdash x_i : A_i}\ i \in 1..n$$
$$ (app) \rulef{\Gamma \vdash M : A\rightarrow B \qquad \Gamma \vdash N:A}{\Gamma \vdash M\ N : B}
\qquad (abs) \rulef{\Gamma, x:A \vdash M : B}{\Gamma \vdash \lambda x :A . M : A\rightarrow B}$$

$$ (const) \rulef{}{\Gamma \vdash n :\texttt{exp}}
\qquad (succ) \rulef{\Gamma \vdash M:\texttt{exp} }{\Gamma \vdash \texttt{succ}\ M:\texttt{exp}}
\qquad (pred) \rulef{\Gamma \vdash M:\texttt{exp} }{\Gamma \vdash \texttt{pred}\ M:\texttt{exp}}$$

$$
(cond) \rulef{\Gamma \vdash M : exp \qquad \Gamma \vdash N_1 : exp \qquad \Gamma \vdash N_2 : exp }{\Gamma \vdash \texttt{cond}\ M\ N_1\ N_2}
\qquad  (rec) \rulef{\Gamma \vdash M : A\rightarrow A }{ \Gamma \vdash Y_A M : A}$$

\caption{Formation rules for PCF terms}
\label{tab:pcf_formrules}
\end{table}

\subsection{Operational semantics}

We give the big-step operational semantics of PCF. The notation $M \eval V$ means
that the closed term $M$ evaluates to the canonical form $V$. The canonical forms are given by the following
grammar:
$$V ::= n\ |\ \lambda x. M$$
In other word, a canonical form is either a number or a function.

The operational semantics is given for closed terms therefore the context $\Gamma$ is not present in
the evaluation rules.

The full operational semantics is given in table \ref{tab:bigstep_pcf}.

\begin{table}[htbp]
$$\rulef{}{V \eval V} \quad \mbox{ provided that $V$ is in canonical form.} $$

$$ \rulef{M \eval \lambda x. M' \quad M'\subst{x}{N}}{M N \eval V}$$

$$\rulef{M \eval n}{\texttt{succ}\ M \eval n+1}
\qquad \rulef{M \eval n+1}{\texttt{pred}\ M \eval n}
\qquad \rulef{M \eval 0}{\texttt{pred}\ M \eval 0}$$

$$\rulef{M \eval 0 \quad N_1 \eval V}{\texttt{cond}\ M N_1 N_2  \eval V}
\qquad
 \rulef{M \eval n+1 \quad N_2 \eval V}{\texttt{cond}\ M N_1 N_2  \eval V}$$

$$\rulef{M (\mathrm{Y} M) \eval V }{\texttt{Y} M \eval V}$$
\label{tab:bigstep_pcf}
\caption{Big-step operational semantics of PCF}
\end{table}



\section{Idealized Algol (IA)}
\label{sec:ia}

\subsection{The syntax of IA}
IA is an extension of PCF introduced by J.C. Reynold in
\cite{Reynolds81}. It adds imperative features such as local variables and sequential composition.

The description of the language that we give here follows the one of \cite{abramsky:game-semantics}.

On top of \texttt{exp}, PCF has the following two new types:
 \texttt{com} for commands and \texttt{var} for variables.

There is a constant \texttt{skip} of type \texttt{com} which corresponds to the command that do
nothing. Commands can be composed using the sequential composition operator \texttt{seq}.
Local variable are declared using the \texttt{new} operator, variable content is written
using \texttt{assign} and retrieved using \texttt{deref}.

The new formations rules are given in table \ref{tab:ia_formrules}.

\begin{table}[htbp]
$$ \rulef{\Gamma \vdash M : \texttt{com} \quad \Gamma \vdash N :A}
    {\Gamma \vdash \texttt{seq}_A \ M\ N\ : A} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulef{\Gamma \vdash M : \texttt{var} \quad \Gamma \vdash N : \texttt{exp}}
    {\Gamma \vdash \texttt{assign}\ M\ N\ : \texttt{com}}
\qquad
 \rulef{\Gamma \vdash M : \texttt{var}}
    {\Gamma \vdash \texttt{deref}\ M\ : \texttt{exp}}$$

$$ \rulef{\Gamma, x : \texttt{var} \vdash M : A}
    {\Gamma \vdash \texttt{new } x \texttt{ in } M} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rulef{\Gamma \vdash M_1 : \texttt{exp} \rightarrow \texttt{com} \quad \Gamma \vdash M_2 : \texttt{exp}}
    {\Gamma \vdash \texttt{mkvar } M_1\ M_2\ : \texttt{var}}$$

\caption{Formation rules for IA terms}
\label{tab:ia_formrules}
\end{table}

If $\vdash M : A$ (i.e. $M$ can be formed with an empty context), we say that $M$ is a close term.

\subsection{Operational semantics}

In IA the semantics is given in a slightly different form from PCF.
In PCF, the evaluation rules were given for closed terms only. Suppose that we
proceed the same way for IA and consider the evaluation rule for the $\texttt{new}$ construct:
the conclusion is $\texttt{new } x:=0 \texttt{ in } M$ and the premise
is an evaluation for a certain term constructed from $M$, more precisely the term $M$
where \emph{some} occurrences of $x$ are replaced by the value $0$.
Because of the presence of the \texttt{assign} operator, we cannot simply replace all
the occurrences of $x$ in $M$ (the required substitution is  more complicated
than the substitution used for beta-reduction).


Therefore, instead of giving the semantics for closed term we consider terms
whose free variables are all of type \texttt{var}. These free variables are ``closed'' by mean of
stores. A store is a function mapping free variables of type \texttt{var} to natural numbers.
Suppose $\Gamma$ is a context containing only variable of type \texttt{var}, then we say that
$\Gamma$ is a \texttt{var}-context. A store whose domain $\Gamma$ is called a $\Gamma$-store.

The notation $s\ |\ x \mapsto n$ refers to the store that maps $x$ to $n$
and otherwise maps variables according to the store $s$.


The canonical forms for IA are given by the grammar:
$$ V ::= n\ |\ \lambda x. M\ |\ x\ |\  \texttt{mkvar} M N$$

where $n \in \nat$ and $x:var$.


A program is now defined by a term together with a $\Gamma$-store such that $\Gamma \vdash M : A$.
The evaluation semantics is expressed by the judgment form
$$s,M \eval s', V$$
where $s$ and $s'$ are $\Gamma$-stores,
$\Gamma \vdash M : A$ and $\Gamma \vdash V : A$ where $V$ is in canonical form.

The operational semantics for IA is given by the rule of PCF (table \ref{tab:bigstep_pcf})
together with the rules of table \ref{tab:bigstep_ia} where the following abbreviation is used:
$$ \rulef{M_1 \eval V_1 \quad M_2 \eval V_2}{M \eval V} \qquad \mbox{for} \qquad
  \rulef{s,M_1 \eval s',V_1 \quad s', M_2 \eval s'',V_2 }{s,M \eval s'',V}
$$


\begin{table}[htbp]
$$\mbox{\textbf{Sequencing }}
    \rulef{M \eval \iaskip \quad N \eval V}{\texttt{seq } M\ N \eval V}
$$

$$\mbox{\textbf{Variables }}
    \rulef{s,N \eval s',n \quad s',M \eval s'',x}{s, \assign\ M\ N \eval (s''\ |\ x \mapsto n),\iaskip}
\qquad
    \rulef{s,M \eval s',x }{s, \deref\ M \eval s',s'(x)}$$

$$\mbox{\texttt{\textbf{mkvar}}}
    \rulef{N \eval n \quad M \eval \texttt{mkvar } M_1\ M_2 \quad M_1\ n \eval \iaskip}
    {\assign\ M\ N \eval \iaskip}
\qquad
    \rulef{N \eval \texttt{mkvar } M_1\ M_2 \quad M_2\ \eval n}
    {\deref\ M \eval n}
$$

$$\mbox{\textbf{Block}}
    \rulef{(s\ |\ x \mapsto 0),M \eval (s'\ |\ x \mapsto n),V }
    {s, \texttt{new } x \texttt{ in } M \eval s',V}
$$

\label{tab:bigstep_ia}
\caption{Big-step operational semantics of IA}
\end{table}

\subsection{Game semantics}

As we have seen in section \ref{sec:catgames}, games and strategies
form a cartesian closed category, therefore games can model the simply-typed $\lambda$-calculus. Let us first
explain how this is achieved before extending the model to PCF and IA.

\subsubsection{Simply typed $\lambda$-calculus}

In the cartesian closed category $\mathcal{C}$, the objects are the arenas and the morphisms are the strategies.

In the games that we describe here, the Opponent represents the environment while
the Proponent plays according to a strategy imposed by the program itself.


Given a simple type $A$, we will model it as an arena $\sem{A}$.
A context $\Gamma = x_1 :A_1, \ldots x_n:A_n$ will be mapped to the arena
$\sem{\Gamma} = \sem{A_1} \times \ldots \times \sem{A_n}$ and a term $\Gamma \vdash M : A$
will be modeled by a strategy on the arena $\sem{\Gamma} \rightarrow \sem{A}$.
Since $\mathcal{C}$ is cartesian closed, there is is a terminal object $\textbf{1}$ (the empty arena) that
models the empty context ($\sem{\Gamma} = \textbf{1}$).


The base type \texttt{exp} is interpreted by the following flat arena of natural numbers noted $\nat$:
$$  \pstree[levelsep=6ex]
    {\TR[name=R]{q}}
    { \TR{1} \TR{2} \TR{\ldots}
    }
$$
In this arena, there is only one question: the initial O-question, P can then answer it by playing a natural number $i \in \nat$.
There are only two kinds strategy on this arena:
\begin{itemize}
\item the empty strategy where P never answer the initial question. This corresponds to a non terminating computation;
\item the strategies where P answers by playing a number $n$. This models the constants of the language.
\end{itemize}

Given the interpretation of base types, we define the interpretation of $A\rightarrow B$ by induction:
$$\sem{A \rightarrow B} = \sem{A} \Rightarrow \sem{B}$$

where the operator $\Rightarrow$ denotes the arena construction $!A \multimap B$ which exist because $\mathcal{C}$ is cartesian closed.

Graphically if we represent the arena $A$ and $B$ by two triangles, the arena for $A \rightarrow B$ would be represented by:
\begin{center}
\psset{xunit=.5pt,yunit=.5pt,runit=.5pt}
\begin{pspicture}(150,80)
\rput[tr](150,80){ \pnode(27,40){a} \pstribox{A} }
\rput[bl](0,0){ \pnode(27,40){b} \pstribox{B} }
\ncline{->}{a}{b}
\end{pspicture}
\end{center}


Variables are interpreted by projection:
$$\sem{x_1 : A_1, \ldots, x_n:A_n \vdash x_i : A_i} = \pi_i : \sem{A_i} \times \ldots \times \sem{A_i} \times \ldots \times \sem{A_n} \rightarrow  \sem{A_i}$$

The abstraction $\Gamma \vdash \lambda x :A.M : A \rightarrow B$ is modeled by a strategy on the arena
$\sem{\Gamma} \rightarrow (\sem{A}\Rightarrow\sem{B})$. This strategy is obtain by using the currying operator of the
cartesian closed category:
$$\sem{\Gamma \vdash \lambda x :A.M : A \rightarrow B} = \Lambda( \sem{\Gamma, x :A \vdash M : B})$$

The application $\Gamma \vdash M N$ is modeled using the evaluation map $ev_{A,B} : (A\Rightarrow B)\times A \rightarrow B$:

$$\sem{\Gamma \vdash M N} = \langle \sem{\Gamma \vdash M, \Gamma \vdash N} \rangle; ev_{A,B}$$


\subsubsection{PCF}

We now show how to model the PCF constructs in the game semantics setting.
In the following, the sub-arena of a game are tagged in order to distinguish identical arenas that are present in different components of the game.
Moves are also tagged in the exponent in order to identify the sub-arena in which moves are played. We will omit the pointers in the play
when they are not essential for the understanding of the model (moreover we will see later on that under certain assumptions
up to order 2, pointers can be recovered uniquely).

The successor arithmetic operator is modeled by the following strategy on the arena $\nat^1 \Rightarrow \nat^0$:
$$\sem{\texttt{succ}} = \{q^0 \cdot q^1 \cdot n^1 \cdot (n+1)^0\ |\ n \in \nat \}$$

The predecessor arithmetic operator is denoted by the strategy
$$\sem{\texttt{pred}} = \{q^0 \cdot q^1 \cdot n^1 \cdot (n-1)^0\ |\ n >0 \} \union \{ q^0 \cdot q^1 \cdot 0^1 \cdot 0^0 \} $$

Then given a term $\Gamma \vdash \texttt{succ} M : \texttt{exp}$ we define:
$$\sem{\Gamma \vdash \texttt{succ } M : \texttt{exp}} = \sem{\Gamma \vdash M} ; \sem{\texttt{succ}} $$
$$\sem{\Gamma \vdash \texttt{pred } M : \texttt{exp}} = \sem{\Gamma \vdash M} ; \sem{\texttt{pred}} $$


The conditional operator is denoted by the following strategy on the arena $\nat^3 \times \nat^2 \times \nat ^1 \Rightarrow \nat^0$:
$$\sem{\texttt{cond}} =
    \{ q^0 \cdot q^3 \cdot 0 \cdot q^2 \cdot n^2 \cdot n^0 \ | \ n \in \nat \}
    \union
    \{ q^0 \cdot q^3 \cdot m \cdot q^2 \cdot n^2 \cdot n^0 \ | \ m >0, n \in \nat \}
    $$


Given a term $\Gamma \vdash \texttt{cond} M\ N_1\ N_2$ we define:
$$\sem{\Gamma \vdash \texttt{cond} M\ N_1\ N_2} =
\langle \sem{\Gamma \vdash M}, \sem{\Gamma \vdash N_1}, \sem{\Gamma \vdash N_2} \rangle ; \sem{\texttt{cond}}$$


The interpretation of the \texttt{Y} combinator is a bit more complicated.

Consider the term $\Gamma \vdash M : A \rightarrow A$, its semantics $f$ is a strategy on $\sem{\Gamma} \times \sem{A} \rightarrow \sem{A}$.
We define the chain $g_n$ of strategies on the arena $\sem{\Gamma} \rightarrow \sem{A}$ as follows:
\begin{eqnarray*}
g_0 &=& \perp \\
g_{n+1} &=&  F(g_n) = \langle id_{\sem{\Gamma}}, g_n\rangle ; f
\end{eqnarray*}

where $\perp$ denotes the empty strategy $\{ \epsilon \}$.

It is easy to see that indeed the $g_n$ forms a chain.
We define $\sem{\texttt{Y } M}$ to be the least upper bound of the chain $g_n$
(i.e. the  least fixed point of $F$). Its existence is guaranteed by the fact that
the category of games is cpo-enriched.

\subsubsection{IA}

It is easy to check that all the strategies given until now are well-bracketed and innocent.
From now on, we will only require well-bracketing and we will introduce strategies that are
not innocent. This is a necessity if we want to give a model of memory cells that correspond
to variables. The intuition behind this fact is that a cell needs to remember what was the last value written in it
in order to be able to return it when it is read, and this can only be done by looking at the whole history of moves,
not only those present in the P-view.





\subsection{Full-abstraction}
In this section we recall the standard full abstraction result proved in  \cite{abramsky94full}
and \cite{hylandong_pcf}.

A context noted $C[-]$ is a term containing a hole denoted by $-$. If $C[-]$ is a context then $C[A]$ denotes the term obtained
after replacing the hole by the term $A$.

\begin{dfn}[Observational preorder]
Let $\vdash M : A$ and $\vdash N : A$ be two closed terms. We define the relation $\sqsubseteq$ as follows:


$M \sqsubseteq N$ if and only if for all context $C[-]$ such that $C[M]$ and $C[M]$ are well-formed terms if
$C[M] \eval$ then $C[N] \eval$.
\end{dfn}


\begin{lem}[Soundness for PCF terms] Let $M$ be a PCF term.
If $M \eval V$ then $\sem{M} = \sem{V}$.
\end{lem}

\begin{lem}[Soundness for IA terms] Let $\Gamma \vdash M : A$ be an IA term and a $\Gamma$ store $s$.
If $s,M \eval s',V$ then the plays of $\sem{s,M} : I \multimap A \otimes !\Gamma$ which begin
with a move of $A$ are identical to those of $\sem{s',V}$.
\end{lem}


\begin{lem}[Computational adequacy for PCF terms]
All PCF terms are computable. (i.e. $\sem{M} \neq \perp$ implies $M \eval$)
\end{lem}

\begin{lem}[Computational adequacy for IA terms]
All IA terms are computable. (i.e. $\sem{M} \neq \perp$ implies $M \eval$)
\end{lem}


The following result follows from soundness and computational adequacy of the model.
\begin{prop}[Inequational soundness]
\label{prop:ineqsoundness}
Let $M$ and $N$ be two closed terms then
$$\sem{M} \subseteq \sem{N} \implies  M \sqsubseteq N $$
\end{prop}

\begin{prop}[Definability]
\label{prop:definability}
Let $\sigma$ be a compact well-bracketed on a game $A$ denoting a IA type. Then there is
an IA-term $M$ such that $\sem{M} = \sigma$.
\end{prop}

The final standard result of game semantics can then be proved using proposition \ref{prop:ineqsoundness} and \ref{prop:definability}:
\begin{thm}[Full abstraction]
Let $M$ and $N$ be two closed IA-terms.
$$\sem{M} \precsim_b \sem{N} \ \iff \ M \sqsubseteq N$$
\end{thm}

where $\precsim_b$ denotes the intrinsic preorder of the category $\mathcal{C}_b$.





\subsection{First-order and second-order Idealized Algol}

The strategies of second-order IA can be represented by an extended regular language
(Dan R. Ghica and Guy McCusker).

\subsection{Call-by-Value first-order Idealized Algol}

Game semantics for call-by-value programming Language.

\section{Data-abstraction refinement}

\input{dataref.tex}
