\chapter{Game semantics}
\section{Semantics of programming languages}

Before the introduction of game semantics in the 1990s, there were
principally two kinds of models for programming languages:
operational semantics and denotational semantics. Operational
semantics defines a program using rewriting rules. whereas
denotational semantics defines a program using mathematical
function.

In the 1990s, a new kind of semantics called game semantics has been
introduced for modeling programming languages. In game semantics,
the meaning of a program is given by a strategy in a two-player
game. The two players are the opponent, representing the
environment, and the Proponent, representing the program itself.


\subsection{Model for PCF}

The problem of the Full Abstraction for PCF goes back to the 1970s.

Scott gave a model for PCF based on domain theory (\cite{scott93}).

The Scott domain based model of PCF is not fully abstract, i.e.
there exist two PCF terms which are observationally equivalent but
their domain denotation is different. This is a consequence from the
fact that the parallel-or operator defined by the following truth
table is not definable as a PCF term:

\begin{tabular}{l|lll}
p-or  & $\bot$ & tt & ff \\
$\bot$ & $\bot$ & tt & $\bot$\\
tt & tt & tt & tt\\
ff & $\bot$ & tt & ff\\
\end{tabular}

The undefinability of this term can be exploited to prove that the
model is not fully abstract. It is possible to create two terms that
behave the same except when the parameter is a term computing p-or.
Since p-or is not definable in PCF, these two terms will in fact be
equivalent.

It is possible to patch PCF by adding the operator $p-or$, the
resulting language ``PCF+p-or'' is fully-abstracted by Scott domain
theoretic model. However the language we are now dealing with is
strictly more powerful than PCF, it has some parallel execution
power that PCF has not.

Also, we may want to get rid of the undefinable elements (like p-or)
by strengthening the conditions on the function used in the model (a
condition strong than strictness and continuity) but unfortunately
this approach did not succeed.

Hence the problem remains: is there any fully abstract model for
PCF?

Solutions to the full abstraction problem for PCF have eventually
been discovered in the 1990s by three different independent research
groups: Ambramsky, Jagadeesan and Malacaria \cite{abramsky94full},
Hyland and Ong \cite{hylandong_pcf} and Nickau. There are all based
on game semantics.


\section{Games}

definition of arena, view, positions
justified sequence.

Game construction: tensor product, implication.

strategy

composition of strategy

\subsection{Category of games}
\label{subsec:catgames}

product of games

\section{Game semantics of PCF}
\subsection{The language PCF}
PCF is a simply-type $\lambda$-calculus with the following
additions: integer constants  (of ground type), first-order
arithmetic operators, if-then-else branching, and the recursion
combinator $Y_A : (A\rightarrow A)\rightarrow A$ for any type $A$.

The types of PCF are given by the following grammar:
$$ T ::= \texttt{exp}\ |\ T \rightarrow T$$

The following grammar gives the structure of terms:
\begin{eqnarray*}
 M ::= x\ |\ \lambda x :A . M \ |\ M M \ |\ \\
\ |\ n \ |\ \texttt{succ} M \ |\  \texttt{pred} M \\
\ |\ \texttt{cond} M M M \ |\ Y_A M
\end{eqnarray*}

where $x$ ranges over a set of countably many variables and $n$
ranges over the set of natural numbers.

Terms are generated according to the formation rules given in table
\ref{tab:pcf_formrules} where the judgement is of the form $ \Gamma  \vdash M : A$.

\begin{table}[htbp]
$$ (var) \rule{}{x_1:A_1, x_2:A_2, \ldots x_n : A_n  \vdash x_i : A_i}\ i \in 1..n$$
$$ (app) \rule{\Gamma \vdash M : A\rightarrow B \qquad \Gamma \vdash N:A}{\Gamma \vdash M\ N : B}
\qquad (abs) \rule{\Gamma, x:A \vdash M : B}{\Gamma \vdash \lambda x :A . M : A\rightarrow B}$$

$$ (const) \rule{}{\Gamma \vdash n :\texttt{exp}}
\qquad (succ) \rule{\Gamma \vdash M:\texttt{exp} }{\Gamma \vdash \texttt{succ}\ M:\texttt{exp}}
\qquad (pred) \rule{\Gamma \vdash M:\texttt{exp} }{\Gamma \vdash \texttt{pred}\ M:\texttt{exp}}$$

$$
(cond) \rule{\Gamma \vdash M : exp \qquad \Gamma \vdash N_1 : exp \qquad \Gamma \vdash N_2 : exp }{\Gamma \vdash \texttt{cond}\ M\ N_1\ N_2}
\qquad  (rec) \rule{\Gamma \vdash M : A\rightarrow A }{ \Gamma \vdash Y_A M : A}$$

\caption{Formation rules for PCF terms}
\label{tab:pcf_formrules}
\end{table}

\subsection{Operational semantics}

We give the big-step operational semantics of PCF. The notation $M \eval V$ means
that the closed term $M$ evaluates to the canonical form $V$. The canonical forms are given by the following
grammar:
$$V ::= n\ |\ \lambda x. M$$
In other word, a canonical form is either a number or a function.

The operational semantics is given for closed terms therefore the context $\Gamma$ is not present in
the evaluation rules.

The full operational semantics is given in table \ref{tab:bigstep_pcf}.

\begin{table}[htbp]
$$\rule{}{V \eval V} \quad \mbox{ provided that $V$ is in canonical form.} $$

$$ \rule{M \eval \lambda x. M' \quad M'\subst{x}{N}}{M N \eval V}$$

$$\rule{M \eval n}{\texttt{succ}\ M \eval n+1}
\qquad \rule{M \eval n+1}{\texttt{pred}\ M \eval n}
\qquad \rule{M \eval 0}{\texttt{pred}\ M \eval 0}$$

$$\rule{M \eval 0 \quad N_1 \eval V}{\texttt{cond}\ M N_1 N_2  \eval V}
\qquad
 \rule{M \eval n+1 \quad N_2 \eval V}{\texttt{cond}\ M N_1 N_2  \eval V}$$

$$\rule{M (\mathrm{Y} M) \eval V }{\texttt{Y} M \eval V}$$
\label{tab:bigstep_pcf}
\caption{Big-step operational semantics of PCF}
\end{table}



\section{Game semantics of IA}
\label{sec:ia}

\subsection{The syntax of IA}
IA is an extension of PCF introduced by J.C. Reynold in
\cite{Reynolds81}. It adds imperative features such as local variables and sequential composition.

The description of the language that we give here follows the one of \cite{abramsky:game-semantics}.

On top of \texttt{exp}, PCF has the following two new types:
 \texttt{com} for commands and \texttt{var} for variables.

There is a constant \texttt{skip} of type \texttt{com} which corresponds to the command that do
nothing. Commands can be composed using the sequential composition operator \texttt{seq}.
Local variable are declared using the \texttt{new} operator, variable content is written
using \texttt{assign} and retrieved using \texttt{deref}.

The new formations rules are given in table \ref{tab:ia_formrules}.

\begin{table}[htbp]
$$ \rule{\Gamma \vdash M : \texttt{com} \quad \Gamma \vdash N :A}
    {\Gamma \vdash \texttt{seq}_A \ M\ N\ : A} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rule{\Gamma \vdash M : \texttt{var} \quad \Gamma \vdash N : \texttt{exp}}
    {\Gamma \vdash \texttt{assign}\ M\ N\ : \texttt{com}}
\qquad
 \rule{\Gamma \vdash M : \texttt{var}}
    {\Gamma \vdash \texttt{deref}\ M\ : \texttt{exp}}$$

$$ \rule{\Gamma, x : \texttt{var} \vdash M : A}
    {\Gamma \vdash \texttt{new } x \texttt{ in } M} \quad A \in \{ \texttt{com}, \texttt{exp}\}$$

$$ \rule{\Gamma \vdash M_1 : \texttt{exp} \rightarrow \texttt{com} \quad \Gamma \vdash M_2 : \texttt{exp}}
    {\Gamma \vdash \texttt{mkvar } M_1\ M_2\ : \texttt{var}}$$

\caption{Formation rules for IA terms}
\label{tab:ia_formrules}
\end{table}

If $\vdash M : A$ (i.e. $M$ can be formed with an empty context), we say that $M$ is a close term.

\subsection{Operational semantics}

In IA the semantics is given in a slightly different form from PCF.
In PCF, the evaluation rules were given for closed terms only. Suppose that we
proceed the same way for IA and consider the evaluation rule for the $\texttt{new}$ construct:
the conclusion is $\texttt{new } x:=0 \texttt{ in } M$ and the premise
is an evaluation for a certain term constructed from $M$, more precisely the term $M$
where \emph{some} occurrences of $x$ are replaced by the value $0$.
Because of the presence of the \texttt{assign} operator, we cannot simply replace all
the occurrences of $x$ in $M$ (the required substitution is  more complicated
than the substitution used for beta-reduction).


Therefore, instead of giving the semantics for closed term we consider terms
whose free variables are all of type \texttt{var}. These free variables are ``closed'' by mean of
stores. A store is a function mapping free variables of type \texttt{var} to natural numbers.
Suppose $\Gamma$ is a context containing only variable of type \texttt{var}, then we say that
$\Gamma$ is a \texttt{var}-context. A store whose domain $\Gamma$ is called a $\Gamma$-store.

The notation $s\ |\ x \mapsto n$ refers to the store that maps $x$ to $n$
and otherwise maps variables according to the store $s$.


The canonical forms for IA are given by the grammar:
$$ V ::= n\ |\ \lambda x. M\ |\ x\ |\  \texttt{mkvar} M N$$

where $n \in \nat$ and $x:var$.


A program is now defined by a term together with a $\Gamma$-store such that $\Gamma \vdash M : A$.
The evaluation semantics is expressed by the judgment form
$$s,M \eval s', V$$
where $s$ and $s'$ are $\Gamma$-stores,
$\Gamma \vdash M : A$ and $\Gamma \vdash V : A$ where $V$ is in canonical form.

The operational semantics for IA is given by the rule of PCF (table \ref{tab:bigstep_pcf})
together with the rules of table \ref{tab:bigstep_ia} where the following abbreviation is used:
$$ \rule{M_1 \eval V_1 \quad M_2 \eval V_2}{M \eval V} \qquad \mbox{for} \qquad
  \rule{s,M_1 \eval s',V_1 \quad s', M_2 \eval s'',V_2 }{s,M \eval s'',V}
$$


\begin{table}[htbp]
$$\mbox{\textbf{Sequencing }}
    \rule{M \eval \skip \quad N \eval V}{\texttt{seq } M\ N \eval V}
$$

$$\mbox{\textbf{Variables }}
    \rule{s,N \eval s',n \quad s',M \eval s'',x}{s, \assign\ M\ N \eval (s''\ |\ x \mapsto n),\skip}
\qquad
    \rule{s,M \eval s',x }{s, \deref\ M \eval s',s'(x)}$$

$$\mbox{\texttt{\textbf{mkvar}}}
    \rule{N \eval n \quad M \eval \texttt{mkvar } M_1\ M_2 \quad M_1\ n \eval \skip}
    {\assign\ M\ N \eval \skip}
\qquad
    \rule{N \eval \texttt{mkvar } M_1\ M_2 \quad M_2\ \eval n}
    {\deref\ M \eval n}
$$

$$\mbox{\textbf{Block}}
    \rule{(s\ |\ x \mapsto 0),M \eval (s'\ |\ x \mapsto n),V }
    {s, \texttt{new } x \texttt{ in } M \eval s',V}
$$

\label{tab:bigstep_ia}
\caption{Big-step operational semantics of IA}
\end{table}

\subsection{Game semantics}

As we have seen in section \ref{subsec:catgames}, games and strategies
form a cartesian closed category, therefore games can model the simply-typed $\lambda$-calculus. Let us first
explain how this is achieved before extending the model to PCF and IA.

Recall that the objects of the category $\mathcal{C}$ are the arenas, the morphisms are the strategies.

Given a simple type $A$, we will model it as an arena $\sem{A}$.
A context $\Gamma = x_1 :A_1, \ldots x_n:A_n$ will be mapped to the arena
$\sem{\Gamma} = \sem{A_1} \times \ldots \times \sem{A_n}$ and a term $\Gamma \vdash M : A$
will be modeled by a strategy on the arena $\sem{\Gamma} \rightarrow \sem{A}$.
Not that in case $M$ is a close term then $\sem{\Gamma} = \textbf{1}$ the terminal object of the category
(i.e. the empty arena).





\subsection{Remark}

\begin{enumerate}
\item
Well-bracketing condition is a condition on P-answers only, it does
not constraint O-answers (see \cite{abramsky:game-semantics}).

\end{enumerate}


\subsection{Second order}

\begin{lem}[Pointers are superfluous up to order 2]
Let $A$ be the arena corresponding to a PCF type of order at most 2.

Let $s$ be a justified sequence of moves in the arena $A$ satisfying
 alternation, visibility and well-bracketing then
the pointers of the sequence $s$ can be reconstructed uniquely.
\end{lem}



\begin{proof}
The only base type here is \typexp. The interpretation of it is the
flat game of natural numbers $\natbf$. The arena is:
\begin{center}
  \pstree[levelsep=6ex]
    {\TR[name=R]{q}}
    { \TR{1} \TR{2} \TR{\ldots}
    }
\end{center}

Let $T$ be a PCF type of order at most 2. $T = T_1 \rightarrow T_2
\rightarrow \ldots T_n \rightarrow \typexp$. Let $I_k = \{ 1.. n\ |\
\order{T_i} = k \}$ for $k = 0..1$.

The arenas $T_i$ for $i \in I_0$ and $T_j$ for $j \in I_1$ are given
below:
\begin{center}
\
  \pstree[levelsep=6ex]
    {\TR{$q_i$}}
    { \TR{$1_i$} \TR{$2_i$} \TR{\ldots} }
\hspace{2cm}
  \pstree[levelsep=6ex]
    { \TR{$q'_j$} }
    {
      \pstree[levelsep=6ex]
        { \TR{$q_j$} }
        { \TR{$1_j$} \TR{$2_j$} \TR{\ldots} }
      \TR{$1'_j$} \TR{$2'_j$} \TR{\ldots}
    }
\end{center}

The entire arena $A$ is
\newcommand{\SubTree}[2][]{\Tr[ref=t]{\pstribox[#1]{#2}}}
\begin{center}
\
  \pstree[levelsep=6ex]
    { \TR{$q$} }
    {
\SubTree{$T_1$} \SubTree[linestyle=dashed]{$T_i$} \SubTree{$T_n$}
    \TR{1} \TR{2} \TR{\ldots} }
\end{center}

where each triangle represents one of the two possible sub arena.

\input{proof.tex}

\end{proof}


\subsection{First-order Idealized Algol}

Dan R. Ghica and Guy McCusker

 regular language Semantics for first order

\subsection{Call-by-Value first-order Idealized Algol}

Call-by-value Programming Language, Ghica


\section{Data-abstraction refinement}

\input{dataref.tex}
