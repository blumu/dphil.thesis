\part{Background}

\chapter{Summary}

\section{Research activities}

\subsection{Courses attended}

I have attended the following courses: \emph{Automata Logic and
Games} in Hilary term 2005, \emph{Domain theory} in Michaelmas term
2005 and \emph{Categories Proofs and Programs} in Hilary term 2006.

\subsection{Teaching}

I was demonstrator for \emph{Network and Operating Systems}
practicals in Hilary term 2005, I tutored two groups of students for
the \emph{Introduction to Specification} classes (Hilary 2006). I
also did the marking for one group.

\subsection{Meetings and conferences}
\begin{itemize}
\item I attended Bonn spring school on GAMES in 2005;

\item  In March 2005, I attended BCTCS (British Colloquium in
Theoretical Computer Science) in Nottingham  where I gave a talk
about my MSc dissertation ``Termination analysis of a subset of
CoreML'';

\item I attended PAT \emph{Program transformation and Analysis} in Copenhagen, July 2005;

\item Marktoberdorf Summer School;
\item CSL (Computer Science Logic) August 2005:
I helped organizing the conference;
\item I visited the Isaac Newton Institute in Cambridge in February
2006.
\end{itemize}
I have also presented a project during the Computer Laboratories
open days.


\section{Work achieved}

During the past months, I have studied a restriction of
lambda-calculus called ``safe lambda-calculus''. \emph{Safety} is a
syntactic property originally defined by Knapik et al. in
\cite{KNU02} for higher-order recursion schemes (grammars). In their
paper they proved that the MSO theory of the term tree generated by
a safe recursion scheme of level $n$ is decidable. More recently,
Ong proved in \cite{OngLics2006} that the safety assumption is in
fact not necessary.

I am interested in the transposition of the safety property for
grammar to the safety property for lambda terms. A definition of the
safe $\lambda$-calculus was first given in a technical report by
Aehlig, de Miranda and Ong in \cite{safety-mirlong2004}. One
interesting property of safe lambda terms is that performing
substitution on such terms does not involve renaming of the
variable.

I have investigated different possible definitions of a safe lambda
calculus. I also tried to find a more general notion of safety that
do not assume homogeneity of types. Unfortunately, I have not yet
found a definition that would preserve the \emph{no variable
renaming} property.

Another direction of research that I have been investigating
consisted in relating the safety restriction and the
\emph{size-change termination} property defined in
\cite{jones01,jones04}. Jones conjectured that any simply typed term
is size-change terminating, however Damien Sereni disproved this
conjecture by exhibiting a class of counter-examples
(\cite{serenistypesct05}). The terms of this class are not all of
homogeneous type but there is a subclass of homogenous and safe
simply typed terms that are not size-change terminating. This
suggests that there is no obvious link between safety and
size-change termination.


Recently, inspired by my reading on game semantics
\cite{abramsky:game-semantics} and by the technics developed by Luke
Ong in \cite{OngLics2006}, I have proved a result on the game
semantics of safe terms: the pointers in the game semantics of safe
simply type terms can be recovered uniquely from the sequence of
moves. This result is similar to the standard result in game
semantics which says that pointers of strategies can be recovered
uniquely for arena of order 2 at most. A consequence of this result
is that the semantics of such terms can be described by (extended)
regular expressions \cite{ghicamccusker00}.



In parallel, I worked on a separate project with Matthew Hagues and
Luke Ong. We developed a SAT-based approach to the LTL model
checking problem based on the work of Merz \emph{et al}
\cite{hammer:truly} and McMillan \cite{DBLP:conf/cav/McMillan03}.

We have produced an experimental implementation in OCaml and C. The
program input is an NuSMV file (\cite{CAV02:nusmv}) containing the
model and the LTL properties to verify.

The result obtained at the moment are not too encouraging but it is
apparently due to an unfortunate bug in the implementation that we
are tracking down. There are also some optimizations that we have
not finished to implement.

We are currently finishing to write a paper about it and we hope to
submit it to the BMC workshop.

\section{Research plan}

First I need to extend the safety restriction to Idealized Algol
terms. Then I would like to extend the result I obtained for game
semantics of safe simply typed term to safe Idealized Algol terms
and investigate if it leads to some application in algorithmic game
semantics.


In \cite{abramsky:mchecking_ia}, Abramsky has studied a language
called Serially Re-entrant Idealized Algol, or SRIA for short. This
language allows multiple occurrences or uses of arguments, as long
as they do not overlap in time. In the games of this language there
is at most one pending occurrence of a question at any time, so that
each move has a unique justifier and so justification pointers may
be ignored.

I would like to find out whether there is a relationship between
SRIA and safe Idealized Algol.


I also want to investigate some application of game semantics to
program analysis and transformation by trying to extend the work of
Dimovski et al. (\cite{DBLP:conf/sas/DimovskiGL05}) on
data-absraction refinement based on game semantics.

Finally I will continue to work with Matthew Hagues and Luke Ong on
the LTL model checking problem.





\part{Research proposal}
\chapter{Program verification}
LTL model checking. LWAA. Project with Matthew and Luke.

\chapter{Program transformation and analysis}


\chapter{Game semantics}

History-free strategies: moves determined by the last move of the
Opponent.

History-sensitive strategy: moves determined by the entire history
of plays.

Innocent strategies: moves determined on the basis of the view of
the history of the play at the point being played.


\subsection{notes} For IA$_2$, complete plays are representable by
regular languages, hence program approximation and equivalence is
decidable.

\subsection{Application to program analysis}
abstraction refinement, data-abstraction refinement, modular
abstraction, inter-procedural data flow analysis, predicate
abstraction.
