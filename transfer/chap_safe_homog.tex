\section{Homogeneous safe $\lambda$-calculus}
\label{sec:safe_homog}

\subsection{Type homogeneity}
Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \funsp A$. Any type different from the base
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \funsp \cdots \funsp A_n \funsp o$ (by
convention, $\rightarrow$ associates to the right). If $T=(A_1,
\cdots, A_n, o)$ then the arity of $T$, written $arity(T)$, is
defined to be $n$.

Suppose that a ranking function ${\sf rank} :
Types \funto (L, \leq)$ is given where $(L, \leq)$ is any linearly ordered
set. Possible candidates for the ranking function are:
\begin{itemize}
\item ${\sf ord} : Types \funto (\nat,\leq)$ with $\ord{o} = 0$
and $\ord{A \funsp B} = \max(\ord{A}+1, \ord{B})$;
\item ${\sf height} : Types \funto (\nat,\leq)$ with
$\slheight{A \funsp B} = 1 + \max(\slheight{A}, \slheight{B})$ and
$\slheight{o} = 0$ ;
\item ${\sf nparam} : Types \funto (\nat,\leq)$ with $\nparam{o} = 0$
and $\nparam{A_1, \cdots, A_n} = n$;
\item ${\sf ordernp} : Types \funto (\nat \times \nat,\leq)$ with $ {\sf ordernp} (t)  = \langle \order{t}, \nparam{t} \rangle$ for $t \in Types$.
\end{itemize}
Following \cite{KNU02}, we say that a type is {\sf rank}-homogeneous
if it is $o$ or if it is $(A_1, \cdots, A_n, o)$ with the condition
that $\rank{A_1} \geq \rank{A_2}\geq \cdots \geq \rank{A_n}$ and
each $A_1$, \ldots, $A_n$ is {\sf rank}-homogeneous.



Suppose that $\overline{A_1}$, $\overline{A_2}$, \ldots,
$\overline{A_n}$ are $n$ lists of types, where $A_{ij}$ denotes the
$j$th type of list $\overline{A_i}$ and $l_i$ the size of
$\overline{A_i}$, then the notation $A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)$ means that
\begin{itemize}
  \item $A$ is the type $(A_{11},A_{12},\cdots, A_{1l_1}, A_{21}, \cdots,A_{2l_2}, \cdots A_{n1},\cdots, A_{nl_n},o)$
  \item $\forall i: \forall u,v \in A_i : \rank u = \rank v $
  \item $\forall i,j . \forall u \in A_i . \forall v \in A_j . i<j \implies \rank u >
   \rank v $
\end{itemize}
and therefore $A$ is {\sf rank}-homogenous. This notation organises
the $A_{ij}$s into partitions according to their ranks. Suppose $B =
(\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$,
we write $(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, |
\, {B})$ to mean
\[(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, | \,
\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o).\]

From now on, we only consider the rank function {\sf ord}. We will
use the term ``homogeneous'' to refer to {\sf ord}-homogeneity.


\subsection{Safe Higher-order recursion scheme}
We now present the original notion of safety introduced in
\cite{KNU02} as a restriction on higher-order recursion schemes. We
introduce briefly the notion of higher-order recursion scheme. The
reader is refered to \cite{KNU02,demirandathesis,safety-mirlong2004}
for more details.

Suppose that $\Gamma$ is a set of typed symbol then the set of
\emph{applicative terms} written $\mathcal{T}(\Gamma)$ is the
closure of $\Gamma$ under the application rule i.e. if $s:
A\rightarrow B$ and $t:A$ are in $\mathcal{T}(\Gamma)$ then so is
$st :B$.

A higher-order recursion scheme is a deterministic grammar that can be used to define potentially infinite term trees:
\begin{dfn}[Higher-order recursion scheme]
A \emph{deterministic higher-order grammar} or \emph{higher-order recursion scheme} is a tuple $\mathcal{G} =
\langle \Sigma, \mathcal{N}, V, \mathcal{R}, S \rangle$, where
\begin{itemize}
\item $\Sigma$ is a ranked alphabet of terminals of order at most 1,
\item $V$ is a finite set of typed variables,
\item $\mathcal{N}$ is a finite set of homogeneously-typed non-terminals,
\item $S$ a distinguished symbol of $\mathcal{N}$ of ground type, called the start symbol,
\item $\mathcal{R}$ is a finite set of production rules, one for each $F : (A_1, \ldots, A_n, o) \in N$, of the form
    $$ F z_1 \ldots z_m \rightarrow e$$
where $z_i$ is a variable of type $A_i$ and $e$ is an applicative
term of type $o$ in $\mathcal{N}(\Sigma \union \mathcal{N} \union
\{z_1 \ldots z_m \} )$. The $z_i$s are called the \emph{parameters}
of the rule.
\end{itemize}
\end{dfn}
The order of a rewrite rule is the order of the non-terminal symbol
appearing on the left hand side of the rule. The order of a grammar
is the highest order of its non-terminals.

Safety is a syntactic restriction on higher-order grammars. It can be formulated as
follows:
\begin{dfn}[Safe Higher-order grammar]
  Let $G$ be a higher-order grammar $G$ of order $n$
    whose non-terminals are of homogeneous type.
    $G$ is \emph{unsafe} if and only if there is a rewrite rule $F z_1 \ldots z_m \rightarrow e$ where
   $e$ contains a subterm $t$ such that:
  \begin{enumerate}
    \item $t$ occurs in an operand position in $e$,
    \item $t$ is of order $k>0$,
    \item $t$ contains a parameter of order strictly less than $k$.
  \end{enumerate}
  $G$ is \emph{safe} if it is not unsafe.
\end{dfn}

Let us give an example taken from \cite{KNU02}:
\begin{exmp} Let $f:(o,o,o)$, $g,h:(o,o)$ and $a,b:o$ be $\Sigma$ constants.
 The grammar of level 3 with non-terminals $S:o$ and $F: ((o,o),o,o,o)$ and production rules:
\begin{eqnarray*}
    S &\rightarrow&  F g a b \\
    F \varphi x y &\rightarrow& f ( \mathcal{F} ( F \varphi x ) y (h y)) (f (\varphi x) y)
\end{eqnarray*}
is not safe because the term $\mathcal{F} \varphi x : (o,o)$ containing a variable of order $0$
occurs at an operand position in the right-hand side expression of the second rule.

On the other hand, the grammar with the following production rules is safe:
\begin{eqnarray*}
    S &\rightarrow&  F g a b \\
    F \varphi x y &\rightarrow& f ( \mathcal{F} ( F \varphi x ) y (h y)) (f (\varphi x) y)
\end{eqnarray*}
Moreover it can be shown that these two grammars are equivalent in the sense that they generate the same
infinite tree.
\end{exmp}


\subsection{Rules of the Safe $\lambda$-Calculus}

There is a correspondence between higher-order recursion schemes and
the simply-typed $\lambda$-calculus. The non-terminals of a
recursion scheme can be interpreted as $\lambda$-abstractions in the
simply-typed $\lambda$-calculus. The $\Sigma$-constants are
interpreted as ``constructors'' constants (in the sense of
constructor used in functional programming languages to represent
abstract data-types such as trees). The notions of variable and
application are directly transposed to the equivalent notions in the
simply-typed $\lambda$-calculus. Using this analogy it is possible
to derive a version of the safety restriction for the
$\lambda$-calculus.

The Safe $\lambda$-calculus has been first proposed in \cite{DBLP:conf/fossacs/AehligMO05},
a corrected definition appeared in \cite{Ong2005}. The definition that we give here is
slightly more general in the sense that we allow the use of
$\Sigma$-constants of any higher-order type whereas the original definition only allows first order constants.


The \textbf{Safe $\lambda$-Calculus} is a sub-system of the
simply-typed $\lambda$-calculus. Typing judgements (or
terms-in-context) are of the form:
\begin{equation}
\nonumber \seq{\overline{x_1}:\overline{A_1} \, | \, \cdots \, | \,
\overline{x_n} :  \overline{A_n}}{M : B}
\end{equation}
which is shorthand for $\seq{x_{11} : A_{11}, \cdots, x_{1r}:
A_{1r}, A_{21},\ldots }{M : B}$ such that the context variables are listed in decreasing type order and
 with the condition that $\ord{x_{ik}} < \ord{x_{jl}}$ for any $k, l$ and $i<j$.

\emph{Valid typing judgements} of the system are defined by
induction over the following rules, where $\Delta$ is a given
homogeneously-typed alphabet and $\Sigma$ is a set of
homogeneously-typed constants:

$$ \rulename{wk}
    {   \rulef{ \seq{\Gamma}{M:B} \qquad {\Gamma \subset \Delta} }
             { \seq{\Delta }{M : B}}
   }
\qquad
    \rulename{perm}
    {
      \rulef { \seq{\Gamma}{M:B} \qquad \sigma(\Gamma) \hbox{ homogeneous} }
            { \seq{\sigma(\Gamma)}{M : B} }
    }
$$

$$ \rulename{\Sigma\mbox{\textbf{-const}}}  \rulef{}{\seq{}{b : A}}\ b:A \in \Sigma
\qquad
 \rulename{var} \rulef{}{\seq{x_{ij} : A_{ij}\, }{x_{ij} : A_{ij}}}
$$

$$ \rulename{\lambda\mbox{\textbf{-abs}}}
\rulef{ {\seq{\overline{x_1} : \overline{A_1}\, | \, \cdots\, | \,
\overline{x_{n+1}} : \overline{A_{n+1}}}{M : B}} \qquad
\ord{\overline{A_{n+1}}} \geq \ord{B} -1}
    {\seq{\overline{x_1} :
\overline{A_1}\, | \, \cdots\, | \, \overline{x_{n}} :
\overline{A_{n}}}{\lterm{\overline{x_{n+1}} : \overline{A_{n+1}}}{M}
: (\overline{A_{n+1}} \, | \, B)}} $$

$$ \rulename{app} \rulef{{\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
\seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} :
B_{1l}} \qquad l = |\overline{B_1}| }}
    { \seq{\Gamma}{M N_1
\cdots N_{l} : (\overline{B_2} \, | \, \cdots \, | \,
\overline{B_m} \, | \, o)}} $$

$$ \rulename{app^+} \rulef
    {\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
    \seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} :
    B_{1l}} \qquad l < |\overline{B_1}| }
    { \seq{\Gamma}{M N_1
    \cdots N_{l} : (\overline{B} \, | \, \overline{B_2} \, | \ \cdots \, | \,
    \overline{B_m} \, | \, o)}} $$

where $\overline{B_1} = B_{11}, \ldots, B_{1l},\overline{B}$ with
the condition that every variable in $\Gamma$ has an order strictly greater
than $\ord{\overline{B_1}}$.






\begin{property}[Basic properties]
\label{proper:safe_basic_prop} Suppose $\Gamma \vdash M : B$ is a
valid judgment then
\begin{itemize}
\item[(i)] $B$ is homogeneous;
\item[(ii)] every free variable of $M$ has order at least $\ord{M}$;
\item[(iii)] $fv(M) \vdash M : B$,
\end{itemize}
where $fv(M) \subseteq \Gamma$ denotes the context constituted of the variables
in $\Gamma$ occurring free in $M$.
\end{property}
\begin{proof}
(i) and (ii) are proved by an easy structural induction. (iii) is
due to the fact that the weakening rule is the only rule which can
introduce a variable not occurring freely in $M$ in the context of a
typing judgement.
\end{proof}

We now define a special kind of substitution that performs
simultaneous substitution and permits variable capture i.e. that
does not rename variables when the substitution is performed on an
abstraction.

\begin{dfn}[Capture-permitting simultaneous substitution (for homogeneous safe terms)]
\label{dnf:safe_simsubst} We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$ and $\overline{y}:\overline{A}$ for $y_1:A_1, \ldots,
y_p:A_p$. A safe term has necessarily one of the forms occurring on
the left-hand side of the following equations, where $M$, $N_1,
\ldots N_l$ are safe terms. The capture-permitting simultaneous
substitution is then defined by:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{ where $c$ is a $\Sigma$-constant}\\
x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
(M N_1 \ldots N_l) \subst{\overline{N}}{\overline{x}} &=& (M \subst{\overline{N}}{\overline{x}}) (N_1 \subst{\overline{N}}{\overline{x}}) \ldots  (N_l \subst{\overline{N}}{\overline{x}})\\
(\lambda \overline{y} : \overline{A}. M)
\subst{\overline{N}}{\overline{x}} &=& \lambda \overline{y} . M
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright I} \\
&& \mbox{where } I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y} \}
\end{eqnarray*}

where $ \upharpoonright$ is the index filtering operator: if $s$ is
a sequence and $I$ a set of indices then $s \upharpoonright I$ is
the subsequence of $s$ obtained by keeping only the element in $s$
at positions in $I$.
\end{dfn}

This substitution is well-defined for safe terms in the sense that safety is preserved by substitution:

\begin{lem}[Capture-permitting simultaneous substitution preserves safety]
\label{lem:subst_preserve_safety} Let $\Gamma \union \overline{x}
\vdash M$ be a safe term where $\overline{x}$ denotes a list of
variables (which do not necessarily belong to the same partition).

For any safe terms $\Gamma \vdash N_1, \cdots, \Gamma \vdash N_n$,
the capture-permitting simultaneous substitution $M[N_1 / x_1 ,
\cdots, N_n / x_n]$ is safe. In other words, the following judgment
is valid:
$$ \Gamma \vdash M[N_1 / x_1 , \cdots, N_n / x_n] $$
\end{lem}
\begin{proof}
An easy proof by an induction on the structure of the safe term.
\end{proof}



With the traditional substitution, it is necessary to rename
variables when performing substitution on an abstraction in order to
avoid possible variable capture. As a consequence, in order to
implement substitution one needs to have access to an unbound number
of variable names. An interesting property of the homogeneous safe
$\lambda$-calculus is that variable capture never occurs when
performing substitution. In other words, the traditional
substitution can be safely replaced by the capture-permitting
substitution:

\begin{lem}[No variable capture lemma]
\label{lem:homog_nocapture} In the safe $\lambda$-calculus, there is
no variable capture when performing the following capture-permitting
simultaneous substitution:
$$ M[N_1 / x_1 , \cdots, N_n / x_n] $$
provided that $\Gamma \union \overline{x} \vdash M$, $\Gamma \vdash  N_1, \cdots ,\Gamma \vdash  N_n$ are valid judgments.
\end{lem}

\begin{proof}
We prove the result by induction. The variable, constant and
application cases are trivial. For the abstraction case, suppose $M
= \lambda \overline{y} : \overline{A}. P$ where $\overline{y} = y_1
\ldots y_p$. The capture-permitting simultaneous substitution gives:
$$M \subst{\overline{N}}{\overline{x}} = \lambda \overline{y} . P
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright
I} \mbox{ where } I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y}
\}. $$


By the induction hypothesis there is no variable capture in $P
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright
I}$. Hence variable capture can only happen when the variable $y_j$
occurs freely in $N_i$ and $x_i$ occurs freely in $P$ for some $i
\in I$ and $j \in 1..p$. In that case, property
\ref{proper:safe_basic_prop} (ii) gives:
$$ \ord{y_j} \geq \ord{N_i} = \ord{x_i}$$

Moreover $i\in I$ therefore $x_i \not \in \overline{y}$ and since $x_i$ occurs freely in $P$, $x_i$ must also occur freely in the safe term
$\lambda \overline{y}. P$. Thus, property \ref{proper:safe_basic_prop} (ii) gives:
$$ \ord{x_i} \geq \ord{\lambda y_1 \ldots y_p . T} \geq 1+ \ord{y_j} > \ord{y_j}$$

which, together with the previous equation, gives a contradiction.
\end{proof}




\subsection{Safe $\beta$-reduction}

We now introduce the notion of safe $\beta$-redex and show how to
reduce them using the capture-permitting simultaneous substitution.
We will then show that a safe $\beta$-reduction reduces to a safe
term.


In the simply-typed lambda calculus a redex is a term of the form $(\lambda x . M) N$.
We generalize this notion to the safe lambda calculus. We call multi-redex a term of the form
$(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ (it is not required to have $n=l$).


We say that a multi-redex is safe if it respects the formation rules
of the safe $\lambda$-calculus: the multi-redex $(\lambda x_1 \ldots
x_n . M) N_1 \ldots N_l$ is a safe redex if the variable
$x_1,\ldots,x_n$ are abstracted altogether at once using the
abstraction rule and if the terms $N_1 \ldots N_l$ are applied to
the term $\lambda x_1 \ldots x_n . M$ at once using either the rule
$\rulename{app^+}$ or $\rulename{app}$. The formal definition
follows:

\begin{dfn}[Safe redex]
A safe redex is a term of the form:
$$(\lambda \overline{x} . M) N_1 \ldots N_l$$
such that
\begin{itemize}
  \item variables $\overline{x}=x_1\ldots x_n$ are abstracted
altogether by one occurrence of the rule $\rulename{abs}$ in the
proof tree (possibly followed by the weakening rule). This implies
that:
$$\ord{M} -1 \leq \ord{\overline{x}} = \ord{x_1} = \ldots = \ord{x_n};$$
\item the terms $(\lambda \overline{x} . M)$, $N_1$,
$N_l$ are applied together at once using either:
\begin{itemize}
    \item the rule $\rulename{app}$:
        $$   \rulef{
                    \Sigma \vdash \lambda \overline{x} . M : (\overline{B_1}|\ldots|\overline{B_m}|o)
                    \quad
                    \Sigma \vdash N_1         \quad \ldots \quad \Sigma \vdash N_l
                    \quad l = |\overline{B_1}|
            }
            {
            \Sigma \vdash (\lambda \overline{x} . M) N_1 \ldots N_l
            } (\mathbf{app}),
        $$
        in which case  $n\leq |\overline{B_1}| = l$;

\item or the rule $\rulename{app^+}$:
        $$   \rulef{
                    \Sigma \vdash \lambda \overline{x} . M : (\overline{B_1}|\ldots|\overline{B_m}|o)
                    \quad
                    \Sigma \vdash N_1         \quad \ldots \quad \Sigma \vdash N_l
                    \quad l < |\overline{B_1}|
            }
            {
            \Sigma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
            } (\mathbf{app^+}),
        $$
      in which case $n \leq |\overline{B_1}|$ and no relation holds between $n$ and $l$.
\end{itemize}
\end{itemize}
It is not required to have $n = |\overline{B_1}|$.
\end{dfn}

Note that there are safe terms of the form $(\lambda x_1 \ldots x_n
. M) N_1 \ldots N_l$ with $l>n$. For instance the term $ (\lambda f
. ((\lambda g h . h) a) ) a a$ of type $o \rightarrow o$ for some
constant $a:o \rightarrow o$ and variables $x : o$ and $f,g,h:o
\rightarrow o$, can be formed using the $\rulename{app}$ rule as
follows:
$$ \rulef{
    \emptyset \vdash (\lambda f . ((\lambda g h . h) a) ) : (o,o),(o,o),o,o
        \quad \emptyset \vdash a : o,o
        \quad \emptyset \vdash a : o,o
    }
    {
       \emptyset \vdash (\lambda f . ((\lambda g h . h) a) ) a a : o,o
    } \rulename{app}
$$


\begin{dfn}[Safe reduction $\beta_s$] \
\label{dfn:safereduction} For the sake of concision, the following
abbreviations are used $\overline{x} = x_1 \ldots x_n$,
$\overline{N} = N_1 \ldots N_l$, and when $n\geq l$, $\overline{x_L}
= x_1 \ldots x_l$, $\overline{x_R} = x_{l+1} \ldots x_n$.
\begin{itemize}
\item The relation $\beta_s$ is defined on the set of safe redex as follows:
\begin{eqnarray*}
\beta_s &=&
\{  \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}}  \\
&& \mbox{ where $(\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ is a safe redex such that $n> l$}
\} \\
&\union&
\{ \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l  \\
&& \mbox{ where $(\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ is a safe redex such that $n\leq l$}
\}
\end{eqnarray*}
where the notation $\subst{\overline{N}}{\overline{x}}$ denotes the capture-permitting simultaneous substitution.

\item
The safe $\beta$-reduction, written $\betasred$, is the closure of
the relation $\beta_s$ by compatibility with the formation rules of
the safe $\lambda$-calculus.
\end{itemize}
\end{dfn}



We observe that safe $\beta$-reduction is a certain kind of multi-steps $\beta$-reduction.
\begin{property}
$\betasred \subset \betaredtr$, i.e. the safe
$\beta$-reduction relation is included in the transitive closure of the $\beta$-reduction relation.
\end{property}
\begin{proof}
Suppose that $(M\mapsto N) \in \beta_s$. We show that $M \betared^* N$.
\begin{itemize}
\item Suppose that the safe-redex is
$M \equiv (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ such that $n\leq l$ then:
\begin{eqnarray*}
 M &=_\alpha& (\lambda z_1 \ldots z_n .T [z_1,\ldots z_n /x_1,\ldots x_n] ) \ N_1  N_2 \ldots N_l
            \\
&& \mbox{where the $z_i$ are fresh variables}  \\
     &\betared& (\lambda z_2 \ldots z_n .T [z_1,\ldots z_n /x_1,\ldots x_n] \subst{N_1}{z_1} ) \ N_2 \ldots N_l \\
&& \mbox{ (because the $z_i$s do not occur freely in $N_1$) }\\
%%    &=_\alpha& (\lambda z_2 \ldots z_n .T [z_2,\ldots z_n /x_2,\ldots x_n] \subst{N_1}{x_1})\  N_2 \ldots N_l  \qquad \mbox{where the $z_i$ are fresh variables}  \\
    &\betared& \ldots \\
    &\betared& (T [z_1,\ldots z_n /x_1,\ldots x_n] \subst{N_1}{z_1}  \ldots \subst{N_n}{z_n})\  N_{n+1} \ldots N_l \\
    &\betared& (T [N_1\ldots N_l/x_1,\ldots x_l])\ N_{n+1} \ldots
    N_l,
\end{eqnarray*}
and since $T$ is safe, the substitution $T [N_1\ldots N_l/x_1,\ldots
x_l]$ in the last equation can be performed using the
capture-permitting substitution. Hence $M \betared^* N$.

\item
 Suppose that $M \equiv (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ such that $n> l$, then necessarily
the redex must be formed using the $\rulename{app^+}$ rule. The
side-condition of this rules says that the free variables of the
terms $N_1, \ldots N_l$ have all order strictly greater than
$\ord{\overline{x}}$, hence the $x_i$s do not occur freely in $N_1,
\ldots N_l$. Therefore:
\begin{eqnarray*}
 M &=& (\lambda x_1 \ldots x_n .T) \ N_1  N_2 \ldots N_l  \\
     &\betared& (\lambda x_2 \ldots x_n .T \subst{N_1}{x_1} ) \ N_2 \ldots N_l \\
            && \mbox{(for $i \in 2..n$, $x_i$ does not occur freely in $N_1$)}\\
    &\betared& \ldots \\
    &\betared& \lambda x_{l+1} \ldots x_n . T \subst{N_1}{x_1}  \ldots \subst{N_l}{x_l} \\
        && \mbox{(for $i \in (l+1)..n$,  $x_i$ does not occur freely in $N_l$)}\\
    &\betared& \lambda x_{l+1} \ldots x_n . T [N_1\ldots, N_l /  \ x_1,\ldots, x_l] \\
        && \mbox{(the $x_i$ do not occur freely in $N_1, \ldots
        N_l$)},
\end{eqnarray*}
and since $T$ is safe, the substitution $T [N_1\ldots N_l/x_1,\ldots
x_l]$ in the last equation can be performed using the
capture-permitting substitution. Hence $M \betared^* N$.
\end{itemize}
\end{proof}

\begin{property} In the simply-typed $\lambda$-calculus:
\begin{enumerate}
\item $\betasred$ is strongly normalizing.
\item $\beta_s$ has the unique normal form property.
\item $\beta_s$ has the Church-Rosser property.
\end{enumerate}
\end{property}

\begin{proof}
1. This is because $\betasred \subset \betaredtr$ and, $\betared$ is
strongly normalizing in the simply-typed $\lambda$-calculus. 2. A
term has a safe redex iff it has a $\beta$-redex therefore the set
of $\beta_s$ normal forms is equal to the set of $\beta_s$ normal
forms. Hence, the unicity of $\beta$-normal form implies the unicity
of $\beta_s$-normal form. 3. is a consequence of 1 and 2.
\end{proof}


Capture-permitting simultaneous substitution preserves safety (lemma
\ref{lem:subst_preserve_safety}), consequently any safe redex
reduces to a safe term:

\begin{lem}[The safe reduction $\beta_s$ preserves safety]
\label{lem:homoh_safered_preserve_safety}
If $M$ is safe and $M \betasred N$ then $N$ is safe.
\end{lem}

\begin{proof}
It suffices to show that the relation $\beta_s$ preserves safety.
Consider the safe-redex $(s\mapsto t) \in \beta_s$ where $ s \equiv (\lambda x_1 \ldots x_n . M) N_1 \ldots N_l $ .
We proceed by case analysis on the last rule used to form the redex.
\begin{itemize}
\item Suppose the last rule used is $\rulename{app}$, then necessarily $n\leq l$ and the reduction is
$$(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l \qquad \mapsto  \qquad t \equiv M[N_1 / x_1 , \cdots, N_n / x_n]\ N_{n+1} \ldots N_l.$$
The first premise of the rule $\rulename{app}$ tells us that $M$ is safe therefore using lemma \ref{lem:subst_preserve_safety} and
the application rule we obtain that $t$ is safe.

\item Suppose the last rule used is $\rulename{app^+}$ and $n> l$ then the reduction is
$$ (\lambda \overline{x_L} : \overline{A_L} \
\overline{x_R}: \overline{A_R} . T) \overline{N_L} \qquad \mapsto
\qquad t \equiv \lambda \overline{x_R}: \overline{A_R} .
T\subst{\overline{x_L}}{\overline{N_L}}.
$$
By lemma \ref{lem:subst_preserve_safety}, $T\subst{\overline{x_L}}{\overline{N_L}}$ is a safe term.
Using the rule $\rulename{abs}$ we derive that $t$ is safe.

\item Suppose the last rule used is $\rulename{app^+}$ and $n\leq l$ then the reduction is
$$(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l \qquad \mapsto \qquad t \equiv M[N_1 / x_1 , \cdots, N_n / x_n]\ N_{n+1} \ldots N_l$$
We conclude that $t$ is safe similarly to case $\rulename{app}$.

\item Rule $\rulename{wk}$ $\rulename{seq}$: these cases reduce to one of the previous cases.
\end{itemize}
\end{proof}


\begin{rem}
\label{rem:betasred_notpreserv_unsafety} $\betasred$ \emph{does not}
preserves un-safety: given two terms $S$ safe and $U$ unsafe of the
same type, the term $(\lambda x y . y) U S$ is also unsafe but it
$\beta_s$-reduces to $S$ which is safe.
\end{rem}


\subsection{An alternative system of rules}


In this section, we will refine the formation rules
given in the previous section. We say that $\Gamma \vdash M : A$ verifies $P_i$ for $i \in \zset$ if the
variables in $\Gamma$ all have orders at least $\ord{A}+i$. We introduce the notation $\Gamma \vdash^{i} M : A$ for $i \in
\zset$ to mean that $\Gamma \vdash M : A$ is a valid judgment satisfying $P_i$.


We remark that if $\Gamma \vdash M : A$ then the variables in $\Gamma$ with order
strictly smaller than $M$ cannot occur freely in $M$ and therefore it is possible to restrict
the context to a smaller number of variables:

\begin{lem}[Context reduction]
\label{lem:restriction}

If $\Gamma \vdash^i M : A$ then $\Gamma' \vdash^{0} M : A$
where $$\Gamma' = \{ z \in \Gamma \ |
\ \ord{z} \geq \ord{M} \} = \Gamma \setminus \{ z \in \Gamma \ | \ \ord{M} + i \leq \ord{z} < \ord{M} \}$$
\end{lem}
\begin{proof}
If $i\geq 0$ then the result is trivial. Suppose $i<0$. We proceed
by structural induction and case analysis. We only give the details
for the application cases $\rulename{app}$ and $\rulename{app^+}$:
\begin{itemize}
\item Case of the rule $\rulename{app}$:

    \[ (\mathbf{app}) \
    \rulef
        {\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
            \seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} :
            B_{1l}} \qquad l = |\overline{B_1}| }
        { \seq{\Gamma}{M N_1
            \cdots N_{l} : (\overline{B_2} \, | \, \cdots \, | \,
            \overline{B_m} \, | \, o)}}
    \]

    If the conclusion verifies $P_i$ then, for all $z \in \Gamma$:
    \begin{eqnarray*}
    \ord{z} \geq 1 + \ord{\overline{B_2}} + i
    &=& 1 + \ord{\overline{B_1}} + \ord{\overline{B_2}} - \ord{\overline{B_1}} + i \\
    &=& \ord{M} + (\ord{\overline{B_2}} - \ord{\overline{B_1}} + i)
    \end{eqnarray*}
    Therefore the first premise satisfies $P_j$ where $j={\ord{\overline{B_2}} - \ord{\overline{B_1}} + i}$.
    Hence by the induction hypothesis,
    $$\Gamma' \vdash^{0} M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$$
    where $\Gamma' = \Gamma \setminus \{ z \in \Gamma \ | \ \ord{M} + j \leq \ord{z} < \ord{M} \}$.


    Similarly, for all $z \in \Sigma$:
    \begin{eqnarray*}
    \ord{z} \geq 1 + \ord{\overline{B_2}} + i
    &=& \ord{\overline{B_1}} + (1+\ord{\overline{B_2}} - \ord{\overline{B_1}} + i) \\
    &=& \ord{\overline{B_1}} + j+1
    \end{eqnarray*}
    Hence by the induction hypothesis:
    $$\Gamma'' \vdash^0 N_k : B_{1k} \mbox{ for } k \in 1..l$$
    where $\Gamma'' = \Gamma \setminus \{ z \in \Gamma \ | \ \ord{M} + j+1 \leq \ord{z} < \ord{M} \}$.

    Furthermore, $\Gamma'' = \Gamma' \union \{ z \in \Gamma \ | \ \ord{M} + j = \ord{z}\}$ therefore
    the weakening rule gives:
    $$\Gamma'' \vdash^{-1} M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$$

    Finally the $\rulename{app}$ rule gives:
    $$\rulef{\Gamma'' \vdash^{-1} M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)
    \quad \Gamma'' \vdash^0 N_1 : B_{11} \quad \ldots \quad \Gamma'' \vdash^0 N_1 : B_{1l}
    }
        { \Gamma'' \vdash M N_1 \ldots N_l : (\overline{B_2} \, | \, \cdots \, | \,
            \overline{B_m} \, | \, o)}
    $$
    such that for all $z\in \Gamma''$:
    \begin{eqnarray*}
    \ord{z} \geq \ord{\overline{B_1}}
    &\geq& 1 + \ord{\overline{B_2}} = \ord{M N_1 \ldots N_l}
    \end{eqnarray*}

    Therefore:
    $$\Gamma'' \vdash^0 M N_1 \ldots N_l : (\overline{B_2} \, | \, \cdots \, | \,
            \overline{B_m} \, | \, o)$$

\item $\rulename{app^+}$  The side-condition of the rule $\rulename{app^+}$ ensures that the first premise
 verifies $P_0$. The conclusion of the rule has the same order as the first premise
 therefore the conclusion also verifies $P_0$.
\end{itemize}
\end{proof}


\begin{lem}
\label{lem:prooftree01only} If $\Gamma \vdash^{0} M : T$ or $\Gamma
\vdash^{-1} M : T$ then there is a valid proof tree showing $\Gamma
\vdash M : T$ such that all the judgments appearing in the proof
tree verify either $P_0$ or $P_{-1}$.
\end{lem}


\begin{proof}
Since $P_{-1}$ implies $P_0$, w.l.o.g. we can assume that the
judgment $\Gamma \vdash M : T$ satisfies $P_{-1}$. We show that
there is a proof tree for $\Gamma \vdash M : T$ where all the nodes
of the tree verify $P_0$ or $P_{-1}$. We proceed by structural
induction and case analysis on the last rule used to show $\Gamma
\vdash M : T$:
\begin{itemize}
\item Axiom $\rulename{\Sigma\mbox{\textbf{-const}}}$: the context is empty therefore the sequent verifies $P_{-1}$.

\item Axiom $\rulename{var}$: the context contains only the variable itself therefore the sequent verifies $P_0$.

\item Rule $\rulename{wk}$: The premise is $\Delta \vdash M : T$ with $\Delta \subset \Gamma$. Since
$\Gamma \vdash M : T$ verifies $P_{-1}$ and $\Delta \subset \Gamma$ the premise must also verify $P_{-1}$. We can conclude using the
induction hypothesis.

\item Rule $\rulename{perm}$: By the induction hypothesis.


\item Rule $\rulename{abs}$: the second premise of the rule guarantees that the first
premise verifies $P_{-1}$.

\item Rule $\rulename{app^+}$: The first premise has the same order as the
conclusion of the rule therefore the first premise verifies
$P_0$. The side-condition of the rule $\rulename{app^+}$ ensures that all the other premises verify $P_0$.

\item Rule $\rulename{app}$:

$$ \rulename{app} \
    \rulef{
        { \Gamma \vdash M : (\overline{A} \, | B)
        \qquad
        \Gamma \vdash N_1 : A_1 \quad \cdots \quad \Gamma \vdash N_{l} : A_l \qquad l = |\overline{A}|
        }
    }
    {
        \Gamma \vdash^0 M N_1 \cdots N_{l} : B
    }
$$

Applying lemma \ref{lem:restriction} to the first premise we obtain:
\begin{equation}
 \Sigma \vdash^0 M : (\overline{A} \, | B) \label{eq:seq1}
\end{equation}
where $\Sigma = \{ z \in \Gamma \ | \ \ord{z} \geq \ord{(\overline{A} \, | B)} \} = \{ z \in \Gamma \ | \ \ord{z} \geq 1 + \ord{\overline{A}} \}.$

Applying lemma \ref{lem:restriction} to each of the remaining
premises gives  :
$$ \Sigma' \vdash^0 N_i : A_i \quad \mbox{ for all } i \in 1..p$$
where $\Sigma' = \{ z \in \Gamma \ | \ \ord{z} \geq \ord{A_i} =
\ord{\overline{A}} \} \supseteq \Sigma.$

If the inclusion $\Sigma \subseteq \Sigma'$ is strict then we apply the weakening rule to sequent (\ref{eq:seq1}):
$$ \rulef{\Sigma \vdash^0 M : (\overline{A} \, | B)}{\Sigma' \vdash^{-1} M : (\overline{A} \, | B)} \rulename{wk} $$

Finally, we obtain the following proof tree:
$$  \rulef{
        \rulef{
            { \Sigma' \vdash^{-1} M : (\overline{A} \, | B)
            \qquad
            \Sigma' \vdash^0 N_1 : A_1 \quad \cdots \quad \Sigma' \vdash^0 N_{l} : A_l \qquad l = |\overline{A}|
            }
        }
        {
            \Sigma' \vdash^0 M N_1 \cdots N_{l} : B
        } \rulename{app}
    }
    {
         \Gamma \vdash^0 M N_1 \cdots N_{l} : B
    } \rulename{wk}
$$

where the last weakening rules is applied only if the inclusion $\Sigma' \subseteq \Gamma$ is strict.

We can now conclude by applying the induction hypothesis on the
sequents $\Sigma' \vdash^{-1} M$, $\Sigma' \vdash^0 N_1$, \ldots,
$\Sigma' \vdash^0 N_l$ .
\end{itemize}
\end{proof}

\subsubsection{An alternative definition of the homogeneous safe $\lambda$-calculus}

Using the observations that we have just made, we will now derive
new rules for the safe $\lambda$-calculus with homogeneous type. We
want a system of rules generating sequents that verify $P_0$. Also,
it must be able to generate intermediate sequents that do not
necessarily satisfy $P_0$ provided that they can be used to produce
\emph{in fine} terms satisfying $P_0$.

Because of the lemma \ref{lem:prooftree01only}, we know that the
only necessary intermediate sequents are those that either satisfy
$P_0$ or $P_{-1}$. Hence, we can assume by default that premises of
the rules all satisfy $P_{-1}$ at least.

First we define an additional rule expressing the fact that $P_0$
implies $P_{-1}$:
$$ \rulename{seq} \  \rulef{\Gamma \vdash^{0} M : A}{\Gamma \vdash^{-1} M : A} $$

The weakening rule can be rewritten as follows:
$$ \rulename{wk^{0}} \   \rulef{\Gamma \vdash^{0} M : A}{\Gamma , x : B \vdash^{0} M : A} \quad \ord{B} \geq \ord{A} $$
$$ \rulename{wk^{-1}} \   \rulef{\Gamma \vdash^{-1} M : A}{\Gamma , x : B \vdash^{-1} M : A} \quad \ord{B} \geq \ord{A} -1$$

Because of the context reduction lemma, any sequent verifying $P_{-1}$ can be obtained
by applying the weakening rule $\rulename{wk^{-1}}$ or the rule $\rulename{seq}$ to another sequent
verifying $P_0$. Therefore, with the exception of these two rules, we only need to use rules
whose conclusion sequents verify $P_0$:
\begin{itemize}
\item For the rules $\rulename{perm}$, $\rulename{const}$ and $\rulename{var}$, only the tagging of the sequents
changes:
$$ \rulename{var} \   \rulef{}{x : A\vdash^{0} x : A}
\qquad
\rulename{\Sigma\mbox{\textbf{-const}}}  \  \rulef{}{\vdash^0 b : A} \ b:A \in \Sigma
$$

$$
  \rulename{perm} \  \rulef{
      { \Gamma \vdash^0 M:B \qquad \sigma(\Gamma)  } \hbox{ homogeneous}
    }
      { \sigma(\Gamma) \vdash^0 M : B }
$$

\item $\rulename{abs}$ The abstraction rule has a side condition
expressing the fact that the premise verifies $P_0$ or $P_{-1}$. Since this is always true for sequents
generated by our new system of rules, we can drop the side condition:
$$ \rulename{abs} \   \rulef{\Gamma | \overline{x} : \overline{A} \vdash^{-1} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A},B)}$$


\item $\rulename{app}$ The application rule has the following form:
$$ \rulename{app} \
    \rulef{
        { \Gamma \vdash^{-1} M : (\overline{A} \, | B)
        \qquad
        \Gamma \vdash^{-1} N_1 : A_1 \quad \cdots \quad \Gamma \vdash^{-1} N_{l} : A_l \qquad l = |\overline{A}|
        }
    }
    {
        \Gamma \vdash^0 M N_1 \cdots N_{l} : B
    }
$$

Since the first premise verifies $P_{-1}$, by property \ref{proper:safe_basic_prop}(ii) we have:
$$\forall z \in \Gamma : \ord{z} \geq 1 + \ord{\overline{A}} -1 = \ord{\overline{A}} = \ord{\overline{N}}$$
Hence, all the sequents of the premises but the first must verify $P_0$. The rule (app) is therefore given by:
$$ \rulename{app} \
    \rulef{
        { \Gamma \vdash^{-1} M : (\overline{A} \, | B)
        \qquad
        \Gamma \vdash^0 N_1 : A_1 \quad \cdots \quad \Gamma \vdash^0 N_{l} : A_l \qquad l = |\overline{A}|
        }
    }{
        \Gamma \vdash^0 M N_1 \cdots N_{l} : B
      }
$$

\item For the application rule $\rulename{app^+}$, the type of the sequent in the first premise has the same order
as the type of the conclusion premise, and since the conclusion
verifies $P_0$, the first premise must also verify $P_0$. The
side-condition implies that all the other sequents in the premise
verify $P_0$. Moreover since the first premise verifies $P_0$, the
side-condition must hold. Hence the rule becomes:
$$ \rulename{app^+} \
    \rulef{
        \Gamma \vdash^0 M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o) \qquad
        \Gamma \vdash^0 N_1 : B_{11} \quad \cdots \quad \Gamma \vdash^0 N_{l} : B_{1l} \qquad l < |\overline{B_1}|
    }
    {
        \Gamma \vdash^0 M N_1 \cdots N_{l} : (\overline{B} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)
    }
$$
where $\overline{B_1} = B_{11}, \ldots, B_{1l},\overline{B}$.
Clearly, this rule can be equivalently stated as:
$$ \rulef{\Gamma \vdash^0 M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A
                                   }
                                   {\Gamma  \vdash^{0} M N : B}$$
\end{itemize}

The full set of rules is given in table \ref{tab:homosafelmd_rules_refined}.

\begin{table}[htbp]
$$  \rulename{perm} \
    \rulef{
      { \Gamma \vdash^0 M:B \qquad \sigma(\Gamma)  } \hbox{ homogeneous}
    }
    { \sigma(\Gamma) \vdash^0 M : B
    }
\qquad
\rulename{seq} \  \rulef{\Gamma \vdash^{0} M : A}{\Gamma \vdash^{-1} M : A}
$$

$$
\rulename{\Sigma\mbox{\textbf{-const}}} \  \rulef{}{\vdash^0 b : A}\ b:A \in \Sigma
\qquad
 \rulename{var} \   \rulef{}{x : A\vdash^{0} x : A} $$

$$ \rulename{wk^{0}} \   \rulef{\Gamma \vdash^{0} M : A}{\Gamma , x : B \vdash^{0} M : A} \quad \ord{B} \geq \ord{A} $$

$$ \rulename{wk^{-1}} \   \rulef{\Gamma \vdash^{-1} M : A}{\Gamma , x : B \vdash^{-1} M : A} \quad \ord{B} \geq \ord{A} -1$$


$$ \rulename{app} \
    \rulef
        {   \Gamma \vdash^{-1} M : (\overline{A} \, | B)
            \qquad
            \Gamma \vdash^0 N_1 : A_1 \quad \cdots \quad \Gamma \vdash^0 N_{l} : A_l \qquad l = |\overline{A}|
        }
        {
            \Gamma \vdash^0 M N_1 \cdots N_{l} : B
        }
$$

$$ \rulename{app^+} \   \rulef{\Gamma \vdash^0 M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A
                                   }
                                   {\Gamma  \vdash^{0} M N : B}$$

$$ \rulename{abs} \   \rulef{\Gamma| \overline{x} : \overline{A} \vdash^{-1} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A}|B)}$$


where $\Gamma| \overline{x} : \overline{A}$ means that the lowest type-partition of the context is
$\overline{x} : \overline{A}$.
\caption{Alternative rules for the homogeneous safe lambda calculus}
\label{tab:homosafelmd_rules_refined}
\end{table}
%%%
