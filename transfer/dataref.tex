Recently \citeauthor{DBLP:conf/sas/DimovskiGL05} presented
\citep{DBLP:conf/sas/DimovskiGL05} a new technique for data
abstraction refinement based on game semantics.

\subsection{Abstraction refinement}

Abstraction refinement is a technique aiming at solving the
following problem: does the safety property $\varphi$ holds for a
given infinite model $M$.

In general the problem is undecidable. The difficulty lies in the
non-finiteness of the model. Indeed, the problem becomes decidable
for finite models. Abstraction refinement makes use of this remark:
it tries to reduces the problem to finite models. The idea is to
produce an abstraction of the model which is finite. Using model
checking techniques, one can check whether a particular property
holds or not for that abstracted model. If it does not hold, then a
counter-example can be produced. If this counter-example is not
spurious (it is a valid trace in the model $M$) then we know that
$M$ does not verify the safety property. If the counter-example is
spurious then we use it to produced a new abstraction, finer that
the previous one. The process is then repeated.

The abstraction produced must be a conservative over-abstraction:
its safety implies the safety of the original model. Therefore the
abstraction refinement algorithm can be stated as follow:

\begin{algo}[Abstraction refinement]
The input: $M$ an infinite model, $\varphi$ a safety property. The
question: does $M \models \varphi$ hold?
\begin{enumerate}
\item[step 1] Build a (finite) abstraction $A$ of model $M$.
\item[step 2] Check whether $A \models \varphi$ using a model
checker. If the answer is yes then \textbf{return} $M \models
\varphi$ otherwise continue to step 3.

\item[step 3] Check whether the counter-example proving that $A \not \models
\varphi$ is not spurious (i.e. is also a counter-example for $M$).
If yes then \textbf{return} $M \not\models \varphi$ otherwise
continue to step 4

\item[step 4] Use the counter-example to refine $A$. Goto step 2.
\end{enumerate}
\end{algo}

Note that the refinement process may loop forever.


\subsection{Game semantics and abstraction refinement}
In \citep{DBLP:conf/sas/DimovskiGL05}, a data-refinement procedure
is derived that is guaranteed to discover an error if it exists.

The target language is Idealized Algol (introduced in section
\ref{sec:ia}).

Abstraction is done at the level of data. For that purpose they
introduce AIA: Abstract Idealized Algol.

The reduction rules of AIA are similar to those of IA, except that
they introduce non determinism and the $abort$ operator.

$abort$ reduces to the special value $\varepsilon$ and any program
involving the evaluation of $abort$ reduces to $\varepsilon$.


\subsection{Game semantics of EIA (Erratic Idealized Algol)}

\subsection{Game semantics of AIA}
Abstraction are equivalence classes on $\zset$ noted $\pi$. We
suppose that the abstractions $\pi$ are computable.

- Basics types + abstract data types $exp_\pi$ where $\pi$ is an
abstraction:

$$ \tau ::= int_\pi\ |\ bool$$

The abstraction used in \cite{DBLP:conf/sas/DimovskiGL05} are:
$$ [] = \{ \zset \} \qquad [n,m] = \{ \{ i | i<n \}, \{ n \}, \{n+1\},
\ldots \{ m-1\}, \{ m\}, \{ i | i > m \} \} \mbox{where } n \leq 0
\leq m$$


- new operators defined on these new types

- For simplicity we only consider abstraction of the base type
$expint$.

- reduction rules:
.non determinism

. $abort$ operator.






\subsection{the algorithm}
-identify counter-example
-analyse it by uncovering the hidden moves.

Strategy represented using CSP process algebra verification done
with FDR.



Advantage of the approach:

the game semantics approach gives compositionality for free. small
size of the model (due to hiding of unobservable internal moves)



Possible extension:
recusion
concurrency
higher-order fragment
