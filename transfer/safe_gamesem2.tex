\def\cmptre#1{\tau(#1)}
\def\aux#1{\lceil #1\rceil}
\def\nf#1{\eta_{\sf nf}(#1)}

\section{Game semantics of safe $\lambda$-terms}

In this section we introduce the concepts of computation tree and
traversals of the computation tree. We will prove a theorem
revealing a correspondence between traversals of the computation
tree and the game semantics of a simply-typed term.

We will then apply this result to the analysis of the game semantics
of safe term. We will prove that safety leads to an economy of
pointers: for safe $\lambda$-terms the pointers from the game
semantics can be reconstructed uniquely from the moves of the play.

In the following we assume that a set of constants of order $1$ at
most and noted $\Sigma$ is fixed.
%\begin{enumerate}
%\item
%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.
%
%\item
%Is there any unsafe $\beta$-normal form whose game semantics is a
%strategy where pointers can be recovered?
%\end{enumerate}

\subsection{$\eta$-long normal form and computation tree}

The $\eta$-expansion of $M: A\typear B$ is defined to be the term $\lambda x . M x : A\typear B$ where $x:A$ is a fresh variable.
It is easy to check that if $M$ is safe then $\lambda x . M x$ is also safe.

A term $M : (A_1,\ldots,A_n,o)$ can be expanded in several steps
into $\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots
\varphi_l$ where the $\varphi_i:A_i$ are fresh variables. The
$\eta$-normal form of a term is obtained by hereditarily
$\eta$-expanding every sub-term occurring at an operand position:

\begin{dfn}[$\eta$-long normal form]
A term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a
constant or an abstraction.

The $\eta$-long normal form of a term $M$ is denoted $\aux{M}$ and
is defined as follows:
\begin{eqnarray*}
\aux{x s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{(\lambda x . s_0) s_1 \ldots s_m } &=& (\lambda x . \aux{s_0}) \aux{s_1} \aux{s_2} \ldots \aux{s_m}
\end{eqnarray*}
where $m,n \geq 0$ and $x$ is either a variable or a constant.
\end{dfn}

For $n=0$, the first clause in the definition gives:
$$\aux{x s_1 \ldots s_m : o} = \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} $$

and in that case, the symbol $\lambda$ is called \textsl{dummy} lambda. We do not omit it since it
plays an important role in the correspondence with game semantics.


The $\eta$-long normal form appeared in \citep{DBLP:journals/tcs/JensenP76}
under the name \emph{long reduced form}
and in \citep{DBLP:journals/tcs/Huet75}
under the name \emph{$\eta$-normal form}. It was then investigated in \citep{huet76}
under the name \emph{extensional form}.


A term can be represented by a tree defined formally by induction on the structure
of its $\eta$-long normal form as follows:

\begin{dfn}[Computation tree]
The computation tree associated to the term $s$ is noted
$\cmptre{s}$. It is obtained by applying the following rules
inductively \emph{on the $\eta$-long normal form} of $s$. In the
following $x$ is either a variable or a constant.
\begin{itemize}
\item for $n\geq0$, the tree for $\lambda x_1 \ldots x_n. M$ where $M$ is not an abstraction is:
$$ \cmptre{\lambda x_1 \ldots x_n . M} =
  \pstree[levelsep=4ex]
    { \TR{\lambda x_1 \ldots x_n} }
    { \SubTree{\cmptre{M}}
    }
$$


\item for $n\geq0$, the tree for $x s_1 \ldots s_n$ is:
$$ \cmptre{ x s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{x} }
    { \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$


\item the tree for $(\lambda x.s_0) s_1 \ldots s_n$ is:
$$ \cmptre{(\lambda x.s_0) s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{@} }
    {
    \SubTree{\cmptre{\lambda x.s_0}}    \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$
\end{itemize}
\end{dfn}


For example, for any order $0$ variable or constant $x$: $
\cmptre{\lambda . x} =  \pstree[levelsep=3ex]
    { \TR{\lambda } }
    { \TR{x}
    }$

The nodes (and leaves) of the tree are of three kinds:
\begin{itemize}
\item $\lambda$-node labeled $\lambda \overline{x}$ (note that a $\lambda$-node represents several consecutive abstractions of
variables),
\item application node labeled $@$,
\item variable or constant nodes labeled $x$.
\end{itemize}

A sub-tree of the computation tree represents a $\lambda$-term. We
define the map $\kappa : N \rightarrow \mathcal{T}$ where $N$
denotes the set of nodes and leaves of the computation tree
$\tau(s)$ and $\mathcal{T}$ denotes the set of $\lambda$-terms.
$\kappa$ associates to a node $n$ of the tree the $\lambda$-term
$\kappa(n)$ (the term represented by the sub-tree of $\tau(s)$
rooted at $n$). In particular if $r$ is the root of the tree
$\tau(s)$ then $\kappa(r) = \aux{s}$.

\begin{dfn}[Node order]

 The node-order function $\textsf{ord}$
is defined on nodes as follows:
\begin{eqnarray*}
\ord{n} = \left\{
  \begin{array}{ll}
    \ord{\alpha}, & \hbox{if $n$ is a variable or constant node labeled $\alpha $;} \\
    1 + \max_{i=1..n} \ord{\xi_i}, & \hbox{if $n$ is labeled $\lambda \overline{\xi}$;} \\
    0, & \hbox{if $n$ is labeled $\lambda$;} \\
    0, & \hbox{if $n$ is labeled $@$.}
  \end{array}
\right.
\end{eqnarray*}
\end{dfn}


Consider the computation tree $\tau(s)$ of a term $s$ in $\eta$-long normal form. Then:
\begin{itemize}
\item One can check that nodes at even level are abstraction
node and nodes at odd level are either application nodes,
operator-application nodes, variable or constant nodes (the root level being numbered $0$).

\item Suppose that a variable $x$ occurs in $s$. The corresponding node in the tree has of one of the two following forms:
    \begin{itemize}
    \item $ \pstree[levelsep=3ex]
        { \TR{\lambda } }
        { \TR{x}
        }$ where $\ord{x} = 0$

    \item $ \pstree[levelsep=3ex]
                { \TR{x} }
                { \TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
        $ where $\ord{x} > 0$ and $x:(A_1,\ldots,A_p,o)$
    \end{itemize}

\item    Moreover for any abstraction node
        $ \pstree[levelsep=4ex]
            { \TR{\lambda \overline{\varphi}} }
            { \pstree[levelsep=3ex]
                {\TR{n}}
                {\TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
            }
        $
    we have $\ord{\kappa(n)}=0$

\end{itemize}



\subsubsection{Pointers and justified sequence of nodes}

\begin{dfn}[Binder]
Let $n$ be a variable node of the computation tree labelled $x$. We
say a node $n$ is bound by the node $m$ if $m$ is the closest node
in the path from $n$ to the root of the tree such that $m$ is
labelled $\lambda \overline{\xi}$ with $x\in \overline{\xi}$. $m$ is
called the binder of $n$.
\end{dfn}

\begin{dfn}[Enabling]
The enabling relation $\vdash$ is defined on the set of nodes of the
computation tree. We write $m \vdash n$ and we say that the node $n$
is enabled by $m$ or that $m$ enables $n$ if and only if
\begin{itemize}
\item $n$ is a bound variable node and $m$ is the binder of $n$;
\item or $n$ is a lambda node labelled and $m$ is the parent node of $n$.
\end{itemize}
\end{dfn}



\begin{dfn}[Justified sequence of nodes]
A \emph{justified sequence of nodes} is an alternating sequence of
lambda and non lambda nodes from the computation tree $\tau(M)$
together with pointers. Any node $n$ in the sequence that is either
a lambda-node different from the root of computation tree or a
variable node labeled $x$ where $x$ is bound in $M$ must have a
pointer to a previous node $m$ in the sequence such that $m \vdash
n$.

If $n$ points to $m$ we say that $m$ justifies $n$ and we write:
$$\rnode{m}{m} \cdot \ldots \cdot \rnode{n}{n} \bkptra[nodesep=1pt]{40}{n}{m}$$


We sometimes add a label to the edge to specify that either node $n$
is labelled by the $i^{th}$ variable abstracted in the lambda node
$m$ or that $n$ is the $i^{th}$ child of the non-lambda node $m$.
Hence the pointers in a justified sequence of nodes must be of one
of the following four forms: \vspace{2pt}
$$
\rnode{m}{\lambda \overline{\xi}} \cdot \ldots \cdot
\rnode{n}{\xi_i} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{i}
\hspace{2cm}
\rnode{m}{@ } \cdot \ldots \cdot \rnode{n}{\lambda \overline{\xi}} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{j}
\hspace{2cm}
\rnode{m}{x} \cdot \ldots \cdot \rnode{n}{\lambda \overline{\xi}} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{k}
\hspace{2cm}
\rnode{m}{f } \cdot \ldots \cdot \rnode{n}{\lambda \overline{\xi}} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{k}
$$
for some variables $x,\xi_1, \ldots \xi_n$, $\Sigma$-constant $f$, integer $i \in 1..n$, $j \in 0..1$ and $k \in 1 ..arity(m)$.

With the following conventions:
\begin{itemize}
\item the first child of a $@$ node is numbered $0$,
\item the first child of a variable or constant node is numbered $1$,
\item the first variable in $\overline{\xi}$ is numbered $1$ ($\overline{\xi} = \xi_1, \ldots \xi_n$).
\end{itemize}
\end{dfn}

Note that justified sequences are also defined for opened terms:
a variable nodes labelled $x$ where $x$ is free in $M$ has no pointer.

We say that a node $n_0$ of a justified sequence is hereditarily justified by $n_p$ if there are nodes $n_1, n_2, \ldots n_{p-1}$ in
the sequence such that for all $i\in 0..p-1$, $n_i$ points to $n_{i+1}$.

If $N$ is a set of nodes and $s$ a justified sequence of nodes then
we write $s \upharpoonright N$ to denote the subsequence of $s$
obtained after removing the nodes that are not hereditarily
justified by nodes in $N$. This subsequence is also a justified
sequence of nodes. If $r$ denotes the root of the tree $\tau(M)$ we
abbreviate $s \upharpoonright \{ r \}$ into $ s\upharpoonright r $.

Remark: all the variable nodes in the justified sequence $s
\upharpoonright r $ are variable bound in $M$.


\begin{dfn}[Equality of justified sequence]
We write $s \jseq t$ to denote that the two justified sequences $t$ and $s$ are the equal
(having same nodes and same pointers).
\end{dfn}

\begin{dfn}[P-view of justified sequence of nodes]
The P-view of a justified sequence of nodes $t$ of $\tau(M)$ noted $\pview{t}$ is defined as follows:
\begin{eqnarray*}
 \pview{\epsilon} &=&  \epsilon \\
 \pview{s \cdot n }  &=&  \pview{s} \cdot n \\
 \pview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{lmd}{\lambda \overline{\xi}}} &=& \pview{s} \cdot \rnode{m2}{m} \cdot \rnode{lmd2}{\lambda \overline{\xi}}
   \bkptra[nodesep=1pt]{30}{lmd}{m}
   \bkptra[nodesep=1pt]{60}{lmd2}{m2} \\
 \pview{s \cdot r }  &=&  r
\end{eqnarray*}
where $r$ is the root of the tree $\tau(M)$ and
$n$ ranges over non-lambda nodes (i.e. labeled either $@$ or by a variable or $\Sigma$-constant).

In the second clause, the pointer associated to $n$ is preserved from the left-hand side to the right-hand side:
if in the left-hand side, $n$ points to some node in $s$ that is also present in $\pview{s}$ then in the right-hand side,
  $n$ points to that corresponding occurrence of the node in $\pview{s}$.

In the third equality, the pointer associated to $m$ is also preserved.
\end{dfn}

Similarly we define the O-view, the dual of the P-view:
\begin{dfn}[O-view of justified sequence of nodes]
The O-view of a justified sequence of nodes $t$ of $\tau(M)$ noted $\oview{t}$ is defined as follows:
\begin{eqnarray*}
 \oview{\epsilon} &=&  \epsilon \\
 \oview{s \cdot \lambda \overline{\xi} }  &=&  \oview{s} \cdot \lambda \overline{\xi} \\
 \oview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{n}{n}} &=& \oview{s} \cdot \rnode{m2}{m} \cdot \rnode{n2}{n} \\
   \bkptra[nodesep=1pt]{30}{n}{m}
   \bkptra[nodesep=1pt]{60}{n2}{m2}
 \oview{s \cdot n' }  &=&  n'
\end{eqnarray*}
where $n$ ranges over non-lambda nodes $x$ where $x$ is a variable bound in $M$.
and  $n'$ ranges over non-lambda nodes with no pointer (either $@$, $f$, $x$ for some
$\Sigma$-constant $f$ or variable $x$ \emph{free} in $M$).

The pointer associated to $\lambda \overline{\xi}$ in the second equality
as well as the pointer associated to $m$ in the third equality are preserved from the left-hand side to the right-hand side of the equalities.
\end{dfn}

\begin{dfn}[Visibility] \ \\
A justified sequence of nodes $s$ satisfies \emph{P-visibility} if every variable node with pointer
points to a node occurring in the P-view a that point.

Dually, $s$ satisfies \emph{O-visibility} if every lambda node occurring in it that has a pointer
points to a node in the O-view a that point.
\end{dfn}

\begin{property}
\label{proper:pview_visibility}
The P-view (resp. O-view) of a justified sequence verifying P-visibility (resp. O-visibility)
is a well-formed justified sequence verifying P-visibility (resp. P-visibility).
\end{property}
This is proved by an easy induction.

\subsubsection{Adding value leaves to the computation tree}

We are now going to alter the definition of computation tree. For every node and leaf of the computation tree,
we add leaves called \emph{value-leaves}. Each value leaf corresponds to a value of the base type $o$. We write $\mathcal{D}$
to denote the set of values of the base type $o$.

The values leaves are added as follows: for each node or leaf $n \in \tau(M)$
and for each value $v \in \mathcal{D}$ we attach a child leaf $n^v$ to the node $n$.

Everything that is been defined for computation tree can be extended to these new computation tree:
The node order of these leaves is defined to be $0$. The enabling relation $\vdash$ is extended so that every leaf is enabled
by its parent node. The definition of justified sequence does not change.
For the definition of P-view, O-view and visibility, value leaves are treated as $\lambda$ nodes if they are at odd level in the computation tree and
as variable nodes if there at a even level.

From now the term ``computation tree'' refers to this extended definition.

In a justified sequence of nodes, we call \emph{pending nodes} any
non value-leaf node that is not pointed to by any value-leaf. We say
that a non value-leaf node $n$ is \emph{answered} by a value-leaf
$n^v$ if $n^v$ points to $n$ in the traversal. We say that a
justified sequence of node is \emph{well-bracketed} if the last
pending node is always the first one to be answered.

If $t$ is a traversal then we write $?(t)$ to denote the sequence
obtained from $t$ by conserving only pending nodes.

We call \emph{input variable} a variable that is either free in $M$ or bound by the root of $\tau(M)$.

\subsubsection{Traversal of the computation tree}
The evaluation of term is performed by traversing the computation tree in a particular way called
\emph{traversal}. Intuitively, a \emph{traversal} is a justified sequence of nodes of the computation tree where each node
of the sequence indicates the step that is taken during the evaluation of the term.

It is formally defined as follows:

\begin{dfn}[Traversal]
\label{def:traversal} A traversal over a computation tree $\tau(M)$
is a justified sequence of nodes defined by induction on the rules
given below and a \emph{maximal-traversal} is a traversal that cannot be
extended by visiting another node.

\emph{Initialization rules}
\begin{itemize}
\item ($\epsilon$) The empty sequence of node $\epsilon$ is a traversal of $\tau(M)$.

\item (Root) A traversal can only starts from the root of the tree: if $r$ denotes root of $\tau(M)$ then the sequence $t = r$
is a traversal.
\end{itemize}


\emph{Structural rules}
\begin{itemize}
\item (Lam) Suppose that $t \cdot \lambda \overline{\xi}$ is a traversal then the next node that can be visited is the only child
node $n$ of $\lambda \overline{\xi}$. Suppose that the binder-node of
$n$ occurs in $\pview{t \cdot \lambda \overline{\xi}}$, then the
following justified sequence of nodes is also a traversal:
$$t \cdot \lambda \overline{\xi} \cdot n,$$
where $n$ points to the previous occurrence of its binding node in $\pview{t \cdot
\lambda \overline{\xi}}$.

\item (App) If $t \cdot @$ is a traversal then so is
$$t \cdot \rnode{m}{@} \cdot
\rnode{n}{n} \bkptra[nodesep=1pt]{80}{n}{m} \bklabelb{0}
$$

i.e. the next visited node is the $0^{th}$ child node of $@$ : the
node corresponding to the operator of the application.
\end{itemize}

\emph{Copy-cat rules}
\begin{itemize}
  \item If $t \cdot \lambda \overline{\xi} \cdot \rnode{app}{@} \cdot \ldots \cdot  \rnode{appv}{@^v}
              \bkptra[nodesep=1pt]{30}{appv}{app}$
              is a traversal then so is:
              $t \cdot \rnode{lmd}{\lambda \overline{\xi}} \cdot \rnode{app}{@} \cdot \ldots \cdot \rnode{appv}{@^v} \cdot
              \rnode{lmdv}{\lambda \overline{\xi}^v}
              \bkptra[nodesep=1pt]{30}{appv}{app}
                \bkptra[nodesep=1pt]{30}{lmdv}{lmd}$

  \item If $t \cdot \lambda \overline{\xi} \cdot \rnode{x}{x} \cdot \ldots \cdot  \rnode{xv}{x^v}
              \bkptra[nodesep=1pt]{30}{xv}{x}$
              is a traversal then so is:
              $t \cdot \rnode{lmd}{\lambda \overline{\xi}} \cdot \rnode{x}{x} \cdot \ldots \cdot \rnode{xv}{@^v} \cdot
              \rnode{lmdv}{\lambda \overline{\xi}^v}
              \bkptra[nodesep=1pt]{30}{xv}{x}
                \bkptra[nodesep=1pt]{30}{lmdv}{lmd}$

  \item Suppose $t \cdot \rnode{lmd}{\lambda \overline{\xi}}
                   \cdot \ldots
                   \cdot \rnode{lmdv}{\lambda \overline{\xi}^v} \bkptra[nodesep=1pt]{40}{lmdv}{lmd}$.
        Let $p$ denotes the last pending node. Since traversal are well-bracketed (this can be proved by induction)
        $p$ must occur in $t$.

        The subsequence obtained from a traversal by keeping only pending nodes is such that
        $\lambda$-nodes and non $\lambda$-nodes alternate (proof by induction).

        Therefore $p$ must be a non $\lambda$-node:
        \begin{itemize}
        \item if $p=@$ then necessarily $\lambda \overline{\xi}$ must be the $0th$ child node of $@$ in the computation tree and
        $$t \cdot \rnode{app}{@} \cdot \ldots
            \cdot \rnode{lmd}{\lambda \overline{\xi}}
                \bkptra[nodesep=1pt]{30}{lmd}{app} \bklabelb{0}
            \cdot \ldots
            \cdot \rnode{lmdv}{\lambda \overline{\xi}^v}
            \cdot \rnode{appv}{@^v}
                \bkptra[arcangleA=-25,nodesep=1pt]{35}{appv}{app}
                \bkptra[nodesep=1pt]{30}{lmdv}{lmd}$$ is also a traversal;
        \item if $p$ is a non-input variable node $y$ then necessary $p$ precedes $\lambda \overline{\xi}$ and the following is also a traversal:
        $$t \cdot \rnode{y}{y}
            \cdot \rnode{lmd}{\lambda \overline{\xi}}
            \cdot \ldots
            \cdot \rnode{lmdv}{\lambda \overline{\xi}^v}
            \cdot \rnode{yv}{y^v}
                \bkptra[nodesep=1pt]{40}{yv}{y}
                \bkptra[nodesep=1pt]{40}{lmdv}{lmd}.$$
        \end{itemize}

\end{itemize}

\emph{Input variable and constant rules}

Suppose $t = t_1 \cdot p \cdot t_2$ is a traversal where $p$ is the last pending $\lambda$ node in $t$ then:
\begin{itemize}
\item ($\mbox{InputVar}^0$) If $p = x$ is a ground-type input variable then for any $v \in \mathcal{D}$
the following is also a traversal
$$t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot \rnode{xv}{x^v}
\bkptra[nodesep=1pt]{60}{xv}{x}$$


\item ($\mbox{InputVar}^{\geq 1}$) If $t \cdot x$ is a traversal for some non-ground type input variable $x$ then so is
$$t_1 \cdot \rnode{m}{x} \cdot t_2 \cdot
\rnode{n}{n} \bkptra[nodesep=1pt]{80}{n}{m} \bklabelb{i} \qquad
\mbox{ for } 1 \leq i \leq arity(x).$$
and for any $v\in \mathcal{D}$ the following sequence is also a traversal:
$$t_1 \cdot \rnode{x}{x} \cdot t_2 \cdot \rnode{xv}{x^v}
\bkptra[nodesep=1pt]{60}{xv}{x}$$

\item ($\mbox{Sig}^0$) If $t \cdot f$ is a traversal where $f$ is an order 0 $\Sigma$-constant then the traversal can be extended the same
way as in rule ($\mbox{Var}^0$).


\item ($\mbox{Sig}^{\geq 1}$) If $t \cdot f$ is a traversal where $f$ is a $\Sigma$-constant of order greater or equal to
$1$ then the traversal can be extended the same
way as in rule ($\mbox{Var}^{\geq 1}$).
\end{itemize}

\emph{Var rules}
\begin{itemize}
\item ($\mbox{Var}^{\geq 1}$)
If $t \cdot x_i$ is a traversal where $x_i$ is not an input variable,
then the next node to visit in the traversal must correspond to the term that would be substituted
for $x_i$ if the $\beta$-redex in term $M$ were reduced.

The binding node $\lambda \overline{x}$ must have been visited
previously in the traversal. Since $\lambda \overline{x}$ is not the
root of the tree, it must be justified by some previous node in the
traversal. This implies that $\lambda \overline{x}$ is not the first
node in the traversal and therefore there is an application node $n$
preceding $\lambda \overline{x}$ in the traversal: $t \cdot x_i = t'
\cdot n \cdot x_i$. We do a case analysis on $n$:

    \begin{itemize}
    \item Suppose $n$ is an application node $@$ then $\lambda \overline{x}$ is the first child node of $n$
    and $n$ has exactly $|\overline{x}| + 1$ children nodes:
    $$\pstree[levelsep=8ex]{\TR{\stackrel{\vdots}{@^{[n]}}}}
    {   \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}\treelabel{0}}
            {\TR{x_i }}
        \tree{\lambda \overline{\eta_1}}{\vdots}\treelabel{1}
        \TR[edge=\dedge]{}
        \tree{\lambda \overline{\eta_i}}{\vdots}\treelabel{i}
        \TR[edge=\dedge]{}
        \tree{\lambda \overline{\eta_{|x|}}}{\vdots}\treelabel{|x|}
    }
    $$
    Then the following justified sequence is also a traversal:
    \vspace{0.3cm}
    $$t' \cdot \rnode{n}{@^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}} \cdot \ldots
    \bkptra[ncurv=0.45]{45}{mi}{n} \bklabel{i}
    \bkptra[nodesep=0pt,ncurv=0.6]{50}{x}{lx} \bklabel{i}
    $$
    i.e. the next step of the traversal is a jump to the $i^{th}$ child of
    $@$ ($\lambda \overline{\eta_i}$) which corresponds to the term that would be substituted for $x_i$ if the $\beta$-reduction was
    performed.



    \item Suppose $n$ is labelled $y$. This means that this occurrence of the variable $y$ is substituted by the term
    $\kappa(\lambda \overline{x})$ during the evaluation of the term. This implies that $y$ is not a ground type variable (indeed
     since $x_i \in \overline{x}$, $\overline{x}$ is not empty therefore
    $\ord{\lambda \overline{x}} \geq 0$ and $\ord{y} = 1 + \ord{\lambda \overline{x}} >0$).
    $y$ is neither a constant nor a free variable (otherwise $y$ would not be substituted during the evaluation of the term).
    Hence $y$ must be a variable bound by a node different from the
    root.

    During reduction, the occurrence of the variable $x_i$ will be substituted by the term represented by
    node $\lambda \overline{\eta_i}$ (the $i^{th}$ child node of $y
    @$).
    Hence the following justified sequence is also a traversal:
    \vspace{0.2cm}
    $$t' \cdot \rnode{n}{y^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}} \cdot \ldots
    \bkptra[ncurv=0.6]{50}{x}{lx} \bklabel{i}
    \bkptra[ncurv=0.5]{50}{mi}{n} \bklabel{i}$$

    \end{itemize}
\end{itemize}

We write $\travset(M)$ for the set of traversals of $\tau(M)$
and $\travset(M)_{max}$ to denote the set of maximal
traversals of $\tau(M)$. Clearly $\travset(M)_{max} \subset
\travset(M)$.
\end{dfn}

\begin{lem}
Traversals are well-defined.
\end{lem}
The proof is by induction.
In particular to prove that the copy-cat rules are well-defined, one needs to ensure that:
\begin{itemize}
\item traversals are well-bracketed;
\item the subsequence obtained from a traversal by keeping only pending nodes is such that
        $\lambda$-nodes and non $\lambda$-nodes alternate;

\item if $@$ is pending in a traversal then the following pending node must be the $0th$ child node of $@$;

\item if the last two pending nodes are $y$ and $\lambda \overline{\xi}$ in that order, for some non-input variable node $y$ then necessary
      $y$ and $\lambda \overline{\xi}$ are consecutive nodes in the traversal.

    This is because in a traversal, a non input variable $y$ is always followed by a lambda node and whenever this lambda node is answered
    there is only one way to extend the traversal : by using the copy cat rule to answer the $y$ node.
\end{itemize}

\begin{exmp}
Consider the following tree:
$$\tree{\lambda}
{
    \tree{@}
    {
        \pstree[levelsep=8ex,linestyle=dotted]{\TR{\lambda y}\treelabel{0} }
        {
            \pstree[levelsep=8ex]{\TR{y}}
            {
                \tree{\lambda \overline{\eta_1}}{\vdots} \treelabel{1}
                \TR[edge=\dedge]{}
                \tree{\lambda \overline{\eta_i}}{\vdots}\treelabel{i}
                \TR[edge=\dedge]{}
                \tree{\lambda \overline{\eta_n}}{\vdots}\treelabel{n}
            }
        }
        \pstree[levelsep=6ex,linestyle=dotted]{\TR{\lambda \overline{x}}\treelabel{1}}{ \tree{x_i}{\TR{} \TR{} } }
    }
}
$$
The following justified sequence is a traversal of the tree:
\vspace{0.3cm}
$$ \lambda \cdot
\rnode{app}{@}  \cdot
\rnode{ly}{\lambda y} \cdot \ldots \cdot
\rnode{y}{y} \cdot
\rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
\rnode{x}{x_i} \cdot
\rnode{leta}{\lambda \overline{\eta_i} } \cdot \ldots
\bkptra[ncurv=0.6,nodesep=0]{40}{x}{lx}  \bklabel{i}
\bkptra[ncurv=0.5]{50}{leta}{y}  \bklabel{i}
\bkptra[ncurv=0.6,nodesep=0]{40}{y}{ly}  \bklabel{1}
\bkptra[ncurv=0.5]{50}{lx}{app}  \bklabel{1}$$

\end{exmp}


\begin{prop}
\label{prop:pviewtrav_is_path}
Let $t$ be a traversal. Then:
\begin{itemize}
\item[(i)] $?(t)$ is a justified sequence verifying P-visibility and O-visibility.
\item[(ii)] $\pview{?(t)}$ is a path in the computation tree going from the root to the last node in $?(t)$.
\end{itemize}
\end{prop}
The proof of this proposition is an adaptation of the proof of proposition 6 of \cite{OngHoMchecking2006} to handle the value-leaves.

\begin{dfn}[Reduced-traversal]
Let $r$ be the root of the computation tree. A \emph{reduced-traversal} is a justified sequence of nodes $s$ such that for some traversal $t$,
$ s \jseq t \upharpoonright r  $. $s$ is called the reduction of $t$.
\end{dfn}

\begin{rem}
\label{rem:redtrav} Clearly, if $s$ is a reduced-traversal then
there is a traversal $t$ verifying $s \jseq t \upharpoonright r$ such that the last node of $t$ is justified by $r$.
\end{rem}

In a reduced-traversal, non-lambda nodes are all labelled
$x$ for some variable $x$ \emph{bound} in $M$. There cannot be nodes
labelled by either $@$, a free variable in $M$ nor a
$\Sigma$-constant since such nodes are pointer-less.

%\begin{dfn}[Set substraction operator]
%Suppose $s$ is a justified sequence of nodes and $N$ is a set of nodes then $s \setminus N$ is the justified sequence of nodes
%obtained by removing from $s$ all the nodes that belongs to $N$.
%The links of $s \setminus N$ are the links of $s$ minus all the links pointing from or to nodes in $N$.
%\end{dfn}

\begin{property}[Traversal of closed terms in $\beta \eta$-long normal form]
\label{proper:betaeta_trav}
Suppose $M$ is a closed term in $\beta \eta$-long normal form (i.e. the $\eta$-long normal form of a $\beta$-normal form), then
for any traversal $t$ of $\tau(M)$ and any node $n$ in $t$:
\begin{eqnarray*}
n \mbox{ is not hereditarily justified by } r  \  \iff \   n \mbox{
is hereditarily justified by some node $m$ in } N_\Sigma
\end{eqnarray*}
where $r$ denotes the root of the tree
$\tau(M)$ and $N_\Sigma$ denotes the set of nodes labelled by $\Sigma$-constants.
\end{property}
\begin{proof}
In a computation tree, the only nodes with no justification pointer are:
the root node $r$, the application nodes $@$ and nodes $\alpha$ where $\alpha$ is a $\Sigma$ constant or a free variable.

Here the term $M$ is in $\beta \eta$-long normal form therefore there is no node of type $@$ in the computation tree.
Moreover $M$ is closed therefore there is no variable node $x$ where $x$ is a
free variable. Hence the only nodes of the computation tree of $M$ without pointer are the root and the nodes in $N_\Sigma$
and therefore the tree nodes are hereditarily justified either by the root $r$ or by a node in $N_\Sigma$. Moreover $r$ is not in
$N_\Sigma$ therefore the ``or'' is exclusive : a node cannot be hereditarily justified both by $r$ and some $f$ in $N_\Sigma$.
\end{proof}

\begin{lem}[Reduced-traversal and traversal]
\label{lem:redtrav_trav} Suppose $M$ is a closed term in $\beta
\eta$-long normal form (i.e. the $\eta$-long normal form of a
$\beta$-normal form). Let us write $r$ for the root of the tree
$\tau(M)$. Then:
\begin{itemize}
\item[(i)] for any traversal $t$ we have:
$$ \pview{?(t) \upharpoonright  r } \jseq \pview{?(t)} \upharpoonright r ,$$
\item[(ii)] and for any traversal $t$ whose last node is hereditarily justified by
$r$ we have:
    $$ \oview{?(t) \upharpoonright r } \jseq \oview{?(t)}.$$
\end{itemize}
\end{lem}

\begin{proof}
(i) By induction. Base case: it is trivially true for the empty
traversal $t = \epsilon$. Step case: consider a traversal $t$ and
suppose that the property (i) is verified for all traversal smaller
than $t$. There are three cases:
\begin{itemize}
\item Suppose $?(t) = t' \cdot n$ where $n = r$. We have:
    \begin{align*}
    \pview{?(t)} \upharpoonright  r
        &\jseq  \pview{t' \cdot r } \upharpoonright  r       & (\mbox{definition of } ?(t))\\
        &\jseq  r \upharpoonright  r                         & (\mbox{def. P-view})\\
        &\jseq  r                                                & (\mbox{def. operator $\upharpoonright$})\\
        &\jseq  \pview{(t' \upharpoonright  r ) \cdot r }    & (\mbox{def. P-view})\\
        &\jseq  \pview{(t' \cdot r)  \upharpoonright  r }    & (\mbox{def. operator $\upharpoonright$})\\
        &\jseq \pview{?(t) \upharpoonright  r }                & (\mbox{definition of } ?(t))
    \end{align*}

\item Suppose $?(t) = t' \cdot n$ where $n$ is a non-lambda
move. We have:
    \begin{equation}
    \pview{?(t)} = \pview{t' \cdot n} = \pview{t'} \cdot n  \label{eq_tprime}
    \end{equation}

    We consider the following two sub-cases:
    \begin{itemize}
    \item Suppose that $n$ is not hereditarily justified by $r$ then:
    \begin{align*}
    \pview{?(t)} \upharpoonright  r
        &\jseq (\pview{t'} \cdot n) \upharpoonright  r  & (\mbox{equation \ref{eq_tprime}}) \\
        &\jseq \pview{t'} \upharpoonright  r            & (n \mbox{ is not hereditarily justified by } r) \\
        &\jseq \pview{t' \upharpoonright  r }           & (\mbox{induction hypothesis}) \\
        &\jseq \pview{(t' \cdot n) \upharpoonright  r } & (n \mbox{ is not hereditarily justified by } r) \\
        &\jseq \pview{?(t) \upharpoonright  r  }           & (\mbox{definition of } ?(t))
    \end{align*}

    \item Suppose that $n$ is hereditarily justified by $r$ then:
    \begin{align*}
    \pview{?(t)} \upharpoonright  r
    &\jseq (\pview{t'} \cdot n) \upharpoonright  r      & (\mbox{equation \ref{eq_tprime}}) \\
    &\jseq (\pview{t'} \upharpoonright  r  ) \cdot n    & (n \mbox{ is hereditarily justified by } r)\\
    &\jseq \pview{t' \upharpoonright  r } \cdot n       & (\mbox{induction hypothesis}) \\
    &\jseq \pview{(t' \upharpoonright  r ) \cdot n }    & (\mbox{def. P-view}) \\
    &\jseq \pview{(t' \cdot n) \upharpoonright  r  }    & (n \mbox{ is hereditarily justified by } r) \\
    &\jseq \pview{?(t) \upharpoonright  r  }               & (\mbox{definition of } ?(t))
    \end{align*}
    \end{itemize}


\item Suppose that:
    $$  ?(t) =  t' \cdot \rnode{m}{m} \cdot  u \cdot \rnode{lmd}{n}
    \bkptra[nodesep=1pt]{30}{lmd}{m}$$

    where $n$ is a $\lambda$ node. Then we have:
    \begin{equation}
    \pview{?(t)} = \pview{t' \cdot \rnode{m}{m} \cdot u \cdot \rnode{n}{n}}
            = \pview{t'} \cdot \rnode{m2}{m} \cdot \rnode{n2}{n}
    \bkptra[nodesep=1pt]{60}{n}{m}
    \bkptra[nodesep=1pt]{60}{n2}{m2}
    \label{eq_tprime_2}
    \end{equation}


    \begin{itemize}
    \item Suppose that $m$ is not hereditarily justified by $r$ then
    neither is $n$.

    Lambda nodes are justified by their parent node therefore $m$ is the parent of $n$.
    By property \ref{proper:betaeta_trav}, nodes that are not hereditarily justified by the root are
    exactly the nodes that are hereditarily justified by $N_\Sigma$.
    Moreover, since $\Sigma$ contains only constant of order $1$ at most, the only nodes that are hereditarily justified by $N_\Sigma$ are the nodes
    in $N_\Sigma \union Succ(N_\Sigma)$ where $Succ(N_\Sigma)$ denotes the set of nodes whose parent node is in in $N_\Sigma$.

    The lambda nodes in $N_\Sigma \union Succ(N_\Sigma)$ are the
    nodes in $Succ(N_{\Sigma})$, they are all labelled $\lambda$.
    Hence necessarily we have $n = \lambda$ and $m \in N_{\Sigma}$.

    Thus, $?(t)$ has the following form:
    $$  ?(t) =  t' \cdot \rnode{m}{f} \cdot  u \cdot \rnode{lmd}{\lambda}
    \bkptra[nodesep=1pt]{30}{lmd}{m}$$
    for some constant $f\in \Sigma$.

    The rules defining traversals are such that any node $\lambda \in Succ(N_\Sigma)$ must be preceded by its parent node. Hence $m$ must preceed $n$
    in the traversal and therefore $u= \epsilon$
        \begin{align*}
        \pview{?(t)} \upharpoonright  r
        &\jseq (\pview{t'} \cdot \rnode{m}{m} \cdot \rnode{lmd}{n} ) \upharpoonright  r
               \bkptra[nodesep=1pt]{60}{lmd}{m}                 & \mbox{(equation \ref{eq_tprime_2})} \\
        &\jseq \pview{t'} \upharpoonright  r                & (m, n \mbox{ are not hereditarily justified by } r) \\
        &\jseq \pview{t' \upharpoonright  r }               & \mbox{(induction hypothesis)} \\
%
        &\jseq \pview{ (t' \cdot u ) \upharpoonright \{r\} }    & (u = \epsilon) \\
%
        &\jseq \pview{ (t' \cdot \rnode{m}{m} \cdot u \cdot \rnode{lmd}{n}) \upharpoonright \{r\} }
                                                                & (\mbox{def. operator $\upharpoonright$ and } m, n \mbox{ are not her. just. by } r)
          \bkptra[nodesep=1pt,ncurv=0.7]{40}{lmd}{m} \\
%
        &\jseq \pview{ ?(t) \upharpoonright \{r\} }                & \mbox{(def. of $?(t)$)}
        \end{align*}

    \item Suppose that $m$ is hereditarily justified by $r$ then
    so is $n$ and we have:
     \begin{align*}
        \pview{?(t)} \upharpoonright  r
        &\jseq (\pview{t'} \cdot \rnode{m}{m} \cdot \rnode{lmd}{n} ) \upharpoonright  r
                                                & \mbox{(equation \ref{eq_tprime_2})} \\
       \bkptra[nodesep=1pt]{60}{lmd}{m}
%
        &\jseq \pview{t'} \upharpoonright  r  \cdot \rnode{m}{m} \cdot \rnode{lmd}{n}
                                                & (m, n \mbox{ are hereditarily justified by } r)
       \bkptra[nodesep=1pt]{60}{lmd}{m} \\
%
        &\jseq \pview{t' \upharpoonright  r } \cdot \rnode{m}{m} \cdot \rnode{lmd}{n}
                                                & \mbox{(induction hypothesis)}
       \bkptra[nodesep=1pt]{60}{lmd}{m} \\
%
        &\jseq \pview{ (t' \upharpoonright  r ) \cdot \rnode{m}{m} \cdot (u \upharpoonright \{r\}) \cdot \rnode{lmd}{n}}
                                                & \mbox{(def. P-view)}
          \bkptra[nodesep=1pt,ncurv=0.7]{30}{lmd}{m} \\
%
        &\jseq \pview{ (t' \cdot \rnode{m}{m} \cdot u \cdot \rnode{lmd}{n}) \upharpoonright \{r\} }
                                                & \mbox{(def. operator $\upharpoonright$)}
          \bkptra[nodesep=1pt,ncurv=0.7]{40}{lmd}{m} \\
%
        &\jseq \pview{ ?(t) \upharpoonright \{r\} }
                                                & \mbox{(def. of $?(t)$)}
        \end{align*}
    \end{itemize}

\end{itemize}
(ii) By a straightforward induction similar to (i).
\end{proof}

\subsection{Correspondence between computation trees and arenas in game semantics}

We now consider the pure simply-typed $\lambda$-calculus without
constants ($\Sigma = \emptyset$). We use the cartesian closed
category of games $\mathcal{C}$ defined in the first chapter as a
model of the simply-typed lambda calculus. We write $\sem{\Gamma
\vdash M : A}$ for the strategy denoting the simply-type term
$\Gamma \vdash M : A$ (defined in section \ref{subsec:pcfgamemodel}
of the first chapter).

However, we will use the alternative definition of strategy (see
remark \ref{rem:atlern_strategy}), which means that we represent a
strategy using a prefix-closed set instead of an ``even length
prefix''-close set. In practice this means that we replace the set
of plays $\sigma$ by $\sigma \union \textsf{dom}(\sigma)$. This
permits to avoid considerations on the parity of the length of
traversals when we show the correspondence between traversals and
game semantics. We write $\textsf{Pref}(S)$ to denote the
prefix-closure of the set $S$.

\subsubsection{Example}

By representing side-by-side the computation tree and the type arena of a term in $\eta$-normal form we observe
that some nodes of the computation tree can be mapped to question moves of the arena.

\begin{exmp}
Consider the following term $M \equiv \lambda f z . (\lambda g x . f (f x)) (\lambda y. y) z$ of type $(o \typear o) \typear o \typear o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f (f x)) (\lambda y. y) (\lambda .z)$.
The computation tree is:

$$
\tree{\lambda f z}
{ \tree{@}
    {
        \tree{\lambda g x}
            { \tree{f}{   \tree{\lambda}{ \tree{f}{  \tree{\lambda}{\TR{x}}} }  }
            }
        \tree{\lambda y}{\TR{y}}
        \tree{\lambda}{\TR{z}}
    }
}
$$

The arena for the type $(o \typear o) \typear o \typear o$ is:
$$\tree{q^1}
{
    \tree{q^3}
        {  \tree{q^4}
                {\TR{a^4_1} \TR{\ldots}}
            \TR{a^3_1} \TR{\ldots} }
    \tree{q^2}
    { \TR{a^2_1} \TR{a^2_2}\TR{\ldots} }
    \TR{a_1} \TR{a_2}\TR{\ldots}
}
$$

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

The computation tree and the arena are represented on the figure
below (left and right respectively). The dashed line defines a
partial function $\varphi$ from the set of nodes in the computation
tree to the set of moves. For simplicity, we now omit answers moves
when representing arenas:
$$
\tree{ \Rnode{root} {\lambda f z w}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}
                { \tree{\Rnode{f}{f^{[6]}}}{  \tree{\Rnode{lmd}\lambda^{[7]}}{ \tree{\Rnode{f2}{f^{[8]}}} {\tree{\Rnode{lmd2}\lambda^{[9]}}{\TR{x^{[10]}}}}}  }
                }
            \tree{\lambda y ^{[4]}}{\TR{y}}
            \tree{\lambda ^{[5]}}{\TR{\Rnode{z}z}}
        }
    }
\hspace{3cm}
  \tree[levelsep=12ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
        \TR{\Rnode{q5}q^5}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{z}{q2}
\ncline{->}{f}{q3}
\ncline{->}{lmd}{q4}
\ncline{->}{f2}{q3}
\ncline{->}{lmd2}{q4}
$$

Consider the justified sequence of moves $s \in \sem{M}$:
\vspace{0.5cm}
 $$s =
\rnode{q1}{q}^1\
\rnode{q3}{q}^3\
\rnode{q4}{q}^4\
\rnode{q3b}{q}^3\
\rnode{q4b}{q}^4\
\rnode{q2}{q}^2
\bkptrc{q3}{q1}
\bkptrc[ncurv=0.5]{q3b}{q1}
\bkptrc{q4}{q3}
\bkptrc{q4b}{q3b}
\bkptrc[ncurv=0.5]{q2}{q1}
\in \sem{M}$$

There is a corresponding justified sequence of nodes in the computation tree:
\vspace{0.5cm}
$$r =
\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=1]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}$$
such that $s_i = \varphi(r_i)$ for all $i < |s|$.

The sequence $r$ is in fact a reduced-traversal, it is the reduction of the following traversal:
\vspace{1cm}
$$t =
\rnode{q1}{\lambda f z} \cdot
\rnode{n2}{@^{[2]}} \cdot
\rnode{n3}{\lambda g x^{[3]}} \cdot
\rnode{q3}{f}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{n8}{x^{[10]}} \cdot
\rnode{n9}{\lambda^{[5]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=0.6]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}
\bkptra[ncurv=0.4]{60}{n3}{n2}
\bkptra[ncurv=0.4]{60}{n8}{n3}
\bkptra[ncurv=0.4]{60}{n9}{n2}
$$

This example suggests that a relation exists between game semantics and computation trees.
\end{exmp}


\subsubsection{Computation tree-arena correspondence}

Let us analyze precisely the relationship between the game semantics
and the computation tree. Let $\Gamma \vdash M : A$ be a term in
$\eta$-long normal form. The arena $\sem{A}$ is represented by the
tree $(M_\sem{A},\vdash)$ where $M_\sem{A}$ is the set of moves and
$\vdash$ is the enabling relation.

The computation tree $\tau(M)$ is represented by $(N,E)$ where $N$
is the set of nodes and value-leaves of the tree and $E$ is the
parent-child relation. $E^+$ denotes the transitive closure of $E$:
$E^+(n)$ is the set of nodes $m$ such that there is a path from $n$
to $m$ in the computation tree.

Let $\mathcal{D}$ be the set of values of the base type $o$. If $n$
is a node in $N$ then $n^v$ denotes the value-leave of $n$
corresponding to the value $v$, where $v$ ranges in $\mathcal{D}$.
Similarly, if $q$ is a question in $M^{QA}$ then the answer moves
enabled by $q$ are written $q^v$ where $v$ ranges in $\mathcal{D}$.

We define two preliminary procedures:
\begin{dfn}[Relation between moves and nodes of the computation tree]
\label{def:phi_procedure} The procedure $f$ takes two parameters:
$nd$, the index number of a $\lambda$-node in the computation tree
and $q$, a question move of the arena of $\Gamma \vdash M : A$ such
that $q$ and $\kappa(nd)$ have the same type.

Similarly we define the procedure $g$ that takes two parameters:
$nd$, the index number of a variable node in the computation tree labelled $x$ and $q$, a question move of the arena
of $\Gamma \vdash M : A$ such that $q$ and $x$ have the same type.

$f$ and $g$ both return a partial function from the set of nodes and
value-leaves of the computation tree to moves of the arena.

\noindent
\begin{description}
\item[\textbf{Procedure} $f(nd,q)$]
    where $nd$ is a $\lambda$-node.

    \begin{itemize}
    \item If $\ord{\kappa(nd)} = 0$ then the term is of ground type therefore
    the game for $M$ is played on the flat arena
    with only one question $q$. Moreover the node $nd$ of the computation tree is labelled with $\lambda$.\\
    \textbf{return} $\{ nd \mapsto q \} \union \{ nd^v \mapsto q^v \ | \ v \in \mathcal{D} \}$.

    \item $\ord{\kappa(nd)} > 0$. The computation tree and the arena
    have the following form (value leaves and answer moves are not represented for simplicity):
    $$ \tree[levelsep=6ex]{ \Rnode{r}\lambda \overline{\xi}  ^{[nd]}}
        {
            \tree[levelsep=6ex]{x^{[nd+1]}}
            {   \TR{\lambda^{[\ldots]}} \TR{\ldots} \TR{\lambda^{[\ldots]}}
            }
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi} \vdash \kappa(x^{[nd+1]}) : o$.

    For each of the abstracted variable $\xi_i$ there is a corresponding question move $q_i$ of the same order
    in the arena.  Each free occurrence of the variable $\xi_i$ is mapped to the move $q_i$
    by the procedure $g$.
    \begin{align*}
    \mathbf{return}\  & \{ nd \mapsto q \} \quad  \union \quad  \{ nd^v \mapsto q^v \ | \ v \in \mathcal{D} \} \\
                      & \union  \Union_{\stackrel{i=1..n}{E^+(nd,\xi_i^{[k]})}} g ( k, q_i)
                        \quad \union \quad \Union_{\stackrel{i=1..n}{E^+(nd,@\xi_i^{[k]})}} g ( k, q_i)
    \end{align*}

    \end{itemize}

\item[\textbf{Procedure} $g(nd,q)$]\  \\
The procedure is not defined on $\lambda$-nodes or $@$ nodes. This
is ok since all the calls to $g(nd,q)$ in $f$ are such that $nd$
denotes a variable node.
Suppose that $nd$ is labelled by the variable $x$ then:
\begin{itemize}
\item[case 1] if $\ord{x} = 0$ then \textbf{return} $\{ nd \mapsto q \} \union \{ nd^v \mapsto q^v \ | \ v \in \mathcal{D} \}$;

\item[case 2] if $\ord{x}>0$ then $x:(A_1|\ldots|A_m|o)$.
The computation tree and the arena  have the following form:


    $$\tree[levelsep=6ex]{\Rnode{r}{x^{[nd]}}}
        {   \tree{\TR{\lambda^{[k_1]}}}{\vdots} \TR{\ldots}
        \tree{\TR{\lambda^{[k_m]}}}{\vdots}
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{\Rnode{q1}{q^1}}{\TR{} \TR{} }
            \tree[linestyle=dotted]{\Rnode{q2}{q^2}}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{\Rnode{qm}{q^m}}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi} \vdash \kappa(x^{[nd]}) : o$.

    For each of the children node of $nd$
    there is a corresponding question move $q_i$ of the same type
    in the arena.
    $$\mathbf{return} \ \{ nd \mapsto q \} \union \{ nd^v \mapsto q^v \ | \ v \in \mathcal{D}
    \} \union
    \Union_{i=1..m} f ( k_i, q_i)
    $$
\end{itemize}
\end{description}

Note that $f(n,q)$ returns a total function from the set of nodes
hereditarily justified by $n$ to the set of moves in the arena.
\end{dfn}

In the pure simply-type $\lambda$-calculus, there are no constants, therefore the only node that are not hereditarily justified
by the root must be hereditarily justified by a $@$ nodes. Therefore, by doing the union of the partial functions $f(n,q)$
for all nodes $n$ parent of a $@$ node, we obtain a total function from the set of nodes of $\tau(M)$ to question moves in different arenas:

We write $q^0_A$ to denote the single initial question of arena $A$.
This is well-defined since the arenas involved in the game semantics
of pure simply-typed $\lambda$-calculus have only one root.


\begin{dfn}[Total mapping from nodes to moves]
Let $\Gamma \vdash M : A$ be a simply-typed term. We define the
total function $\varphi_M : N \rightarrow M_\sem{\Gamma \rightarrow
A} \union \Union_{n \in N | E(n, @)} M_{\sem{type(\kappa(n))}}$ as
follows:
$$\varphi_M = f(r, q^0_{\sem{\Gamma \rightarrow A}}) \union \Union_{n \in N | E(n, @)}  f(n, q^0_{\sem{type(\kappa(n))}} ) $$
\end{dfn}

By definition of procedure $f$, the following properties follow
immediately:
\begin{property} \
\label{proper:phi_conserve_order}
\begin{itemize}
\item[(i)] $\varphi$ maps $\lambda$-nodes to O-questions, variable nodes to
P-questions, value-leaves of $\lambda$-nodes to P-answers and
value-leaves of variable nodes to O-answers;
\item[(ii)] $\varphi$ maps nodes of a given order to moves of the same order.
\end{itemize}
\end{property}


By extension, the function $\varphi$ is also defined on justified
sequences of nodes: if $t$ is the justified sequences of nodes $t =
t_0 t_1 \ldots$ then $\varphi(t)$ denotes the following sequence of
moves of the arena $\sem{A}$:
$$\varphi(t) = \varphi(t_0)\ \varphi(t_1)\  \varphi(t_2) \ldots$$
where the pointers of the justified sequence of move $\varphi(t)$
are defined to be exactly those of the justified sequences of nodes
$t$. It is straightforward to check that the sequence obtained is a
valid justified sequence of moves.


A justified sequence can be regarded as a sequence of pairs. Each pair encodes an element of the sequence together
with an index indicating the position where the element points to. Hence the set of justified sequence nodes is isomorphic
to the free monoid $P^*$ where $P = N \times \nat$. Similarly, the set of justified sequence of moves is isomorphic to
the free monoid ${M_{\sem{A}}}^*$. From the definition of $\varphi$ we have:
\begin{lem}
\label{lem:varphi_monoidhomom}
$\varphi : P^* \rightarrow {M_{\sem{A}}}^*$ is a monoid homomorphism.
\end{lem}


\begin{property}
\label{proper:phi_pview} Suppose $\varphi(t) \jseq s$ where $s$ is a
justified sequence of moves and $t$ is a justified sequence of nodes
then
\begin{itemize}
\item (i) $s$ and $t$ have the same pointers.
\item (ii) the P-view of $s$ and the P-view of $t$ are computed
identically: the set of indices of elements that must be removed
from both sequences in order to obtain their P-view is the same.
\item (iii) the O-view of $s$ and the O-view of $t$ are computed identically.
\end{itemize}
\end{property}
\begin{proof}
(i): By definition of $\varphi$, $t$ and $\varphi(t)$ have the same
pointers.

(ii) and (iii): $\varphi$ maps lambda nodes to O-question,
non-lambda nodes to P-question, value leaves of lambda nodes to P-answers and
value leaves of non-lambda to O-answers. Therefore since $t$ and $s$ have the
same pointers, the computations of the P-view (resp. O-view) of the
sequence of moves and the P-view (resp. O-view) of the sequence of
nodes follow the same steps.
\end{proof}


Let us fix some notation: we write $s\upharpoonright A,B$ for the
sequence obtained from $s$ by keeping only the moves that are in $A$ or $B$ and by removing any link pointing to a move that
has been removed.

If $m$ is an initial move, we write $s \upharpoonright m$ to
denote the thread of $s$ initiated by $m$, i.e. the sequence obtained from $s$ by keeping all the moves
hereditarily justified by $m$.

We also write $s \upharpoonright A,B,m$ where $m$ is an initial move
for the sequence obtained from $s \upharpoonright A,B$ by keeping
all moves hereditarily justified by $m$.


%\begin{property} Let $s$ be a justified sequence of moves. Then
%\label{proper:tildepview}
%$$\widetilde{\pview{s}} = \pview{\tilde{s}}$$
%\end{property}
%The proof is an easy induction.

\subsection{Category of interaction games}

In game semantics, strategy composition is achieved by performing a CSP-like ``composition + hiding''.
It is possible to define an alternative semantics where the internal moves are not hidden when performing composition.
This semantics has been named \emph{interaction} semantics in \cite{DBLP:conf/sas/DimovskiGL05}.

In addition to the moves of the standard semantics, the interaction semantics contains all
the internal moves of the computation.
Consequently, the interaction semantics depends on the syntactical structure of the term and therefore cannot
lead to a full abstraction result. However this semantics will prove to be useful to identify
a correspondence between the game semantics
of a term and the traversals of its computation tree.

We will be interested in the interaction semantics computed from the
$\eta$-normal form of a term. However we do not want to keep all the internal moves. We will only keep the internal
moves that are produced when composing two sub-terms of the computation tree that are joined by an $@$ node.
This means that when computing the strategy of
$y N_1 \ldots N_p$ where $y$ is a variable, we keep the internal moves of $N_1$, \ldots, $N_p$, but
we omit the internal moves produced by the copy-cat projection strategy denoting $y$.

\begin{dfn}[Type-tree]
We call \emph{type-tree} or \emph{type decomposition-tree}, a tree whose leaves are labelled with linear simple types
and nodes are labelled with symbol in  $\{ \fatsemi, \times, !, \otimes \}$.

Nodes labelled $\fatsemi$, $\times$ or $\otimes$ are binary nodes, nodes labelled $!$ are unary nodes.

A (linear) simple-type is associated to every node or leaf of the tree, this type is determined by the
structure of the tree as follows:
\begin{itemize}
\item a leaf represents the type of its label;
\item a $\fatsemi$-node with two children nodes $T_1$ and $T_2$ representing the types $!A\multimap B$
and $!B \multimap C$ for some arena $A$, $B$ and $C$, represents the type $!A \multimap C$;

\item a $\times$-node with two children nodes $T_1$ and $T_2$ representing the type $A$
and $B$ respectively, represents the type $A \times B$;

\item a $\otimes$-node with two children nodes $T_1$ and $T_2$ representing the type $A$
and $B$ respectively, represents the type $A\otimes B$;

\item a $!$-node with the child node $T$ representing a type $A$ represents the type $!A$.
\end{itemize}
For a type-tree to be well-defined, the children nodes of a $\fatsemi$-node must have a compatible type (i.e. of the form
$!A\rightarrow B$ and $!B\rightarrow C$).

We write $type(T)$ to denote the type represented by the root of the tree $T$. An we say that $T$ is a \emph{valid
tree decomposition} of $type(T)$.

If $T_1$ and $T_2$ are type-tree we write $T_1 \times T_2$ to denotes the tree obtained by attaching $T_1$ and $T_2$ to a $\times$-node.
Similarly we use the notation $T_1 \otimes T_2$, $T_1 \fatsemi T_2$ and $!T_1$.
\end{dfn}


Let $T$ be a type-tree. Each leaf $A$ of this tree can be mapped to the
arena (in the standard sense) $\sem{A}$. Similarly, each node of the tree representing a type $A$ can be mapped to
the arena $\sem{A}$. By taking the image of $T$ across this mapping we obtain a tree whose leaves and nodes are labelled by arenas.
This tree written $\intersem{T}$ is called the \emph{interaction arena} of type $T$.
We write $root(\intersem{T})$ to denote the arena located at the root of the interaction arena $\intersem{T}$.

%\begin{dfn}[Interaction arena construction]
%Let $\intersem{T_1}$ and $\intersem{T_2}$ be two interaction arenas
%where $T_1$ and $T_2$ represent the types $A$ and $B$ respectively. We can construct new interaction arenas
%as follows:
%\begin{itemize}
%\item \emph{Composition} $\intersem{T_1 \rightarrow T_2}$ denotes the interaction arena obtained by attaching the trees
%$\intersem{T_1}$ and $\intersem{T_2}$ to a $\rightarrow$-node.
%\item \emph{Product interaction}: $\intersem{T_1 \times T_2}$ denotes the interaction arena obtained by attaching the trees
%$\intersem{T_1}$ and $\intersem{T_2}$ to a $\times$-node.
%\item \emph{Tensor product}: $\intersem{T_1 \otimes T_2}$ denotes the interaction arena obtained by attaching the trees
%$\intersem{T_1}$ and $\intersem{T_2}$ to a $\otimes$-node.
%\item \emph{Exponential}: $\intersem{!T_1}$ denotes the interaction arena obtained by attaching the trees
%$\intersem{T}$ to a $!$-node.
%\end{itemize}
%\end{dfn}



An \emph{interaction strategy} $\Sigma$ on the interaction arena
$\intersem{T}$ is a composition of several standard strategies where
the internal moves are not hidden. Formally this can be defined as
follows:
\begin{dfn}[Interaction strategy]
An interaction strategy $\Sigma$ on a game $\intersem{T}$ noted
$\Sigma: \intersem{T}$ is a tree type $T$ where each leaf $\sem{A}$ of
$\intersem{T}$ is annotated with a (standard) strategy $\sigma$ on the
game $\sem{A}$.
\end{dfn}


\begin{dfn}[Composition of interaction strategies]
Suppose $\Sigma_1 : \intersem{T_1}$ and $\Sigma_2 :
\intersem{T_2}$ are interaction strategies where $type(T_1) = A \rightarrow B$
and $type(T_2) = B \rightarrow C$ then we
can define the strategy $\Sigma_1 \intercomp \Sigma_2$ on the interaction arena $\intersem{T_1 \fatsemi T_2}$.
$\Sigma_1 \intercomp \Sigma_2$ is obtained just by copying the annotation of the leaves in $\Sigma_1$ and $\Sigma_2$
to the leaves of the tree-type $T_1 \fatsemi T_2$.

$\Sigma_1 \intercomp \Sigma_2$  is called the \emph{interaction composition} of $\Sigma_1$ and $\Sigma_2$.
\end{dfn}

\begin{exmp}
The diagram below represents a tree-type $T$ (left) the corresponding interaction arena $\intersem{T}$ (middle) and the
interaction strategy $\Sigma = (\sigma_1 \intercomp \sigma_2) \intercomp \sigma_3$ (right):
$$
\pstree[levelsep=6ex]{\TR{\fatsemi}}
        {
            \pstree[levelsep=6ex]{\TR{\fatsemi}}
            { \TR{!A\multimap B}
              \TR{!B\multimap C}
            }
            \TR{!C\multimap D}
        }
\hspace{1cm}
\pstree[levelsep=6ex]{\TR{\fatsemi}}
        {
            \pstree[levelsep=6ex]{\TR{\fatsemi}}
            { \TR{\sem{!A\multimap B}}
              \TR{\sem{!B\multimap C}}
            }
            \TR{\sem{!C\multimap D}}
        }
\hspace{1cm}
\pstree[levelsep=6ex]{\TR{\fatsemi}}
        {
            \pstree[levelsep=6ex]{\TR{\fatsemi}}
            { \TR{!A\multimap B^{\sigma_1}}
              \TR{!B\multimap C^{\sigma_2}}
            }
            \TR{!C\multimap D^{\sigma_3}}
        }
$$
\end{exmp}

A play of the interaction semantics is called an \emph{uncovered
play}. It is a play containing internal moves.
The moves are implicitly tagged so that it is possible to retrieve in which component
of which node/leaf-arena the move is situated. The internal moves of an
interaction play on the game $\intersem{T}$ are those which do not
belong to the arena $root(\intersem{T})$.

For any uncovered play $s$ and any interaction arena $\intersem{T}$
we can define the filtering operator $s\upharpoonright \intersem{T}$ to be the
sequence of moves obtained from $s$ by keeping only the moves
belonging to a node-arena or a leaf-arena of $\intersem{T}$.


An interaction strategy can alternatively be represented by a set of
uncovered plays instead of an annotated tree-type.
It can be defined inductively on the structure of the annotated tree-type $\Sigma$ as follows:
the interaction strategy for a leaf $\sem{A}$ of
$\Sigma$ annotated by $\sigma :\sem{A}$ is just the the standard strategy $\sigma$.
For a node of $\Sigma$ with two sub-trees $T_1$, $T_2$ where $\Sigma_1$ is the interaction associated to $T_1$
and $\Sigma_2$ is the interaction associated to $T_2$:
\begin{itemize}
\item if it is a $\fatsemi$-node then the interaction strategy is the
``uncovered-composition'' of $\Sigma_1$ and $\Sigma_2$ noted $\Sigma_1
\intercomp \Sigma_1$ and defined to be the a set of uncovered plays
obtained by performing the usual composition while ignoring and
copying the internal moves of arenas in $\intersem{T_1}$ and $\intersem{T_2}$
and preserving the internal moves in $root(\intersem{T_1})$ and $root(\intersem{T_2})$
``produced'' during the composition;

\item for a $\otimes$-node, it is the tensor product noted $\Sigma_1 \otimes \Sigma_2$;
\item for a $\times$-node, it is the pairing noted $\langle \Sigma_1, \Sigma_2 \rangle$;
\item for a $!$-node, it is the promotion noted $\Sigma_1^\dagger$;
\end{itemize}
where the tensor product, pairing and promotion are defined similarly as in the standard game semantics.


We can now define the category $\mathcal{I}$ of interaction games:
\begin{dfn}[Category of interaction games]
The category of interaction games is noted $\mathcal{I}$. The
objects of $\mathcal{I}$ are the same as $\mathcal{C}$ : the arenas $\sem{A}$ for any linear type $A$. The morphisms of
the category are the interaction strategies: a morphism from $A$
to $B$ is an interaction strategy $\Sigma$ on some interaction arena
$\intersem{T}$ such that $root(\intersem{T}) = \sem{A\rightarrow B}$.

The composition of morphisms is given by the interaction strategy
composition $\intercomp$.

The identity on $A$ is the single leaf interaction arena $\sem{A}$ annotated with $id_A$.
\end{dfn}

It can be check that this indeed define a category.

Most of the construction of the category $\mathcal{C}$ can then be constructed similarly in $\mathcal{I}$ and consequently
$\mathcal{I}$ is a cartesian closed category.


\begin{dfn}[Valid strategy]
Consider a term $\Gamma \vdash M : A$ and $\Sigma : \intersem{T}$ an interaction strategy.
We say that $\Sigma$ is a valid interaction strategies for $M$ if $root(\intersem{T}) = \sem{\Gamma \rightarrow A}$.
\end{dfn}

We would like to use the category $\mathcal{I}$ to model terms of the
simply-typed lambda calculus. However there may be several valid tree-type decomposition for a given term $M$ and therefore
several strategies denoting $M$!

To fix this problem, we will compute a tree-type decomposition and the associated strategy from the
the computation tree of $M$. Since the computation tree is unique it will be possible to uniquely define
the interaction strategy of a term.






We write $\intersem{\Gamma \vdash M : T}$ to denote the interaction semantics of $M$ and $\intersem{\Gamma \rightarrow T}_M$
to denote the unique interaction arena obtained from the computation tree of $M$.


In the standard semantics, given two strategies $\sigma : A \rightarrow B$, $\tau : B \rightarrow C$ and
a sequence $s \in \sigma \fatsemi \tau$, it is possible to (uniquely) recover the internal moves. The uncovered sequence is noted
 ${\bf u}(s, \sigma, \tau)$. The algorithm to obtain this unique uncovering is given in part II of \cite{hylandong_pcf}.

Given a term $M$, we can completely uncover the internal moves of a sequence $s\in\sem{M}$
by performing the uncovering recursively at every $@$ nodes of the computation tree.
This operation is called \emph{full-uncovering with respect to $M$}.
Consequently, the interaction semantics can be computed from the standard semantics.

Conversely, the standard semantics can be recovered from the interaction semantics by filtering the moves, keeping only those played
in the root arena:
\begin{eqnarray}
 \sem{\Gamma \vdash M : T} = \intersem{\Gamma \vdash M : T} \upharpoonright root(\intersem{\Gamma \rightarrow T}_M) \label{eqn:int_std_gamsem}
\end{eqnarray}

Hence we have the following lemma:
\begin{lem}[$\mathcal{I'}$ is isomorphic to $\mathcal{C}$]
$\mathcal{I'} \cong \mathcal{C}$
\end{lem}
\begin{proof}
We define the functor $F:\mathcal{I'} \rightarrow \mathcal{C}$
by $F(A) = A$ and for $\Sigma \in \mathcal{I'}(A,B)$,
$F(\Sigma) = \Sigma \upharpoonright \sem{A\rightarrow B}$
and the functor $G:\mathcal{C} \rightarrow \mathcal{I'}$ by
by $G(A) = A$ and for $\Sigma \in \mathcal{I'}(A,B)$,
$F(\Sigma) = \Sigma \upharpoonright \sem{A\rightarrow B}$

\end{proof}

Consequently the lluf sub-category $\mathcal{I'}$ of $\mathcal{I}$ is fully abstract for the simply-typed lambda calculus.
Note that this is a major difference with $\mathcal{I}$ which is not fully-abstract since there may be several maps denoting a given
term.



\begin{dfn}[Intrinsic tree-type of a term]
Let $M$ be a term. The \emph{tree-type of $M$} is a binary tree
isomorphic to the tree obtained by collapsing every maximal sub-term
of the computation tree that is in $\beta$-normal form to a single
leaf. The nodes of the tree-type of $M$ correspond to $@$-nodes in
the computation tree of $M$, leaves correspond to maximal sub-terms
in $\beta$-normal form. Suppose that $n$ denotes an $@$-node in the
computation tree then the corresponding node in the type-tree is
labelled with $type(\kappa(p))$ where $p$ denotes the parent node of
$n$ in the computation tree.
\end{dfn}
The tree-type of $M$ is a well-defined tree-type (the type of a node
is equal to the type composition of its two children nodes).

The interaction arena of a term $\Gamma \vdash M:A$ noted
$\intersem{\Gamma \rightarrow A}_M$ is defined to be $\intersem{T}$
where $T$ denotes the tree-type of $M$.


\begin{exmp}
Consider the term $\lambda x . (\lambda f . f x) (\lambda y . y)$.
Its computation tree and interaction arena are represented below:
$$
\tree{\lambda x} {
    \pstree[levelsep=4ex]{\TR[name=App]{@}}
    {
            \pstree[levelsep=4ex]{\TR[name=L]{\lambda f}}
                { \tree{f}{  \tree{\lambda}{ \TR[name=Lf]{x}  } } }
            \pstree[levelsep=4ex]{\TR[name=R]{\lambda y}}
                    {\TR[name=Rf]{y}}
    }
} \ncbox[linearc=.3,boxsize=.3,linestyle=dashed]{L}{Lf}
\ncbox[linearc=.3,boxsize=.3,linestyle=dashed]{R}{Rf} \hspace{3cm}
    \pstree[levelsep=8ex]{\TR[name=A1]{A_1}}
        {
            \TR[name=A2]{A_2}
            \TR[name=A3]{A_3}
        }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt
1,linestyle=dashed,linewidth=0.3pt} \ncline{->}{App}{A1}
\ncarc{->}{L}{A2} \ncline{->}{R}{A3}
$$
where the arena $A_1$,$A_2$ and $A_3$ are given below (the answer
moves are omitted):
$$ \tree{ q_{\lambda x} }
        { \TR{q_x} }
\hspace{2cm}
    \tree{ q_{\lambda f} }
    {
        \tree{ q_f }
        {  \TR{q_{f_1}}   }
        \TR{q_x}
    }
\hspace{2cm}
     \tree{ q_{\lambda y} }
        { \TR{q_y} \TR{q_x}}
$$
\end{exmp}



\vspace{18pt}

\subsection{Correspondence between interaction semantics and traversals}

Before being able to to reveal the correspondence between the
interaction game semantics and traversals of the computation tree we
need to introduce some definitions and lemmas.

%\begin{dfn}[Question-move filtering]
%Suppose $s$ is a justified sequence of moves then we write $\tilde{s}$
%the subsequence of $s$ consisting of question-moves only:
%\begin{eqnarray*}
%\tilde{} &: L_A &\longrightarrow (M^Q)^* \\
%& s &\longmapsto \tilde{s} = s \upharpoonright M^Q
%\end{eqnarray*}
%where $M^Q$ denotes the set of question-moves.
%$\tilde{s}$ is also a justified sequence of move (there is no dangling pointer since questions-moves points to other question-moves).
%If $s = u\upharpoonright A,B$ then clearly $\tilde{s} = \tilde{u} \upharpoonright A,B$.
%\end{dfn}

%\begin{dfn}
%\begin{eqnarray*}
%\sem{\Gamma\vdash M:T}^{\sim} &=& \{ \tilde{s} \ | \ s \in \sem{\Gamma\vdash M:T} \} \\
%\intersem{\Gamma\vdash M:T}^{\sim} &=& \{ \tilde{s} \ | \ s \in \intersem{\Gamma\vdash M:T} \}
%\end{eqnarray*}
%We write $\sem{\Gamma\vdash M:T}^{\sim}_{max}$ for the subset of maximal sequences of question moves in
%$\sem{\Gamma\vdash M:T}^{\sim}$.
%
%$\sem{\Gamma\vdash M:T}_{max}$, $\intersem{\Gamma\vdash M:T}^{\sim}_{max}$ and
%$\intersem{\Gamma\vdash M:T}_{max}$ are defined similarly.
%\end{dfn}

\begin{dfn}[$@$-hiding of traversals]
Let $t$ be a traversal of $\tau(M)$.

We write $t-@$ for the sequence sequence of nodes with pointers
(i.e. not a proper justified sequence of nodes) obtained by removing
from $t$ all the nodes $@$ and replacing any link pointing to an $@$
node by a link pointing to the predecessor node of $@$ in $t$.

Suppose $u = t-@$ is as sequence of nodes obtained by applying the
previously defined transformation on the traversal $t$, then $t$ can
be recovered from $u$ by reinserting the $@$ nodes as follows:
\begin{itemize}
\item replace any two consecutive lambda-nodes $n_1 \cdot n_2$ in $j$
by $n_1 \cdot @ \cdot n_2$ where $@$ denotes the parent node of
$n_2$ which is also the child node of $n_1$ in the computation tree.
\item replace any link in $u$ pointing from a $\lambda$-node to $n_1$ by a link pointing to the inserted $@$ node.
\end{itemize}
We write $u+@$ for this second transformation.
\end{dfn}
These transformations are well-defined since in a traversal, the node
$@$ always occurs in-between nodes $n_1$ and $n_2$ where in the computation tree $n_1$ is the parent node of $@$
and $n_2$ is the first child node of $@$:
$$      \pstree[levelsep=4ex]{\TR{n_1}\treelabel{0} }
        {
            \pstree[levelsep=3ex]{\TR{@}}
            {
                \tree{n_2}{\vdots}
                \TR[edge=\dedge]{}
                \TR[edge=\dedge]{}
            }
        }
$$

The following lemma follows directly from the definition:
\begin{lem}
\label{lem:minus_at_plus_at} For any traversal $t$, $(t-@)+@=t$.
\end{lem}

\begin{lem}
Let $M$ be a term in $\beta$-normal form and $t \in
\travset(M)$. Then
$$t = t \upharpoonright r = t - @$$
\end{lem}
\begin{proof}
This is because the computation tree of a term in $\beta$-normal
does not contain any $@$ node and therefore all the nodes are
hereditarily justified by the root.
\end{proof}


We introduce the following notation:
\begin{eqnarray*}
\travset(M)^{-@} &=& \{ t - @ \ | \  t \in \travset(M) \} \\
\travset(M)^{\upharpoonright r} &=& \{ t  \upharpoonright r \ | \  t  \in \travset(M) \} .
\end{eqnarray*}


\begin{lem}[Filtering lemma] \
\label{lem:varphi_filter}
$$ \varphi_M(\travset^{-@}) \upharpoonright root(\intersem{\Gamma \rightarrow T}) = \varphi_M(\travset^{\upharpoonright r}) $$
In other words, for any traversal $t$ of the computation tree of $\Gamma \vdash M :T$ we have:
$$\varphi_M(t-@) \upharpoonright root(\intersem{\Gamma \rightarrow T}) = \varphi_M(t\upharpoonright r)$$
\end{lem}
\begin{proof}
    Let $r$ denotes the root of $\tau(M)$.
    It is easy to check from the definition of $\varphi_M$ that the nodes of the computation tree that are mapped by $\varphi_M$
    to moves belonging to the root of the interaction arenas $\intersem{\Gamma}$ and $\intersem{T}$ are
    exactly the nodes hereditarily justified by $r$.
    Since $@$ is not hereditarily justified by $r$ the result follows immediately.
\end{proof}


\begin{lem}[$\varphi_M$ is injective]
We consider $\varphi_M$ as a function defined on the set of
justified sequence of nodes. For any two traversal $t$ and $t'$:
\begin{itemize}
\item[(i)] if $\varphi_M (t \upharpoonright r ) = \varphi_M (t' \upharpoonright r )$ then $t\upharpoonright r = t'\upharpoonright r$.
\item[(ii)] if $\varphi_M (t - @ ) = \varphi_M (t' - @ )$ then $t-@ =t' -@$.
\end{itemize}
\end{lem}
\begin{proof}
(i) We just need to prove that the restriction defines an injection
from $\travset(M)^{-@}$ to $\travset(M)^{-@}$. Suppose
that it is not the case then there are two traversals $t,t'$ such
that $t-@ \neq t'-@$


\end{proof}

Consequently:
\begin{cor} \
\label{cor:varphi_bij}
\begin{itemize}
\item[(i)] $\varphi_M$ defines a bijection from $\travset(M)^{-@}$
to $\varphi_M(\travset(M)^{-@})$;
\item[(ii)] $\varphi_M$ defines a bijection from $\travset(M)^{\upharpoonright r}$ to
$\varphi_M(\travset(M)^{\upharpoonright r})$.
\end{itemize}
\end{cor}






\begin{prop}
\label{prop:rel_gamesem_trav_closed} Let $\Gamma \vdash M : T$ be a
term of the pure simply-typed $\lambda$-calculus and $r$ be the root
of $\tau(M)$. Then:
\begin{itemize}
\item[(i)]  $\varphi_M(\travset(M)^{-@}) = \intersem{M}$
\item[(ii)] $\varphi_M(\travset(M)^{\upharpoonright r}) = \sem{M}$
\end{itemize}
\end{prop}


\begin{proof}
(i) Suppose $\Gamma = \xi_1:X_1,\ldots \xi_n:X_n$. Then we have:
\begin{eqnarray*}
\intersem{\Gamma \vdash M:T} &=& \Lambda^n( \intersem{\emptyset \vdash \lambda \xi_1\ldots \xi_n . M: (X_1,\ldots,X_n,T) } ) \\
        &\simeq& \intersem{\emptyset \vdash \lambda \xi_1\ldots \xi_n . M: (X_1,\ldots,X_n,T) }.
\end{eqnarray*}
Similarly the computation tree $\tau(M)$ is isomorphic to
$\tau(\lambda \xi_1\ldots \xi_n . M)$ (up to a renaming of the root
of the computation tree) therefore $\travset(M)$, the set of
traversal of $\tau(M)$, is also isomorphic to
$\travset(\lambda \xi_1\ldots \xi_n . M)$. Hence we can make
the assumption that $M$ is a closed term. If we prove that the
property is true for all closed terms of a given height then it will
be automatically true for any open term of the same height.


Let us assume that $M$ is already in $\eta$-long normal form. We
proceed by induction on the height of of the tree $\tau(M)$ and by
case analysis on the structure of the computation tree:
\begin{itemize}

%  \item[(order 0 constant)] $M = f \in \Sigma$. The tree $\tau(M)$ has the following form:
%  $$ \tree[levelsep=6ex]{\lambda}{ \TR{f} }$$
%  There is only one question in the game arena: the initial question $q$ verifying $ q = \varphi_M(\lambda)$.
%  It suffices to take $t = \lambda^{|\tilde{s}|}$.

%  \item[(abstraction of a constant)]
%      $M'$ is an order 0 constant: same treatment as the (constant) case above.

  \item (abstraction of a variable): $M \equiv \lambda \overline{\xi} . x$
      Since $M$ is in $\eta$-long normal form, $x$ must be of ground type and since $M$ is
      closed we have $x = \xi_i \in \overline{\xi}$ for some $i$.
      Hence $\tau(M)$ has the following shape:
        $$ \tree[levelsep=6ex]{ \lambda \overline{\xi}^{[0]} }{\TR{\xi_i^{[1]}}}$$
        The arena is of the following form (only question moves are represented):
        $$ \tree{ q_0 }
        {   \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
            \TR{q'}
        }$$
        where $q'$ denotes the root of the flat arena $\sem{o}$.

        Let $\pi_i$ denotes the $ith$ projection of the interaction game
        semantics. We have:
        \begin{align*}
        \intersem{M} &= \intersem{\emptyset \vdash \lambda \overline{\xi} . \xi_i} \\
                     &= \Lambda^n(\intersem{\overline{\xi} \vdash  \xi_i}) \\
                     &= \Lambda^n(\pi_i) \\
                     &\cong \pi_i \\
                     &= \textsf{Pref}(\{ q \cdot q_0 \cdot q^v \cdot q_0^v \ | \ v\in \mathcal{D} \})
        \end{align*}

        Since $M$ is in $\beta$-normal we have $\travset(M)^{-@} = \travset(M)$.
        One can check that the set of traversals of $M$ is the set of prefix of
        the traversal $\lambda \overline{\xi} \cdot \xi_i \cdot \xi_i^v \cdot \lambda
        \overline{\xi}^v$. Therefore:
        $$ \travset^{-@}(M) = \travset(M) = \textsf{Pref}( \lambda \overline{\xi} \cdot \xi_i \cdot \xi_i^v \cdot \lambda \overline{\xi}^v)
        $$

        The pointers of the traversal $\lambda \overline{\xi} \cdot \xi_i \cdot \xi_i^v \cdot \lambda
        \overline{\xi}^v$ are the same as the play $q \cdot q_0 \cdot q^v \cdot
        q_0^v$. Therefore since $\varphi_M(\lambda \overline{\xi}) = q_0$ and $\varphi_M(\xi_i) =
        q'$ we have:
        $$ \varphi_M(\travset^{-@}(M)) = \intersem{M}$$


    \item (abstraction of an application): we have $M = \lambda \overline{\xi} . N_0 N_1 \ldots N_p$. Let $\Gamma$ be the context
    $\Gamma = \overline{\xi} : \overline{X}$. Then we have the following sequents:
    $\emptyset \vdash M : (X_1,\ldots,X_n,o)$,
    $\Gamma \vdash N_0 N_1 \ldots N_p : o$,
    $\Gamma \vdash N_i : B_i$ for $i\in 0..p$ with $B_0 = (B_1,\ldots,B_p,o)$ and $p\geq 1$.

    There are two subcases, either $N_0 \equiv \xi_i$ where $\alpha$ is a variable in $\overline{\xi}$ and the tree has the following form:
    $$ \tree[levelsep=6ex]{\lambda \overline{\xi}^{[0]}}
        { \tree[levelsep=6ex]{\xi_i^{[1]}}
            {   \TR{\tau(N_1)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$
    or $N_0$ is not a variable and the tree $\tau(M)$ has the following form:
    $$ \tree[levelsep=6ex]{\lambda \overline{\xi}^{[0]}}
        { \tree[levelsep=6ex]{@^{[1]}}
            {   \TR{\tau(N_0)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$
    We only consider the second case, the first one can be treated
    similarly. Moreover we make the assumption that $p=1$. It is
    straightforward to generalize to any $p\geq1$.
\begin{align*}
  \intersem{M}
    &=  \Lambda^n( \intersem{\Gamma \vdash N_0 N_1 : o} )
           & \mbox{(game semantics for abstraction)}\\
    &\cong  \intersem{\Gamma \vdash N_0 N_1 : o}
           & \mbox{(isomorphism up to a retagging of the moves)}\\
    &=  \langle \intersem{\Gamma \vdash N_0}, \intersem{\Gamma \vdash N_1} \rangle \fatsemi ev
           & \mbox{(game semantics for application)}\\
    &=  \langle \varphi_{N_0} (\travset^{-@}(N_0)), \varphi_{N_1}(\travset^{-@}(N_1) \rangle \fatsemi ev
           & \mbox{(by the induction hypothesis)}\\
    &=  \langle \varphi_{M} (\travset^{-@}(N_0)), \varphi_{M}(\travset^{-@}(N_1)) \rangle \fatsemi ev
           & \mbox{(by the inducitve defintion of $\varphi$)}\\
    &=  \varphi_{M}( \langle \travset^{-@}(N_0), \travset^{-@}(N_1) \rangle \fatsemi
    ev )
           & \mbox{($\varphi$ is a monoid homomorphism, lemma \ref{lem:varphi_monoidhomom})}\\
    &=  \varphi_{M}( \travset^{-@}(M) )
           &
\end{align*}

    with $\sigma : !A \multimap B$ and $ev_{B_1,o} : !B \multimap C$, the arena $A,B,C$ being defined as follows:
    \begin{eqnarray*}
        A &=& \sem{\Gamma} = \sem{X_1} \times \ldots \times \sem{X_n}\\
        B &=& \sem{B_1 \rightarrow o} \times \sem{B_1} \\
        C &=& \sem{o}
    \end{eqnarray*}




%    We have $s \in \sem{M} \cong \sem{\Gamma \vdash N_0 N_1 \ldots N_p : o} = \sigma \fatsemi ev_{B_1,\ldots,B_p,o}$ therefore:
%    \begin{equation}
%        s = u \upharpoonright !A, C   \quad \mbox{ for some } u \in \sigma^{\dag} \parallel ev_{B_1,\ldots,B_p,o}
%    \end{equation}
%    In other words for some $u \in int(!A,!B,C)$:
%    \begin{eqnarray}
%        s &=& u \upharpoonright !A, C    \label{eq:def_s} \\
%        w \defeq u \upharpoonright !A,!B & \in& \sigma^\dagger       \label{eq:def_w}\\
%        u \upharpoonright !B,C & \in & ev_{B_1,\ldots,B_p,o} \nonumber
%    \end{eqnarray}
%
%    For any initial move $m$ in $w$ we write $w_m = w \upharpoonright
%    m$. Since $w \in \sigma^\dagger$, for all initial $m$ in $w$, $w_m \in \sigma$. Hence for
%    all initial $m$ in $w$ there is $j \in 1..p$ such that:
%    \begin{eqnarray}
%        z_m \defeq w_m \upharpoonright !A, B_j &\in& \sem{\Gamma \vdash N_j}  \label{eq:def_z} \\
%        \mbox{ and for every } k\neq j &:& w_m \upharpoonright B_k = \epsilon \label{eq:b}
%    \end{eqnarray}
%
%    We write $\lambda \overline{y_i}$ to denote the root of the tree $\tau(N_i)$ for $i \in 1..p$.
%    From equation \ref{eq:def_z} we have $z_m \in \sem{N_j}$. Since the term $N_j$ is a closed term of height strictly smaller than the height
%    of $M$, we can apply the induction hypothesis:
%    there is a traversal $t^j_m$ of the tree $\tau(N_j)$
%    such that $\varphi_{N_j}(t^j_m \upharpoonright \lambda \overline{y_j} ) \jseq \widetilde{z_m}$.
%
%
%
%    Equation \ref{eq:def_w} gives:
%    \begin{eqnarray}
%        \tilde{w} &=& \tilde{u} \upharpoonright !A,!B  \nonumber \\
%        \widetilde{w_m} &=& \tilde{w}\upharpoonright m  = \tilde{u} \upharpoonright !A,!B,m
%        \label{eq:def_wtilde}
%    \end{eqnarray}
%
%    From equation \ref{eq:b}, for $k\neq j : w_m \upharpoonright B_k = \epsilon$. Since $B =
%    B_0 \times B_1 \times \ldots \times B_p$ this implies that moves in $w_m$ hereditarily justified by moves in $B$ are in fact all
%    hereditarily justified by moves in $B_j$.  Hence $z_m = w_m \upharpoonright !A, B_j = w_m \upharpoonright !A, B$ and:
%    \begin{eqnarray*}
%            \widetilde{z_m} =& \widetilde{w_m} \upharpoonright !A,B \\
%            =& (\tilde{u} \upharpoonright !A,!B,m) \upharpoonright !A,B &\mbox{(by eq \ref{eq:def_wtilde})} \\
%            =& \tilde{u} \upharpoonright !A,B,m \\
%            =& \widetilde{w_m}  & \mbox{(by eq \ref{eq:def_wtilde})}
%    \end{eqnarray*}
%
%
%    Hence $\varphi_{N_j}(t^j_m \upharpoonright \lambda \overline{y_j} ) \jseq \widetilde{w_m}$.





    We are now going to construct the traversal $t$ of the
    tree $\tau(M)$.

    First let us analyse how a traversal of $M$ should proceed.
    Here is a sketch of the expected behaviour:

    The traversal starts at the root $\lambda \overline{\xi}$ of the tree $\tau(M)$ (rule
    (Root)), it then passes the node $@$ (rule (Lam)). Afterwards, it proceeds by traversing the term $N_0$ (rule (App))
    until a variable in $\overline{y_0}$ is reached. A that point the traversal
    of $N_0$ is interrupted and the traversal jumps (rule (Var)) to the root of $\tau(N_i)$ and goes on by traversing $\tau(N_i)$.

    When traversing $N_i$, if the traversal encounters a variable in $\overline{y_i}$ then the traversal of $N_i$ is interrupted and
    the traversal of $N_0$ resumes. The exact node in $\tau(N_0)$ where the traversal should resume is again determined by the (Var) rule.
    This schema is repeated until the traversal of $\tau(N_0)$ is completed.

    It becomes clear that the traversal $t$ follows a pattern that resembles the composition of the strategy $\sigma$
    with the copycat strategy evaluation map $ev$.

    However we need to construct a traversal $t$ verifying $\varphi_M(t \upharpoonright \lambda \overline{\xi}) =
    s$. To achieve this we will construct $t$ by reusing the traversals $t^i_m$ for $i \in 0..p$ and some initial $m$.


    We now give an algorithm that produces the traversal $t$: it proceeds by reading $u$, the uncovering of the sequence of moves $s$.
    It is also possible to work on $s$ directly while performing an on-the-fly uncovering of the moves that have been hidden by
    composition. The algorithm to obtain this unique uncovering of $u$ is given in part II of \cite{hylandong_pcf}).

    The moves in $u$ are read one by one. As we progress in the reading of $u$, we insert
 We describe in parallel how the traversal progresses.


    We initialize $t = \lambda \xi \cdot @$ : the first node of $t$ is the
    root of the tree $\tau(M)$ which corresponds to the initial move
    first played in $s$. This is permitted by the rule (Root). The
    second node $@$ is added using the (Lam) rule.

    In the game semantics, the evaluation map (a copy-cat strategy) copies this opening move to an initial move $m_0$ in the game
    $B_0$ and the game continues in $B_0$. We reflect this in the traversal : we make $t$ follow
    the ``script'' given by the traversal $t^0_{m_0}$.
    The rule (App) allow us to initiate this simulation
    by visiting the  first move in $t^0_{m_0}$: the root of $\tau(N_0)$.

    This simulation continues until it reaches a node $\alpha_0$ which is hereditarily justified by the root
    $\tau(N_0)$: $\alpha_0$ is present in the
    reduced-traversal of $t^0_{m_0}$ therefore $\varphi_{N_0}(\alpha_0)$ is an un-hidden move played in $A_0$.

    In the game semantics this corresponds to a move played in a component $A_k$ for some $k\in 1..p$ of
    of the game $B_0$ in which case the evaluation map copies the move to an initial move $m_1$ in the corresponding component $B_k$.

    To reflect this the traversal now opens up a new thread and
    simulates the traversal $t^k_{m_1}$.
    Again, this simulation stops when we reach a node
    $\alpha_1$ in $t^k_{m_1}$ which is hereditarily justified by the root of
    $\tau(N_k)$: $\alpha_1$ must be present in the reduced-traversal
    of $t^k_{m_1}$ therefore $\varphi_{N_k}(\alpha_1)$ is an un-hidden move played in $A_k$.
    In the game semantics, this move $\alpha$ is copied
    back to the component $B_k$ of the game $B_0$.

    The traversal now resumes the simulation of $t^0_{m_0}$. And the
    process goes continuously.

    \begin{itemize}
    \item[Remark 1:] Whenever the traversal pauses a simulation thread and
    jumps to another thread, the jump
    is permitted by the (Var) rule.

    \item[Remark 2:] When simulating a traversal $t^k_{m}$, if a variable
     $\xi_i \in \overline{\xi}$ is encountered, the pointer must be
     altered. The reason is that $t^k_{m}$ is a traversal of $N_k$ in which $\overline{\xi}$ are free
     variables. We therefore need to create a link to make the node point to the root of $\tau(M)$.

    \item[Remark 3:]Every time the traversal opens up a new thread and simulates a
    traversal $t^i_{m}$, we make the first node copied from $t^i_{m}$ point to the
    second node in $t$ (the application node $@$). This is indeed a valid justification pointer since the root of $\tau(N_i)$ is a child of $@$.
    \end{itemize}
\end{itemize}

(ii) is an immediate consequence of (i):
\begin{align*}
\sem{M} &= \intersem{M} \upharpoonright root(\intersem{\Gamma \rightarrow T}) & \mbox{(eq. \ref{eqn:int_std_gamsem})} \\
        &= \varphi_M(\travset^{-@}(M)) \upharpoonright root(\intersem{\Gamma \rightarrow T}) & \mbox{(by (i))}\\
        &= \varphi_M(\travset^{\upharpoonright r}(M)) & \mbox{(lemma \ref{lem:varphi_filter})}\\
\end{align*}
\end{proof}

%\input corresp_proofbis.tex

%%%%%%%%%%%%%%
% remark that may be useful for discussing the case of opened terms
%$$\forall i \geq 0 . \tilde{s}_i = \varphi_M(t_i) \not \in \sem{A} \mbox{(i.e. $\in \sem{\Gamma}$)}
%\implies            t_i = x \in \Gamma $$
%%%%%%%%%%%%



Putting corollary \ref{cor:varphi_bij} and proposition
\ref{prop:rel_gamesem_trav_closed} together we obtain the following
theorem:

\begin{thm}[Correspondence between game semantics and traversals]
For any simply-typed term $M$, $\varphi_M$ defines a bijection from
$\travset(M)^{\upharpoonright r}$ to $\sem{M}$ and a bijection
from $\travset(M)^{-@}$ to $\intersem{M}$:
\begin{eqnarray*}
 \varphi_M  &:& \travset(M)^{\upharpoonright r} \stackrel{\cong}{\longrightarrow} \sem{M} \\
 \varphi_M  &:& \travset(M)^{-@} \stackrel{\cong}{\longrightarrow} \intersem{M}
\end{eqnarray*}

Moreover if $M$ is in $\beta$-normal form and $s$ is a
\emph{maximal} play then  $t$ is a \emph{maximal} traversal.
\end{thm}

\begin{proof}
The first part is an immediate consequence of corollary
\ref{cor:varphi_bij} and proposition
\ref{prop:rel_gamesem_trav_closed}.

Finally, if $M$ is in $\beta$-normal form then
$\travset(M)^{\upharpoonright r} = \travset(M)$
therefore $\varphi$ is a bijection from $\travset(M)$ to
$\sem{M}$. Suppose $s$ is a maximal play and suppose $t' \sqsubseteq
t$ then since $\varphi$ is monotonous $s = \varphi(t) \sqsubseteq
\varphi(t')$. But $s$ is maximal therefore $s = \varphi(t') =
\varphi(t)$. Since $\varphi$ is injective we have $t'=t$.
\end{proof}




\subsection{Pointers in the game semantics of safe terms are uniquely recoverable}
We now use the correspondence theorem to study the game semantics of
safe terms. We prove that pointers in the game semantics of safe
terms can be uniquely recovered.

The example of section \ref{subsec:pointer_necessary} gives a good
intuition: remember that in order to distinguish the terms $M_1$ and
$M_2$, we had to keep the pointers in the plays of strategies.
However, if we limit ourself to the safe $\lambda$-calculus then the
ambiguity disappears since $M_1$ is safe whereas $M_2$ is not (in
the sub-term $f (\lambda y . x)$, the free variable $x$ has the same
order as $y$ but $x$ is not abstracted together with $y$).


First we prove that the computation tree of a safe term verifies a
property called regularity:
\begin{lem}[Computation tree of safe terms are regular]
\label{lem:regularity}
If $M$ is a safe term then any bound variable node $x$ of the computation tree $\tau(M)$ is bound
by the first $\lambda$-node in the path to the root that has
order strictly greater than $\ord{x}$.
\end{lem}
\begin{proof}
First note that in the computation tree, the binder of a node $x$ occurs in the path from $x$ to the root.

In the safe $\lambda$-calculus when applying the abstraction rule the variables in the lowest partition of the context
(smallest order) must all be abstracted together. Expressing this fact from point of view of the the computation tree
(where consecutive abstractions are merged into a single node) we obtain:
for each lambda node $\lambda \overline{\xi}$, any variable $x$ occurring free in $\kappa(\lambda \overline{\xi})$
has order greater or equal to $\ord{\lambda \overline{\xi}}$.

Reciprocally, if a lambda node $\lambda \overline{\xi}$ binds a variable node $x$ then $\ord{\lambda \overline{\xi}} = \max_{z\in\overline{\xi}} \ord{z} > \ord{x}$.

Hence $x$ must be bound by the first $\lambda$ node occurring in the path the root of the computation tree.
\end{proof}


\begin{prop}
The pointers in the game semantics of safe terms are
uniquely recoverable.
\end{prop}

\begin{proof}
Let $\Gamma \vdash M : A$ be an opened safe term where $\Gamma = y_1:Y_1, \ldots y_n:Y_n$.
We assume that $M$ is in $\beta \eta$-long normal form : the $\eta$-long normal form of the $\beta$-normal form.
It is a safe assumption since safety is preserved by $\eta$-expansion and $\beta$-reduction.

Consider a justified sequence of move $s \in \sem{\Gamma \vdash M}$. Firstly,
we remark that the pointers for O and P answer moves in $s$ can all be
recovered thanks to the well-bracketing condition.
Let us prove by induction that the pointers for question moves can also be recovered.

\emph{Base case}: if $s \in \sem{M}$ where $|s| \leq 1$ then there is no pointer to recover.

\emph{Step case}: suppose $s \in \sem{M}$ with $|s| > 1$. Let $q$ denotes the last move in $s$.

Consider the closed term $M'  = \lambda \overline{y} . M$.
Up to a retagging of the moves, the justified sequence of moves $s$ belongs to the strategy
$\sem{\vdash \lambda \overline{y} . M} = \Lambda^n(\sem{\Gamma \vdash M})$.

Proposition \ref{prop:rel_gamesem_trav_closed} tells us that there
is a reduced-traversal $r$ of $\tau(M')$ such that:
$$\varphi_{M'}(r) \jseq s.$$

Let us write $n$ for the last node in the sequence $r$
and $root$ the root of $\tau(M')$.
$r$ is a reduced-traversal therefore by remark \ref{rem:redtrav}:
$$ r \jseq t \upharpoonright  root  $$
for some traversal $t$ whose last node $n$ is hereditarily justified by $root$.

\begin{itemize}
\item Suppose $q$ is a P-move.

Since $r$ is a reduced-traversal of $\tau(M')$ and $M'$ is in $\beta
\eta$-long normal form, lemma \ref{lem:redtrav_trav} (i) gives:
\begin{equation}
 \pview{?(r)} \jseq \pview{?(t)} \upharpoonright  root  \label{eq:pre_pview_r}
\end{equation}

%% REMOVED
%%By property \ref{proper:betaeta_trav}, the nodes that are not hereditarily justified by the root are
%%exactly the nodes that are hereditarily justified by $N_\Sigma$.
%%Since $\Sigma$ contains only constant of order $1$ at most, the only nodes that are hereditarily justified by $N_\Sigma$ are the nodes
%%in $N_\Sigma \union Succ(N_\Sigma)$. Hence equation \label{eq:pre_pview_r} becomes:
%%\begin{equation}
%% \pview{r} \jseq \pview{t} \setminus \left( N_\Sigma \union Succ(N_\Sigma) \right) \label{eq:pview_r}
%%\end{equation}

Proposition \ref{prop:pviewtrav_is_path} gives us that $\pview{?(t)}$ is
the path in $\tau(M)$ from the root to the node $n$.
Therefore by regularity of $\tau(M)$ (lemma \ref{lem:regularity}) $n$ points to the
last $\lambda$-node in $\pview{?(t)}$ of order strictly greater than $\ord{n}$.

Since $n$ is the last node of $\pview{?(t)} \upharpoonright root$,
it is hereditarily justified by the root and it must point to a node
$m$ in $\pview{?(t)}$ that is also hereditarily justified by the
root. Therefore $m$ also occurs in $\pview{?(r)}$. But $m$ is the
last $\lambda$-node in $\pview{?(t)}$ that has order strictly
greater than $\ord{n}$, therefore since $\pview{?(r)}$ is a
subsequence of $\pview{?(t)}$, $m$ is also the last $\lambda$-node
in $\pview{?(r)}$ that has order greater strictly greater than
$\ord{n}$.


%The lambda nodes in $N_\Sigma \union Succ(N_\Sigma)$ are exactly the
%nodes in $Succ(N_{\Sigma})$, they are all labelled $\lambda$ and
%hence are of order $-1$. Moreover we have $\ord{n} \geq 0$ therefore
%the last $\lambda$-node in $\pview{t}$ that has order greater or
%equal to $\ord{n}$ is also the last node in $\pview{r} = \pview{t}
%\setminus \left( N_\Sigma \union Succ(N_\Sigma) \right)$ that has
%order greater or equal to $\ord{n}$.

By property \ref{proper:phi_pview} (ii), the P-view of $?(s)$ and the P-view of $?(r)$ are computed
similarly and have the same pointers. This means that
node $n$ and  move $q$ both point to the same position in
the justified sequence $\pview{?(r)}$ and $\pview{?(s)}$ respectively.

By the induction hypothesis, the pointers of $s$ can been recovered up to the last move $q$: this
ensures that the P-view $\pview{?(s)}$ can be computed.

Since $\varphi$ maps nodes of a given order to moves of the same order (property \ref{proper:phi_conserve_order}),
$q$ also points to the last O-move in $\pview{?(s)}$ whose
order is strictly greater than $\ord{q}$.

\item Suppose $q$ is an O-move.

$M'$ is in $\beta\eta$-long normal form and $t$ is a traversal of $\tau(M')$
whose last node $n$ is hereditarily justified by $root$. Therefore  by lemma \ref{lem:redtrav_trav} (ii):
\begin{equation}
 \oview{?(r)} \jseq \oview{?(t)} \label{eq:oview_r}
\end{equation}


A lambda-nodes always points to its parent node in the computation
tree. For terms in $\beta$-normal form, this parent node must be a
variable node of order strictly greater than $\ord{n}$.

By inspecting the formation rules of traversals (definition
\ref{def:traversal}) one can check that a lambda-node occurring in a
traversal always points to the last node with order strictly greater
that $\ord{n}$ in the O-view of the sequence of pending nodes at
that point (there are just two cases, $n$ points either to the
preceding node or to the third previous node in $\oview{?(t)}$).

Similarly, as in the P-move case, we conclude that $q$ points to the
last question move in $\oview{?(s)}$ of order strictly greater than
$\ord{q}$, the induction hypothesis guaranteeing that the O-view
$\oview{?(s)}$ is computable.

\end{itemize}

\end{proof}
