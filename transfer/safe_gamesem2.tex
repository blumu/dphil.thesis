\def\cmptre#1{\tau(#1)}
\def\aux#1{\lceil #1\rceil}
\def\nf#1{\eta_{\sf nf}(#1)}

\section{Game semantics of safe $\lambda$-terms}

In this section we will prove that the safety condition
of section \ref{sec:safe_alt} leads to a pointer economy in the game
semantics: for safe $\lambda$-terms the pointers from the game semantics can be reconstructed uniquely from the moves of
the play.

The example of section \ref{subsec:ptrless_strat} gives the intuition.
Remember that in order to distinguish the terms $M_1$ and $M_2$,
we introduced pointers in strategies. In the safe $\lambda$-calculus
this ambiguity disappears because $M_2$ is not a safe term. Indeed, in the
sub-term $f (\lambda y . x)$, the free variable $x$
has the same order as $y$ but $x$ is not abstracted together
with $y$.

We fix $\Sigma$, a set of constants of order at most 1.
%\begin{enumerate}
%\item
%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.
%
%\item
%Is there any unsafe $\beta$-normal form whose game semantics is a
%strategy where pointers can be recovered?
%\end{enumerate}






\subsection{$\eta$-long normal form and computation tree}

The $\eta$-expansion of $M: A\typear B$ is defined to be the term $\lambda x . M x : A\typear B$ where $x:A$ is a fresh variable.
It is easy to check that if $M$ is safe then $\lambda x . M x$ is also safe.

Consider the term $M : (A_1,\ldots,A_n,o)$, it can be expanded in several steps into
$\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots \varphi_l$
where the $\varphi_i:A_i$ are fresh variables.

The $\eta$-normal form of a term is obtained by hereditarily $\eta$-expanding every sub-term occurring
at an operand position:

\begin{dfn}[$\eta$-long normal form]
A term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a
constant or an abstraction.

The $\eta$-long normal form of a term $M$ is denoted $\aux{M}$ and
is defined as follows:
\begin{eqnarray*}
\aux{x s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{x s_1 \ldots s_m : o} &=& \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \\
\aux{(\lambda x . s_0) s_1 \ldots s_m } &=& (\lambda x . \aux{s_0}) \aux{s_1} \aux{s_2} \ldots \aux{s_m}
\end{eqnarray*}
where $m \geq 0$ and $x$ is either a variable or a constant.
\end{dfn}

The $\eta$-long normal form appeared in \citep{DBLP:journals/tcs/JensenP76}
under the name \emph{long reduced form}
and in \citep{DBLP:journals/tcs/Huet75}
under the name \emph{$\eta$-normal form}. It was then investigated in \citep{huet76}
under the name \emph{extensional form}.


A term can be represented by a tree defined formally by induction on the structure
of its $\eta$-long normal form as follows:

\begin{dfn}[Computation tree]
The computation tree associated to the term $s$ is noted
$\cmptre{s}$. It is obtained by applying the following rules
inductively \emph{on the $\eta$-long normal form} of $s$. In the
following $x$ is either a variable or a constant.
\begin{itemize}
\item the tree for $\lambda x_1 \ldots x_n. M$ where $M$ is not an abstraction is:
$$ \cmptre{\lambda x_1 \ldots x_n . M} =
  \pstree[levelsep=4ex]
    { \TR{\lambda x_1 \ldots x_n} }
    { \SubTree{\cmptre{M}}
    }
$$


\item the tree for $x s_1 \ldots s_n$ is:
$$ \cmptre{ x s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{x @} }
    { \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$

\item the tree for $x$ is the single leaf $x$.

\item the tree for $(\lambda x.s_0) s_1 \ldots s_n$ is:
$$ \cmptre{(\lambda x.s_0) s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{@} }
    {
    \SubTree{\cmptre{\lambda x.s_0}}    \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$
\end{itemize}
\end{dfn}

Example: if $x$ is a variable or a constant then
$ \cmptre{\lambda . x} =
  \pstree[levelsep=3ex]
    { \TR{\lambda } }
    { \TR{x}
    }$

The nodes (and leaves) of the tree are of three kinds:
\begin{itemize}
\item $\lambda$-node labeled $\lambda \overline{x}$. A $\lambda$-node represents several consecutive abstractions of variables.
\item application node labeled $@$
\item operator-application nodes labeled $x @$ where the operator $x$ is
either a variable or a constant.
\end{itemize}

A sub-tree of the computation tree represents a $\lambda$-term. We
define the map $\kappa : N \rightarrow \mathcal{T}$ where $N$
denotes the set of nodes and leaves of the computation tree
$\tau(s)$ and $\mathcal{T}$ denotes the set of $\lambda$-terms.
$\kappa$ associates to any node $n$ of the tree the $\lambda$-term
$\kappa(n)$ that is represented by the sub-tree of $\tau(s)$ rooted
at $n$. In particular if $r$ is the root of the tree $\tau(s)$ then
$\kappa(s) = \aux{s}$.

\begin{dfn}[Node order]
The order of a lambda-node $n$ labelled $\lambda \overline{\xi}$ is defined as follows:
$$\ord{n} = \max_{i=1..n} \ord{\xi_i}$$
The order of $n$ labelled $x$ or $x@$ is the order of the variable or constant $x$:
$\ord{n} = \ord{x}$.
The order of node labelled $@$ is $0$.
\end{dfn}


Consider the computation tree $\tau(s)$ of a term $s$ in $\eta$-long normal form. Then:
\begin{itemize}
\item One can check that nodes at even level are abstraction
node and nodes at odd level are either application nodes,
operator-application nodes, variable or constant nodes (the root level being numbered $0$).

\item Suppose that a variable $x$ occurs in $s$. The corresponding node in the tree has of one of the two following forms:
    \begin{itemize}
    \item $ \pstree[levelsep=3ex]
        { \TR{\lambda } }
        { \TR{x}
        }$ where $\ord{x} = 0$

    \item $ \pstree[levelsep=3ex]
                { \TR{x @} }
                { \TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
        $ where $\ord{x} > 0$ and $x:(A_1,\ldots,A_p,o)$
    \end{itemize}

\item    Moreover for any abstraction node
        $ \pstree[levelsep=4ex]
            { \TR{\lambda \overline{\varphi}} }
            { \pstree[levelsep=3ex]
                {\TR{@^{[n]}}}
                {\TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
            }
        $
    we have $\ord{\kappa(@^{[n]})}=0$

\end{itemize}



\subsubsection{Pointers and justified sequence of nodes}

\begin{dfn}[Binder]
Let $n$ be a node of the computation tree labelled $x$ or $x@$.
We say a node $n$ is bound by the node $m$ if $m$ is
the closest node in the path from $n$ to the root of the tree such that
$m$ is labelled $\lambda \overline{\xi}$ with $x\in \overline{\xi}$.
$m$ is called the binder of $n$
\end{dfn}

\begin{dfn}[Enabling]
The enabling relation noted $\vdash$ over the set of nodes of the computation tree is defined as follows:

We write $m \vdash n$ and we say that the node $n$ is enabled by $m$ or that $m$ enables $n$ if and only if
\begin{itemize}
\item the node $n$ is labelled $x$ or $x@$ and $m$ is the binder of $n$;
\item or $n$ is a lambda node labelled $\lambda \overline{\xi}$ and $m$ is the parent node of $n$
        (labelled $@$ or $x@$ for some variable or $\Sigma$-constant $x$).
\end{itemize}
\end{dfn}



\begin{dfn}[Justified sequence of nodes]
A \emph{justified sequence of nodes} is an alternating sequence of lambda and non lambda nodes
from the computation tree $\tau(M)$ together with pointers.
Each node $n$ of the sequence that is either
a lambda-node, a $\xi$-node or a $\xi@$-node where $\xi$ is a variable not occurring free in $M$,
and that is not the root of the computation tree has a pointer to a previous node $m$ in the sequence
such that $m \vdash n$.

If $n$ points to $m$ we say that $m$ justifies $n$ and we note it:
$$\justseq{m & \ldots & n \apointto{ll}}$$

Hence the pointers in a justified sequence of nodes must be of one of the following forms:
$$\xymatrix @=12pt@M=0pt{
\lambda \overline{\xi} & \ldots & \xi_i @ \apointto{ll} \\
\lambda \overline{\xi}  & \ldots & \xi_i \apointto{ll} \\
@  & \ldots & \lambda \overline{\xi} \apointto{ll} \\
x@ & \ldots & \lambda \overline{\xi} \apointto{ll} \\
f@ & \ldots & \lambda \overline{\xi} \apointto{ll}
}$$
where $x$ is a variable and $f$ a $\Sigma$-constant.
\end{dfn}

Note that justified sequences are also defined for non closed terms
(a nodes occurring in a justified sequence and labelled by a variable free in $M$ has no pointer).

We say that a node $n_0$ of a justified sequence is hereditarily justified by $n_p$ if there are nodes $n_1, n_2, \ldots n_{p-1}$ in
the sequence such that for all $i\in 0..p-1$, $n_i$ points to $n_{i+1}$.

If $N$ is a set of nodes and $s$ a justified sequence of nodes then we note $s \upharpoonright N$ the
subsequence of $s$ obtained after removing the nodes that are not hereditarily justified by nodes in $N$.
This subsequence is also a justified sequence of nodes.

Let $r$ be the root of the tree $\tau(M)$ then no node in the justified sequence
$s \upharpoonright \{ r \}$ is labelled by a free variable in $M$.


\begin{dfn}[Equality of justified sequence]
We note $s \jseq t$ to denotes that the two justified sequences $t$ and $s$ are the equal
(having same nodes and same pointers).
\end{dfn}

\begin{dfn}[P-view of justified sequence of nodes]
The P-view of a justified sequence of nodes $t$ of $\tau(M)$ noted $\pview{t}$ is defined as follows:
\begin{eqnarray*}
 \pview{\epsilon} &=&  \epsilon \\
 \pview{s \cdot f@ }  &=&  \pview{s} \cdot f@ \\
 \pview{s \cdot @ }  &=&  \pview{s} \cdot @ \\
\pview{s \cdot x@ }  &=&   \pview{s} \cdot x@ \\
 \pview{s \cdot x }  &=&   \pview{s} \cdot x \\
 \pview{s \cdot \lambda \overline{\xi} }  &=&  \lambda \overline{\xi} \qquad \mbox{if $\lambda \overline{\xi}$ is the root of } \tau(M) \\
 \pview{\justseq[5pt]{s & m & \ldots & \lambda \overline{\xi}\pointto{ll} }}  &=& \justseq[5pt]{ \pview{s} & m & \lambda \overline{\xi}\pointto{l} }
\end{eqnarray*}
where $f$ ranges over $\Sigma$ and $x$ over variables.
\end{dfn}


\begin{dfn}[Visibility]
\end{dfn}
\todomargin{definition visibility}

\begin{property}
\label{proper:pview_visibility}
The P-view of a justified sequence verifying visibility is a well-formed justified sequence verifying P-visibility.
\end{property}


\subsubsection{Traversal of the computation tree}
The evaluation of term is performed by traversing the computation tree in a particular way called
\emph{traversal}. Intuitively, a \emph{traversal} is a justified sequence of nodes of the computation tree such that each node
of the sequence indicates which step is taken during the evaluation of the term.

Formally a \emph{traversal} is defined to be the prefix of a maximal-traversal.
A maximal-traversal is a traversal that cannot be extended by visiting another node and is defined as follows:
\begin{dfn}[Maximal-traversal]
A maximal-traversal always starts with the root of the tree. This marks the beginning of the computation.
The exploration of the tree then progresses as follows:
\begin{itemize}
\item (Lam) After visiting a lambda-node, a maximal-traversal must visit its child node.

\item (App) After a node labelled $@$, a maximal-traversal must visit the node
corresponding to the operator of the application (the leftmost child node of $@$).

\item (Sig) After a node labelled $f@$ where $f$ is a $\Sigma$-constant,
a maximal-traversal must visit one of the children nodes of $f@$.

\item (Var) After a node labelled $x$ or $x@$ where either $x$ occurs free variable in $M$
                or $x$ is bound by the root of the tree $\tau(M)$,
        a maximal-traversal must visit one of the children nodes.

\item (Var') If the last node visited is $x_i$ (or $x_i@$) where the node $x_i$ is bound by a node $\lambda \overline{x}$
different from the root of $\tau(M)$. Then the next node to be visited in a maximal-traversal
corresponds to the term that would be substituted for $x_i$ if the $\beta$-redex
in term $M$ were reduced.

Then binding node $\lambda \overline{x}$ must have been visited previously in the traversal.
Since $\lambda \overline{x}$ is not the root of the tree, there must be an application node $n$
preceding $\lambda \overline{x}$ in the traversal.

    \begin{itemize}
    \item Suppose $n$ is the parent node of $\lambda \overline{x}$, then $n$ is an application node labelled $@$ having exactly $|\overline{x}| + 1$ children numbered
    $m_0, m_1, \ldots m_n$:
    $$\pstree[levelsep=8ex]{\TR{\stackrel{\vdots}{@^{[n]}}}}
    {   \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}\tvput*{0}}
            {\TR{x_i}}
        \tree{\lambda \overline{\eta_1}^{[m_1]}}{\vdots}\tvput*{1}
        \TR[edge=\dedge]{}
        \tree{\lambda \overline{\eta_i}^{[m_i]}}{\vdots}\tvput*{{\tiny i}}
        \TR[edge=\dedge]{}
        \tree{\lambda \overline{\eta_n}^{[m_n]}}{\vdots}\tvput*{n}
    }
    $$
    The next step of the maximal-traversal is a jump to the child node $m_i$
    (the node corresponding to the term that would be substituted for $x_i$ if the $\beta$-reduction was performed).
    The traversal has the following form:
    \vspace{0.2cm}
    $$\ldots \rnode{n}{@^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}^{[m_i]}} \cdot \ldots
    \bkptra[ncurv=0.6]{50}{x}{lx}
    \bkptra[ncurv=0.5]{50}{mi}{n}$$

    \item Suppose $n$ is labelled by the ground type variable $y$. This case is impossible since in a traversal
    a node following $y$ must be labelled $\lambda$. In the current case the following node is $\lambda \overline{x}$.

    \item Suppose $n$ is labelled $\psi @$. This means that this occurrence of the variable $\psi$ is substituted by the term
    $\kappa(\lambda \overline{x})$ during the evaluation of the term.
    $$
    \tree{@}
    {
        \tree[levelsep=8ex,linestyle=dotted]{\lambda \psi}
        {
            \pstree[levelsep=8ex]{\TR{\psi @^{[n]}}}
            {
                \tree{\lambda \overline{\eta_1}^{[m_1]}}{\vdots}\tvput*{1}
                \TR[edge=\dedge]{}
                \tree{\lambda \overline{\eta_i}^{[m_i]}}{\vdots}\tvput*{{\tiny i}}
                \TR[edge=\dedge]{}
                \tree{\lambda \overline{\eta_n}^{[m_n]}}{\vdots}\tvput*{n}
            }
        }
        \pstree[levelsep=6ex,linestyle=dotted]{\TR{\lambda \overline{x}}}{\TR{x_i}}
    }
    $$
    Therefore during reduction,
    the occurrence of the variable $x_i$ will be substituted by the term represented by the $i^{th}$ child node of node $\psi @$. Hence
    the traversal looks like this:
    \vspace{0.2cm}
    $$\ldots \rnode{n}{\psi @^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}^{[m_i]}} \cdot \ldots
    \bkptra[ncurv=0.6]{50}{x}{lx}
    \bkptra[ncurv=0.5]{50}{mi}{n}$$
    \end{itemize}
\end{itemize}
\end{dfn}



\begin{property}
\label{proper:pviewtrav_is_path}
(i) Traversals are justified sequence verifying P-visibility.
(ii) The P-view of a traversal is a path from the root to some node in the computation tree.
\end{property}
\todomargin{proof}

\begin{dfn}[Reduced-traversal]
A \emph{reduced-traversal} is a justified sequence of nodes $s$ such that for some traversal $t$:
$$ s \jseq t \upharpoonright \left( \{ r \} \union N_\Sigma \union N_{fv(M)} \right)$$

where $r$ denotes the root of the computation tree, $N_\Sigma$ denotes nodes lablelled $a$ or $f@$ where
$a$ and $f$ are $\Sigma$-constant, $N_{fv(M)}$ denotes nodes lablelled $x$ or $\psi@$ where
$x$ and $\psi$ are variables occuring free in $M$.

We say that $s$ is the reduction of the traversal $t$.
\end{dfn}

In a reduced-traversal there are no node labelled $@$:
nodes are either lambda nodes, nodes labelled $x@$ or $x$
where $x$ is a variable or nodes labelled $f@$ or $f$
where $f$ is a $\Sigma$ constant.
This is because in justified sequences, nodes of type $@$ have no pointer.

\begin{property}[Reduced-traversal and traversal]
\label{proper:redtrav_trav}
Suppose $M$ is in $\beta \eta$-long normal form (i.e. the $\eta$-long normal form of a $\beta$-normal form) then
any reduced-traversal is a traversal.
\end{property}
\todomargin{proof}

\subsection{Correspondence with game semantics}

By representing side-by-side the computation tree and the type arena of a term in $\eta$-normal form we observe
that for each question move of the arena there are corresponding nodes in the computation tree.

\begin{exmp}
Consider the following term $M \equiv \lambda f z . (\lambda g x . f (f x)) (\lambda y. y) z$ of type $(o \typear o) \typear o \typear o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f (f x)) (\lambda y. y) (\lambda .z)$.
The computation tree is:

$$
\tree{\lambda f z}
{ \tree{@}
    {
        \tree{\lambda g x}
            { \tree{f@}{   \tree{\lambda}{ \tree{f@}{  \tree{\lambda}{\TR{x}}} }  }
            }
        \tree{\lambda y}{\TR{y}}
        \tree{\lambda}{\TR{z}}
    }
}
$$

The arena for the type $(o \typear o) \typear o \typear o$ is:
$$\tree{q^1}
{
    \tree{q^3}
        {  \tree{q^4}
                {\TR{a^4_1} \TR{\ldots}}
            \TR{a^3_1} \TR{\ldots} }
    \tree{q^2}
    { \TR{a^2_1} \TR{a^2_2}\TR{\ldots} }
    \TR{a_1} \TR{a_2}\TR{\ldots}
}
$$

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

We now omit the answers moves when we represent the arena.
The arena and the computation tree are represented on the figure below (right and left respectively).
The dashed line defines a relation $\varphi$ from the set of question moves to nodes in the computation tree.
$\varphi$ maps questions to zero or more nodes in the computation tree:
$$
\tree{ \Rnode{root} {\lambda f z w}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}
                { \tree{\Rnode{f}{f@^{[6]}}}{  \tree{\Rnode{lmd}\lambda^{[7]}}{ \tree{\Rnode{f2}{f@^{[8]}}} {\tree{\Rnode{lmd2}\lambda^{[9]}}{\TR{x^{[10]}}}}}  }
                }
            \tree{\lambda y ^{[4]}}{\TR{y}}
            \tree{\lambda ^{[5]}}{\TR{\Rnode{z}z}}
        }
    }
\hspace{3cm}
  \tree[levelsep=12ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
        \TR{\Rnode{q5}q^5}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{<-}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{q2}{z}
\ncline{->}{q3}{f}
\ncline{->}{q4}{lmd}
\ncline{->}{q3}{f2}
\ncline{->}{q4}{lmd2}
$$

Consider the justified sequence of moves $s \in \sem{M}$:
\vspace{0.5cm}
 $$s =
\rnode{q1}{q}^1\
\rnode{q3}{q}^3\
\rnode{q4}{q}^4\
\rnode{q3b}{q}^3\
\rnode{q4b}{q}^4\
\rnode{q2}{q}^2
\bkptrc{q3}{q1}
\bkptrc[ncurv=0.5]{q3b}{q1}
\bkptrc{q4}{q3}
\bkptrc{q4b}{q3b}
\bkptrc[ncurv=0.5]{q2}{q1}
\in \sem{M}$$

There is a corresponding justified sequence of nodes in the computation tree:
\vspace{0.5cm}
$$r =
\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f@}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f@}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=1]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}$$
such that $r_i \in \varphi(s_i)$ for all $i < |s|$.

The sequence $r$ is in fact a reduced-traversal, it is the reduction of the following traversal:
\vspace{1cm}
$$t =
\rnode{q1}{\lambda f z} \cdot
\rnode{n2}{@^{[2]}} \cdot
\rnode{n3}{\lambda g x^{[3]}} \cdot
\rnode{q3}{f@}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f@}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{n8}{x^{[10]}} \cdot
\rnode{n9}{\lambda^{[5]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=0.6]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}
\bkptra[ncurv=0.4]{60}{n3}{n2}
\bkptra[ncurv=0.4]{60}{n8}{n3}
\bkptra[ncurv=0.4]{60}{n9}{n2}
$$

We see on this example that the game semantics and the computation tree are somehow related to each other.
\end{exmp}


Let us now analyze precisely the relationship between the game semantics and the computation tree.

Let $\Gamma \vdash M : A$ be a term in $\eta$-long normal form.
Suppose $(M^{QA},\vdash)$ is the arena $\sem{A}$ where $M^{QA}$ is the set of moves and $\vdash$ is the enabling relation.
$M^Q \subseteq M^{QA}$ denotes the set of question-moves.
We note $(N,E)$ the computation tree $\tau(M)$ where $N$ is the set of nodes and leaves of the tree and $E$ is the parent-child relation.

We give an algorithm computing the partial function $\varphi^{-1} : N \rightarrow M^Q$ which maps
some question-moves to set of nodes in the computation tree.

\begin{dfn}[Relation between question-moves and nodes of the computation tree]
\label{def:phi_procedure}
We start by defining two preliminary procedures.
The procedure $f$ takes two parameters: $n$ is the index number of a
$\lambda$-node in the computation tree and $q$ is a question move of the arena
of $\Gamma \vdash M : A$ such that $q$ and $\kappa(n)$ have the same type.

Similarly we define the procedure $g$ that
takes two parameters: $n$ is the index number of a
$x@$-labelled node or a $x$-labelled node in the computation tree and $q$ is a question move
of the arena of $\Gamma \vdash M : A$ such that $q$ and $x$ have the same type.
\\

\noindent
\begin{description}
\item[\textbf{Procedure} $f(nd,q)$]
    where $nd$ is a $\lambda$-node.

    \begin{itemize}
    \item If $\ord{\kappa(nd)} = 0$ then the term is of ground type therefore
    the game for $M$ is played on the flat arena
    with only one question $q$. Moreover the node $nd$ of the computation tree is labelled with $\lambda$.\\
    \textbf{return} $\{ nd \mapsto q \}$.

    \item $\ord{\kappa(nd)} > 0$. The computation tree and the arena
    have the following form:
    $$ \tree[levelsep=6ex]{ \Rnode{r}\lambda \overline{\xi}  ^{[nd]}}
        {
            \tree[levelsep=6ex]{x@^{[nd+1]}}
            {   \TR{\lambda^{[\ldots]}} \TR{\ldots} \TR{\lambda^{[\ldots]}}
            }
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi} \vdash \kappa(x@^{[nd+1]}) : o$.

    For each of the abstracted variable $\xi_i$ there is a corresponding question move $q_i$ of the same order
    in the arena.  Each free occurrence of the variable $\xi_i$ is mapped to the move $q_i$
    by the procedure $g$.

    $$\mathbf{return} \ \{ nd \mapsto q \}
    \union
    \Union_{\stackrel{i=1..n}{\xi_i^{[k]} \in Desc(nd)}} g ( k, q_i)
    \quad \union \quad
    \Union_{\stackrel{i=1..n}{@\xi_i^{[k]} \in Desc(nd)}} g ( k, q_i)
    $$
    where $Desc(nd)$ is the set of descendants of  node $nd$
    (nodes $m$ such that there is a path from node $nd$ to node $m$ in the computation
    tree).

    \end{itemize}

\item[\textbf{Procedure} $g(nd,q)$]\  \\
The procedure is not defined on $\lambda$-nodes or $@$ nodes.
This is ok since all the calls to $g$ in $f$ are of the type $g(nd,q)$ where $nd$ denotes a $@x$-node or a $x$-node.

\begin{itemize}
\item[case 1] Suppose that $nd$ is labelled with $x$ then we must have $x:0$. \textbf{return}
$\{ nd \mapsto q \}$.

\item[case 2] If $nd$ is labelled with $x@$ then $x:(A_1|\ldots|A_m|o)$.
The computation tree and the arena  have the following form:


    $$\tree[levelsep=6ex]{\Rnode{r}{x@^{[nd]}}}
        {   \tree{\TR{\lambda^{[k_1]}}}{\vdots} \TR{\ldots}
        \tree{\TR{\lambda^{[k_m]}}}{\vdots}
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{\Rnode{q1}{q^1}}{\TR{} \TR{} }
            \tree[linestyle=dotted]{\Rnode{q2}{q^2}}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{\Rnode{qm}{q^m}}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi} \vdash \kappa(x@^{[nd]}) : o$.

    For each of the children node of $nd$
    there is a corresponding question move $q_i$ of the same type
    in the arena.
    $$\mathbf{return} \ \{ nd \mapsto q \} \union
    \Union_{i=1..m} f ( k_i, q_i)
    $$
\end{itemize}
\end{description}

We define $\varphi^{-1}$ as follows:
$$\varphi^{-1} = f(0,q^0)$$
where the index $0$ denotes the root of the computation tree and $q^0$ is the root of the arena
(in the game semantics of simply-typed lambda calculus the arenas have
a single root).
\end{dfn}

The function $\varphi^{-1} : N \rightarrow M^Q$ and its inverse
$\varphi : M^Q \rightarrow \mathcal{P}(N)$ are partial function.
Moreover $\varphi$ relates player O questions to $\lambda$-nodes
and player P questions to $x @$-nodes or $x$-nodes where $x$ is a variable.

\begin{property}[$\varphi^{-1}$ conserves order]
\label{proper:phi_conserve_order}
$\varphi^{-1}$ maps nodes of a given order to moves of the same order.
\end{property}


The function $\varphi^{-1}$ is also defined on justified sequences: suppose $t$
is a justified sequences of nodes $t = t_0 t_1 \ldots$ then $\varphi^{-1}(t)$ denotes
the following justified sequence of question-moves of the arena $\sem{A}$:
$$\varphi^{-1}(t) = \varphi^{-1}(t_0)\ \varphi^{-1}(t_1)\  \varphi^{-1}(t_2) \ldots$$
where the pointers of the justified sequence of move $\varphi^{-1}(t)$ are defined to be exactly those
of the justified sequences of nodes $t$.

\begin{dfn}[Question-move filtering]
Suppose $s$ is a justified sequence of moves then we note $\tilde{s}$
the subsequence of $s$ consisting of question-moves only:
\begin{eqnarray*}
\tilde{} &: L_A &\longrightarrow (M^Q)^* \\
& s &\longmapsto \tilde{s} = s \upharpoonright M^Q
\end{eqnarray*}
where $M^Q$ denotes the set of question-moves.
$\tilde{s}$ is also a justified sequence of move (there is no dangling pointer since questions-moves points to other question-moves).
If $s = u\upharpoonright A,B$ then clearly $\tilde{s} = \tilde{u} \upharpoonright A,B$.
\end{dfn}

\begin{property} Let $s$ be a justified sequence of moves. Then
\label{proper:tildepview}
$$\widetilde{\pview{s}} = \pview{\tilde{s}}$$
\end{property}
The proof is an easy induction.


\begin{prop}[Relation between game semantics and reduced-traversals]
\label{prop:rel_gamesem_redtrav_closed}
Let $\emptyset \vdash M : A$ be a closed term.
Let $r$ denotes the root of $\tau(M)$. If $s$ is a justified sequence of moves such
that $s \in \sem{\Gamma \vdash M:A}$ then there is a reduced-traversal of nodes of $\tau(M)$
$t = n_0 n_1 \ldots$ such that:
 $$\tilde{s} \jseq  \varphi_M^{-1} (t)$$
\end{prop}
\begin{proof}
Let us assume that $M$ is already in $\eta$-long normal form.
Let $s$ be as justified sequence of moves in $\sem{M}$.

We proceed by induction on the height of of
the tree $\tau(M)$ and by case analysis on the structure of the term.

\begin{itemize}
  \item (variable) $M = x$. This case does not happen since $M$ is a closed term.

    \item (application) The term $M$ is of the form $\emptyset \vdash N_0 N_1 \ldots N_p : o$ where $N_0$ is not
    a variable (since $M$ is closed) and:
    \begin{eqnarray*}
    \emptyset &\vdash& N_0 : (A_1,\ldots,A_p,o)\\
    \emptyset &\vdash& N_i : A_i \mbox{ for } i \in 1..p
    \end{eqnarray*}

    The tree $\tau(M)$ has the following form:
    $$ \tree[levelsep=6ex]{\lambda}
        { \tree[levelsep=6ex]{@^{[1]}}
            {   \TR{\tau(N_0)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$

    We have:
    $$\sem{M} = \sem{\emptyset \vdash N_0 N_1 \ldots N_p : o} = \overbrace{\langle \sem{\emptyset \vdash N_0}, \ldots, \sem{\emptyset \vdash N_p} \rangle}^\sigma ; ev_{A_1,\ldots,A_p,o}$$
    with $\sigma : \textbf{1} \longrightarrow B$ and $ev_{A_1,\ldots,A_p,o} : B \longrightarrow \sem{o}$ where
    $$ B = \sem{(A_1,\ldots,A_p,o)} \times \sem{A_1} \times \ldots \times \sem{A_p} $$

    Since $s \in \sem{M} = \sem{\emptyset \vdash N_0 N_1 \ldots N_p : o}$ we have:
    \begin{equation*}
        s = u \upharpoonright \textbf{1},\sem{o} = u \upharpoonright \sem{o}
    \end{equation*}
    for some $u \in \sigma \parallel ev_{A_1,\ldots,A_p,o}$.

    Let $q_C$ denotes the only question of the arena $\sem{o}$ then $s \in \{ q_C \}^*$.
    We construct the reduced-traversal $t$ by replacing the moves $q_C$ in $\tilde{s}$ by the root node
    $\lambda \overline{\xi}$:
    $$ t \jseq  \tilde{s} [\lambda \overline{\xi} / q_C].$$

    Since $\tilde{s} \in \{ q_C \}^*$ and $\varphi^{-1}_{M}(\lambda \overline{\xi}) = q_C$, we have:
    $$\varphi^{-1}_{M} (t) = \varphi^{-1}_{M}( \tilde{s} [\lambda \overline{\xi} / q_C] )
        = \tilde{s} [\lambda \overline{\xi} / q_C] [q_C / \lambda \overline{\xi}]
        = \tilde{s}$$
    Since all the moves in $\tilde{s}$ are initial, they do not have pointers. Hence
    $$ \varphi^{-1}_{M} (t) \jseq \tilde{s} $$


    \item (variable-abstraction)
        $M = \lambda \overline{\xi} . x$.  Then $x$ must be of ground type $o$ and since $M$ is closed
        $x = \xi_i \in \overline{\xi}$ .
        Then $\tau(M)$ has the following shape:
        $$ \tree[levelsep=6ex]{ \lambda \overline{\xi}^{[0]} }{\TR{x^{[1]}}}$$
        The arena is of the following form (only question moves are represented):
        $$ \tree{ q }
        {   \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
            \TR{q^x}
        }$$
        where $q^x$ denotes the root of the flat arena $\sem{o}$.
        We have:
        $$ \sem{M} = \sem{\emptyset \vdash \lambda \overline{\xi} . \xi_i} = \Lambda^n(\sem{\overline{\xi} \vdash  \xi_i}) = \Lambda^n(\pi_i)$$
        where $\pi_i$ denotes the $i$-th projection

        Therefore the only question-moves that can occur in $s \in \sem{M}$ are the initial question $q$ and the question $q_x$.
        We take $t \jseq \tilde{s} [0/q, 1/q^x]$ which is a valid justified sequence of nodes since
        node $1$ ($x$) is bound by node $0$ ($\lambda \overline{\xi}$) and a valid
        reduced-traversal. Clearly we have $\varphi^{-1}(t) \jseq \tilde{s}$.

    \item (application-abstraction) The term $M$ is of the form $M = \lambda \overline{\xi} . x N_1 \ldots N_p$ where
    \begin{eqnarray*}
    \emptyset &\vdash& M : (X_1,\ldots,X_n,o) \\
    \Gamma &\vdash& x N_1 \ldots N_p : o \\
    \Gamma &\vdash& x : (A_1,\ldots,A_p,o) \\
    \Gamma &\vdash& N_i : A_i \mbox{ for } i \in 1..p \\
    \Gamma &=& \overline{\xi} : \overline{X}
    \end{eqnarray*}

    The tree $\tau(M)$ has the following form:
    $$ \tree[levelsep=6ex]{\lambda \overline{\xi}^{[0]}}
        { \tree[levelsep=6ex]{x @^{[1]}}
            {   \TR{\tau(N_0)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$
    where $x \in \overline{\xi}$ (since $M$ is a closed term).

    We have:
    \begin{eqnarray*}
    \sem{ \emptyset \vdash M} &=& \Lambda^n( \sem{\Gamma \vdash x N_1 \ldots N_p : o} ) \\
    \sem{\Gamma \vdash x N_1 \ldots N_p : o} &=& \overbrace{\langle \sem{\Gamma \vdash N_0}, \ldots, \sem{\Gamma \vdash N_p} \rangle}^\sigma ; ev_{A_1,\ldots,A_p,o}
    \end{eqnarray*}

    with $\sigma : A \longrightarrow B$ and $ev_{A_1,\ldots,A_p,o} : B \longrightarrow C$, the arena being defined as follows:
    \begin{eqnarray*}
        A &=& \sem{\Gamma} = \sem{X_1} \times \ldots \times \sem{X_n}\\
        B &=& H_0 \times H_1 \times \ldots \times H_p \\
        C &=& \sem{o}\\
        H_0 &=& \sem{(A_1,\ldots,A_p,o)} \\
        H_j &=& \sem{A_j} \mbox{ for }j \in 1..p
    \end{eqnarray*}

    Since $s \in \sem{M}$ we must have $s\in \sem{\Gamma \vdash x N_1 \ldots N_p : o}$ therefore:
    \begin{equation}
        s = u \upharpoonright A, C \label{eq:def_s}
    \end{equation}
    for some $u \in \sigma \parallel ev_{A_1,\ldots,A_p,o}$, more precisely for some $u$ such that:
    \begin{eqnarray}
        u &\in& int(A,B,C) \nonumber \\
        w = u \upharpoonright A,B & \in& \sigma       \label{eq:def_w}\\
        u \upharpoonright B,C & \in & ev_{A_1,\ldots,A_p,o} \nonumber
    \end{eqnarray}

    $w \in \sigma$ implies that for some $j \in 1..p$:
    \begin{eqnarray}
        z = w \upharpoonright A, H_j &\in& \sem{\Gamma \vdash N_j}  \label{eq:def_z} \\
        \mbox{ and for every } k\neq j &:& w \upharpoonright H_k = \epsilon \label{eq:b}
    \end{eqnarray}

    We cannot use the induction hypothesis on $\Gamma \vdash N_j : A_j$ because it is not a closed terms!
    We therefore consider the closed term $N'_j = \lambda \overline{\xi} . N_j$:
        $$\emptyset \vdash N'_j : (X_1, \ldots, X_n,A_j)$$

    We have $z \in \sem{N_j} = \Lambda^n(\sem{\Gamma \vdash N_j})$. But $\Lambda^n(\sem{\Gamma \vdash N_j})$
    and $\sem{\Gamma \vdash N_j}$ are the same strategies up to an isomorphism that
    retaggs the moves. Hence the equation \ref{eq:def_z} gives $z \in \sem{N'_j}$ where $N'_j$ is a closed term. Since
    the term $N'_j$ has the same height as the term $N_j$ which is strictly smaller than the height
    of the term $M$, we can use the induction hypothesis on $N'_j$:
    there is a reduced-traversal $t'$ of the tree $\tau(N'_j)$
    such that $\varphi^{-1}_{N'_j}(t') \jseq \tilde{z}$.




    From equation \ref{eq:def_w} we have:
    \begin{equation}
        \tilde{w} = \tilde{u} \upharpoonright A,B
        \label{eq:def_wtilde}
    \end{equation}

    From equation \ref{eq:b}, for $k\neq j : w \upharpoonright H_k = \epsilon$. Since $B =
    H_0 \times H_1 \times \ldots \times H_p$ this implies that moves in $w$ hereditarily justified by moves in $B$ are in fact all
    hereditarily justified by moves in $H_j$.  Hence $z = w \upharpoonright A, H_j = w \upharpoonright A, B$ and:
    \begin{eqnarray*}
            \tilde{z} =& \tilde{w} \upharpoonright A,B \\
            =& (\tilde{u} \upharpoonright A,B) \upharpoonright A,B &\mbox{(by eq \ref{eq:def_wtilde})} \\
            =& \tilde{u} \upharpoonright A,B \\
            =& \tilde{w}  & \mbox{(by eq \ref{eq:def_wtilde})}
    \end{eqnarray*}


    Hence $\varphi^{-1}_{N'_j}(t') \jseq \tilde{w}$.


    For $i \in 1..p$, the tree $\tau(N_i)$ (left) and $\tau(N'_i)$ (right) have the following form:
    $$ \tree[levelsep=6ex]{ \lambda \overline{y_i}^{[n_i]} }
    { \tree[levelsep=6ex,linestyle=dotted]{}
        {   \TR{} \TR{} \TR{} }}
    \hspace{2cm}
    \tree[levelsep=6ex]{ \lambda \overline{\xi}\  \overline{y_i}^{[n_i]} }
    { \tree[levelsep=6ex,linestyle=dotted]{}
        {   \TR{} \TR{} \TR{} }}
    $$
    where only the label of the root differs between the two trees.

    From the justified sequence $t'$ of $\tau(N'_j)$ we construct the justified sequence $t$ of
    $\tau(M)$ by mapping the nodes of $\tau(N'_j)$ to the corresponding node in the subtree $\tau(N_j)$
    of $\tau(M)$. Moreover we change all the pointers going from a node $\xi_i$ or $\xi_i @$ to the root node of $\tau(N'_j)$
    into a pointer starting from the corresponding node $\xi_i$ or $\xi_i @$ to the root of the tree $\tau(M)$.
    $t$ is a valid justified sequence of nodes of $\tau(M)$ since the nodes labelled $\xi_i$ and $\xi_i @$
    are bound by the root $\lambda \overline{\xi}$.

    The function $\varphi^{-1} : Nodes \rightarrow M^Q$ has been defined by an inductive procedure
    guaranteeing that $\varphi^{-1}_{N_j}$ is equal to the function $\varphi^{-1}_{M}$ restricted to
    the set of nodes of $\tau(N_j)$. Hence we have:
    \begin{equation}
    \varphi^{-1}_{M}(t) \jseq \tilde{w}. \label{eq:def_t}
    \end{equation}

    Let $q_C$ denotes the only question of the arena $C = \sem{o}$.
    We can construct from $t$ the justified sequence $t^\ast$ as follows:
    we insert the root node $\lambda \overline{\xi}$ at the positions where the move $q_C$ occurs in $\tilde{u}$.
    Since $\varphi^{-1}_{M}(\lambda \overline{\xi}) = q_C$, we have:
    $$\varphi^{-1}_{M}(t^\ast) = \tilde{u}$$

    Now we transfer links from $\tilde{u}$ to $t^\ast$: for each
    move $\tilde{u}_k$ pointing to $\tilde{u}_i = q_C$ in $\tilde{u}$ for some $0 \leq i \leq k$,
    we add a pointer in $t^\ast$ going from $t^\ast_k$ to $t^\ast_i = \lambda \overline{\xi}$.

    Then the pointers of the traversal $t^\ast$ and the sequence of move $\tilde{u}$ are the same and we obtain:
    \begin{equation}
    \varphi^{-1}_{M}(t^\ast) \jseq \tilde{u}. \label{eq:def_tstar}
    \end{equation}

    We need to ensure that the sequence $t^\ast$ is a valid justified sequence of $\tau(M)$.
    This requires us to check the validity of the the pointers introduced in $t^\ast$.
    Suppose $u_k$ points to $q_C$ in $\tilde{u}$ then $u_k$ belongs to the arena $A$. More precisely it is one
    of the root $q^1 \ldots q^n$ of the arena $A$. Therefore $u_k$ must belong to the sequence $\tilde{w}$ and
    for some $r \geq 0$, $u_k = \phi^{-1}_{N'_j}(t'_r)$ and $t^\ast_k = t'_r$.

    The arena of the term $\emptyset \vdash N'_j = \lambda \overline{\xi} . N_j$ is of the following form (only question moves are represented):
        $$ \tree{ q }
        {   \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
        }$$
    We observe from the definition of $\phi^{-1}_{N'_j}$ that the
    only node that are mapped to the question  $q^1 \ldots q^n$ are labelled $\xi_i$ or $\xi_i @$ for some $i\in 1..n$.
    Consequently $t^\ast_k = \xi_i$ and the node $t^\ast_k$ is bound by the node $\lambda \overline{\xi}$.
    Hence the added pointer is indeed valid.\\


    For any justified sequence of nodes $t$ we define the justified sequence of nodes $t \upharpoonright A,C$
    to be the subsequence of $t$ constituted of nodes $n$
    verifying $\varphi^{-1}_M(n) \in A \union C$ together with the same
    pointers as the justified sequence of move $\varphi^{-1}_M(t) \upharpoonright A,C$ (here the
    operator $\upharpoonright$ denotes the filtering operator
    defined on justified sequence of moves).

    The effect of this transformation is to remove from $t^\ast$ all the elements at positions $i$ such that $\tilde{u}_i \in B$.
    We obtain a justified sequence of nodes $t^\dagger = t^\ast \upharpoonright A,C$
    verifying
        $$\varphi^{-1}_{M}(t^\dagger) \jseq \tilde{s}$$

    $t^\dagger$ is also a reduced-traversal of $\tau(M)$.

    \textbf{Example}: Let us illustrate each step of the demonstration on a short example.
        For clarity only some relevant pointers are specified in the following justified sequences.
    $$
    \xymatrix @=3pt{
        & \tilde{u} &=& q_C & m_1 & q_C & m_3 & m_4 & q_C & m_6 & m_7 & q_C & \ldots \\
        & &\in& C & B & C & A & A & C & B & B & C & \ldots \\
        \mbox{ (equation \ref{eq:def_s})} & \tilde{s} &=& q_C & & q_C & m_3  \ar@/_1pc/[l] & m_4 & q_C &  & & q_C & \ldots \\
        \mbox{ (equation \ref{eq:def_w})} & \tilde{w}  &=&  & m_1 &  & m_3 & m_4 &  & m_6 & m_7 &  & \ldots  \\ \\ \\
        \mbox{ (equation \ref{eq:def_t})} & t &=&  & n_1\ar[uuu]^{\varphi^{-1}_{N'_j}} &  & n_3 \ar[uuu] & n_4\ar[uuu] & & n_6\ar[uuu] & n_7\ar[uuu] &  & \ldots \\ \\
        & \tilde{u}  &=& q_C & m_1 & q_C & m_3 & m_4 & q_C & m_6 & m_7 & q_C & \ldots  \\ \\ \\
        \mbox{ (equation \ref{eq:def_tstar})} & t^\ast &=& \lambda \ar@{=>}[uuu]^{\varphi^{-1}_{M}} & n_1\ar[uuu]^{\varphi^{-1}_{N'_j}} & \lambda\ar@{=>}[uuu] & n_3 \ar[uuu] \ar@/_1pc/[l] & n_4\ar[uuu] & \lambda\ar@{=>}[uuu] & n_6\ar[uuu] & n_7\ar[uuu] & \lambda\ar@{=>}[uuu] & \ldots \\
        t^\ast\upharpoonright A,C =& t^\dagger &=& \lambda &  & \lambda & n_3\ar@/_1pc/[l] & n_4 & \lambda & &  & \lambda & \ldots \\
        }
    $$
    Note that there is only one question $q_C$ in the arena $C$ therefore $m_2 = m_5 = m_8 = q_C$.
    It is easy to check that $\varphi^{-1}(t') \jseq \tilde{s}$
\end{itemize}
\end{proof}

The previous proposition has an equivalent for open terms. Its proof is omitted here. It
follows the same step as for the case of closed terms.
\begin{prop}[Relation between game semantics and reduced-traversals of open terms]
\label{prop:rel_gamesem_redtrav_opened}
Suppose $\Gamma \vdash M : A$. Let $r$ denotes the root of $\tau(M)$. If $s$ is a justified sequence of moves such
that $s \in \sem{\Gamma \vdash M:A}$ then there is a reduced-traversal of nodes of $\tau(M)$
$t = n_0 n_1 \ldots$ such that:
 $$\tilde{s} \upharpoonright \sem{A} \jseq  \varphi^{-1}_M (t \upharpoonright \{r \})$$
and
$$\forall i \geq 0 . \tilde{s}_i = \varphi^{-1}_M(t_i) \not \in \sem{A}
\implies \left\{
        \begin{array}{ll}
            t_i = x \mbox{ or } t_i = x@, \hbox{where } x \in \Gamma \\
            \varphi^{-1}_M(t \upharpoonright \{t_i\}) \jseq \tilde{s} \upharpoonright \{ \varphi^{-1}_M(t_i) \}
        \end{array}
        \right.
$$
\end{prop}

\begin{property}
\label{proper:phi_pview}
Suppose $\varphi^{-1}(t) \jseq s$ where $s$ is a justified sequence of moves and
$t$ is a justified sequence of nodes then
\begin{itemize}
\item (i) the P-view of $\tilde{s}$ and the P-view of $t$ are computed
similarly: the set of indices of elements that must be removed from both sequences
in order to obtain their P-view is the same.
\item (ii) $\tilde{s}$ and $\tilde{t}$ have the same pointers.
\end{itemize}
\end{property}
\begin{proof}
(i) By definition of $\varphi^{-1}$, $t$ and $\varphi^{-1}(t)$ have the same pointers. Moreover,
$\varphi^{-1}$ maps lambda nodes to O-question and non-lambda nodes to P-question. Therefore the computations of the
P-view of the sequence of moves and P-view of the sequence of nodes follow the same steps.
(ii) is a consequence of (i).
\end{proof}

\subsection{Pointers in the game semantics of safe terms are recoverable}

The computation tree of safe terms verifies a property called regularity:
\begin{property}[Computation tree of safe terms are regular]
\label{proper:regularity}
If $M$ is a safe term then any node of the computation tree $\tau(M)$ labelled $x$ or $x@$ where
$x$ is a variable bound in $M$ is bound by the first $\lambda$-node in the path to the root that has
order greater or equal to $\ord{x}$.
\end{property}
\begin{proof}
For safe terms, the first $\lambda$-node $\lambda \overline{\xi}$ in the path to the root such that
$x \in \overline{\xi}$ is also the first $\lambda$-node whose order is greater or equal to $\ord{x}$.
\end{proof}


\begin{prop}
The pointers in the game semantics of safe terms are
uniquely recoverable.
\end{prop}

\begin{proof}
Let $\Gamma \vdash M : A$ be an opened safe term where $\Gamma = y_1:Y_1, \ldots y_n:Y_n$.
We assume that $M$ is in $\beta \eta$-long normal form : the $\eta$-long normal form of the $\beta$-normal form.
It is a safe assumption since safety is preserved by $\eta$-expansion and $\beta$-reduction.

Consider a justified sequence of move $s \in \sem{\Gamma \vdash M}$. Firstly,
we remark that the pointers for O and P answer moves in $s$ can all be
recovered thanks to the well-bracketing condition.

Let us prove by induction that the pointers for question moves can be recovered.

\textbf{Base case}: if $s \in \sem{M}$ where $|s| \leq 1$ then there is no pointer to recover.

\textbf{Step case}: suppose $s\cdot q \in \sem{M}$.

Consider the closed term $M'  = \lambda \overline{y} . M$.
Up to a retagging of the moves, the justified sequence of moves $s \cdot q$ belongs to the strategy
$\sem{\vdash \lambda \overline{y} . M} = \Lambda^n(\sem{\Gamma \vdash M})$.

Proposition \ref{prop:rel_gamesem_redtrav_closed} tells us that
there is a reduced-traversal $t \cdot n$ of $\tau(M')$ such that:
$$\varphi^{-1}_{M'}(t \cdot n) \jseq \tilde{s} \cdot q.$$

\begin{itemize}
\item Suppose $q$ is a P-move.

By the induction hypothesis, the pointers of $s$ have been recovered therefore we can compute the P-view $\pview{s}$.
$q$ must point to a question in the P-view at that point therefore it point to $\widetilde{\pview{s}} = \pview{\tilde{s}}$
(property \ref{proper:tildepview}).


By property \ref{proper:phi_pview}, the P-view of $\tilde{s}$ and the P-view of $t$ are computed
similarly and have the same pointers. Hence the link
of $n$ and the link of $q$ points to the same position in
the justified sequence $\pview{t}$ and $\pview{\tilde{s}}$ respectively.

Since $M'$ is in $\beta \eta$-long normal form, the reduced-traversal $t$ is a traversal
(property \ref{proper:redtrav_trav}).
By property \ref{proper:pviewtrav_is_path}, $\pview{t}$ is a path from the root to some node
in the computation tree $\tau(M)$.

The regularity of $\tau(M)$ (property \ref{proper:regularity}) implies that $n$ points to the
the first $\lambda$-node in the path to the root that has order greater or equal to $\ord{x}$.
Hence $n$ points to the the first $\lambda$-node in $\pview{t}$ that
has order greater or equal to $\ord{x}$.

But $\varphi^{-1}$ maps nodes of a given order to moves of the same order (property \ref{proper:phi_conserve_order}),
therefore $q$ also points to the first move in $\pview{\tilde{s}}$ whose
order is greater or equal to $\ord{q}$.


\item Suppose $q$ is a O-move.

Then $q$ points to the last move in the O-view of $\tilde{s}$ having an order strictly greater than $\ord{q}$.

\todomargin{not finished}

%For O-question, the justification pointer always points to its
%parent node in the computation tree.


\end{itemize}

\end{proof}
