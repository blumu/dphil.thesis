\def\cmptre#1{\tau(#1)}
\def\aux#1{\lceil #1\rceil}
\def\nf#1{\eta_{\sf nf}(#1)}

\section{Game semantics of safe $\lambda$-terms}

In this section we will prove that the safety condition
of section \ref{sec:safe_alt} leads to a pointer economy in the game
semantics: for safe $\lambda$-terms the pointers from the game semantics can be reconstructed uniquely from the moves of
the play.

The example of section \ref{subsec:ptrless_strat} gives the intuition.
Remember that in order to distinguish the terms $M_1$ and $M_2$,
we introduced pointers in strategies. In the safe $\lambda$-calculus
this ambiguity disappears because $M_2$ is not a safe term. Indeed, in the
sub-term $f (\lambda y . x)$, the free variable $x$
has the same order as $y$ but $x$ is not abstracted together
with $y$.


%\begin{enumerate}
%\item
%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.
%
%\item
%Is there any unsafe $\beta$-normal form whose game semantics is a
%strategy where pointers can be recovered?
%\end{enumerate}






\subsection{$\eta$-long normal form}

The $\eta$-expansion of $M: A\typear B$ is defined to be the term $\lambda x . M x : A\typear B$ where $x:A$ is a fresh variable.
It is easy to check that if $M$ is safe then $\lambda x . M x$ is also safe.

Consider the term $M : (A_1,\ldots,A_n,o)$, it can be expanded in several steps into
$\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots \varphi_l$
where the $\varphi_i:A_i$ are fresh variables.

The $\eta$-normal form of a term is obtained by hereditarily $\eta$-expanding every sub-term occurring
at an operand position:

\begin{dfn}[$\eta$-long normal form]
A term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a
constant or an abstraction.

The $\eta$-long normal form of a term $M$ is denoted $\aux{M}$ and
is defined as follow:
\begin{eqnarray*}
\aux{x s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{x s_1 \ldots s_m : o} &=& \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \\
\aux{(\lambda x . s_0) s_1 \ldots s_m } &=& (\lambda x . \aux{s_0}) \aux{s_1} \aux{s_2} \ldots \aux{s_m}
\end{eqnarray*}
where $m \geq 0$ and $x$ is either a variable or a constant.
\end{dfn}

The $\eta$-long normal form appeared in \citep{DBLP:journals/tcs/JensenP76}
under the name \emph{long reduced form}
and in \citep{DBLP:journals/tcs/Huet75}
under the name \emph{$\eta$-normal form}. It was then investigated in \citep{huet76}
under the name \emph{extensional form}.



Terms in $\eta$-long normal form can be represented by a tree
defined formally by induction on the structure of the term in $\eta$-long normal form as follow:

\begin{dfn}[Computation tree]
The computation tree associated to the term $s$ is noted
$\cmptre{s}$. It is obtained by applying the following rules
inductively \emph{on the $\eta$-long normal form} of $s$. In the
following $x$ is either a variable or a constant.
\begin{itemize}
\item the tree for $\lambda x_1 \ldots x_n. M$ where $M$ is not an abstraction is:
$$ \cmptre{\lambda x_1 \ldots x_n . M} =
  \pstree[levelsep=4ex]
    { \TR{\lambda x_1 \ldots x_n} }
    { \SubTree{\cmptre{M}}
    }
$$


\item the tree for $x s_1 \ldots s_n$ is:
$$ \cmptre{ x s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{x @} }
    { \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$

\item the tree for $x$ is the single leaf $x$.

\item the tree for $(\lambda x.s_0) s_1 \ldots s_n$ is:
$$ \cmptre{(\lambda x.s_0) s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{@} }
    {
    \SubTree{\cmptre{\lambda x.s_0}}    \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$
\end{itemize}
\end{dfn}

Example: if $x$ is a variable or a constant then
$ \cmptre{\lambda . x} =
  \pstree[levelsep=3ex]
    { \TR{\lambda } }
    { \TR{x}
    }$

The nodes of the tree are of three kinds: lambda node labeled
 $\lambda \overline{x}$, application node labeled $@$ or
operator-application nodes labeled $x @$ where the operator $x$ is
either a variable or a constant. The leaves of the tree are
variables or constants.

A sub-tree of the computation tree represents a $\lambda$-term. We
define the map $\kappa : N \rightarrow \mathcal{T}$ where $N$
denotes the set of nodes and leaves of the computation tree
$\tau(s)$ and $\mathcal{T}$ denotes the set of $\lambda$-terms.
$\kappa$ associates to any node $n$ of the tree the $\lambda$-term
$\kappa(n)$ that is represented by the sub-tree of $\tau(s)$ rooted
at $n$. In particular if $r$ is the root of the tree $\tau(s)$ then
$\kappa(s) = \aux{s}$.



Consider the computation tree $\tau(s)$ of a term $s$ in $\eta$-long normal form. Then:
\begin{itemize}
\item It is easy to check nodes or leaves at even level are abstraction
node and the odd level nodes are either application nodes,
operator-application nodes, variable or constant (the root of the
tree being at level $0$).

\item Suppose that a variable $x$ occurs in $s$. The corresponding node in the tree has of one of the two following forms:
    \begin{itemize}
    \item $ \pstree[levelsep=3ex]
        { \TR{\lambda } }
        { \TR{x}
        }$ where $\ord{x} = 0$

    \item $ \pstree[levelsep=3ex]
                { \TR{x @} }
                { \TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
        $ where $\ord{x} > 0$ and $x:(A_1,\ldots,A_p,o)$
    \end{itemize}

\item    Moreover for any abstraction node
        $ \pstree[levelsep=4ex]
            { \TR{\lambda \overline{\varphi}} }
            { \pstree[levelsep=3ex]
                {\TR{@^{[n]}}}
                {\TR{\lambda \overline{\xi_1}} \ldots \TR{\lambda \overline{\xi_p}}}
            }
        $
    we have $\ord{\kappa(@^{[n]})}=0$

\end{itemize}

\subsubsection{Pointers and justified sequence of nodes}
We introduce pointer in the computation tree: a node $n$ labeled
with the variable $x$ points to a lambda node $m$ labeled $\lambda
\overline{\varphi}$ if and only if the variable $x$ is bound in
$\kappa(m)$ by the abstraction $\lambda \overline{\varphi}$. In that
case we say that the node $n$ is bound by $m$. Additionally a lambda node points to its parent node.

We call \emph{justified sequence of nodes} any sequence of nodes of the computation tree together
with links as defined above.

\subsection{Correspondence with game semantics}

By observing side-by-side the computation tree and the type arena of a term in $\eta$-normal form it becomes clear that
we can map each question move of the arena to a set of nodes in the computation tree.


\begin{exmp}
Consider the following term $M \equiv \lambda f z . (\lambda g x . f (f x)) (\lambda y. y) z$ of type $(o \typear o) \typear o \typear o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f (f x)) (\lambda y. y) (\lambda .z)$.
The computation tree is:

$$
\tree{\lambda f z}
{ \tree{@}
    {
        \tree{\lambda g x}
            { \tree{f@}{   \tree{\lambda}{ \tree{f@}{  \tree{\lambda}{\TR{x}}} }  }
            }
        \tree{\lambda y}{\TR{y}}
        \tree{\lambda}{\TR{z}}
    }
}
$$

The arena for the type $(o \typear o) \typear o \typear o$ is:
$$\tree{q^1}
{
    \tree{q^3}
        {  \tree{q^4}
                {\TR{a^4_1} \TR{\ldots}}
            \TR{a^3_1} \TR{\ldots} }
    \tree{q^2}
    { \TR{a^2_1} \TR{a^2_2}\TR{\ldots} }
    \TR{a_1} \TR{a_2}\TR{\ldots}
}
$$

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

We now omit the answers moves when we represent the arena.
The arena is represented on the right and the computation tree on the left.

The dashed line defines a relation $\varphi$ from the set of question moves to nodes in the computation tree.
$\varphi$ maps each question to one or more nodes in the computation tree:
$$
\tree{ \Rnode{root} {\lambda f z}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}
                { \tree{\Rnode{f}{f@^{[6]}}}{  \tree{\Rnode{lmd}\lambda^{[7]}}{ \tree{\Rnode{f2}{f@^{[8]}}} {\tree{\Rnode{lmd2}\lambda^{[9]}}{\TR{x^{[10]}}}}}  }
                }
            \tree{\lambda y ^{[4]}}{\TR{y}}
            \tree{\lambda ^{[5]}}{\TR{\Rnode{z}z}}
        }
    }
\hspace{3cm}
  \tree[levelsep=12ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{<-}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{q2}{z}
\ncline{->}{q3}{f}
\ncline{->}{q4}{lmd}
\ncline{->}{q3}{f2}
\ncline{->}{q4}{lmd2}
$$

Consider the justified sequence of moves $s \in \sem{M}$:
\vspace{0.5cm}
 $$s =
\rnode{q1}{q}^1\
\rnode{q3}{q}^3\
\rnode{q4}{q}^4\
\rnode{q3b}{q}^3\
\rnode{q4b}{q}^4\
\rnode{q2}{q}^2
\bkptrc{q3}{q1}
\bkptrc[ncurv=0.5]{q3b}{q1}
\bkptrc{q4}{q3}
\bkptrc{q4b}{q3b}
\bkptrc[ncurv=0.5]{q2}{q1}
\in \sem{M}$$

There is a corresponding justified sequence of nodes in the computation tree:
\vspace{0.5cm}
$$t =
\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f@}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f@}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=1]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}$$
such that $t_i = \varphi(s_i)$ for all $i < |s|$.

We see on this example that the game semantics and the computation tree are somehow related to each other.
\end{exmp}

Let us now define precisely the relationship between game semantics and computation tree.

First we define the map $\varphi$ that associate a set of nodes in the computation tree to any
question-move of the game semantics of the term.

\begin{dfn}[Question move-nodes relationship]
Let $\Gamma \vdash M : A$ be a term in $\eta$-long normal form.
Suppose $(M,\vdash)$ is the arena $\sem{A}$ where $M$ is the set of moves and $\vdash$ is the enabling relation.
We note $(N,E)$ the computation tree $\tau(M)$ where $N$ is the set of nodes and leaves of the tree and $E$ is the parent-child relation.

We define a map $\varphi$

\end{dfn}

Procedure to compute $\varphi$:
We give an algorithm to compute $\varphi^{-1} : N \rightarrow \mathcal{T}$ from which $\varphi$ can then be obtained.

Consider a term $\Gamma \vdash M : A$.
\begin{itemize}
\item[step 1] $\varphi^{-1} \leftarrow \emptyset$
\item[step 2]

Suppose that $A = o$ then the term is of ground type therefore the game for $M$ is played on the flat arena
with only one question $q$. The root $r$ of the computation tree is labelled with $\lambda$.\\
\textbf{Return} $\varphi^{-1} = \{ r \mapsto q \}$.

Suppose that $\ord{A} > 0$ then the computation tree and the arena have the following form:
$$ \tree[levelsep=6ex]{ \lambda \overline{\xi}_n  ^{[-1]}}
     {
        \tree[levelsep=6ex]{@^{[0]}}
        {   \TR{\lambda^{[1]}} \TR{\ldots} \TR{\lambda^{[n]}}
        }
    }
\hspace{3cm}
  \tree{ \Rnode{q1}q^0 }
    {
        \tree{q^1}{\TR{} \TR{\ldots} }
        \tree{q^2}{\TR{} \TR{\ldots} }
        \TR{\ldots}
        \tree{q^n}{\TR{} \TR{\ldots} }
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{<-}{root}{q1}
\ncarc{->}{q2}{z}
\ncline{->}{q3}{f}
\ncline{->}{q4}{lmd}
\ncline{->}{q3}{f2}
\ncline{->}{q4}{lmd2}
$$

such that $\Gamma, \overline{\xi}_n \vdash \kappa(@^{[0]}) : o$.

$\varphi^{-1} \leftarrow \{ \lambda \overline{\xi}_n  ^{[-1]} \mapsto q^0 \}
 \union \{ n \mapsto q^i |\ n \mbox{ is a node labelled by $\xi_i$ for some $i \in 1..n$} \}$

\end{itemize}



This relation from question moves to tree nodes is such that player O questions are associated to $\lambda$-nodes
and player P questions are associated to nodes of type $x @$ or $x$ where $x$ is variable or a constant.


\todomargin{to finish}

\subsection{Pointers in the game semantics of safe terms are recoverable}

We claim that the pointers in the game semantics of a safe term are
uniquely recoverable.

Let $M$ be a safe term, we consider its $\eta$-long normal form $\aux{M}$.
$\aux{M}$ is also safe because safety is preserved by $\eta$-expansion.


\todomargin{rework this paragraph!}
The term can be represented by a computation tree: nodes at even
depth (starting at level 0) correspond to $\lambda$ and nodes at odd
length corresponds to either application $@$, variable $x$ or
variable followed by an application $f@$. A $\lambda$ node
represented consecutive abstraction of variables.

There are justification pointers going upward from variable
occurrences to their bindings.

In the game semantics of the term $M$, the pointers for O and P
answers can be recovered by using the well-bracketing condition.

For O-question, the justification pointer always points to its
parent node in the computation tree.

For P-question, suppose P ask for the value of variable $x$. Then
there may be several choices for the destination of the pointer but
we claim that in the case of safe terms, it should point to the
closest parent node (in the path from the root to P-question) whose
order is greater than the order of $x$.
