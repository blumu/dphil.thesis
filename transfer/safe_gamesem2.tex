\def\cmptre#1{\tau(#1)}
\def\aux#1{\lceil #1\rceil}
\def\nf#1{\eta_{\sf nf}(#1)}

\section{Game semantics of safe $\lambda$-terms}

In this section we will prove that the safety condition
of section \ref{sec:safe_alt} leads to a pointer economy in the game
semantics: for safe $\lambda$-terms the pointers from the game semantics can be reconstructed uniquely from the moves of
the play.

The example of section \ref{subsec:ptrless_strat} gives the intuition.
Remember that in order to distinguish the terms $M_1$ and $M_2$,
we introduced pointers in strategies. In the safe $\lambda$-calculus
this ambiguity disappears because $M_2$ is not a safe term. Indeed, in the
sub-term $f (\lambda y . x)$, the free variable $x$
has the same order as $y$ but $x$ is not abstracted together
with $y$.


%\begin{enumerate}
%\item
%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.
%
%\item
%Is there any unsafe $\beta$-normal form whose game semantics is a
%strategy where pointers can be recovered?
%\end{enumerate}






\subsection{$\eta$-long normal form}

The $\eta$-expansion of $M: A\typear B$ is defined to be the term $\lambda x . M x : A\typear B$ where $x:A$ is a fresh variable.
It is easy to check that if $M$ is safe then $\lambda x . M x$ is also safe.

Consider the term $M : (A_1,\ldots,A_n,o)$, it can be expanded in several steps into
$\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots \varphi_l$
where the $\varphi_i:A_i$ are fresh variables.

The $\eta$-normal form of a term is obtained by hereditarily $\eta$-expanding every sub-term occurring
at an operand position:

\begin{dfn}[$\eta$-long normal form]
A term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a
constant or an abstraction.

The $\eta$-long normal form of a term $M$ is denoted $\aux{M}$ and
is defined as follow:
\begin{eqnarray*}
\aux{x s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{x s_1 \ldots s_m : o} &=& \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \\
\aux{(\lambda x . s_0) s_1 \ldots s_m } &=& (\lambda x . \aux{s_0}) \aux{s_1} \aux{s_2} \ldots \aux{s_m}
\end{eqnarray*}
where $m \geq 0$ and $x$ is either a variable or a constant.
\end{dfn}

The $\eta$-long normal form appeared in \citep{DBLP:journals/tcs/JensenP76}
under the name \emph{long reduced form}
and in \citep{DBLP:journals/tcs/Huet75}
under the name \emph{$\eta$-normal form}. It was then investigated in \citep{huet76}
under the name \emph{extensional form}.



Terms in $\eta$-long normal form can be represented by a tree
defined formally by induction on the structure of the term in $\eta$-long normal form as follow:

\begin{dfn}[Computation tree]
The computation tree associated to the term $s$ is noted
$\cmptre{s}$. It is obtained by applying the following rules
inductively \emph{on the $\eta$-long normal form} of $s$. In the
following $x$ is either a variable or a constant.
\begin{itemize}
\item the tree for $\lambda x_1 \ldots x_n. M$ where $M$ is not an abstraction is:
$$ \cmptre{\lambda x_1 \ldots x_n . M} =
  \pstree[levelsep=4ex]
    { \TR{\lambda x_1 \ldots x_n} }
    { \SubTree{\cmptre{M}}
    }
$$


\item the tree for $x s_1 \ldots s_n$ is:
$$ \cmptre{ x s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{x @} }
    { \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$

\item the tree for $x$ is the single leaf $x$.

\item the tree for $(\lambda x.s_0) s_1 \ldots s_n$ is:
$$ \cmptre{(\lambda x.s_0) s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{@} }
    {
    \SubTree{\cmptre{\lambda x.s_0}}    \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$
\end{itemize}
\end{dfn}

Example: if $x$ is a variable or a constant then
$ \cmptre{\lambda . x} =
  \pstree[levelsep=3ex]
    { \TR{\lambda } }
    { \TR{x}
    }$

The nodes of the tree are of three kinds: lambda node labeled
 $\lambda \overline{x}$, application node labeled $@$ or
operator-application nodes labeled $x @$ where the operator $x$ is
either a variable or a constant. The leaves of the tree are
variables or constants.

A sub-tree of the computation tree represents a $\lambda$-term. We
define the map $\kappa : N \rightarrow \mathcal{T}$ where $N$
denotes the set of nodes and leaves of the computation tree
$\tau(s)$ and $\mathcal{T}$ denotes the set of $\lambda$-terms.
$\kappa$ associates to any node $n$ of the tree the $\lambda$-term
$\kappa(n)$ that is represented by the sub-tree of $\tau(s)$ rooted
at $n$. In particular if $r$ is the root of the tree $\tau(s)$ then
$\kappa(s) = \aux{s}$.

We introduced pointer in the computation tree: a node $n$ labeled
with the variable $x$ points to a lambda node $m$ labeled $\lambda
\overline{\varphi}$ if and only if the variable $x$ is bound in
$\kappa(m)$ by the abstraction $\lambda \overline{\varphi}$. In that
case we say that the node $n$ is bound by $m$. Additionally we make
lambda nodes point to their parent node.


Consider the computation tree $\tau(s)$ of a term $s$ in $\eta$-long normal form. Then:
\begin{itemize}
\item It is easy to check nodes or leaves at even level are abstraction
node and the odd level nodes are either application nodes,
operator-application nodes, variable or constant (the root of the
tree being at level $0$).

\item Suppose that a variable $x$ occurs in $s$. The corresponding node in the tree has of one of the two following forms:
    \begin{itemize}
    \item $ \pstree[levelsep=3ex]
        { \TR{\lambda } }
        { \TR{x}
        }$ where $\ord{x} = 0$

    \item $ \pstree[levelsep=3ex]
                { \TR{x @} }
                { \TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
        $ where $\ord{x} > 0$ and $x:(A_1,\ldots,A_p,o)$
    \end{itemize}

\item    Moreover for any abstraction node
        $ \pstree[levelsep=4ex]
            { \TR{\lambda \overline{\varphi}} }
            { \pstree[levelsep=3ex]
                {\TR{@^{[n]}}}
                {\TR{\lambda \overline{\xi_1}} \ldots \TR{\lambda \overline{\xi_p}}}
            }
        $
    we have $\ord{\kappa(n)}=0$

\end{itemize}

\subsection{Correspondence with game semantics}

By observing side-by-side the computation tree and the type arena of a term in $\eta$-normal form we
realize that it is possible to map each questions move of the arena to a node in the computation tree.
This mapping is defined as follow:
\todo{Define map from arena to comput tree.}


\begin{exmp}
Consider the following term in $\eta$-long normal form
$\lambda f z . (\lambda g x . f x) (\lambda y. y) (\lambda .z)$ of type $(o \typear o) \typear o \typear o$.
The computation tree and the arena for the type $(o \typear o) \typear o \typear o$ are represented below:

\def\pstr{\pstree[levelsep=4ex]}
$$
\pstr
            { \TR{\lambda f z} }
            { \pstr
                {\TR{@}}
                {
                    \pstr
                        {\TR{\lambda g x}}
                        { \pstr{\TR{f@}}{\pstr{\TR{\lambda}}{\TR{x}}}
                        }
                    \pstr{\TR{\lambda y}}{\TR{y}}
                    \pstr{\TR{\lambda}}{\TR{z}}
                }
            }
            \qquad
  \pstr
    { \TR{q^1} }
    {
      \pstr{\TR{q^3}}
               {  \pstr{\TR{q^4}}{\TR{a^4_1} \TR{\ldots}} \TR{a^3_1} \TR{\ldots} }
      \pstr
        { \TR{q^2} }
        { \TR{a^2_1} \TR{a^2_2}\TR{\ldots} }
      \TR{a_1} \TR{a_2}\TR{\ldots}
    }
$$

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

%\psset{arrows=->,arcangle=30,arrowsize=4pt 2,labelsep=2pt,linewidth=0.6mm}


$$
\pstr
            { \TR{\Rnode{root}\lambda f z} }
            { \pstr
                {\TR{@}}
                {
                    \pstr
                        {\TR{\lambda g x}}
                        { \pstr{\TR{\Rnode{f}f@}}{\pstr{\TR{\Rnode{lmd}\lambda}}{\TR{x}}}
                        }
                    \pstr{\TR{\lambda y}}{\TR{y}}
                    \pstr{\TR{\lambda}}{\TR{\Rnode{z}z}}
                }
            }
\hspace{3cm}
\def\pstr{\pstree[levelsep=12ex]}
  \pstr
    { \TR{\Rnode{q1}q^1} }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
    }
\psset{nodesep=1pt,arrows=->,arcangle=20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q1}
\ncarc{->}{f}{q3}
\ncarc{->}{z}{q2}
\ncline{->}{lmd}{q4}
$$
\end{exmp}

There is a nice interpretation of this tree in the game semantics setting: the $\lambda$ nodes
correspond to player O questions, the $x @$ nodes, the variable and constant leaves
correspond to player P questions.

\todomargin{to finish}

\subsection{Pointers in the game semantics of safe terms are recoverable}

We claim that the pointers in the game semantics of a safe term are
uniquely recoverable.

Let $M$ be a safe term, we consider its $\eta$-long normal form $\aux{M}$.
$\aux{M}$ is also safe because safety is preserved by $\eta$-expansion.


\todomargin{rework this paragraph!}
The term can be represented by a computation tree: nodes at even
depth (starting at level 0) correspond to $\lambda$ and nodes at odd
length corresponds to either application $@$, variable $x$ or
variable followed by an application $f@$. A $\lambda$ node
represented consecutive abstraction of variables.

There are justification pointers going upward from variable
occurrences to their bindings.

In the game semantics of the term $M$, the pointers for O and P
answers can be recovered by using the well-bracketing condition.

For O-question, the justification pointer always points to its
parent node in the computation tree.

For P-question, suppose P ask for the value of variable $x$. Then
there may be several choices for the destination of the pointer but
we claim that in the case of safe terms, it should point to the
closest parent node (in the path from the root to P-question) whose
order is greater than the order of $x$.
