\def\cmptre#1{\tau(#1)}
\def\aux#1{\lceil #1\rceil}
\def\nf#1{\eta_{\sf nf}(#1)}

\section{Game semantics of safe $\lambda$-terms}

In this section we will prove that the safety condition
of section \ref{sec:safe_alt} leads to am economy of pointer in the game
semantics: for safe $\lambda$-terms the pointers from the game semantics can be reconstructed uniquely from the moves of
the play.

The example of section \ref{subsec:ptrless_strat} gives the intuition.
Remember that in order to distinguish the terms $M_1$ and $M_2$,
we introduced pointers in strategies. In the safe $\lambda$-calculus
this ambiguity disappears because $M_2$ is not a safe term. Indeed, in the
sub-term $f (\lambda y . x)$, the free variable $x$
has the same order as $y$ but $x$ is not abstracted together
with $y$.

We fix $\Sigma$, a set of constants of order at most 1.
%\begin{enumerate}
%\item
%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.
%
%\item
%Is there any unsafe $\beta$-normal form whose game semantics is a
%strategy where pointers can be recovered?
%\end{enumerate}






\subsection{$\eta$-long normal form and computation tree}

The $\eta$-expansion of $M: A\typear B$ is defined to be the term $\lambda x . M x : A\typear B$ where $x:A$ is a fresh variable.
It is easy to check that if $M$ is safe then $\lambda x . M x$ is also safe.

A term $M : (A_1,\ldots,A_n,o)$ can be expanded in several steps
into $\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots
\varphi_l$ where the $\varphi_i:A_i$ are fresh variables.

The $\eta$-normal form of a term is obtained by hereditarily $\eta$-expanding every sub-term occurring
at an operand position:

\begin{dfn}[$\eta$-long normal form]
A term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a
constant or an abstraction.

The $\eta$-long normal form of a term $M$ is denoted $\aux{M}$ and
is defined as follows:
\begin{eqnarray*}
\aux{x s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{(\lambda x . s_0) s_1 \ldots s_m } &=& (\lambda x . \aux{s_0}) \aux{s_1} \aux{s_2} \ldots \aux{s_m}
\end{eqnarray*}
where $m,n \geq 0$ and $x$ is either a variable or a constant.
\end{dfn}

For $n=0$, the first clause in the definition gives:
$$\aux{x s_1 \ldots s_m : o} = \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} $$

and in that case, the symbol $\lambda$ is called \textsl{dummy} lambda. We do not omit it since it
plays an important role in the correspondence with game semantics.


The $\eta$-long normal form appeared in \citep{DBLP:journals/tcs/JensenP76}
under the name \emph{long reduced form}
and in \citep{DBLP:journals/tcs/Huet75}
under the name \emph{$\eta$-normal form}. It was then investigated in \citep{huet76}
under the name \emph{extensional form}.


A term can be represented by a tree defined formally by induction on the structure
of its $\eta$-long normal form as follows:

\begin{dfn}[Computation tree]
The computation tree associated to the term $s$ is noted
$\cmptre{s}$. It is obtained by applying the following rules
inductively \emph{on the $\eta$-long normal form} of $s$. In the
following $x$ is either a variable or a constant.
\begin{itemize}

\item the tree for $x$ is the single leaf $x$.

\item for $n\geq0$, the tree for $\lambda x_1 \ldots x_n. M$ where $M$ is not an abstraction is:
$$ \cmptre{\lambda x_1 \ldots x_n . M} =
  \pstree[levelsep=4ex]
    { \TR{\lambda x_1 \ldots x_n} }
    { \SubTree{\cmptre{M}}
    }
$$


\item for $n\geq1$, the tree for $x s_1 \ldots s_n$ is:
$$ \cmptre{ x s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{x @} }
    { \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$


\item the tree for $(\lambda x.s_0) s_1 \ldots s_n$ is:
$$ \cmptre{(\lambda x.s_0) s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{@} }
    {
    \SubTree{\cmptre{\lambda x.s_0}}    \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$
\end{itemize}
\end{dfn}

Example: if $x$ is a variable or a constant then
$ \cmptre{\lambda . x} =
  \pstree[levelsep=3ex]
    { \TR{\lambda } }
    { \TR{x}
    }$

The nodes (and leaves) of the tree are of three kinds:
\begin{itemize}
\item $\lambda$-node labeled $\lambda \overline{x}$. A $\lambda$-node represents several consecutive abstractions of variables.
\item application node labeled $@$
\item operator-application nodes labeled $x @$ where the operator $x$ is
either a variable or a constant.
\end{itemize}

A sub-tree of the computation tree represents a $\lambda$-term. We
define the map $\kappa : N \rightarrow \mathcal{T}$ where $N$
denotes the set of nodes and leaves of the computation tree
$\tau(s)$ and $\mathcal{T}$ denotes the set of $\lambda$-terms.
$\kappa$ associates to any node $n$ of the tree the $\lambda$-term
$\kappa(n)$ that is represented by the sub-tree of $\tau(s)$ rooted
at $n$. In particular if $r$ is the root of the tree $\tau(s)$ then
$\kappa(r) = \aux{s}$.

\begin{dfn}[Node order]
The node-order function $\textsf{ord}$ is defined on nodes as
follows:
\begin{eqnarray*}
\ord{\lambda \overline{\xi}} &=& \max_{i=1..n} \ord{\xi_i} \\
\ord{\lambda} &=& -1 \\
\ord{x} &=& \ord{x} \\
\ord{x@} &=& \ord{x} \\
\ord{@} &=& 0
\end{eqnarray*}
where $x$ denotes a variable or a constant.
\end{dfn}


Consider the computation tree $\tau(s)$ of a term $s$ in $\eta$-long normal form. Then:
\begin{itemize}
\item One can check that nodes at even level are abstraction
node and nodes at odd level are either application nodes,
operator-application nodes, variable or constant nodes (the root level being numbered $0$).

\item Suppose that a variable $x$ occurs in $s$. The corresponding node in the tree has of one of the two following forms:
    \begin{itemize}
    \item $ \pstree[levelsep=3ex]
        { \TR{\lambda } }
        { \TR{x}
        }$ where $\ord{x} = 0$

    \item $ \pstree[levelsep=3ex]
                { \TR{x @} }
                { \TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
        $ where $\ord{x} > 0$ and $x:(A_1,\ldots,A_p,o)$
    \end{itemize}

\item    Moreover for any abstraction node
        $ \pstree[levelsep=4ex]
            { \TR{\lambda \overline{\varphi}} }
            { \pstree[levelsep=3ex]
                {\TR{@^{[n]}}}
                {\TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
            }
        $
    we have $\ord{\kappa(@^{[n]})}=0$

\end{itemize}



\subsubsection{Pointers and justified sequence of nodes}

\begin{dfn}[Binder]
Let $n$ be a node of the computation tree labelled $x$ or $x@$. We
say a node $n$ is bound by the node $m$ if $m$ is the closest node
in the path from $n$ to the root of the tree such that $m$ is
labelled $\lambda \overline{\xi}$ with $x\in \overline{\xi}$. $m$ is
called the binder of $n$.
\end{dfn}

\begin{dfn}[Enabling]
The enabling relation $\vdash$ is defined on the set of nodes of the
computation tree. We write $m \vdash n$ and we say that the node $n$
is enabled by $m$ or that $m$ enables $n$ if and only if
\begin{itemize}
\item the node $n$ is labelled $x$ or $x@$ and $m$ is the binder of $n$;
\item or $n$ is a lambda node labelled $\lambda \overline{\xi}$ and $m$ is the parent node of $n$
        (labelled $@$ or $x@$ for some variable or $\Sigma$-constant $x$).
\end{itemize}
\end{dfn}



\begin{dfn}[Justified sequence of nodes]
A \emph{justified sequence of nodes} is an alternating sequence of lambda and non lambda nodes
from the computation tree $\tau(M)$ together with pointers.
Each node $n$ of the sequence that is either
a lambda-node, a $\xi$-node or a $\xi@$-node where $\xi$ is a variable bound in $M$,
and that is not the root of the computation tree has a pointer to a previous node $m$ in the sequence
such that $m \vdash n$.

If $n$ points to $m$ we say that $m$ justifies $n$ and we write:
$$\rnode{m}{m} \cdot \ldots \cdot \rnode{n}{n} \bkptra[nodesep=1pt]{40}{n}{m}$$


We sometimes add a label to the edge to specify that
either node $n$ is labelled by the $i^{th}$ variable abstracted in the lambda node $m$
or that $n$ is the $i^{th}$ child of the non-lambda node $m$.
Hence the pointers in a justified sequence of nodes must be of one of the following five forms:
\vspace{2pt}
$$
\rnode{m}{\lambda \overline{\xi}} \cdot \ldots \cdot \rnode{n}{\xi_i @} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{i}
\hspace{2cm}
\rnode{m}{\lambda \overline{\xi}} \cdot \ldots \cdot \rnode{n}{\xi_i} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{i}$$
\vspace{5pt}
$$\rnode{m}{@ } \cdot \ldots \cdot \rnode{n}{\lambda \overline{\xi}} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{i}
\hspace{2cm}
\rnode{m}{x@} \cdot \ldots \cdot \rnode{n}{\lambda \overline{\xi}} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{i}
\hspace{2cm}
\rnode{m}{f@ } \cdot \ldots \cdot \rnode{n}{\lambda \overline{\xi}} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{i}
$$
for some integer $i$, variable $x$ and $\Sigma$-constant $f$.

With the following conventions:
\begin{itemize}
\item the first child of a $@$ node is numbered $0$,
\item the first child of an application nodes of type $x@$ is numbered $1$,
\item the first variable in $\overline{\xi}$ is numbered $1$.
\end{itemize}
\end{dfn}

Note that justified sequences are also defined for non closed terms
(a nodes occurring in a justified sequence and labelled by a variable free in $M$ has no pointer).

We say that a node $n_0$ of a justified sequence is hereditarily justified by $n_p$ if there are nodes $n_1, n_2, \ldots n_{p-1}$ in
the sequence such that for all $i\in 0..p-1$, $n_i$ points to $n_{i+1}$.

If $N$ is a set of nodes and $s$ a justified sequence of nodes then we write $s \upharpoonright N$ to denote the
subsequence of $s$ obtained after removing the nodes that are not hereditarily justified by nodes in $N$.
This subsequence is also a justified sequence of nodes.

Let $r$ be the root of the tree $\tau(M)$ then no node in the justified sequence
$s \upharpoonright \{ r \}$ is labelled by a free variable in $M$.


\begin{dfn}[Equality of justified sequence]
We write $s \jseq t$ to denote that the two justified sequences $t$ and $s$ are the equal
(having same nodes and same pointers).
\end{dfn}

\begin{dfn}[P-view of justified sequence of nodes]
The P-view of a justified sequence of nodes $t$ of $\tau(M)$ noted $\pview{t}$ is defined as follows:
\begin{eqnarray*}
 \pview{\epsilon} &=&  \epsilon \\
 \pview{s \cdot n }  &=&  \pview{s} \cdot n \\
 \pview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{lmd}{\lambda \overline{\xi}}} &=& \pview{s} \cdot \rnode{m2}{m} \cdot \rnode{lmd2}{\lambda \overline{\xi}}
   \bkptra[nodesep=1pt]{30}{lmd}{m}
   \bkptra[nodesep=1pt]{60}{lmd2}{m2} \\
 \pview{s \cdot r }  &=&  r
\end{eqnarray*}
where $r$ is the root of the tree $\tau(M)$ and
$n$ ranges over non-lambda nodes (either $@$, $f@$, $f$, $x$ or $x@$ for some $\Sigma$-constant $f$
or variable $x$).

In the second clause, the pointer associated to $n$ is preserved from the left-hand side to the right-hand side:
if in the left-hand side, $n$ points to some node in $s$ that is also present in $\pview{s}$ then in the right-hand side,
  $n$ points to that corresponding occurrence of the node in $\pview{s}$.

In the third equality, the pointer associated to $m$ is also preserved.
\end{dfn}

Similarly we define the O-view, the dual of the P-view:
\begin{dfn}[O-view of justified sequence of nodes]
The O-view of a justified sequence of nodes $t$ of $\tau(M)$ noted $\oview{t}$ is defined as follows:
\begin{eqnarray*}
 \oview{\epsilon} &=&  \epsilon \\
 \oview{s \cdot \lambda \overline{\xi} }  &=&  \oview{s} \cdot \lambda \overline{\xi} \\
 \oview{s \cdot \rnode{m}{m} \cdot \ldots \cdot \rnode{n}{n}} &=& \oview{s} \cdot \rnode{m2}{m} \cdot \rnode{n2}{n} \\
   \bkptra[nodesep=1pt]{30}{n}{m}
   \bkptra[nodesep=1pt]{60}{n2}{m2}
 \oview{s \cdot n' }  &=&  n'
\end{eqnarray*}
where $n$ ranges over non-lambda nodes $x$ or $x@$ where $x$ is a variable bound in $M$.
and  $n'$ ranges over non-lambda nodes with no pointer (either $@$, $f@$, $f$, $x$ or $x@$ for some
$\Sigma$-constant $f$ or variable $x$ free in $M$).

The pointer associated to $\lambda \overline{\xi}$ in the second equality
as well as the pointer associated to $m$ in the third equality are preserved from the left-hand side to the right-hand side of the equalities.
\end{dfn}

\begin{dfn}[Visibility] \ \\
A justified sequence of nodes $s$ satisfies \emph{P-visibility} if every variable node with pointer
points to a node occurring in the P-view a that point.

Dually, $s$ satisfies \emph{O-visibility} if every lambda node occurring in it that has a pointer
points to a node in the O-view a that point.
\end{dfn}

\begin{property}
\label{proper:pview_visibility}
The P-view (resp. O-view) of a justified sequence verifying P-visibility (resp. O-visibility)
is a well-formed justified sequence verifying P-visibility (resp. P-visibility).
\end{property}
This is proved by an easy induction.


\subsubsection{Traversal of the computation tree}
The evaluation of term is performed by traversing the computation tree in a particular way called
\emph{traversal}. Intuitively, a \emph{traversal} is a justified sequence of nodes of the computation tree such that each node
of the sequence indicates which step is taken during the evaluation of the term.

It is formally defined as follows:

\begin{dfn}[Traversal]
\label{def:traversal} A traversal over a computation tree $\tau(M)$
is a justified sequence of nodes defined by induction on the rules
given below. A maximal-traversal is a traversal that cannot be
extended by visiting another node. A \emph{traversal} is a prefix of
a maximal-traversal.

A traversal always starts with the root of the tree. This marks the
beginning of the computation. The exploration of the tree then
progresses as follows:
\begin{itemize}
\item (Lam) Suppose that $t \cdot \lambda \overline{\xi}$ is a traversal then the next node that can be visited is the only child
node $n$ of $\lambda \overline{\xi}$. Suppose that the node binding
$n$ occurs in $\pview{t \cdot \lambda \overline{\xi}}$, then the
justified sequence of nodes:
$$t \cdot \lambda \overline{\xi} \cdot n,$$
where $n$ points to the previous occurrence in $\pview{t \cdot
\lambda \overline{\xi}}$ of its binding node, is also a traversal.

\item (App) If $t \cdot @$ is a traversal then so is
$$t \cdot \rnode{m}{@} \cdot
\rnode{n}{n} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{0}$$

i.e. the next visited node is the $0^{th}$ child node of $@$ : the
node corresponding to the operator of the application.


\item ($\mbox{Sig}^0$) If $t \cdot f$ is a traversal where $f$ is an order 0 $\Sigma$-constant then $t \cdot f$ is a maximal traversal.

\item ($\mbox{Sig}^{\geq 1}$) If $t \cdot f@$ is a traversal where $f$ is a $\Sigma$-constant of order greater or equal to
$1$ then so is
$$t \cdot \rnode{m}{f@} \cdot
\rnode{n}{n} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{0}
\qquad \mbox{ for } 1 \leq i \leq arity(f) $$

i.e. the traversal must visit one of the children nodes of $f@$.

\item ($\mbox{Var}^0$) If $t \cdot x$ is a traversal where $x$ is a variable of order $0$ either occurring free in $M$
or bound by the root of the tree $\tau(M)$ then it is a maximal
traversal.

\item ($\mbox{Var}^{\geq 1}$) If $t \cdot x@$ is a traversal where $x$ is a variable of order greater or equal to $1$ either occurring free in $M$
or bound by the root of the tree $\tau(M)$ then so is
$$t \cdot \rnode{m}{x@} \cdot
\rnode{n}{n} \bkptra[nodesep=1pt]{40}{n}{m} \bklabel{0}
\qquad \mbox{ for } 1 \leq i \leq arity(x) $$
i.e. the
traversal must visit one of the children nodes of $x@$.


\item (Var) If $t \cdot x_i$ is a traversal (or $t \cdot x_i@$) where the node $x_i$ is bound by a node $\lambda \overline{x}$
different from the root of $\tau(M)$, then the next node to visit in
the traversal must correspond to the term that would be substituted
for $x_i$ if the $\beta$-redex in term $M$ were reduced.

The binding node $\lambda \overline{x}$ must have been visited
previously in the traversal. Since $\lambda \overline{x}$ is not the
root of the tree, it must be justified by some previous node in the
traversal. This implies that $\lambda \overline{x}$ is not the first
node in the traversal and therefore there is an application node $n$
preceding $\lambda \overline{x}$ in the traversal: $t \cdot x_i = t'
\cdot n \cdot x_i$. We do a case analysis on $n$:

    \begin{itemize}
    \item Suppose $n$ is an application node $@$ then $\lambda \overline{x}$ is the first child node of $n$
    and $n$ has exactly $|\overline{x}| + 1$ children nodes:
    $$\pstree[levelsep=8ex]{\TR{\stackrel{\vdots}{@^{[n]}}}}
    {   \pstree[linestyle=dotted]{\TR{\lambda \overline{x}}\treelabel{0}}
            {\TR{x_i @}}
        \tree{\lambda \overline{\eta_1}}{\vdots}\treelabel{1}
        \TR[edge=\dedge]{}
        \tree{\lambda \overline{\eta_i}}{\vdots}\treelabel{i}
        \TR[edge=\dedge]{}
        \tree{\lambda \overline{\eta_{|x|}}}{\vdots}\treelabel{|x|}
    }
    $$
    Then the following justified sequence is also a traversal:
    \vspace{0.3cm}
    $$t' \cdot \rnode{n}{@^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i@} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}} \cdot \ldots
    \bkptra[ncurv=0.45]{45}{mi}{n} \bklabel{i}
    \bkptra[nodesep=0pt,ncurv=0.6]{50}{x}{lx} \bklabel{i}
    $$
    i.e. the next step of the traversal is a jump to the $i^{th}$ child of
    $@$ ($\lambda \overline{\eta_i}$) which corresponds to the term that would be substituted for $x_i$ if the $\beta$-reduction was
    performed.



    \item Suppose $n$ is labelled $y @$. This means that this occurrence of the variable $y$ is substituted by the term
    $\kappa(\lambda \overline{x})$ during the evaluation of the term.
    $y$ is neither a constant nor a free variable (otherwise $y$ would not be substituted during the evaluation of the term).
    Hence $y$ must be a variable bound by a node different from the
    root.

    During reduction, the occurrence of the variable $x_i$ will be substituted by the term represented by
    node $\lambda \overline{\eta_i}$ (the $i^{th}$ child node of $y
    @$).
    Hence the following justified sequence is also a traversal:
    \vspace{0.2cm}
    $$t' \cdot \rnode{n}{y @^{[n]}} \cdot
    \rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
    \rnode{x}{x_i @} \cdot
    \rnode{mi}{\lambda \overline{\eta_i}} \cdot \ldots
    \bkptra[ncurv=0.6]{50}{x}{lx} \bklabel{i}
    \bkptra[ncurv=0.5]{50}{mi}{n} \bklabel{i}$$

    \end{itemize}
\end{itemize}
\end{dfn}


\begin{exmp}
Consider the following tree:
$$\tree{\lambda}
{
    \tree{@}
    {
        \pstree[levelsep=8ex,linestyle=dotted]{\TR{\lambda y}\treelabel{0} }
        {
            \pstree[levelsep=8ex]{\TR{y @}}
            {
                \tree{\lambda \overline{\eta_1}}{\vdots} \treelabel{1}
                \TR[edge=\dedge]{}
                \tree{\lambda \overline{\eta_i}}{\vdots}\treelabel{i}
                \TR[edge=\dedge]{}
                \tree{\lambda \overline{\eta_n}}{\vdots}\treelabel{n}
            }
        }
        \pstree[levelsep=6ex,linestyle=dotted]{\TR{\lambda \overline{x}}\treelabel{1}}{ \tree{x_i @}{\TR{} \TR{} } }
    }
}
$$
The following justified sequence is a traversal of the tree:
\vspace{0.3cm}
$$ \lambda \cdot
\rnode{app}{@}  \cdot
\rnode{ly}{\lambda y} \cdot \ldots \cdot
\rnode{y}{y @} \cdot
\rnode{lx}{\lambda \overline{x}} \cdot \ldots \cdot
\rnode{x}{x_i @} \cdot
\rnode{leta}{\lambda \overline{\eta_i} } \cdot \ldots
\bkptra[ncurv=0.6,nodesep=0]{40}{x}{lx}  \bklabel{i}
\bkptra[ncurv=0.5]{50}{leta}{y}  \bklabel{i}
\bkptra[ncurv=0.6,nodesep=0]{40}{y}{ly}  \bklabel{1}
\bkptra[ncurv=0.5]{50}{lx}{app}  \bklabel{1}$$

\end{exmp}

\begin{property} \  \label{proper:pviewtrav_is_path}
\begin{itemize}
\item[(i)] Traversals are justified sequence verifying P-visibility and O-visibility.
\item[(ii)] The P-view of a traversal is a path from the root to some node in the computation tree.
\end{itemize}
\end{property}
(i) and (ii) are proved simultaneously by induction on the rule. The proof is given in \citep{OngLics2006}.

\begin{dfn}[Reduced-traversal]
A \emph{reduced-traversal} is a justified sequence of nodes $s$ such that for some traversal $t$:
$$ s \jseq t \upharpoonright \{ r \} $$
where $r$ denotes the root of the computation tree.

We say that $s$ is the reduction of the traversal $t$.
\end{dfn}

\begin{rem}
\label{rem:redtrav} Clearly, if $s$ is a reduced-traversal then
there is a traversal $t$ \emph{whose last node is justified by $r$}
such that $s \jseq t \upharpoonright \{ r \}$.
\end{rem}

In a reduced-traversal, non-lambda nodes are all labelled $x @$ or
$x$ for some variable $x$ \emph{bound} in $M$. There cannot be nodes
labelled $@$, $u@$ or $u$, where $u$ is a free variable in $M$ or a
$\Sigma$-constant, since such nodes are pointer-less.

%% REMOVED
%%
%%\begin{dfn}[Set substraction operator]
%%Suppose $s$ is a justified sequence of nodes and $N$ is a set of nodes then $s \setminus N$ is the justified sequence of nodes
%%obtained by removing from $s$ all the nodes that belongs to $N$.
%%The links of $s \setminus N$ are the links of $s$ minus all the links pointing from or to nodes in $N$.
%%\end{dfn}

\begin{property}[Traversal of closed term in $\beta \eta$-long normal form]
\label{proper:betaeta_trav}
Suppose $M$ is a closed term in $\beta \eta$-long normal form (i.e. the $\eta$-long normal form of a $\beta$-normal form), then
for any traversal $t$ of $\tau(M)$ and any node $n$ in $t$:
\begin{eqnarray*}
n \mbox{ is not hereditarily justified by } r  \  \iff \   n \mbox{
is hereditarily justified by some node $m$ in } N_\Sigma
\end{eqnarray*}
where $r$ denotes the root of the tree
$\tau(M)$ and $N_\Sigma$ denotes the set of nodes labelled $f$ or $f@$ for
some $\Sigma$-constant $f$.
\end{property}
\begin{proof}
In a computation tree, the only nodes with no justification pointer are:
the root node $r$, the application nodes $@$, the application nodes $u @$ or $u$ where $u$ is a $\Sigma$ constant or a free variable.

Here the term $M$ is in $\beta \eta$-long normal form therefore there is no node of type $@$ in the computation tree.
Moreover $M$ is closed therefore there is no node of type $x@$ or $x$ where $x$ is a
free variable. Hence the only nodes of the computation tree of $M$ without pointer are the root and the nodes in $N_\Sigma$.

Consequently, all the nodes in the tree are either hereditarily justified by the root $r$ or by a node in $N_\Sigma$. Since $r$ is not in
$N_\Sigma$, the ``or'' is an exclusive-or.
\end{proof}

\begin{lem}[Reduced-traversal and traversal]
\label{lem:redtrav_trav} Suppose $M$ is a closed term in $\beta
\eta$-long normal form (i.e. the $\eta$-long normal form of a
$\beta$-normal form). Let us note $r$ denotes the root of the tree
$\tau(M)$. Then:
\begin{itemize}
\item[(i)] for any traversal $t$, the reduced-traversal $t \upharpoonright \{ r \}$ verifies
$$ \pview{t \upharpoonright \{ r \}} \jseq \pview{t} \upharpoonright \{ r \},$$
\item[(ii)] for any traversal $t$ whose last node is hereditarily justified by $r$,
     the reduced-traversal $t \upharpoonright \{ r \}$ verifies
    $$ \oview{t \upharpoonright \{ r \}} \jseq \oview{t}.$$
\end{itemize}
\end{lem}

\begin{proof}
(i) By induction. Base case: it is trivially true for the empty
traversal $t = \epsilon$. Step case: consider a traversal $t$ and
suppose that the property (i) is verified for all traversal smaller
than $t$. There are three cases:
\begin{itemize}
\item Suppose $t = t' \cdot n$ where $n = r$. We have:
    \begin{align*}
    \pview{t} \upharpoonright \{ r \}
        &\jseq  \pview{t' \cdot r } \upharpoonright \{ r \}      & (\mbox{definition of } t)\\
        &\jseq  r \upharpoonright \{ r \}                        & (\mbox{def. P-view})\\
        &\jseq  r                                                & (\mbox{def. operator $\upharpoonright$})\\
        &\jseq  \pview{(t' \upharpoonright \{ r \}) \cdot r }    & (\mbox{def. P-view})\\
        &\jseq  \pview{(t' \cdot r)  \upharpoonright \{ r \}}    & (\mbox{def. operator $\upharpoonright$})\\
        &\jseq \pview{t \upharpoonright \{ r \}}                & (\mbox{definition of } t)
    \end{align*}

\item Suppose $t = t' \cdot n$ where $n$ is a non-lambda
move. We have:
    \begin{equation}
    \pview{t} = \pview{t' \cdot n} = \pview{t'} \cdot n  \label{eq_tprime}
    \end{equation}

    We consider the following two sub-cases:
    \begin{itemize}
    \item Suppose that $n$ is not hereditarily justified by $r$ then:
    \begin{align*}
    \pview{t} \upharpoonright \{ r \}
        &\jseq (\pview{t'} \cdot n) \upharpoonright \{ r \} & (\mbox{equation \ref{eq_tprime}}) \\
        &\jseq \pview{t'} \upharpoonright \{ r \}           & (n \mbox{ is not hereditarily justified by } r) \\
        &\jseq \pview{t' \upharpoonright \{ r \}}           & (\mbox{induction hypothesis}) \\
        &\jseq \pview{(t' \cdot n) \upharpoonright \{ r \}} & (n \mbox{ is not hereditarily justified by } r) \\
        &\jseq \pview{t \upharpoonright \{ r \} }           & (\mbox{definition of } t)
    \end{align*}

    \item Suppose that $n$ is hereditarily justified by $r$ then:
    \begin{align*}
    \pview{t} \upharpoonright \{ r \}
    &\jseq (\pview{t'} \cdot n) \upharpoonright \{ r \}     & (\mbox{equation \ref{eq_tprime}}) \\
    &\jseq (\pview{t'} \upharpoonright \{ r \} ) \cdot n    & (n \mbox{ is hereditarily justified by } r)\\
    &\jseq \pview{t' \upharpoonright \{ r \}} \cdot n       & (\mbox{induction hypothesis}) \\
    &\jseq \pview{(t' \upharpoonright \{ r \}) \cdot n }    & (\mbox{def. P-view}) \\
    &\jseq \pview{(t' \cdot n) \upharpoonright \{ r \} }    & (n \mbox{ is hereditarily justified by } r) \\
    &\jseq \pview{t \upharpoonright \{ r \} }               & (\mbox{definition of } t)
    \end{align*}
    \end{itemize}


\item Suppose that the traversal is:
    $$  t =  t' \cdot \rnode{m}{m} \cdot  u \cdot \rnode{lmd}{n}
    \bkptra[nodesep=1pt]{30}{lmd}{m}$$

    where $n$ is a $\lambda$ node. Then we have:
    \begin{equation}
    \pview{t} = \pview{t' \cdot \rnode{m}{m} \cdot u \cdot \rnode{n}{n}}
            = \pview{t'} \cdot \rnode{m2}{m} \cdot \rnode{n2}{n}
    \bkptra[nodesep=1pt]{60}{n}{m}
    \bkptra[nodesep=1pt]{60}{n2}{m2}
    \label{eq_tprime_2}
    \end{equation}


    \begin{itemize}
    \item Suppose that $m$ is not hereditarily justified by $r$ then
    neither is $n$.

    Lambda nodes are justified by their parent node therefore $m$ is the parent of $n$.
    By property \ref{proper:betaeta_trav}, nodes that are not hereditarily justified by the root are
    exactly the nodes that are hereditarily justified by $N_\Sigma$.
    Moreover, since $\Sigma$ contains only constant of order $1$ at most, the only nodes that are hereditarily justified by $N_\Sigma$ are the nodes
    in $N_\Sigma \union Succ(N_\Sigma)$ where $Succ(N_\Sigma)$ denotes the set of nodes whose parent node is in in $N_\Sigma$.

    The lambda nodes in $N_\Sigma \union Succ(N_\Sigma)$ are the
    nodes in $Succ(N_{\Sigma})$, they are all labelled $\lambda$.
    Hence necessarily we have $n = \lambda$ and $m \in N_{\Sigma}$.

    Thus, the traversal has the following form:
    $$  t =  t' \cdot \rnode{m}{f@} \cdot  u \cdot \rnode{lmd}{\lambda}
    \bkptra[nodesep=1pt]{30}{lmd}{m}$$
    for some constant $f\in \Sigma$.

    The rules defining traversals are such that any node $\lambda \in Succ(N_\Sigma)$ must be preceded by its parent node. Hence $m$ must preceed $n$
    in the traversal and therefore $u= \epsilon$
        \begin{align*}
        \pview{t} \upharpoonright \{ r \}
        &\jseq (\pview{t'} \cdot \rnode{m}{m} \cdot \rnode{lmd}{n} ) \upharpoonright \{ r \}
               \bkptra[nodesep=1pt]{60}{lmd}{m}                 & \mbox{(equation \ref{eq_tprime_2})} \\
        &\jseq \pview{t'} \upharpoonright \{ r \}               & (m, n \mbox{ are not hereditarily justified by } r) \\
        &\jseq \pview{t' \upharpoonright \{ r \}}               & \mbox{(induction hypothesis)} \\
%
        &\jseq \pview{ (t' \cdot u ) \upharpoonright \{r\} }    & (u = \epsilon)
          \bkptra[nodesep=1pt,ncurv=0.7]{30}{lmd}{m} \\
%
        &\jseq \pview{ (t' \cdot \rnode{m}{m} \cdot u \cdot \rnode{lmd}{n}) \upharpoonright \{r\} }
                                                                & (\mbox{def. operator $\upharpoonright$ and } m, n \mbox{ are not her. just. by } r)
          \bkptra[nodesep=1pt,ncurv=0.7]{40}{lmd}{m} \\
%
        &\jseq \pview{ t \upharpoonright \{r\} }                & \mbox{(def. of $t$)}
        \end{align*}

    \item Suppose that $m$ is hereditarily justified by $r$ then
    so is $n$ and we have:
     \begin{align*}
        \pview{t} \upharpoonright \{ r \}
        &\jseq (\pview{t'} \cdot \rnode{m}{m} \cdot \rnode{lmd}{n} ) \upharpoonright \{ r \}
                                                & \mbox{(equation \ref{eq_tprime_2})} \\
       \bkptra[nodesep=1pt]{60}{lmd}{m}
%
        &\jseq \pview{t'} \upharpoonright \{ r \} \cdot \rnode{m}{m} \cdot \rnode{lmd}{n}
                                                & (m, n \mbox{ are hereditarily justified by } r)
       \bkptra[nodesep=1pt]{60}{lmd}{m} \\
%
        &\jseq \pview{t' \upharpoonright \{ r \}} \cdot \rnode{m}{m} \cdot \rnode{lmd}{n}
                                                & \mbox{(induction hypothesis)}
       \bkptra[nodesep=1pt]{60}{lmd}{m} \\
%
        &\jseq \pview{ (t' \upharpoonright \{ r \}) \cdot \rnode{m}{m} \cdot (u \upharpoonright \{r\}) \cdot \rnode{lmd}{n}}
                                                & \mbox{(def. P-view)}
          \bkptra[nodesep=1pt,ncurv=0.7]{30}{lmd}{m} \\
%
        &\jseq \pview{ (t' \cdot \rnode{m}{m} \cdot u \cdot \rnode{lmd}{n}) \upharpoonright \{r\} }
                                                & \mbox{(def. operator $\upharpoonright$)}
          \bkptra[nodesep=1pt,ncurv=0.7]{40}{lmd}{m} \\
%
        &\jseq \pview{ t \upharpoonright \{r\} }
                                                & \mbox{(def. of $t$)}
        \end{align*}
    \end{itemize}

\end{itemize}
(ii) By a straightforward induction similar to (i).
\end{proof}

\subsection{Correspondence with game semantics}

By representing side-by-side the computation tree and the type arena of a term in $\eta$-normal form we observe
that for each question move of the arena there are corresponding nodes in the computation tree.

\begin{exmp}
Consider the following term $M \equiv \lambda f z . (\lambda g x . f (f x)) (\lambda y. y) z$ of type $(o \typear o) \typear o \typear o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f (f x)) (\lambda y. y) (\lambda .z)$.
The computation tree is:

$$
\tree{\lambda f z}
{ \tree{@}
    {
        \tree{\lambda g x}
            { \tree{f@}{   \tree{\lambda}{ \tree{f@}{  \tree{\lambda}{\TR{x}}} }  }
            }
        \tree{\lambda y}{\TR{y}}
        \tree{\lambda}{\TR{z}}
    }
}
$$

The arena for the type $(o \typear o) \typear o \typear o$ is:
$$\tree{q^1}
{
    \tree{q^3}
        {  \tree{q^4}
                {\TR{a^4_1} \TR{\ldots}}
            \TR{a^3_1} \TR{\ldots} }
    \tree{q^2}
    { \TR{a^2_1} \TR{a^2_2}\TR{\ldots} }
    \TR{a_1} \TR{a_2}\TR{\ldots}
}
$$

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

We now omit the answers moves when we represent the arena.
The arena and the computation tree are represented on the figure below (right and left respectively).
The dashed line defines a partial function $\varphi$ from the set of nodes in the computation tree to the set of
question moves:
$$
\tree{ \Rnode{root} {\lambda f z w}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}
                { \tree{\Rnode{f}{f@^{[6]}}}{  \tree{\Rnode{lmd}\lambda^{[7]}}{ \tree{\Rnode{f2}{f@^{[8]}}} {\tree{\Rnode{lmd2}\lambda^{[9]}}{\TR{x^{[10]}}}}}  }
                }
            \tree{\lambda y ^{[4]}}{\TR{y}}
            \tree{\lambda ^{[5]}}{\TR{\Rnode{z}z}}
        }
    }
\hspace{3cm}
  \tree[levelsep=12ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
        \TR{\Rnode{q5}q^5}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{->}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{z}{q2}
\ncline{->}{f}{q3}
\ncline{->}{lmd}{q4}
\ncline{->}{f2}{q3}
\ncline{->}{lmd2}{q4}
$$

Consider the justified sequence of moves $s \in \sem{M}$:
\vspace{0.5cm}
 $$s =
\rnode{q1}{q}^1\
\rnode{q3}{q}^3\
\rnode{q4}{q}^4\
\rnode{q3b}{q}^3\
\rnode{q4b}{q}^4\
\rnode{q2}{q}^2
\bkptrc{q3}{q1}
\bkptrc[ncurv=0.5]{q3b}{q1}
\bkptrc{q4}{q3}
\bkptrc{q4b}{q3b}
\bkptrc[ncurv=0.5]{q2}{q1}
\in \sem{M}$$

There is a corresponding justified sequence of nodes in the computation tree:
\vspace{0.5cm}
$$r =
\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f@}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f@}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=1]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}$$
such that $s_i = \varphi(r_i)$ for all $i < |s|$.

The sequence $r$ is in fact a reduced-traversal, it is the reduction of the following traversal:
\vspace{1cm}
$$t =
\rnode{q1}{\lambda f z} \cdot
\rnode{n2}{@^{[2]}} \cdot
\rnode{n3}{\lambda g x^{[3]}} \cdot
\rnode{q3}{f@}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f@}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{n8}{x^{[10]}} \cdot
\rnode{n9}{\lambda^{[5]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=0.6]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}
\bkptra[ncurv=0.4]{60}{n3}{n2}
\bkptra[ncurv=0.4]{60}{n8}{n3}
\bkptra[ncurv=0.4]{60}{n9}{n2}
$$

We see on this example that the game semantics and the computation tree are somehow related to each other.
\end{exmp}


Let us now analyze precisely the relationship between the game semantics and the computation tree.

Let $\Gamma \vdash M : A$ be a term in $\eta$-long normal form.
Suppose $(M^{QA},\vdash)$ is the arena $\sem{A}$ where $M^{QA}$ is the set of moves and $\vdash$ is the enabling relation.
$M^Q \subseteq M^{QA}$ denotes the set of question-moves.
$(N,E)$ denotes the computation tree $\tau(M)$ where $N$ is the set of nodes and leaves of the tree and $E$ is the parent-child relation.

We give an algorithm computing the partial function $\varphi : N \rightarrow M^Q$ which maps
some question-moves to set of nodes in the computation tree.

\begin{dfn}[Relation between question-moves and nodes of the computation tree]
\label{def:phi_procedure}
We start by defining two preliminary procedures.
The procedure $f$ takes two parameters: $n$ is the index number of a
$\lambda$-node in the computation tree and $q$ is a question move of the arena
of $\Gamma \vdash M : A$ such that $q$ and $\kappa(n)$ have the same type.

Similarly we define the procedure $g$ that takes two parameters: $n$
is the index number of a $x@$-labelled node or a $x$-labelled node
in the computation tree and $q$ is a question move of the arena of
$\Gamma \vdash M : A$ such that $q$ and $x$ have the same type.

\noindent
\begin{description}
\item[\textbf{Procedure} $f(nd,q)$]
    where $nd$ is a $\lambda$-node.

    \begin{itemize}
    \item If $\ord{\kappa(nd)} = 0$ then the term is of ground type therefore
    the game for $M$ is played on the flat arena
    with only one question $q$. Moreover the node $nd$ of the computation tree is labelled with $\lambda$.\\
    \textbf{return} $\{ nd \mapsto q \}$.

    \item $\ord{\kappa(nd)} > 0$. The computation tree and the arena
    have the following form:
    $$ \tree[levelsep=6ex]{ \Rnode{r}\lambda \overline{\xi}  ^{[nd]}}
        {
            \tree[levelsep=6ex]{x@^{[nd+1]}}
            {   \TR{\lambda^{[\ldots]}} \TR{\ldots} \TR{\lambda^{[\ldots]}}
            }
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi} \vdash \kappa(x@^{[nd+1]}) : o$.

    For each of the abstracted variable $\xi_i$ there is a corresponding question move $q_i$ of the same order
    in the arena.  Each free occurrence of the variable $\xi_i$ is mapped to the move $q_i$
    by the procedure $g$.

    $$\mathbf{return} \ \{ nd \mapsto q \}
    \union
    \Union_{\stackrel{i=1..n}{\xi_i^{[k]} \in Desc(nd)}} g ( k, q_i)
    \quad \union \quad
    \Union_{\stackrel{i=1..n}{@\xi_i^{[k]} \in Desc(nd)}} g ( k, q_i)
    $$
    where $Desc(nd)$ is the set of descendants of  node $nd$
    (nodes $m$ such that there is a path from node $nd$ to node $m$ in the computation
    tree).

    \end{itemize}

\item[\textbf{Procedure} $g(nd,q)$]\  \\
The procedure is not defined on $\lambda$-nodes or $@$ nodes.
This is ok since all the calls to $g$ in $f$ are of the type $g(nd,q)$ where $nd$ denotes a $@x$-node or a $x$-node.

\begin{itemize}
\item[case 1] Suppose that $nd$ is labelled with $x$ then we must have $x:0$. \textbf{return}
$\{ nd \mapsto q \}$.

\item[case 2] If $nd$ is labelled with $x@$ then $x:(A_1|\ldots|A_m|o)$.
The computation tree and the arena  have the following form:


    $$\tree[levelsep=6ex]{\Rnode{r}{x@^{[nd]}}}
        {   \tree{\TR{\lambda^{[k_1]}}}{\vdots} \TR{\ldots}
        \tree{\TR{\lambda^{[k_m]}}}{\vdots}
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{\Rnode{q1}{q^1}}{\TR{} \TR{} }
            \tree[linestyle=dotted]{\Rnode{q2}{q^2}}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{\Rnode{qm}{q^m}}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi} \vdash \kappa(x@^{[nd]}) : o$.

    For each of the children node of $nd$
    there is a corresponding question move $q_i$ of the same type
    in the arena.
    $$\mathbf{return} \ \{ nd \mapsto q \} \union
    \Union_{i=1..m} f ( k_i, q_i)
    $$
\end{itemize}
\end{description}

We define $\varphi$ as follows:
$$\varphi = f(0,q^0)$$
where the index $0$ denotes the root of the computation tree and $q^0$ is the root of the arena
(in the game semantics of simply-typed lambda calculus the arenas have
a single root).
\end{dfn}

The function $\varphi : N \rightarrow M^Q$ and its inverse
$\varphi^{-1} : M^Q \rightarrow \mathcal{P}(N)$ are partial function.
Moreover $\varphi$ relates player O questions to $\lambda$-nodes
and player P questions to $x @$-nodes or $x$-nodes where $x$ is a variable.

\begin{property}[$\varphi$ conserves order]
\label{proper:phi_conserve_order}
$\varphi$ maps nodes of a given order to moves of the same order.
\end{property}


The function $\varphi$ is also defined on justified sequences: suppose $t$
is a justified sequences of nodes $t = t_0 t_1 \ldots$ then $\varphi(t)$ denotes
the following justified sequence of question-moves of the arena $\sem{A}$:
$$\varphi(t) = \varphi(t_0)\ \varphi(t_1)\  \varphi(t_2) \ldots$$
where the pointers of the justified sequence of move $\varphi(t)$ are defined to be exactly those
of the justified sequences of nodes $t$.

\begin{dfn}[Question-move filtering]
Suppose $s$ is a justified sequence of moves then we write $\tilde{s}$
the subsequence of $s$ consisting of question-moves only:
\begin{eqnarray*}
\tilde{} &: L_A &\longrightarrow (M^Q)^* \\
& s &\longmapsto \tilde{s} = s \upharpoonright M^Q
\end{eqnarray*}
where $M^Q$ denotes the set of question-moves.
$\tilde{s}$ is also a justified sequence of move (there is no dangling pointer since questions-moves points to other question-moves).
If $s = u\upharpoonright A,B$ then clearly $\tilde{s} = \tilde{u} \upharpoonright A,B$.
\end{dfn}

%\begin{property} Let $s$ be a justified sequence of moves. Then
%\label{proper:tildepview}
%$$\widetilde{\pview{s}} = \pview{\tilde{s}}$$
%\end{property}
%The proof is an easy induction.


\begin{prop}[Relation between game semantics and reduced-traversals]
\label{prop:rel_gamesem_redtrav_closed}
Let $\emptyset \vdash M : A$ be a closed term.
Let $r$ denotes the root of $\tau(M)$. If $s$ is a justified sequence of moves such
that $s \in \sem{\Gamma \vdash M:A}$ then there is a reduced-traversal of nodes of $\tau(M)$
$t = n_0 n_1 \ldots$ such that:
 $$\tilde{s} \jseq  \varphi_M(t)$$
\end{prop}
\begin{proof}
Let us assume that $M$ is already in $\eta$-long normal form.
Let $s$ be as justified sequence of moves in $\sem{M}$.

We proceed by induction on the height of of
the tree $\tau(M)$ and by case analysis on the structure of the term.

\begin{itemize}
  \item[(constant)] $M = f \in \Sigma$. The tree $\tau(M)$ has the following form:
  $$ \tree[levelsep=6ex]{r}{ \TR{f} }$$
  There is only one question in the game arena: the initial question $q$ verifying $ q = \varphi_M(r)$.
  It suffices to take $t = r^{|\tilde{s}|}$.

  \item[(variable)] $M = x$. This case does not happen since $M$ is a closed term.

  \item[(application)] The term $M$ is of the form $\emptyset \vdash N_0 N_1 \ldots N_p : o$ where $N_0$ is not
    a variable (since $M$ is closed) and:
    \begin{eqnarray*}
    \emptyset &\vdash& N_0 : (A_1,\ldots,A_p,o)\\
    \emptyset &\vdash& N_i : A_i \mbox{ for } i \in 1..p
    \end{eqnarray*}

    The tree $\tau(M)$ has the following form:
    $$ \tree[levelsep=6ex]{\lambda}
        { \tree[levelsep=6ex]{@^{[1]}}
            {   \TR{\tau(N_0)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$

    We have:
    $$\sem{M} = \sem{\emptyset \vdash N_0 N_1 \ldots N_p : o} = \overbrace{\langle \sem{\emptyset \vdash N_0}, \ldots, \sem{\emptyset \vdash N_p} \rangle}^\sigma ; ev_{A_1,\ldots,A_p,o}$$
    with $\sigma : \textbf{1} \longrightarrow B$ and $ev_{A_1,\ldots,A_p,o} : B \longrightarrow \sem{o}$ where
    $$ B = \sem{(A_1,\ldots,A_p,o)} \times \sem{A_1} \times \ldots \times \sem{A_p} $$

    Since $s \in \sem{M} = \sem{\emptyset \vdash N_0 N_1 \ldots N_p : o}$ we have:
    \begin{equation*}
        s = u \upharpoonright \textbf{1},\sem{o} = u \upharpoonright \sem{o}
    \end{equation*}
    for some $u \in \sigma \parallel ev_{A_1,\ldots,A_p,o}$.

    Let $q_C$ denotes the only question of the arena $\sem{o}$ then $s \in \{ q_C \}^*$.
    We construct the reduced-traversal $t$ by replacing the moves $q_C$ in $\tilde{s}$ by the root node
    $\lambda \overline{\xi}$:
    $$ t \jseq  \tilde{s} [\lambda \overline{\xi} / q_C].$$

    Since $\tilde{s} \in \{ q_C \}^*$ and $\varphi_{M}(\lambda \overline{\xi}) = q_C$, we have:
    $$\varphi_{M} (t) = \varphi_{M}( \tilde{s} [\lambda \overline{\xi} / q_C] )
        = \tilde{s} [\lambda \overline{\xi} / q_C] [q_C / \lambda \overline{\xi}]
        = \tilde{s}$$
    Since all the moves in $\tilde{s}$ are initial, they do not have pointers. Hence
    $$ \varphi_{M} (t) \jseq \tilde{s} $$


  \item[(abstraction)]
    $M \equiv \lambda \overline{\xi} . M'$ where $M'$ is not an abstraction. We do a case analysis on
    the last rule used to derive $N'$:
    \begin{itemize}
      \item $M'$ is a constant: same treatment as the (constant) case above.
      \item $M'$ is a variable:
        $M = \lambda \overline{\xi} . x$.  Then $x$ must be of ground type $o$ and since $M$ is closed
        $x = \xi_i \in \overline{\xi}$ .
        Then $\tau(M)$ has the following shape:
        $$ \tree[levelsep=6ex]{ \lambda \overline{\xi}^{[0]} }{\TR{x^{[1]}}}$$
        The arena is of the following form (only question moves are represented):
        $$ \tree{ q }
        {   \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
            \TR{q^x}
        }$$
        where $q^x$ denotes the root of the flat arena $\sem{o}$.
        We have:
        $$ \sem{M} = \sem{\emptyset \vdash \lambda \overline{\xi} . \xi_i} = \Lambda^n(\sem{\overline{\xi} \vdash  \xi_i}) = \Lambda^n(\pi_i)$$
        where $\pi_i$ denotes the $i$-th projection

        Therefore the only question-moves that can occur in $s \in \sem{M}$ are the initial question $q$ and the question $q_x$.
        We take $t \jseq \tilde{s} [0/q, 1/q^x]$ which is a valid justified sequence of nodes since
        node $1$ ($x$) is bound by node $0$ ($\lambda \overline{\xi}$) and a valid
        reduced-traversal. Clearly we have $\varphi(t) \jseq \tilde{s}$.

    \item $M'$ is an application: $M = \lambda \overline{\xi} . x N_1 \ldots N_p$ where
    \begin{eqnarray*}
    \emptyset &\vdash& M : (X_1,\ldots,X_n,o) \\
    \Gamma &\vdash& x N_1 \ldots N_p : o \\
    \Gamma &\vdash& x : (A_1,\ldots,A_p,o) \\
    \Gamma &\vdash& N_i : A_i \mbox{ for } i \in 1..p \\
    \Gamma &=& \overline{\xi} : \overline{X}
    \end{eqnarray*}

    The tree $\tau(M)$ has the following form:
    $$ \tree[levelsep=6ex]{\lambda \overline{\xi}^{[0]}}
        { \tree[levelsep=6ex]{x @^{[1]}}
            {   \TR{\tau(N_0)} \TR{\ldots} \TR{\tau(N_p)}}}
    $$
    where $x \in \overline{\xi}$ (since $M$ is a closed term).

    We have:
    \begin{eqnarray*}
    \sem{ \emptyset \vdash M} &=& \Lambda^n( \sem{\Gamma \vdash x N_1 \ldots N_p : o} ) \\
    \sem{\Gamma \vdash x N_1 \ldots N_p : o} &=& \overbrace{\langle \sem{\Gamma \vdash N_0}, \ldots, \sem{\Gamma \vdash N_p} \rangle}^\sigma ; ev_{A_1,\ldots,A_p,o}
    \end{eqnarray*}

    with $\sigma : A \longrightarrow B$ and $ev_{A_1,\ldots,A_p,o} : B \longrightarrow C$, the arena being defined as follows:
    \begin{eqnarray*}
        A &=& \sem{\Gamma} = \sem{X_1} \times \ldots \times \sem{X_n}\\
        B &=& H_0 \times H_1 \times \ldots \times H_p \\
        C &=& \sem{o}\\
        H_0 &=& \sem{(A_1,\ldots,A_p,o)} \\
        H_j &=& \sem{A_j} \mbox{ for }j \in 1..p
    \end{eqnarray*}

    Since $s \in \sem{M}$ we must have $s\in \sem{\Gamma \vdash x N_1 \ldots N_p : o}$ therefore:
    \begin{equation}
        s = u \upharpoonright A, C \label{eq:def_s}
    \end{equation}
    for some $u \in \sigma \parallel ev_{A_1,\ldots,A_p,o}$, more precisely for some $u$ such that:
    \begin{eqnarray}
        u &\in& int(A,B,C) \nonumber \\
        w = u \upharpoonright A,B & \in& \sigma       \label{eq:def_w}\\
        u \upharpoonright B,C & \in & ev_{A_1,\ldots,A_p,o} \nonumber
    \end{eqnarray}

    $w \in \sigma$ implies that for some $j \in 1..p$:
    \begin{eqnarray}
        z = w \upharpoonright A, H_j &\in& \sem{\Gamma \vdash N_j}  \label{eq:def_z} \\
        \mbox{ and for every } k\neq j &:& w \upharpoonright H_k = \epsilon \label{eq:b}
    \end{eqnarray}

    We cannot use the induction hypothesis on $\Gamma \vdash N_j : A_j$ because it is not a closed terms!
    We therefore consider the closed term $N'_j = \lambda \overline{\xi} . N_j$:
        $$\emptyset \vdash N'_j : (X_1, \ldots, X_n,A_j)$$

    We have $z \in \sem{N_j} = \Lambda^n(\sem{\Gamma \vdash N_j})$. But $\Lambda^n(\sem{\Gamma \vdash N_j})$
    and $\sem{\Gamma \vdash N_j}$ are the same strategies up to an isomorphism that
    retaggs the moves. Hence the equation \ref{eq:def_z} gives $z \in \sem{N'_j}$ where $N'_j$ is a closed term. Since
    the term $N'_j$ has the same height as the term $N_j$ which is strictly smaller than the height
    of the term $M$, we can use the induction hypothesis on $N'_j$:
    there is a reduced-traversal $t'$ of the tree $\tau(N'_j)$
    such that $\varphi_{N'_j}(t') \jseq \tilde{z}$.




    From equation \ref{eq:def_w} we have:
    \begin{equation}
        \tilde{w} = \tilde{u} \upharpoonright A,B
        \label{eq:def_wtilde}
    \end{equation}

    From equation \ref{eq:b}, for $k\neq j : w \upharpoonright H_k = \epsilon$. Since $B =
    H_0 \times H_1 \times \ldots \times H_p$ this implies that moves in $w$ hereditarily justified by moves in $B$ are in fact all
    hereditarily justified by moves in $H_j$.  Hence $z = w \upharpoonright A, H_j = w \upharpoonright A, B$ and:
    \begin{eqnarray*}
            \tilde{z} =& \tilde{w} \upharpoonright A,B \\
            =& (\tilde{u} \upharpoonright A,B) \upharpoonright A,B &\mbox{(by eq \ref{eq:def_wtilde})} \\
            =& \tilde{u} \upharpoonright A,B \\
            =& \tilde{w}  & \mbox{(by eq \ref{eq:def_wtilde})}
    \end{eqnarray*}


    Hence $\varphi_{N'_j}(t') \jseq \tilde{w}$.


    For $i \in 1..p$, the tree $\tau(N_i)$ (left) and $\tau(N'_i)$ (right) have the following form:
    $$ \tree[levelsep=6ex]{ \lambda \overline{y_i}^{[n_i]} }
    { \tree[levelsep=6ex,linestyle=dotted]{}
        {   \TR{} \TR{} \TR{} }}
    \hspace{2cm}
    \tree[levelsep=6ex]{ \lambda \overline{\xi}\  \overline{y_i}^{[n_i]} }
    { \tree[levelsep=6ex,linestyle=dotted]{}
        {   \TR{} \TR{} \TR{} }}
    $$
    where only the label of the root differs between the two trees.

    From the justified sequence $t'$ of $\tau(N'_j)$ we construct the justified sequence $t$ of
    $\tau(M)$ by mapping the nodes of $\tau(N'_j)$ to the corresponding node in the subtree $\tau(N_j)$
    of $\tau(M)$. Moreover we change all the pointers going from a node $\xi_i$ or $\xi_i @$ to the root node of $\tau(N'_j)$
    into a pointer starting from the corresponding node $\xi_i$ or $\xi_i @$ to the root of the tree $\tau(M)$.
    $t$ is a valid justified sequence of nodes of $\tau(M)$ since the nodes labelled $\xi_i$ and $\xi_i @$
    are bound by the root $\lambda \overline{\xi}$.

    The function $\varphi : Nodes \rightarrow M^Q$ has been defined by an inductive procedure
    guaranteeing that $\varphi_{N_j}$ is equal to the function $\varphi_{M}$ restricted to
    the set of nodes of $\tau(N_j)$. Hence we have:
    \begin{equation}
    \varphi_{M}(t) \jseq \tilde{w}. \label{eq:def_t}
    \end{equation}

    Let $q_C$ denotes the only question of the arena $C = \sem{o}$.
    We can construct from $t$ the justified sequence $t^\ast$. The construction is in three steps.
    \begin{itemize}
    \item First we describe the elements of the sequence $t^\ast$ (the pointers are ignored at the moment).

    We insert the root node $\lambda \overline{\xi}$ at the positions where the move $q_C$ occurs in $\tilde{u}$.
    Since $\varphi_{M}(\lambda \overline{\xi}) = q_C$, we have the following equality of \emph{pointer-less} sequences:
    $$\varphi_{M}(t^\ast) = \tilde{u}$$

    \item The next step is to add the pointers to the sequence $t^\ast$.
    These pointers are transferred from $\tilde{u}$ to $t^\ast$: for each
    move $\tilde{u}_k$ pointing to $\tilde{u}_i = q_C$ in $\tilde{u}$ for some $0 \leq i \leq k$,
    we add a pointer in $t^\ast$ going from $t^\ast_k$ to $t^\ast_i = \lambda \overline{\xi}$.

    Then the pointers of the traversal $t^\ast$ and the sequence of move $\tilde{u}$ are the same and we obtain the equality of the
    \emph{justified} sequences:
    \begin{equation}
    \varphi_{M}(t^\ast) \jseq \tilde{u}. \label{eq:def_tstar}
    \end{equation}

    \item Finally, we need to ensure that the sequence $t^\ast$ is a valid justified sequence of $\tau(M)$.
    This requires us to check the validity of the the pointers introduced in $t^\ast$.
    Suppose $u_k$ points to $q_C$ in $\tilde{u}$ then $u_k$ belongs to the arena $A$. More precisely it is one
    of the root $q^1 \ldots q^n$ of the arena $A$. Therefore $u_k$ must belong to the sequence $\tilde{w}$ and
    for some $r \geq 0$, $u_k = \varphi^{-1}_{N'_j}(t'_r)$ and $t^\ast_k = t'_r$.

    The arena of the term $\emptyset \vdash N'_j = \lambda \overline{\xi} . N_j$ is of the following form (only question moves are represented):
        $$ \tree{ q }
        {   \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
        }$$
    We observe from the definition of $\varphi_{N'_j}$ that the
    only node that are mapped to the question  $q^1 \ldots q^n$ are labelled $\xi_i$ or $\xi_i @$ for some $i\in 1..n$.
    Consequently $t^\ast_k = \xi_i$ and the node $t^\ast_k$ is bound by the node $\lambda \overline{\xi}$.
    Hence the added pointer is indeed valid.
    \end{itemize}

    \vspace{5pt}

    For any justified sequence of nodes $t$ we define the justified sequence of nodes $t \upharpoonright A,C$
    to be the subsequence of $t$ constituted of nodes $n$
    verifying $\varphi_M(n) \in A \union C$ together with the same
    pointers as the justified sequence of move $\varphi_M(t) \upharpoonright A,C$ (here the
    operator $\upharpoonright$ denotes the filtering operator
    defined on justified sequence of moves).

    The effect of this transformation is to remove from $t^\ast$ all the elements at positions $i$ such that $\tilde{u}_i \in B$.
    We obtain a justified sequence of nodes $t^\dagger = t^\ast \upharpoonright A,C$
    verifying
        $$\varphi_{M}(t^\dagger) \jseq \tilde{s}$$

    $t^\dagger$ is also a reduced-traversal of $\tau(M)$.

    \textbf{Example}: Let us illustrate each step of the demonstration on a short example.
        For clarity only some relevant pointers are specified in the following justified sequences.
    $$
    \xymatrix @=3pt{
        & \tilde{u} &=& q_C & m_1 & q_C & m_3 & m_4 & q_C & m_6 & m_7 & q_C & \ldots \\
        & &\in& C & B & C & A & A & C & B & B & C & \ldots \\
        \mbox{ (equation \ref{eq:def_s})} & \tilde{s} &=& q_C & & q_C & m_3  \ar@/_1pc/[l] & m_4 & q_C &  & & q_C & \ldots \\
        \mbox{ (equation \ref{eq:def_w})} & \tilde{w}  &=&  & m_1 &  & m_3 & m_4 &  & m_6 & m_7 &  & \ldots  \\ \\ \\
        \mbox{ (equation \ref{eq:def_t})} & t &=&  & n_1\ar[uuu]^{\varphi_{N'_j}} &  & n_3 \ar[uuu] & n_4\ar[uuu] & & n_6\ar[uuu] & n_7\ar[uuu] &  & \ldots \\ \\
        & \tilde{u}  &=& q_C & m_1 & q_C & m_3 & m_4 & q_C & m_6 & m_7 & q_C & \ldots  \\ \\ \\
        \mbox{ (equation \ref{eq:def_tstar})} & t^\ast &=& \lambda \ar@{=>}[uuu]^{\varphi_{M}} & n_1\ar[uuu]^{\varphi_{N'_j}} & \lambda\ar@{=>}[uuu] & n_3 \ar[uuu] \ar@/_1pc/[l] & n_4\ar[uuu] & \lambda\ar@{=>}[uuu] & n_6\ar[uuu] & n_7\ar[uuu] & \lambda\ar@{=>}[uuu] & \ldots \\
        t^\ast\upharpoonright A,C =& t^\dagger &=& \lambda &  & \lambda & n_3\ar@/_1pc/[l] & n_4 & \lambda & &  & \lambda & \ldots \\
        }
    $$
    Note that there is only one question $q_C$ in the arena $C$ therefore $m_2 = m_5 = m_8 = q_C$.
    It is easy to check that $\varphi(t') \jseq \tilde{s}$
    \end{itemize}
\end{itemize}
\end{proof}

The previous proposition has an equivalent for open terms. Its proof is omitted here. It
follows the same step as for the case of closed terms.
\begin{prop}[Relation between game semantics and reduced-traversals of open terms]
\label{prop:rel_gamesem_redtrav_opened}
Suppose $\Gamma \vdash M : A$. Let $r$ denotes the root of $\tau(M)$. If $s$ is a justified sequence of moves such
that $s \in \sem{\Gamma \vdash M:A}$ then there is a reduced-traversal of nodes of $\tau(M)$
$t = n_0 n_1 \ldots$ such that:
 $$\tilde{s} \upharpoonright \sem{A} \jseq  \varphi_M (t \upharpoonright \{r \})$$
and
$$\forall i \geq 0 . \tilde{s}_i = \varphi_M(t_i) \not \in \sem{A}
\implies \left\{
        \begin{array}{ll}
            t_i = x \mbox{ or } t_i = x@, \hbox{where } x \in \Gamma \\
            \varphi_M(t \upharpoonright \{t_i\}) \jseq \tilde{s} \upharpoonright \{ \varphi_M(t_i) \}
        \end{array}
        \right.
$$
\end{prop}

\begin{property}
\label{proper:phi_pview}
Suppose $\varphi(t) \jseq s$ where $s$ is a justified sequence of moves and
$t$ is a justified sequence of nodes then
\begin{itemize}
\item (i) $s$ and $t$ have the same pointers.
\item (ii) the P-view of $\tilde{s}$ and the P-view of $t$ are computed
identically: the set of indices of elements that must be removed from both sequences
in order to obtain their P-view is the same.
\item (iii) the O-view of $\tilde{s}$ and the O-view of $t$ are computed identically.
\end{itemize}
\end{property}
\begin{proof}
(i): By definition of $\varphi$, $t$ and $\varphi(t)$ have the same pointers.

(ii) and (iii): $\varphi$ maps lambda nodes to
O-question and non-lambda nodes to P-question. Therefore since $t$ and $s$ have the same
pointers, the computations of the P-view (resp. O-view) of the sequence of moves and the P-view
(resp. O-view) of the sequence of nodes follow the same steps.
\end{proof}

\subsection{Pointers in the game semantics of safe terms are recoverable}

The computation tree of safe terms verifies a property called regularity:
\begin{property}[Computation tree of safe terms are regular]
\label{proper:regularity}
If $M$ is a safe term then any node of the computation tree $\tau(M)$ labelled $x$ or $x@$ where
$x$ is a variable bound in $M$ is bound by the first $\lambda$-node in the path to the root that has
order greater or equal to $\ord{x}$.
\end{property}
\begin{proof}
(a) In the safe $\lambda$-calculus when applying the abstraction rule the variables in the lowest partition of the context
(smallest order) must all be abstracted together. Translating this to the computation tree point of view
(where consecutive abstractions are merged into a single node), it gives :
for each lambda node $\lambda \overline{\xi}$, any variable $x$ occurring free in $\kappa(\lambda \overline{\xi})$
has order strictly greater than $\ord{\lambda \overline{\xi}}$.

(b) If $x$ is bound by a node $\lambda \overline{\xi}$ then
$\ord{\lambda \overline{\xi}} \geq \ord{x}$.

(c) $t$ satisfies P-visibility (property \ref{proper:pviewtrav_is_path}) therefore $x$ points
to a lambda-node in the P-view at that point.
By property \ref{proper:pviewtrav_is_path} the P-view $\pview{t}$ is
the path in $\tau(M)$ from the root to the node $n$.

Consider the lambda nodes occurring in this path:
$\lambda \overline{\eta_p}, \ldots, \lambda \overline{\eta_1}$
(the bigger the index is the closer the nodes is to the root).

Since $x$ is not free in $M$, it must be bound by one of the nodes
$\lambda \overline{\eta_1}, \ldots, \lambda \overline{\eta_p}$.
Take $i$ the smallest index such that $\ord{\lambda \overline{\eta_i}} \geq \ord{x}$ ((b) guarantees the existence of $i$).

The nodes $\lambda \overline{\eta_j}$ for $j<i$ are of order smaller than $\ord{x}$ therefore
by (b) for all $j<i$, $x \not\in \overline{\eta_j}$. Suppose that $x \not\in \overline{\eta_i}$ then $x$ occurs free in
$\kappa(\lambda \overline{\eta_i})$. By (a) this implies
$\ord{x} > \ord{\lambda \overline{\eta_i}}$ which is a contradiction.
Hence $x \in \overline{\eta_i}$.

Hence the first $\lambda$-node in the path to the root whose order is greater or equal to $\ord{x}$
is also the first $\lambda$-node $\lambda \overline{\xi}$ in the path to the root such that $x \in \overline{\xi}$.
\end{proof}


\begin{prop}
The pointers in the game semantics of safe terms are
uniquely recoverable.
\end{prop}

\begin{proof}
Let $\Gamma \vdash M : A$ be an opened safe term where $\Gamma = y_1:Y_1, \ldots y_n:Y_n$.
We assume that $M$ is in $\beta \eta$-long normal form : the $\eta$-long normal form of the $\beta$-normal form.
It is a safe assumption since safety is preserved by $\eta$-expansion and $\beta$-reduction.

Consider a justified sequence of move $s \in \sem{\Gamma \vdash M}$. Firstly,
we remark that the pointers for O and P answer moves in $s$ can all be
recovered thanks to the well-bracketing condition.

Let us prove by induction that the pointers for question moves can be recovered.

\emph{Base case}: if $s \in \sem{M}$ where $|s| \leq 1$ then there is no pointer to recover.

\emph{Step case}: suppose $s \in \sem{M}$ with $|s| > 1$. Let $q$ denotes the last move in $s$.

Consider the closed term $M'  = \lambda \overline{y} . M$.
Up to a retagging of the moves, the justified sequence of moves $s$ belongs to the strategy
$\sem{\vdash \lambda \overline{y} . M} = \Lambda^n(\sem{\Gamma \vdash M})$.

Proposition \ref{prop:rel_gamesem_redtrav_closed} tells us that
there is a reduced-traversal $r$ of $\tau(M')$ such that:
$$\varphi_{M'}(r) \jseq \tilde{s}.$$

Let us note $n$ the last node in the sequence $r$
and $root$ the root of $\tau(M')$.
$r$ is a reduced-traversal therefore by remark \ref{rem:redtrav}:
$$ r \jseq t \upharpoonright \{ root \} $$
for some traversal $t$ whose last node $n$ is hereditarily justified by $root$.

\begin{itemize}
\item Suppose $q$ is a P-move.

Since $r$ is a reduced-traversal of $\tau(M')$ and $M'$ is in $\beta
\eta$-long normal form, lemma \ref{lem:redtrav_trav} (i) gives:
\begin{equation}
 \pview{r} \jseq \pview{t} \upharpoonright \{ root \} \label{eq:pre_pview_r}
\end{equation}

%% REMOVED
%%By property \ref{proper:betaeta_trav}, the nodes that are not hereditarily justified by the root are
%%exactly the nodes that are hereditarily justified by $N_\Sigma$.
%%Since $\Sigma$ contains only constant of order $1$ at most, the only nodes that are hereditarily justified by $N_\Sigma$ are the nodes
%%in $N_\Sigma \union Succ(N_\Sigma)$. Hence equation \label{eq:pre_pview_r} becomes:
%%\begin{equation}
%% \pview{r} \jseq \pview{t} \setminus \left( N_\Sigma \union Succ(N_\Sigma) \right) \label{eq:pview_r}
%%\end{equation}

Property \ref{proper:pviewtrav_is_path} gives us that $\pview{t}$ is
the path in $\tau(M)$ from the root to the node $n$.
Hence the regularity of $\tau(M)$ (property \ref{proper:regularity}) tells us that $n$ points to the
last $\lambda$-node in $\pview{t}$ (the path from the root to $n$) that has order greater or equal to $\ord{n}$.

Since $n$ is the last node of $\pview{t} \upharpoonright \{ root \}$, it is hereditarily justified by the root and
it must point to a node $m$ in $\pview{t}$ that is also hereditarily justified by the root (i.e. $m$ also occurs in $\pview{r}$).
But $m$ is the last $\lambda$-node in $\pview{t}$ that has order greater or equal to $\ord{n}$, therefore
since $\pview{r}$ is a subsequence of $\pview{t}$, $m$ is also the
last $\lambda$-node in $\pview{r}$ that has order greater or equal to $\ord{n}$.


%The lambda nodes in $N_\Sigma \union Succ(N_\Sigma)$ are exactly the
%nodes in $Succ(N_{\Sigma})$, they are all labelled $\lambda$ and
%hence are of order $-1$. Moreover we have $\ord{n} \geq 0$ therefore
%the last $\lambda$-node in $\pview{t}$ that has order greater or
%equal to $\ord{n}$ is also the last node in $\pview{r} = \pview{t}
%\setminus \left( N_\Sigma \union Succ(N_\Sigma) \right)$ that has
%order greater or equal to $\ord{n}$.

By property \ref{proper:phi_pview} (ii), the P-view of $\tilde{s}$ and the P-view of $r$ are computed
similarly and have the same pointers. This means that
node $n$ and  move $q$ point to the same position in
the justified sequence $\pview{r}$ and $\pview{\tilde{s}}$ respectively.

Finally, by the induction hypothesis, the pointers of $s$ can been recovered up to the last move $q$: this
ensures that the P-view $\pview{\tilde{s}}$ can be computed.

Since $\varphi$ maps nodes of a given order to moves of the same order (property \ref{proper:phi_conserve_order}),
$q$ also points to the last O-move in $\pview{\tilde{s}}$ whose
order is greater or equal to $\ord{q}$.

\item Suppose $q$ is an O-move.

$M'$ is in $\beta\eta$-long normal form and $t$ is a traversal of $\tau(M')$
whose last node $n$ is hereditarily justified by $root$. Therefore  by lemma \ref{lem:redtrav_trav} (ii):
\begin{equation}
 \oview{r} \jseq \oview{t} \label{eq:oview_r}
\end{equation}


A lambda-nodes $n$ always points to its parent node $p$, therefore
verifying the relation $\ord{p} > \ord{n}$. By inspecting the
formation rules of traversals (definition \ref{def:traversal}) one
can check that a lambda-node $n$ occurring in a traversal always
points to the last node in the O-view at that point whose order is
strictly greater that $\ord{n}$ (there are just two cases, $n$
points either to the preceding node or to the third previous node in
its O-view).

Similarly as in the P-move case, we conclude that $q$ points to the last move in
the O-view of $\tilde{s}$ having an order strictly greater than $\ord{q}$,
the induction hypothesis guaranteeing that the O-view $\oview{\tilde{s}}$ is computable.

\end{itemize}

\end{proof}
