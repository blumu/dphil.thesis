\def\cmptre#1{\tau(#1)}
\def\aux#1{\lceil #1\rceil}
\def\nf#1{\eta_{\sf nf}(#1)}

\section{Game semantics of safe $\lambda$-terms}

In this section we will prove that the safety condition
of section \ref{sec:safe_alt} leads to a pointer economy in the game
semantics: for safe $\lambda$-terms the pointers from the game semantics can be reconstructed uniquely from the moves of
the play.

The example of section \ref{subsec:ptrless_strat} gives the intuition.
Remember that in order to distinguish the terms $M_1$ and $M_2$,
we introduced pointers in strategies. In the safe $\lambda$-calculus
this ambiguity disappears because $M_2$ is not a safe term. Indeed, in the
sub-term $f (\lambda y . x)$, the free variable $x$
has the same order as $y$ but $x$ is not abstracted together
with $y$.


%\begin{enumerate}
%\item
%Is there any unsafe term whose game semantics is a strategy where
%pointers can be recovered?
%
%The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
%where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
%$\beta$-reduce to the safe term $S$, therefore
%$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
%unsafe. Since it is possible to recover the pointer from the game
%semantics of $S$, it is as well possible to recover the pointer from
%the semantics of $T_2$ which is unsafe.
%
%\item
%Is there any unsafe $\beta$-normal form whose game semantics is a
%strategy where pointers can be recovered?
%\end{enumerate}






\subsection{$\eta$-long normal form}

The $\eta$-expansion of $M: A\typear B$ is defined to be the term $\lambda x . M x : A\typear B$ where $x:A$ is a fresh variable.
It is easy to check that if $M$ is safe then $\lambda x . M x$ is also safe.

Consider the term $M : (A_1,\ldots,A_n,o)$, it can be expanded in several steps into
$\lambda \varphi_1 \ldots \varphi_l . M \varphi_1 \ldots \varphi_l$
where the $\varphi_i:A_i$ are fresh variables.

The $\eta$-normal form of a term is obtained by hereditarily $\eta$-expanding every sub-term occurring
at an operand position:

\begin{dfn}[$\eta$-long normal form]
A term is either an abstraction or it can be written uniquely as
$s_0 s_1 \ldots s_m$ where $m\geq0$ and $s_0$ is a variable, a
constant or an abstraction.

The $\eta$-long normal form of a term $M$ is denoted $\aux{M}$ and
is defined as follow:
\begin{eqnarray*}
\aux{x s_1 \ldots s_m : (A_1,\ldots,A_n,o)} &=& \lambda \overline{\varphi} . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \aux{\varphi_1} \ldots \aux{\varphi_n} \\
\aux{x s_1 \ldots s_m : o} &=& \lambda . x \aux{s_1} \aux{s_2} \ldots \aux{s_m} \\
\aux{(\lambda x . s_0) s_1 \ldots s_m } &=& (\lambda x . \aux{s_0}) \aux{s_1} \aux{s_2} \ldots \aux{s_m}
\end{eqnarray*}
where $m \geq 0$ and $x$ is either a variable or a constant.
\end{dfn}

The $\eta$-long normal form appeared in \citep{DBLP:journals/tcs/JensenP76}
under the name \emph{long reduced form}
and in \citep{DBLP:journals/tcs/Huet75}
under the name \emph{$\eta$-normal form}. It was then investigated in \citep{huet76}
under the name \emph{extensional form}.


A term can be represented by a tree defined formally by induction on the structure
of its $\eta$-long normal form as follow:

\begin{dfn}[Computation tree]
The computation tree associated to the term $s$ is noted
$\cmptre{s}$. It is obtained by applying the following rules
inductively \emph{on the $\eta$-long normal form} of $s$. In the
following $x$ is either a variable or a constant.
\begin{itemize}
\item the tree for $\lambda x_1 \ldots x_n. M$ where $M$ is not an abstraction is:
$$ \cmptre{\lambda x_1 \ldots x_n . M} =
  \pstree[levelsep=4ex]
    { \TR{\lambda x_1 \ldots x_n} }
    { \SubTree{\cmptre{M}}
    }
$$


\item the tree for $x s_1 \ldots s_n$ is:
$$ \cmptre{ x s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{x @} }
    { \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$

\item the tree for $x$ is the single leaf $x$.

\item the tree for $(\lambda x.s_0) s_1 \ldots s_n$ is:
$$ \cmptre{(\lambda x.s_0) s_1 \ldots s_n} =
  \pstree[levelsep=4ex]
    { \TR{@} }
    {
    \SubTree{\cmptre{\lambda x.s_0}}    \SubTree{\cmptre{s_1}} \SubTree[linestyle=none]{\ldots} \SubTree{\cmptre{s_n}}
    }
$$
\end{itemize}
\end{dfn}

Example: if $x$ is a variable or a constant then
$ \cmptre{\lambda . x} =
  \pstree[levelsep=3ex]
    { \TR{\lambda } }
    { \TR{x}
    }$

The nodes (and leaves) of the tree are of three kinds:
\begin{itemize}
\item $\lambda$-node labeled $\lambda \overline{x}$. A $\lambda$-node represents several consecutive abstractions of variables.
\item application node labeled $@$
\item operator-application nodes labeled $x @$ where the operator $x$ is
either a variable or a constant.
\end{itemize}

A sub-tree of the computation tree represents a $\lambda$-term. We
define the map $\kappa : N \rightarrow \mathcal{T}$ where $N$
denotes the set of nodes and leaves of the computation tree
$\tau(s)$ and $\mathcal{T}$ denotes the set of $\lambda$-terms.
$\kappa$ associates to any node $n$ of the tree the $\lambda$-term
$\kappa(n)$ that is represented by the sub-tree of $\tau(s)$ rooted
at $n$. In particular if $r$ is the root of the tree $\tau(s)$ then
$\kappa(s) = \aux{s}$.



Consider the computation tree $\tau(s)$ of a term $s$ in $\eta$-long normal form. Then:
\begin{itemize}
\item One can check that nodes at even level are abstraction
node and nodes at odd level are either application nodes,
operator-application nodes, variable or constant nodes (the root level being numbered $0$).

\item Suppose that a variable $x$ occurs in $s$. The corresponding node in the tree has of one of the two following forms:
    \begin{itemize}
    \item $ \pstree[levelsep=3ex]
        { \TR{\lambda } }
        { \TR{x}
        }$ where $\ord{x} = 0$

    \item $ \pstree[levelsep=3ex]
                { \TR{x @} }
                { \TR{\lambda \overline{\xi_1}} \TR{\ldots} \TR{\lambda \overline{\xi_p}}}
        $ where $\ord{x} > 0$ and $x:(A_1,\ldots,A_p,o)$
    \end{itemize}

\item    Moreover for any abstraction node
        $ \pstree[levelsep=4ex]
            { \TR{\lambda \overline{\varphi}} }
            { \pstree[levelsep=3ex]
                {\TR{@^{[n]}}}
                {\TR{\lambda \overline{\xi_1}} \ldots \TR{\lambda \overline{\xi_p}}}
            }
        $
    we have $\ord{\kappa(@^{[n]})}=0$

\end{itemize}

\subsubsection{Pointers and justified sequence of nodes}

We introduce pointer in the computation tree: a node $n$ labeled
with the variable $x$ points to a lambda node $m$ labeled $\lambda
\overline{\varphi}$ if and only if the variable $x$ is bound in
$\kappa(m)$ by the abstraction $\lambda \overline{\varphi}$. In that
case we say that the node $n$ is bound by $m$. Additionally a lambda node points to its parent node.

To sum up a justification pointer goes upward from a variable occurrence to its bindings or from an abstraction node to its parent node.


We call \emph{traversal} or \emph{justified sequence of nodes} any sequence of nodes of the computation tree together
with links as defined above.

\subsection{Correspondence with game semantics}

By representing side-by-side the computation tree and the type arena of a term in $\eta$-normal form we observe
that for each question move of the arena there are corresponding nodes in the computation tree.

\begin{exmp}
Consider the following term $M \equiv \lambda f z . (\lambda g x . f (f x)) (\lambda y. y) z$ of type $(o \typear o) \typear o \typear o$.
Its $\eta$-long normal form is $\lambda f z . (\lambda g x . f (f x)) (\lambda y. y) (\lambda .z)$.
The computation tree is:

$$
\tree{\lambda f z}
{ \tree{@}
    {
        \tree{\lambda g x}
            { \tree{f@}{   \tree{\lambda}{ \tree{f@}{  \tree{\lambda}{\TR{x}}} }  }
            }
        \tree{\lambda y}{\TR{y}}
        \tree{\lambda}{\TR{z}}
    }
}
$$

The arena for the type $(o \typear o) \typear o \typear o$ is:
$$\tree{q^1}
{
    \tree{q^3}
        {  \tree{q^4}
                {\TR{a^4_1} \TR{\ldots}}
            \TR{a^3_1} \TR{\ldots} }
    \tree{q^2}
    { \TR{a^2_1} \TR{a^2_2}\TR{\ldots} }
    \TR{a_1} \TR{a_2}\TR{\ldots}
}
$$

\newlength{\yNull}
\def\bow{\quad\psarc{->}(0,\yNull){1.5ex}{90}{270}}

We now omit the answers moves when we represent the arena.
The arena is represented on the right and the computation tree on the left.

The dashed line defines a relation $\varphi$ from the set of question moves to nodes in the computation tree.
$\varphi$ maps each question to one or more nodes in the computation tree:
$$
\tree{ \Rnode{root} {\lambda f z}^{[1]} }
     {  \tree{@^{[2]}}
        {   \tree{\lambda g x ^{[3]}}
                { \tree{\Rnode{f}{f@^{[6]}}}{  \tree{\Rnode{lmd}\lambda^{[7]}}{ \tree{\Rnode{f2}{f@^{[8]}}} {\tree{\Rnode{lmd2}\lambda^{[9]}}{\TR{x^{[10]}}}}}  }
                }
            \tree{\lambda y ^{[4]}}{\TR{y}}
            \tree{\lambda ^{[5]}}{\TR{\Rnode{z}z}}
        }
    }
\hspace{3cm}
  \tree[levelsep=12ex]{ \Rnode{q1}q^1 }
    {   \pstree[levelsep=4ex]{\TR{\Rnode{q3}q^3}}{\TR{\Rnode{q4}q^4}}
        \TR{\Rnode{q2}q^2}
    }
\psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
\ncline{<-}{root}{q1} \aput*{:U}{\varphi}
\ncarc{->}{q2}{z}
\ncline{->}{q3}{f}
\ncline{->}{q4}{lmd}
\ncline{->}{q3}{f2}
\ncline{->}{q4}{lmd2}
$$

Consider the justified sequence of moves $s \in \sem{M}$:
\vspace{0.5cm}
 $$s =
\rnode{q1}{q}^1\
\rnode{q3}{q}^3\
\rnode{q4}{q}^4\
\rnode{q3b}{q}^3\
\rnode{q4b}{q}^4\
\rnode{q2}{q}^2
\bkptrc{q3}{q1}
\bkptrc[ncurv=0.5]{q3b}{q1}
\bkptrc{q4}{q3}
\bkptrc{q4b}{q3b}
\bkptrc[ncurv=0.5]{q2}{q1}
\in \sem{M}$$

There is a corresponding justified sequence of nodes in the computation tree:
\vspace{0.5cm}
$$t =
\rnode{q1}{\lambda f z} \cdot
\rnode{q3}{f@}^{[6]} \cdot
\rnode{q4}{\lambda^{[7]}} \cdot
\rnode{q3b}{f@}^{[8]} \cdot
\rnode{q4b}{\lambda^{[9]}} \cdot
\rnode{q2}{z}
\bkptra[ncurv=1]{60}{q3}{q1}
\bkptra[ncurv=1]{60}{q4}{q3}
\bkptra[ncurv=0.4]{75}{q3b}{q1}
\bkptra[ncurv=0.8]{70}{q4b}{q3b}
\bkptra[ncurv=0.4]{80}{q2}{q1}$$
such that $t_i = \varphi(s_i)$ for all $i < |s|$.

We see on this example that the game semantics and the computation tree are somehow related to each other.
\end{exmp}

Let us now define precisely the relationship between game semantics and computation tree.

First we define the map $\varphi$ that associate a set of nodes in the computation tree to any
question-move of the game semantics of the term.

\begin{dfn}[Relation between question-moves and nodes]
Let $\Gamma \vdash M : A$ be a term in $\eta$-long normal form.
Suppose $(M,\vdash)$ is the arena $\sem{A}$ where $M$ is the set of moves and $\vdash$ is the enabling relation.
$M^Q \subseteq M$ denotes the set of question moves.
We note $(N,E)$ the computation tree $\tau(M)$ where $N$ is the set of nodes and leaves of the tree and $E$ is the parent-child relation.


We give an algorithm to compute the partial function $\varphi^{-1} : N \rightarrow M^Q$.
The total function $\varphi : M^Q \rightarrow \mathcal{P}(N)$ can then be obtained from
$\varphi^{-1}$.

We define $\varphi^{-1} = f(0,q^0)$ where the index $0$ denotes
the root of the computation tree, $q^0$ is the root of the arena
(in the game semantics of simply-typed lambda calculus the arenas involved
are always trees (single root)) and $f$ is defined below.

The procedure $f$ takes two parameters: $n$ is the index number of a
$\lambda$-node in the computation tree and $q$ is a question move of the arena
of $\Gamma \vdash M : A$ such that $q$ and $\kappa(n)$ have the same type.

Similarly we define the procedure $g$ that
takes two parameters: $n$ is the index number of a
$x@$-labelled node or a $x$-labelled node in the computation tree and $q$ is a question move
of the arena of $\Gamma \vdash M : A$ such that $q$ and $x$ have the same type.
\\

\noindent
\begin{description}
\item[\textbf{Procedure} $f(nd,q)$]
    where $nd$ is a $\lambda$-node.

    \begin{itemize}
    \item If $\ord{\kappa(nd)} = 0$ then the term is of ground type therefore
    the game for $M$ is played on the flat arena
    with only one question $q$. Moreover the node $nd$ of the computation tree is labelled with $\lambda$.\\
    \textbf{return} $\{ nd \mapsto q \}$.

    \item $\ord{\kappa(nd)} > 0$. The computation tree and the arena
    have the following form:
    $$ \tree[levelsep=6ex]{ \Rnode{r}\lambda \overline{\xi}_n  ^{[nd]}}
        {
            \tree[levelsep=6ex]{x@^{[nd+1]}}
            {   \TR{\lambda^{[\ldots]}} \TR{\ldots} \TR{\lambda^{[\ldots]}}
            }
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^n}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi}_n \vdash \kappa(x@^{[nd+1]}) : o$.

    For each of the abstracted variable $\xi_i$ there is a corresponding question move $q_i$ of the same order
    in the arena.  Each free occurrence of the variable $\xi_i$ is mapped to the move $q_i$
    by the procedure $g$.

    $$\mathbf{return} \ \{ nd \mapsto q \}
    \union
    \Union_{\stackrel{i=1..n}{\xi_i^{[k]} \in Desc(nd)}} g ( k, q_i)
    \quad \union \quad
    \Union_{\stackrel{i=1..n}{@\xi_i^{[k]} \in Desc(nd)}} g ( k, q_i)
    $$
    where $Desc(nd)$ is the set of descendants of  node $nd$
    (the set of node $m$ such that there is a path from node $nd$ to node $m$ in the computation
    tree).

    \end{itemize}

\item[\textbf{Procedure} $g(nd,q)$]\  \\
The procedure is not defined on $\lambda$-nodes or $@$ nodes.
This is ok since for all the calls $g(nd,q)$ in $f$ are such that $nd$ denotes a $@x$-node or a $x$-node.

\begin{itemize}
\item[case 1] Suppose that $nd$ is labelled with $x$ then we must have $x:0$. \textbf{return}
$\{ nd \mapsto q \}$.

\item[case 2] If $nd$ is labelled with $x@$ then $x:(A_1|\ldots|A_m|o)$.
The computation tree and the arena  have the following form:

    $$\tree[levelsep=6ex]{\Rnode{r}{x@^{[nd]}}}
        {   \tree{\TR{\lambda^{[k_1]}}}{\vdots} \TR{\ldots}
        \tree{\TR{\lambda^{[k_m]}}}{\vdots}
        }
    \hspace{3cm}
    \tree{ \Rnode{q0}q }
        {
            \tree[linestyle=dotted]{\Rnode{q1}{q^1}}{\TR{} \TR{} }
            \tree[linestyle=dotted]{\Rnode{q2}{q^2}}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{\Rnode{qm}{q^m}}{\TR{} \TR{} }
        }
    \psset{nodesep=1pt,arrows=->,arcangle=-20,arrowsize=2pt 1,linestyle=dashed,linewidth=0.3pt}
    \ncline{->}{r}{q0}
    \ncarc{->}{q2}{z}
    \ncline{->}{q3}{f}
    \ncline{->}{q4}{lmd}
    \ncline{->}{q3}{f2}
    \ncline{->}{q4}{lmd2}
    $$

    such that $\Gamma, \overline{\xi}_n \vdash \kappa(x@^{[nd]}) : o$.

    For each of the children node of $nd$
    there is a corresponding question move $q_i$ of the same type
    in the arena.
    $$\mathbf{return} \ \{ nd \mapsto q \} \union
    \Union_{i=1..m} f ( k_i, q_i)
    $$
\end{itemize}
\end{description}
\end{dfn}

We remark that the function $\varphi : M^Q \rightarrow N$ is such that player O questions are associated to $\lambda$-nodes
and player P questions are associated to nodes of type $x @$ or $x$ where $x$ is variable or a constant.


Notation: Suppose $s$ is a justified sequence of moves then we note $\tilde{s}$
the subsequence of $s$ consisting of question moves only:
\begin{eqnarray*}
\tilde{} &: L_A &\longrightarrow (M^Q)^* \\
& s &\longmapsto \tilde{s} = s \upharpoonright M^Q
\end{eqnarray*}
where $M^Q$ denotes the set of question moves.
$\tilde{s}$ is also a justified sequence of move (there is no dangling pointer since questions moves points to other question moves).


\begin{prop}[Justified sequence of moves -- traversal in the computation tree]
Let $s$ be a justified sequence of moves such that $s \in \sem{\Gamma \vdash M:A}$ then
there is a traversal $t = n_0 n_1 \ldots$ such that $\tilde{s} = \varphi^{-1} (t)$ (i.e. $\tilde{s} = \varphi^{-1}(n_0)\ \varphi^{-1}(n_1) \ldots$)
\end{prop}
\begin{proof}
By induction on the structure of $M$ in $\eta$-long normal form.
Let $\Gamma = \{y_1, : B_1, \ldots , y_r : B_r \}$ and $s$ be as justified sequence of moves in $\sem{\Gamma \vdash M}$.

\begin{itemize}
  \item Suppose that $\ord{M} = 0$ then the arena is of the following form (only question moves are represented):
    $$ \tree{ q }
        {   \tree[linestyle=dotted]{q^1}{\TR{} \TR{} }
            \tree[linestyle=dotted]{q^2}{\TR{} \TR{} }
            \TR{\ldots}
            \tree[linestyle=dotted]{q^r}{\TR{} \TR{} }
        }$$
        \begin{itemize}
        \item Suppose that $\Gamma \vdash \lambda. y_i : o$. Then $\sem{M} = \pi_i$ and the only question move that can occur
                in $s \in \pi_i$ is $q$. Take $t = \tilde{s}[\lambda/q]$. It is clear that $\varphi^{-1}(t) = \tilde{s}$.

        \item $\Gamma \vdash h_0 h_1 \ldots h_p : o$ where $\Gamma \vdash h_0 : (A_1,\ldots,A_p,o)$ and $\Gamma \vdash h_1 : A_1, \ldots, \Gamma \vdash h_p:A_p$.
        Then $$
            \sem{\Gamma \vdash h_0 h_1 \ldots h_p : o} = \overbrace{\langle \sem{\Gamma \vdash h_0}, \ldots, \sem{\Gamma \vdash h_p} \rangle}^\sigma ; ev_{A_1,\ldots,A_p,o}
            $$
        with $\sigma : A \longrightarrow B$ , $ev_{A_1,\ldots,A_p,o} : B \longrightarrow C$ where
        \begin{eqnarray*}
         A &=& \sem{\Gamma} \\
         B &=& \sem{(A_1,\ldots,A_p,o)} \times H_1 \times \ldots \times H_p \\
         C &=& \sem{o} \\
         H_j &=& \sem{A_j} \mbox{ for }j \in 1..p
        \end{eqnarray*}

        Consequently $s = u \upharpoonright A, C$ for some $u \in \sigma \parallel ev_{A_1,\ldots,A_p,o}$. More precisely:
        \begin{eqnarray*}
          u &\in& int(A,B,C) \\
          w = u \upharpoonright A,B & \in& \sigma \\
          u \upharpoonright B,C & \in & ev
        \end{eqnarray*}

        $w \in \sigma$ implies that for some $j \in 1..p$:
        \begin{eqnarray}
          z = w \upharpoonright A, H_j &\in& \sem{h_j}  \label{eq:a} \\
          \mbox{ and for every } k\neq j &:& w \upharpoonright H_k = \epsilon \label{eq:b}
        \end{eqnarray}

        Equation \ref{eq:a} allows us to use the induction hypothesis on the term $h_j$:
        there is a traversal $t$ of the tree $\tau(h_j)$ such that $\varphi^{-1}(t) = \tilde{z}$.



        It suffices to take $t'' = (t[\lambda / \cdot]) \upharpoonright A,C$ where
        the filtering operator $\upharpoonright$ is defined on traversal as follow:
        $t\upharpoonright A$ is the subsequence of the traversal $t$ constituted of the nodes $n$ of $t$ verifying
        $\varphi^{-1}(n) \in A$.

        \textbf{Example}: for clarity the pointers are not specified in the following justified sequences.

        $$
        \xymatrix @=1pt{
          & \tilde{u} &=& m_0 & m_1 & m_2 & m_3 & m_4 & m_5 & m_6 & m_7 & m_8 & \ldots \\
          & &\in& A & B & C & A & B & C & A & B & C & \ldots \\
          \tilde{u} \upharpoonright A, C =& \tilde{s} &=& m_0 & \cdot & m_2 & m_3 & \cdot & m_5 & m_6 & \cdot & m_8 & \ldots \\
          \tilde{u} \upharpoonright A, B =& \tilde{w} &=& m_0 & m_1 & \cdot & m_3 & m_4 & \cdot & m_6 & m_7 & \cdot & \ldots \\
          (\ast)\ \tilde{w} \upharpoonright A, H_j = & \tilde{z}  &=& m_0 & m_1 & \cdot & m_3 & m_4 & \cdot & m_6 & m_7 & \cdot & \ldots  \\ \\ \\
          HI \imp \exists t | \varphi^{-1}(t) = \tilde{z}: & t &=& N_0 \ar[uuu]^{\varphi^{-1}} & N_1 & \cdot & N_3 \ar[uuu] & N_4\ar[uuu] & \cdot & N_6\ar[uuu] & N_7\ar[uuu] & \cdot & \ldots \\
          t[\lambda/\cdot] =& t' &=& N_0 & N_1 & \lambda & N_3 & N_4 & \lambda & N_6 & N_7 & \lambda & \ldots \\
          t'\upharpoonright A,C =& t'' &=& N_0 & \cdot & \lambda & N_3 & \cdot & \lambda & N_6 & \cdot & \lambda & \ldots \\
          }
        $$
        It is easy to check that $\varphi^{-1}(t'') = \tilde{s}$



        ($\ast$) $z = w \upharpoonright A, H_j$ therefore $\tilde{z} = \tilde{w} \upharpoonright A, H_j$. Moreover
        since for $k\neq h : w \upharpoonright H_k = \epsilon$ the moves of the sequence
        $\tilde{z}$ belonging to the arena $B$ are in fact moves of the arena $H_j$. And consequently,
        moves of the sequence $\tilde{s}$ belonging to the arena $B$ are in fact moves of the arena $H_j$.

        \end{itemize}

    \item Suppose that $\ord{M} > 0$ then $M = \lambda \overline{\xi} . N : \overline{A}|B$ and :
    $$ \sem{\Gamma : M} = \Lambda( \sem{\Gamma,\overline{\xi} \vdash N: B} )$$
\end{itemize}

\end{proof}

\todomargin{to finish}

\subsection{Pointers in the game semantics of safe terms are recoverable}

\begin{prop}
The pointers in the game semantics of safe terms are
uniquely recoverable.
\end{prop}

\begin{proof}
Let $M$ be a safe term, we consider its $\eta$-long normal form $\aux{M}$.
$\aux{M}$ is also safe because safety is preserved by $\eta$-expansion.

We consider a justified sequence of move $s \in \sem{M}$.
First, the pointers for O and P answers can all be recovered by using the well-bracketing condition.

For O-question, the justification pointer always points to its
parent node in the computation tree.

For P-question, suppose P ask for the value of variable $x$. Then
there may be several choices for the destination of the pointer but
we claim that in the case of safe terms, it should point to the
closest parent node (in the path from the root to P-question) whose
order is greater than the order of $x$.
\todomargin{to finish}
\end{proof}
