\section{Homogeneous safe $\lambda$-calculus}
\label{sec:safe_homog}

\subsection{Type homogeneity}
Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \funsp A$. Any type different from the base
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \funsp \cdots \funsp A_n \funsp o$ (by
convention, $\rightarrow$ associates to the right).

We suppose that a ranking function has been defined: ${\sf rank} :
Types \funto (L, \leq)$ where $(L, \leq)$ is any linearly ordered
set. Possible candidates for the ranking function are:
\begin{itemize}
\item ${\sf ord} : Types \funto (\nat,\leq)$ with $\ord{o} = 0$
and $\ord{A \funsp B} = \max(\ord{A}+1, \ord{B})$;
\item ${\sf height} : Types \funto (\nat,\leq)$ with
$\slheight{A \funsp B} = 1 + \max(\slheight{A}, \slheight{B})$ and
$\slheight{o} = 0$ ;
\item ${\sf nparam} : Types \funto (\nat,\leq)$ with $\nparam{o} = 0$
and $\nparam{A_1, \cdots, A_n} = n$;
\item ${\sf ordernp} : Types \funto (\nat \times \nat,\leq)$ with $ {\sf ordernp} (t)  = (\order{t}, \nparam{t})$ for $t \in Types$.
\end{itemize}


Following \cite{KNU02}, a type is rank-homogeneous if it is $o$ or
if it is $(A_1, \cdots, A_n, o)$ with the condition that $\rank{A_1}
\geq \rank{A_2}\geq \cdots \geq \rank{A_n}$ and each $A_1$, \ldots,
$A_n$ is rank-homogeneous.



Suppose that $\overline{A_1}$, $\overline{A_2}$, \ldots,
$\overline{A_n}$ are $n$ lists of types, where $A_{ij}$ denotes the
$j$th type of list $\overline{A_i}$ and $l_i$ the size of
$\overline{A_i}$. Then the notation $A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)$ means that
\begin{itemize}
  \item $A$ is the type $(A_{11},A_{12},\cdots, A_{1l_1}, A_{21}, \cdots,A_{2l_2}, \cdots A_{n1},\cdots, A_{nl_n},o)$
  \item $\forall i: \forall u,v \in A_i : \rank u = \rank v $
  \item $\forall i,j . \forall u \in A_i . \forall v \in A_j . i<j \implies \rank u >
   \rank v $
\end{itemize}
Consequently, $A$ is rank-homogenous. This notation organises the
$A_{ij}$s into partitions according to their ranks. Suppose $B =
(\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$.
We write $(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, |
\, {B})$ to mean
\[(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, | \,
\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o).\]

From now on, we only consider the rank function {\sf ord}. The term
``homogeneous'' will be used to refer to {\sf ord}-homogeneity.


\subsection{Safe recursion scheme}
In \cite{KNU02}, safety is defined as a restriction for homogeneous recursion scheme.
A recursion scheme is homogeneous if:
\begin{itemize}
    \item[(i)] the $\Sigma$ constants are of order 1 at most and therefore have homogeneous types;
    \item[(ii)] the variables in the alphabet $\Delta$ have homogeneous types,
    \item[(iii)] and every non-terminal in the recursion scheme has a homogeneous type.
\end{itemize}

The first and second restriction imposes that every applicative terms in $\mathcal{T}(\Delta)$ must be homogeneous.

There is an obvious transformation mapping simply-typed terms to recursion schemes and reciprocally
(the abstractions of the simply-typed terms correspond to the non-terminals of recursion schemes).

The definition of the Safe $\lambda$-calculus that follows is an adaption of the safety restriction to the simply-typed $\lambda$-calculus.
In \cite{demirandathesis}, it is proved that

\todobox{Introduce safe grammars.}
%In the following we shall consider terms-in-context $\seq{\Gamma}{M
%: A}$ of the simply-typed $\lambda$-calculus.
%Let $\Delta$ be a
%simply-typed alphabet i.e., each symbol in $\Delta$ has a simple
%type.
%We write $\terms{A}{\Delta}$ for the set of terms of type $A$
%built up from the set $\Delta$ understood as constant symbols,
%\emph{without} using $\lambda$-abstraction.

\subsection{Rules of the Safe $\lambda$-Calculus}

The \textbf{Safe $\lambda$-Calculus} is a sub-system of the
simply-typed $\lambda$-calculus. Typing judgements (or
terms-in-context) are of the form:
\begin{equation}
\nonumber \seq{\overline{x_1}:\overline{A_1} \, | \, \cdots \, | \,
\overline{x_n} :  \overline{A_n}}{M : B}
\end{equation}
which is shorthand for $\seq{x_{11} : A_{11}, \cdots, x_{1r}:
A_{1r}, A_{21},\ldots }{M : B}$ such that the context variables are listed in decreasing type order and
 with the condition that $\ord{x_{ik}} < \ord{x_{jl}}$ for any $k, l$ and $i<j$.

\emph{Valid typing judgements} of the system are defined by
induction over the following rules, where $\Delta$ is a given
homogeneously-typed alphabet and $\Sigma$ is a set of
homogeneously-typed constant:

$$ \rulename{wk}
    {   \rulef{ \seq{\Sigma}{M:B} \qquad {\Sigma \subset \Delta} }
             { \seq{\Delta }{M : B}}
   }
\qquad
    \rulename{perm}
    {
      \rulef { \seq{\Gamma}{M:B} \qquad \sigma(\Gamma) \hbox{ homogeneous} }
            { \seq{\sigma(\Gamma)}{M : B} }
    }
$$

$$ \rulename{\Sigma\mbox{\textbf{-const}}}  \rulef{}{\seq{}{b : A}}\ b:A \in \Sigma
\qquad
 \rulename{var} \rulef{}{\seq{x_{ij} : A_{ij}\, }{x_{ij} : A_{ij}}}
$$

$$ \rulename{\lambda\mbox{\textbf{-abs}}}
\rulef{ {\seq{\overline{x_1} : \overline{A_1}\, | \, \cdots\, | \,
\overline{x_{n+1}} : \overline{A_{n+1}}}{M : B}} \qquad
\ord{\overline{A_{n+1}}} \geq \ord{B} -1}
    {\seq{\overline{x_1} :
\overline{A_1}\, | \, \cdots\, | \, \overline{x_{n}} :
\overline{A_{n}}}{\lterm{\overline{x_{n+1}} : \overline{A_{n+1}}}{M}
: (\overline{A_{n+1}} \, | \, B)}} $$

$$ \rulename{app} \rulef{{\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
\seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} :
B_{1l}} \qquad l = |\overline{B_1}| }}
    { \seq{\Gamma}{M N_1
\cdots N_{l} : (\overline{B_2} \, | \, \cdots \, | \,
\overline{B_m} \, | \, o)}} $$

$$ \rulename{app^+} \rulef
    {\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
    \seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} :
    B_{1l}} \qquad l < |\overline{B_1}| }
    { \seq{\Gamma}{M N_1
    \cdots N_{l} : (\overline{B} \, | \, \cdots \, | \,
    \overline{B_m} \, | \, o)}} $$

where $\overline{B_1} = B_{11}, \ldots, B_{1l},\overline{B}$ with
the condition that every variable in $\Gamma$ has an order strictly greater
than $\ord{\overline{B_1}}$.


Rules for the safe $\lambda$-calculus have been first proposed in
\cite{DBLP:conf/fossacs/AehligMO05} and a corrected version is given
in \cite{Ong2005}. The definition that we have given here is
slightly more general in the sense that we authorize the use of
$\Sigma$-constants of any higher-order type whereas the original
definition only allows first order constants.


\begin{property}[Basic properties]
\label{proper:safe_basic_prop} Suppose $\Gamma \vdash M : B$ is a
valid judgment then
\begin{itemize}
\item[(i)] $B$ is homogeneous
\item[(ii)] Every free variables of $M$ has order at least $\ord{M}$
\item[(iii)] $fv(M) \vdash M : B$
\end{itemize}
where $fv(M) \subseteq \Gamma$ denotes the context constituted of the variables
in $\Gamma$ occurring free in $M$.
\end{property}
\begin{proof}
(i) and (ii) An easy proof by structural induction.
(iii) Because the weakening rule is the only rule which can introduce in the context some variable not occurring freely in $M$.
\end{proof}

We now define a special kind of substitution that performs simultaneous substitution and
that permits variable capture (i.e. that does not rename variables when the substitution is performed on an abstraction).

\begin{dfn}[Capture permitting simultaneous substitution (for homogeneous safe terms)]
\label{dnf:safe_simsubst}
 We use the notation $\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1 \ldots x_n}$ and
$\overline{y}:\overline{A}$ for $y_1:A_1, \ldots, y_p:A_p$.
A safe term must have one of the forms occurring on the left-hand side of the following equations, where
the terms $M$, $N_1, \ldots N_l$ are safe terms:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{ where $c$ is a $\Sigma$-constant}\\
x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
(M N_1 \ldots N_l) \subst{\overline{N}}{\overline{x}} &=& (M \subst{\overline{N}}{\overline{x}}) (N_1 \subst{\overline{N}}{\overline{x}}) \ldots  (N_l \subst{\overline{N}}{\overline{x}})\\
(\lambda \overline{y} : \overline{A}. M)
\subst{\overline{N}}{\overline{x}} &=& \lambda \overline{y} . M
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright I} \\
&& \mbox{where } I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y} \}
\end{eqnarray*}

where $ \upharpoonright$ is the index filtering operator: if $s$ is a sequence and $I$ a set of indices then
$s \upharpoonright I$ is the subsequence of $s$ obtained by removing from $s$ all the elements
at a position that is not in $I$.
\end{dfn}

This substitution is well-defined for safe terms in the sense that safety is preserved by substitution:

\begin{lem}[Capture-permitting simultaneous substitution preserves safety]
\label{lem:subst_preserve_safety}
Let $\Gamma \union \overline{x} \vdash M$ be a safe term where $\overline{x}$ denotes a list of variables
(not necessarily belonging to the same partition).

Then for any safe terms safe terms $\Gamma \vdash N_1, \cdots, \Gamma \vdash N_n$,
the capture permitting simultaneous substitution $M[N_1 / x_1 , \cdots, N_n / x_n]$ is safe. i.e. the following judgment is valid :
$$ \Gamma \vdash M[N_1 / x_1 , \cdots, N_n / x_n] $$
\end{lem}
\begin{proof}
An easy proof by an induction on the structure of the safe term.
\end{proof}



With the traditional substitution, it is necessary to rename
variables when performing substitution on an abstraction in order to
avoid possible captures of variables. Hence in general implementing
substitution requires to have access to an unbound number of
variables names. An interesting property of the homogeneous safe
$\lambda$-calculus is that variable capture never occurs when
performing substitution. In other words, the traditional
substitution can be safely replaced by the capture permitting
substitution:

\begin{lem}[No variable capture lemma]
\label{lem:homog_nocapture}
In the safe $\lambda$-calculus, there is no capture of variable
when performing the following capture permitting simultaneous substitution:
$$ M[N_1 / x_1 , \cdots, N_n / x_n] $$
provided that $\Gamma \union \overline{x} \vdash M$, $\Gamma \vdash  N_1, \cdots ,\Gamma \vdash  N_n$ are valid judgments.
\end{lem}

\begin{proof}
We prove the result by induction. The variable, constant and application cases are trivial.
For the abstraction case, suppose $M = \lambda \overline{y} : \overline{A}. P$ where $\overline{y} = y_1 \ldots y_p$. The capture permitting
simultaneous substitution gives:
$$M \subst{\overline{N}}{\overline{x}} = \lambda \overline{y} . P
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright
I} \mbox{ where } I  = \{ i \in 1..n \ | \ x_i \not \in \overline{y}
\}. $$


By the induction hypothesis there is no variable capture in $P
\subst{\overline{N} \upharpoonright I}{\overline{x} \upharpoonright
I}$. Hence the only possible case of variable capture happens when
for some $i \in I$ and $j \in 1..p$ the variable $y_j$ occurs freely
in $N_i$ and $x_i$ occurs freely in $P$. In that case, property
\ref{proper:safe_basic_prop} (ii) gives:
$$ \ord{y_j} \geq \ord{N_i} = \ord{x_i}$$

Moreover $i\in I$ therefore $x_i \not \in \overline{y}$ and since $x_i$ occurs freely in $P$, $x_i$ must also occur freely in the safe term
$\lambda \overline{y}. P$. Thus, property \ref{proper:safe_basic_prop} (ii) gives:
$$ \ord{x_i} \geq \ord{\lambda y_1 \ldots y_p . T} \geq 1+ \ord{y_j} > \ord{y_j}$$

Hence we reach a contradiction.
\end{proof}




\subsection{Safe $\beta$-reduction}

We now introduce the notion of safe $\beta$-redex and show how such redex can be reduced using the
capture-permitting simultaneous substitution. We will then show that
a safe $\beta$-reduction reduces to a safe term.


In the simply-typed lambda calculus a redex is a term of the form $(\lambda x . M) N$.
We generalize this notion to the safe lambda calculus. We call multi-redex a term of the form
$(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ (it is not required to have $n=l$).


We say that a multi-redex is safe if it respects the formation rules of the safe $\lambda$-calculus. More precisely,
the multi-redex $(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l$ is a safe redex if the variable $x_1,\ldots,x_n$
are abstracted altogether at once using the abstraction rule and if the terms $N_1 \ldots N_l$ are applied to the
term $\lambda x_1 \ldots x_n . M$ at once using either the application rule $\rulename{app^+}$ or $\rulename{app}$.

Note that there exist safe terms of the form $(\lambda x_1 \ldots
x_n . M) N_1 \ldots N_l$ such that $l>n$. For instance the term:
$$ (\lambda f g . ((\lambda h i . i) a) ) (\lambda x.x) (\lambda x.x) (\lambda x.x)$$
for some constant $a$ and variables $x : o$ and $f,g,h,i,a:o
\rightarrow o$, can be formed using the $\rulename{app}$ rule as
follows:
$$ \rulef{
    \emptyset \vdash (\lambda f g . ((\lambda h i . i) a) )
        \quad \emptyset \vdash (\lambda x.x)
        \quad \emptyset \vdash (\lambda x.x)
        \quad \emptyset \vdash (\lambda x.x)
    }
    {
       \emptyset \vdash (\lambda f g . ((\lambda h i . i) a) ) (\lambda x.x) (\lambda x.x) (\lambda x.x)
    } \rulename{app}
$$


The formal definition follows:

\begin{dfn}[Safe redex]
A safe redex is a term of the form:
$$(\lambda \overline{x} . M) N_1 \ldots N_l$$
such that the variables $\overline{x}=x_1\ldots x_n$ are abstracted altogether by one occurrence
of the rule $\rulename{abs}$ in the proof tree (possibly followed by the weakening rule)
which implies that:
$$\ord{M} -1 \leq \ord{\overline{x}} = \ord{x_1} = \ldots = \ord{x_n}$$
and such that the terms $(\lambda \overline{x} . M)$, $N_1$, $N_l$ are applied together at
once using either:
\begin{itemize}
    \item the rule $\rulename{app}$ with
        $$   \rulef{
                    \Sigma \vdash \lambda \overline{x} . M : (\overline{B_1}|\ldots|\overline{B_m}|o)
                    \quad
                    \Sigma \vdash N_1         \quad \ldots \quad \Sigma \vdash N_l
                    \quad l = |\overline{B_1}|
            }
            {
            \Sigma \vdash (\lambda \overline{x} . M) N_1 \ldots N_l
            } (\mathbf{app})
        $$

        In which case  $n\leq |\overline{B_1}| = l$.

\item or the rule $\rulename{app^+}$ with:
        $$   \rulef{
                    \Sigma \vdash \lambda \overline{x} . M : (\overline{B_1}|\ldots|\overline{B_m}|o)
                    \quad
                    \Sigma \vdash N_1         \quad \ldots \quad \Sigma \vdash N_l
                    \quad l < |\overline{B_1}|
            }
            {
            \Sigma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
            } (\mathbf{app^+})
        $$

      In which case $n \leq |\overline{B_1}|$ and no relation holds between $n$ and $l$.
\end{itemize}
Note that we do not necessarily have $n = |\overline{B_1}|$.
\end{dfn}


\begin{dfn}[Safe reduction $\beta_s$] \
For concision the following abbreviations are used $\overline{x} = x_1 \ldots
x_n$, $\overline{N} = N_1 \ldots N_l$, and when $n\geq l$, $\overline{x_L} = x_1 \ldots
x_l$, $\overline{x_R} = x_{l+1} \ldots x_n$.
\begin{itemize}
\item The relation $\beta_s$ is defined on the set of safe redex as follows:
\begin{eqnarray*}
\beta_s &=&
\{  \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto \lambda \overline{x_R}. T\subst{\overline{N}}{\overline{x_L}}  \\
&& \mbox{ where $(\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ is a safe redex such that $n> l$}
\} \\
&\union&
\{ \ (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l \mapsto T\subst{\overline{N}}{\overline{x}} N_{n+1} \ldots N_l  \\
&& \mbox{ where $(\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ is a safe redex such that $n\leq l$}
\}
\end{eqnarray*}
where the notation $\subst{\overline{N}}{\overline{x}}$ denotes the capture-permitting simultaneous substitution.

\item
The safe $\beta$-reduction noted $\betasred$ is the closure
of the relation $\beta_s$ by compatibility with the formation rules
of the safe $\lambda$-calculus.
\end{itemize}
\end{dfn}



We observe that safe $\beta$-reduction is a certain kind of multi-steps $\beta$-reduction.
\begin{property}
$\betasred \subset \betaredtr$, i.e. the safe
$\beta$-reduction relation is included in the transitive closure of the $\beta$-reduction relation.
\end{property}
\begin{proof}
Suppose that $(M\mapsto N) \in \beta_s$. We show that $M \betared^* N$.
\begin{itemize}
\item Suppose that the safe-redex is
$M \equiv (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ such that $n\leq l$ then:
\begin{eqnarray*}
 M &=_\alpha& (\lambda z_1 \ldots z_n .T [z_1,\ldots z_n /x_1,\ldots x_n] ) \ N_1  N_2 \ldots N_l
            \\
&& \mbox{where the $z_i$ are fresh variables}  \\
     &\betared& (\lambda z_2 \ldots z_n .T [z_1,\ldots z_n /x_1,\ldots x_n] \subst{N_1}{z_1} ) \ N_2 \ldots N_l \\
&& \mbox{ (because the $z_i$ do not occur freely in $N_1$) }\\
%%    &=_\alpha& (\lambda z_2 \ldots z_n .T [z_2,\ldots z_n /x_2,\ldots x_n] \subst{N_1}{x_1})\  N_2 \ldots N_l  \qquad \mbox{where the $z_i$ are fresh variables}  \\
    &\betared& \ldots \\
    &\betared& (T [z_1,\ldots z_n /x_1,\ldots x_n] \subst{N_1}{z_1}  \ldots \subst{N_n}{z_n})\  N_{n+1} \ldots N_l \\
    &\betared& (T [N_1\ldots N_l/x_1,\ldots x_l])\ N_{n+1} \ldots N_l
\end{eqnarray*}
And since $T$ is safe, the substitution $T [N_1\ldots N_l/x_1,\ldots x_l]$ in the last equation
can be performed using the capture-permitting substitution. Hence $M \betared^* N$.

\item
 Suppose that $M \equiv (\lambda \overline{x} : \overline{A} . T) N_1 \ldots N_l$ such that $n> l$, then necessarily
the redex must be formed using the $\rulename{app^+}$ rule. The side-condition of this rules
says that the free variables of the terms $N_1, \ldots N_l$ have all order strictly greater than $\ord{\overline{x}}$,
hence the $x_i$ do not occur freely in $N_1, \ldots N_l$. Therefore:

\begin{eqnarray*}
 M &=& (\lambda x_1 \ldots x_n .T) \ N_1  N_2 \ldots N_l  \\
     &\betared& (\lambda x_2 \ldots x_n .T \subst{N_1}{x_1} ) \ N_2 \ldots N_l \\
            && \mbox{(for $i \in 2..n$, $x_i$ does not occur freely in $N_1$)}\\
    &\betared& \ldots \\
    &\betared& \lambda x_{l+1} \ldots x_n . T \subst{N_1}{x_1}  \ldots \subst{N_l}{x_l} \\
        && \mbox{(for $i \in (l+1)..n$,  $x_i$ does not occur freely in $N_l$)}\\
    &\betared& \lambda x_{l+1} \ldots x_n . T [N_1\ldots, N_l /  \ x_1,\ldots, x_l] \\
        && \mbox{(the $x_i$ do not occur freely in $N_1, \ldots N_l$)}
\end{eqnarray*}
And since $T$ is safe, the substitution $T [N_1\ldots N_l/x_1,\ldots x_l]$ in the last equation
can be performed using the capture-permitting substitution. Hence $M \betared^* N$.
\end{itemize}
\end{proof}

\begin{property} In the simply typed $\lambda$-calculus setting:
\begin{enumerate}
\item $\betasred$ is strongly normalizing.
\item $\beta_s$ has the unique normal form property.
\item $\beta_s$ has the Church-Rosser property.
\end{enumerate}
\end{property}

\begin{proof}
1. This is because $\betasred \subset \betaredtr$ and $\betared$ is strongly normalizing (in the simply typed lambda calculus).
2. A term has a safe redex iff it has a $\beta$-redex therefore
the set of $\beta_s$ normal form is equal to the set of $\beta_s$
normal form. Hence, the unicity of $\beta$ normal form implies the
unicity of $\beta_s$ normal form.
3. is a consequence of 1 and 2.
\end{proof}




Since capture-permitting simultaneous substitution preserves safety (lemma \ref{lem:subst_preserve_safety}),
consequently any safe redex reduces to a safe term:

\begin{lem}[The safe reduction $\beta_s$ preserves safety]
\label{lem:homoh_safered_preserve_safety}
If $M$ is safe and $M \betasred N$ then $N$ is safe.
\end{lem}

\begin{proof}
It suffices to show that the relation $\beta_s$ preserves safety.
Consider the safe-redex $(s\mapsto t) \in \beta_s$ where $ s \equiv (\lambda x_1 \ldots x_n . M) N_1 \ldots N_l $ .
We proceed by case analysis on the the last rule used to form the redex.
\begin{itemize}
\item Suppose the last rules used is $\rulename{app}$, then necessarily $n\leq l$ and the reduction is:
$$(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l \qquad \mapsto  \qquad t \equiv M[N_1 / x_1 , \cdots, N_n / x_n]\ N_{n+1} \ldots N_l$$
The first premise of the rule $\rulename{app}$ tells us that $M$ is safe therefore using lemma \ref{lem:subst_preserve_safety} and
the application rule we obtain that $t$ is safe.

\item Suppose the last rules used is $\rulename{app^+}$ and $n> l$ then the reduction is
$$ (\lambda \overline{x_L} : \overline{A_L} \
\overline{x_R}: \overline{A_R} . T) \overline{N_L} \qquad \mapsto
\qquad t \equiv \lambda \overline{x_R}: \overline{A_R} .
T\subst{\overline{x_L}}{\overline{N_L}}
$$
By lemma \ref{lem:subst_preserve_safety}, $T\subst{\overline{x_L}}{\overline{N_L}}$ is a safe term.
Using the rule $\rulename{abs}$ we derive that $t$ is safe.

\item Suppose the last rules used is $\rulename{app^+}$ and $n\leq l$ then the reduction is
$$(\lambda x_1 \ldots x_n . M) N_1 \ldots N_l \qquad \mapsto \qquad t \equiv M[N_1 / x_1 , \cdots, N_n / x_n]\ N_{n+1} \ldots N_l$$
Similarly to case $\rulename{app}$, we conclude that $t$ is safe.

\item Rule $\rulename{wk}$ $\rulename{seq}$: these cases reduce to one of the previous cases.
\end{itemize}
\end{proof}


\begin{rem}
\label{rem:betasred_notpreserv_unsafety} $\betasred$ \emph{does not} preserves un-safety: given two terms of
the same type $S$ safe and $U$ unsafe, the term $(\lambda x y . y) U S$ is also unsafe
but it $\beta_s$-reduces to $S$ which is safe.
\end{rem}


\subsection{An alternative system of rules}


In this section, we will refine the formation rules
given in the previous section. We say that $\Gamma \vdash M : A$ verifies $P_i$ for $i \in \zset$ if the
variables in $\Gamma$ all have orders at least $\ord{A}+i$. We introduce the notation $\Gamma \vdash^{i} M : A$ for $i \in
\zset$ to mean that $\Gamma \vdash M : A$ is a valid judgment satisfying $P_i$.


We remark that if $\Gamma \vdash M : A$ then the variables in $\Gamma$ with order
strictly smaller than $M$ cannot occur freely in $M$ and therefore it is possible to restrict
the context to a smaller number of variables:

\begin{lem}[Context reduction]
\label{lem:restriction}

If $\Gamma \vdash^i M : A$ then $\Gamma' \vdash^{0} M : A$
where $$\Gamma' = \{ z \in \Gamma \ |
\ \ord{z} \geq \ord{M} \} = \Gamma \setminus \{ z \in \Gamma \ | \ \ord{M} + i \leq \ord{z} < \ord{M} \}$$
\end{lem}
\begin{proof}
If $i\geq 0$ then the result is trivial.
Suppose $i<0$. We proceed by structural induction and by case analysis.
We only give the details for the application cases $\rulename{app}$ and $\rulename{app^+}$:
\begin{itemize}
\item Case of the rule $\rulename{app}$:

    \[ (\mathbf{app}) \
    \rulef
        {\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
            \seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} :
            B_{1l}} \qquad l = |\overline{B_1}| }
        { \seq{\Gamma}{M N_1
            \cdots N_{l} : (\overline{B_2} \, | \, \cdots \, | \,
            \overline{B_m} \, | \, o)}}
    \]

    If the conclusion verifies $P_i$ then, for all $z \in \Gamma$:
    \begin{eqnarray*}
    \ord{z} \geq 1 + \ord{\overline{B_2}} + i
    &=& 1 + \ord{\overline{B_1}} + \ord{\overline{B_2}} - \ord{\overline{B_1}} + i \\
    &=& \ord{M} + (\ord{\overline{B_2}} - \ord{\overline{B_1}} + i)
    \end{eqnarray*}
    Therefore the first premise satisfies $P_j$ where $j={\ord{\overline{B_2}} - \ord{\overline{B_1}} + i}$.
    Hence by the induction hypothesis,
    $$\Gamma' \vdash^{0} M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$$
    where $\Gamma' = \Gamma \setminus \{ z \in \Gamma \ | \ \ord{M} + j \leq \ord{z} < \ord{M} \}$.


    Similarly, for all $z \in \Sigma$:
    \begin{eqnarray*}
    \ord{z} \geq 1 + \ord{\overline{B_2}} + i
    &=& \ord{\overline{B_1}} + (1+\ord{\overline{B_2}} - \ord{\overline{B_1}} + i) \\
    &=& \ord{\overline{B_1}} + j+1
    \end{eqnarray*}
    Hence by the induction hypothesis:
    $$\Gamma'' \vdash^0 N_k : B_{1k} \mbox{ for } k \in 1..l$$
    where $\Gamma'' = \Gamma \setminus \{ z \in \Gamma \ | \ \ord{M} + j+1 \leq \ord{z} < \ord{M} \}$.

    Furthermore, $\Gamma'' = \Gamma' \union \{ z \in \Gamma \ | \ \ord{M} + j = \ord{z}\}$ therefore
    the weakening rule gives:
    $$\Gamma'' \vdash^{-1} M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$$

    Finally the $\rulename{app}$ rule gives:
    $$\rulef{\Gamma'' \vdash^{-1} M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)
    \quad \Gamma'' \vdash^0 N_1 : B_{11} \quad \ldots \quad \Gamma'' \vdash^0 N_1 : B_{1l}
    }
        { \Gamma'' \vdash M N_1 \ldots N_l : (\overline{B_2} \, | \, \cdots \, | \,
            \overline{B_m} \, | \, o)}
    $$
    such that for all $z\in \Gamma''$:
    \begin{eqnarray*}
    \ord{z} \geq \ord{\overline{B_1}}
    &\geq& 1 + \ord{\overline{B_2}} = \ord{M N_1 \ldots N_l}
    \end{eqnarray*}

    Therefore:
    $$\Gamma'' \vdash^0 M N_1 \ldots N_l : (\overline{B_2} \, | \, \cdots \, | \,
            \overline{B_m} \, | \, o)$$

\item $\rulename{app^+}$  The side-condition of the rule $\rulename{app^+}$ ensures that the first premise
 verify $P_0$. The conclusion of the rule has the same order as the first premise
 therefore the conclusion also verifies $P_0$.
\end{itemize}
\end{proof}


\begin{lem}
\label{lem:prooftree01only}
If $\Gamma \vdash^{0} M : T$ or $\Gamma \vdash^{-1} M : T$ then there is valid proof tree
showing $\Gamma \vdash M : T$ such that all the judgments
appearing in the proof tree verify either $P_0$ or $P_{-1}$.
\end{lem}


\begin{proof}
Since $P_{-1}$ implies $P_0$, we assume that the judgment $\Gamma \vdash M : T$ satisfies $P_{-1}$.

We show that there is a proof tree for
$\Gamma \vdash M : T$ where all the nodes of the tree verify $P_0$
or $P_{-1}$. We proceed by structural induction and case analysis on the last rule used
to show $\Gamma \vdash M : T$.
\begin{itemize}
\item Axiom $\rulename{\Sigma\mbox{\textbf{-const}}}$: the context is empty therefore the sequent verifies $P_{-1}$.

\item Axiom $\rulename{var}$: the context contains only the variable itself therefore the sequent verifies $P_0$.

\item Rule $\rulename{wk}$: If $\Delta \vdash M : T$ verifies $P_{-1}$ then in particular $\Gamma
\vdash M : T$ verifies $P_{-1}$ for any $\Gamma \subseteq \Delta$.

\item Rule $\rulename{perm}$: By the induction hypothesis.


\item Rule $\rulename{abs}$: the second premise of the rule guarantees that the first
premise verifies $P_{-1}$.

\item Rule $\rulename{app^+}$: The first premise has the same order has the
conclusion of the rule therefore the first premise verifies
$P_0$. The side-condition of the rule $\rulename{app^+}$ ensures that all the other premises verify $P_0$.

\item Rule $\rulename{app}$:

$$ \rulename{app} \
    \rulef{
        { \Gamma \vdash M : (\overline{A} \, | B)
        \qquad
        \Gamma \vdash N_1 : A_1 \quad \cdots \quad \Gamma \vdash N_{l} : A_l \qquad l = |\overline{A}|
        }
    }
    {
        \Gamma \vdash^0 M N_1 \cdots N_{l} : B
    }
$$

Applying lemma \ref{lem:restriction} to the first premise we obtain:
\begin{equation}
 \Sigma \vdash^0 M : (\overline{A} \, | B) \label{eq:seq1}
\end{equation}
where $\Sigma = \{ z \in \Gamma \ | \ \ord{z} \geq \ord{(\overline{A} \, | B)} \} = \{ z \in \Gamma \ | \ \ord{z} \geq 1 + \ord{\overline{A}} \}.$

Since $\ord{\overline{A}} = \ord{A_1} = \ldots = \ord{A_l}$ by applying lemma \ref{lem:restriction} to all the premises but the first we have
for all $i \in 1..p$ :
$$ \Sigma' \vdash^0 N_i : A_i $$
where
$\Sigma' = \{ z \in \Gamma \ | \ \ord{z} \geq \ord{\overline{A}} \} \supseteq \Sigma.$

If the inclusion $\Sigma \subseteq \Sigma'$ is strict then we apply the weakening rule to sequent (\ref{eq:seq1}):
$$ \rulef{\Sigma \vdash^0 M : (\overline{A} \, | B)}{\Sigma' \vdash^{-1} M : (\overline{A} \, | B)} \rulename{wk} $$

We obtain the following proof tree:
$$  \rulef{
        \rulef{
            { \Sigma' \vdash^{-1} M : (\overline{A} \, | B)
            \qquad
            \Sigma' \vdash^0 N_1 : A_1 \quad \cdots \quad \Sigma' \vdash^0 N_{l} : A_l \qquad l = |\overline{A}|
            }
        }
        {
            \Sigma' \vdash^0 M N_1 \cdots N_{l} : B
        } \rulename{app}
    }
    {
         \Gamma \vdash^0 M N_1 \cdots N_{l} : B
    } \rulename{wk}
$$

where the last weakening rules is applied only if the inclusion $\Sigma' \subseteq \Gamma$ is strict.

We can now conclude using the induction hypothesis on the sequents $\Sigma' \vdash^{-1} M$,
$\Sigma' \vdash^0 N_1$, \ldots, $\Sigma' \vdash^0 N_l$ .
\end{itemize}
\end{proof}

\subsubsection{Refining the rules of the homogeneous safe $\lambda$-calculus}

Using the observations that we have just made, we will now derive the rules
of the safe $\lambda$-calculus with homogeneous type. We want a system
of rules generating sequents that verify $P_0$. Also, it must be able to generate intermediate
sequents that do not necessarily satisfy $P_0$ provided that they can be used
to produce \emph{in fine} terms satisfying $P_0$.

Because of the lemma \ref{lem:prooftree01only}, we know that the only necessary intermediate sequents
are those that either satisfy $P_0$ or $P_{-1}$.
Hence, we will assume by default that premises of the rules all satisfy $P_{-1}$. We will see that in
some cases, some premise will actually satisfy $P_0$.

First we define an additional rules expressing the fact that $P_0$ implies $P_{-1}$:
$$ \rulename{seq} \  \rulef{\Gamma \vdash^{0} M : A}{\Gamma \vdash^{-1} M : A} $$

The weakening rule specializes into two rules:
$$ \rulename{wk^{0}} \   \rulef{\Gamma \vdash^{0} M : A}{\Gamma , x : B \vdash^{0} M : A} \quad \ord{B} \geq \ord{A} $$
$$ \rulename{wk^{-1}} \   \rulef{\Gamma \vdash^{-1} M : A}{\Gamma , x : B \vdash^{-1} M : A} \quad \ord{B} \geq \ord{A} -1$$

Because of the context reduction lemma, any sequent verifying $P_{-1}$ can be obtained
by applying the weakening rule $\rulename{wk^{-1}}$ or the rule $\rulename{seq}$ to another sequent
verifying $P_0$. Therefore, with the exception of these two rules, we only need to use rules
whose conclusion sequents verify $P_0$:
\begin{itemize}
\item For the rules $\rulename{perm}$, $\rulename{const}$ and $\rulename{var}$, only the tagging of the sequents
changes:
$$ \rulename{var} \   \rulef{}{x : A\vdash^{0} x : A}
\qquad
\rulename{\Sigma\mbox{\textbf{-const}}}  \  \rulef{}{\vdash^0 b : A} \ b:A \in \Sigma
$$

$$
  \rulename{perm} \  \rulef{
      { \Gamma \vdash^0 M:B \qquad \sigma(\Gamma)  } \hbox{ homogeneous}
    }
      { \sigma(\Gamma) \vdash^0 M : B }
$$

\item $\rulename{abs}$ The definition of the abstraction rule has a side condition
expressing the fact that the premise verifies $P_0$ or $P_{-1}$. Since this is always true for sequents
generated by our new system of rules, we can drop the side condition:
$$ \rulename{abs} \   \rulef{\Gamma | \overline{x} : \overline{A} \vdash^{-1} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A},B)}$$


\item $\rulename{app}$ The application rule has the following form:
$$ \rulename{app} \
    \rulef{
        { \Gamma \vdash^{-1} M : (\overline{A} \, | B)
        \qquad
        \Gamma \vdash^{-1} N_1 : A_1 \quad \cdots \quad \Gamma \vdash^{-1} N_{l} : A_l \qquad l = |\overline{A}|
        }
    }
    {
        \Gamma \vdash^0 M N_1 \cdots N_{l} : B
    }
$$

Since the first premise verifies $P_{-1}$, by property \ref{proper:safe_basic_prop}(ii) we have:
$$\forall z \in \Gamma : \ord{z} \geq 1 + \ord{\overline{A}} -1 = \ord{\overline{A}} = \ord{\overline{N}}$$
Hence, all the sequents of the premises but the first must verify $P_0$. The rule (app) is therefore given by:
$$ \rulename{app} \
    \rulef{
        { \Gamma \vdash^{-1} M : (\overline{A} \, | B)
        \qquad
        \Gamma \vdash^0 N_1 : A_1 \quad \cdots \quad \Gamma \vdash^0 N_{l} : A_l \qquad l = |\overline{A}|
        }
    }{
        \Gamma \vdash^0 M N_1 \cdots N_{l} : B
      }
$$

\item For the application rule $\rulename{app^+}$, the type of the sequent in the first premise has the same order
as the type of the conclusion premises, therefore since the conclusion verifies $P_0$, the first premise also verifies $P_0$.
The side-condition implies that that all the other sequents in the premise verify $P_0$. Moreover the fact
that the first premise verifies $P_0$ ensure that the side-condition always holds. Hence the rule becomes:
$$ \rulename{app^+} \
    \rulef{
        \Gamma \vdash^0 M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o) \qquad
        \Gamma \vdash^0 N_1 : B_{11} \quad \cdots \quad \Gamma \vdash^0 N_{l} : B_{1l} \qquad l < |\overline{B_1}|
    }
    {
        \Gamma \vdash^0 M N_1 \cdots N_{l} : (\overline{B} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)
    }
$$
where $\overline{B_1} = B_{11}, \ldots, B_{1l},\overline{B}$.
Clearly, this rule can be equivalently stated as:
$$ \rulef{\Gamma \vdash^0 M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A
                                   }
                                   {\Gamma  \vdash^{0} M N : B}$$
\end{itemize}

The full set of rules is given in table \ref{tab:homosafelmd_rules_refined}.

\begin{table}[htbp]
$$  \rulename{perm} \
    \rulef{
      { \Gamma \vdash^0 M:B \qquad \sigma(\Gamma)  } \hbox{ homogeneous}
    }
    { \sigma(\Gamma) \vdash^0 M : B
    }
\qquad
\rulename{seq} \  \rulef{\Gamma \vdash^{0} M : A}{\Gamma \vdash^{-1} M : A}
$$

$$
\rulename{\Sigma\mbox{\textbf{-const}}} \  \rulef{}{\vdash^0 b : A}\ b:A \in \Sigma
\qquad
 \rulename{var} \   \rulef{}{x : A\vdash^{0} x : A} $$

$$ \rulename{wk^{0}} \   \rulef{\Gamma \vdash^{0} M : A}{\Gamma , x : B \vdash^{0} M : A} \quad \ord{B} \geq \ord{A} $$

$$ \rulename{wk^{-1}} \   \rulef{\Gamma \vdash^{-1} M : A}{\Gamma , x : B \vdash^{-1} M : A} \quad \ord{B} \geq \ord{A} -1$$


$$ \rulename{app} \
    \rulef
        {   \Gamma \vdash^{-1} M : (\overline{A} \, | B)
            \qquad
            \Gamma \vdash^0 N_1 : A_1 \quad \cdots \quad \Gamma \vdash^0 N_{l} : A_l \qquad l = |\overline{A}|
        }
        {
            \Gamma \vdash^0 M N_1 \cdots N_{l} : B
        }
$$

$$ \rulename{app^+} \   \rulef{\Gamma \vdash^0 M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A
                                   }
                                   {\Gamma  \vdash^{0} M N : B}$$

$$ \rulename{abs} \   \rulef{\Gamma| \overline{x} : \overline{A} \vdash^{-1} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A}|B)}$$


where $\Gamma| \overline{x} : \overline{A}$ means that the lowest type-partition of the context is
$\overline{x} : \overline{A}$.
\caption{Alternative rules for the homogeneous safe lambda calculus}
\label{tab:homosafelmd_rules_refined}
\end{table}
%%%
