\clearpage

\section{Non homogeneous safe $\lambda$-calculus - VERSION B}

In section \ref{sec:safe_alt}, we have presented a safe lambda
calculus in the setting of homogeneous types. In this section, we
give a general notion of safety for the simply typed
$\lambda$-calculus. The rules we give here do not assume homogeneity
of the types.

We call safe terms the simply typed lambda terms that are
typable within the following system of formation rules:

\subsection{Rules}

We use a set of sequents of the form $\Gamma \vdash M : A$ where $\Gamma$ is the context of the term and $A$ is its type.
The following system of rules defined the non homogeneous safe $\lambda$-calculus:

$$ \rulename{var} \quad  \rulef{}{x : A\vdash x : A}
\qquad  \rulename{wk} \quad  \rulef{\Gamma \vdash M : A}{\Delta \vdash M : A} \quad \Sigma \subseteq \Gamma$$

$$ \rulename{app} \rulef{\Gamma \vdash M : (A,\ldots,A_l,B)
                                        \qquad \Gamma \vdash N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash N_l : A_l  }
                                   {\Gamma  \vdash M N_1 \ldots N_l : B}
                                    \quad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{B}$$

$$ \rulename{abs} \quad  \rulef{\Gamma \union \overline{x} : \overline{A} \vdash M : B}
                                   {\Gamma  \vdash \lambda \overline{x} : \overline{A} . M : (\overline{A},B)} \qquad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{\overline{A},B}$$


Remark:
\begin{itemize}
\item $(\overline{A},B)$ denotes the type $(A_1,A_2, \ldots, A_n, B)$;
\item all the types appearing in the rule are not required to be homogeneous. For instance
the type $(A,\ldots,A_l,B)$ in the rule $\rulename{app}$ may be such that $\ord{A_l} < \ord{B}$;
\item the environment $\Gamma \union \overline{x}:\overline{A}$ is not stratified. In particular, variables in $\overline{x}$ do not necessarily have the same order;
\item In the abstraction rule, the side-condition imposes that at least all the variable of the lowest order
in the context are abstracted. However other variables can also be
abstracted together with the lowest order variables. Moreover there
is not constraint on the order on which the variables are abstracted
(this contrasts with the homogeneous safe lambda calculus);
\end{itemize}

\begin{exmp}
Suppose $x:o$, $f:o\rightarrow o$ and $\varphi:(o\rightarrow
o)\rightarrow o$ then the term $$\vdash \lambda x f \varphi .
\varphi : o \rightarrow (o\rightarrow o) \rightarrow ((o\rightarrow
o)\rightarrow o) \rightarrow (o\rightarrow o)\rightarrow o$$ is
a valid non homogeneous safe term.
\end{exmp}

Side-remark: safety is preserved by $\eta$-expansion: consider the safe term
$\Gamma \vdash M:(A_1,\ldots,A_l,o)$ where $(A_1,\ldots,A_l,o)$ is not homogeneous. Then for all $i \in 1..l$ we have $\Gamma \union \Sigma \vdash x_i :A_i$ for some
context $\Sigma = \{ x_1:A_1, \cdots x_l :A_l \}$. Applying $\rulename{app}$ we then get that $\Gamma, \Sigma \vdash M x_1 \ldots x_l$ is valid. Hence
the $\eta$-expansion of $M$ is safe:
$$\Gamma \vdash \lambda x_1:A_1, \cdots x_l:A_l .\ M\ x_1 \ldots x_l$$


\begin{lem}[Context reduction]
\label{lem:nonhomosafe_basic_prop}
If $\Gamma \vdash M : B$ is a valid judgment then
\begin{enumerate}
\item $fv(M) \vdash M : B$
\item every variable in $\Gamma$ \emph{occuring free in $M$} has order at
least $ord(M)$.
\end{enumerate}
where $fv(M)$ denotes the context constituted of the free variables occurring in $M$.
\end{lem}
\begin{proof}
(i) Suppose some variable $x$ in $\Gamma$ does not occur free in $M$,
then the $x$ must have been introduced in the context by the weakening rule.
Hence $M$ must also be typable with the rules of the safe lambda calculus but with the variable $x$ removed from the context.
(ii) An easy structural induction.
\end{proof}


\subsection{Substitution in the safe lambda calculus}

The traditional notion of substitution, on which the
$\lambda$-calculus is based on, is defined as follows:
\begin{dfn}[Substitution]
\label{dfn:subst}
\begin{eqnarray*}
c \subst{t}{x} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
x \subst{t}{x} &=& t\\
 y\subst{t}{x} &=& y \quad \mbox{for } x \not \neq y,\\
(M_1 M_2) \subst{t}{x} &=& (M_1 \subst{t}{x}) (M_2 \subst{t}{x})\\
(\lambda x . M) \subst{t}{x} &=& \lambda x . M\\
(\lambda y . M) \subst{t}{x} &=& \lambda z . M \subst{z}{y}
\subst{t}{x} \mbox{where $z$ is a fresh variable and $x\not = y$}
\end{eqnarray*}
\end{dfn}

In the setting of the safe lambda calculus, the notion of
substitution can be simplified. Indeed, similarly to what we observe in the homogeneous
safe $\lambda$-calculus, we remark that for safe
$\lambda$-terms there is no need to rename variables when performing
substitution:

\begin{lem}[No variable capture lemma]
\label{lem:noclash} There is no variable capture when performing
substitution on a safe term.
\end{lem}

This is the equivalent of lemma \ref{lem:homog_nocapture} for the non-homogeneous case. The proof (which does not rely on homogeneity)
is identical.
Consequently, in the safe lambda calculus setting, we can omit to to rename
variable when performing substitution and the equation
$$(\lambda x . M) \subst{t}{y} = \lambda z . M \subst{z}{x}
\subst{t}{y} \mbox{where $z$ is a fresh variable}$$ becomes
$$(\lambda x . M) \subst{t}{y} = \lambda x . M \subst{t}{y}.$$

Unfortunately, this notion of substitution is still not adequate for
the purpose of the safe simply-typed lambda calculus. The problem is
that performing a single $\beta$-reduction on a safe term will not
necessarily produce another safe term.

The solution consist in reducing several consecutive $\beta$-redex at the same time until we obtain a safe
term. To achieve this, we introduce the \emph{simultaneous substitution},
a generalization of the standard substitution given in definition \ref{dfn:subst}.

\begin{dfn}[Simultaneous substitution]
\label{dnf:simsubst}
 We note $\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
(M N) \subst{\overline{N}}{\overline{x}} &=& (M \subst{\overline{N}}{\overline{x}}) (N \subst{\overline{N}}{\overline{x}}) \\
(\lambda x_i . M) \subst{\overline{N}}{\overline{x}} &=& \lambda x_i
. M
\subst{N_1 \ldots N_{i-1} N_{i+1}\ldots N_n}{x_1 \ldots x_{i-1} x_{i+1}\ldots x_n} \\
(\lambda y . M)
\subst{\overline{N}}{\overline{x}} &=& \lambda z . M \subst{z}{y} \subst{\overline{N}}{\overline{x}} \\
&& \mbox{where $z$ is a fresh variables and } y \neq x_i \mbox{ for
all } i
\end{eqnarray*}
\end{dfn}

In general, variable captures should be avoided, this explains why
the definition of simultaneous substitution uses auxiliary fresh
variables. However in the current setting, lemma \ref{lem:noclash}
can clearly be transposed to the simultaneous substitution therefore
there is no need to rename variable.

The notion of substitution that we need is therefore the
\emph{capture permitting simultaneous substitution} defined as
follow:

\begin{dfn}[Capture permitting simultaneous substitution]
 We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
 x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{where } x \not \neq y_i \mbox{ for all } i,\\
(M_1 M_2) \subst{\overline{N}}{\overline{x}} &=& (M_1 \subst{\overline{N}}{\overline{x}}) (M_2 \subst{\overline{N}}{\overline{x}})\\
(\lambda x_i . M) \subst{\overline{N}}{\overline{x}} &=& \lambda x_i
. M
\subst{N_1 \ldots N_{i-1} N_{i+1}\ldots N_n}{x_1 \ldots x_{i-1} x_{i+1}\ldots x_n} \\
(\lambda y . M) \subst{\overline{N}}{\overline{x}} &=& \lambda y . M
\subst{\overline{N}}{\overline{x}} \mbox{where $y \not = x_i$ for
all $i$} \qquad \mathbf{(\star)}
\end{eqnarray*}
The symbol $\mathbf{(\star)}$ identifies the equation that changed
compared to the previous definition.
\end{dfn}

\begin{lem}[Substitution preserves safety]
\label{lem:subst_preserve_i}
$$ \Gamma\union \overline{x} : \overline{A}\vdash M : T
\quad \mbox{and} \quad \Gamma \vdash N_k : B_k \mbox{, } k \in
1..n \qquad \mbox{ implies } \qquad \Gamma \vdash
M[\overline{N}/\overline{x}] : T$$
\end{lem}

\begin{proof}
Suppose that $\Gamma \union \overline{x}: \overline{A} \vdash M :T$ and
$\Gamma \vdash N_k : B_k$ for $k \in 1..n$.

We prove $\Gamma \vdash M[\overline{N}/\overline{x}]$ by induction
on the size of the proof tree of $\Gamma\union \overline{x}:\overline{A}
\vdash M : T$ and by case analysis on the last rule used. We just
give the detail for the abstraction case. Suppose that the property
is verified for terms whose proof tree is smaller than $M$. Suppose
$\Gamma \union \overline{x}:\overline{A} \vdash \lambda \overline{y} :
\overline{C}. P : (\overline{C}|D)$ where $\Gamma\union
\overline{x}:\overline{A}\union \overline{y}:\overline{C} \vdash P :
D$, then by the induction hypothesis $\Gamma\union
\overline{y}:\overline{C} \vdash
P\subst{\overline{N}}{\overline{x}} : D$. Applying the rule
$\rulename{abs}$ gives $\Gamma \vdash \lambda
\overline{y}:\overline{C} . P \subst{\overline{N}}{\overline{x}}$.
\end{proof}

\subsection{Safe-redex}
In the simply-typed lambda calculus a redex is a term of the form
$(\lambda x . M) N$. We generalize this definition to the safe
lambda calculus:
\begin{dfn}[Safe redex]
We call safe redex a term of the form $(\lambda \overline{x} . M)
N_1 \ldots N_l$ such that:
\begin{itemize}
\item $ \Gamma \vdash (\lambda \overline{x} . M) N_1 \ldots N_l $
\item the variable $\overline{x}=x_1\ldots x_n$ are abstracted altogether by one occurrence of the rule $\rulename{abs}$ in the proof tree.
\item The terms $(\lambda \overline{x} . M)$, $N_1$, $N_l$ are applied together at once using the $\rulename{app}$ rule :
$$   \rulef{
            \Sigma \vdash \lambda \overline{x} . M
            \quad
            \Sigma \vdash N_1         \quad \ldots \quad \Sigma \vdash N_l
    }
    {
       \Sigma \vdash (\lambda \overline{x} . L) N_1 \ldots N_l
    } (\mathbf{app})
$$
Consequently each $N_i$ is safe.

\item $l\leq n$
\end{itemize}
\end{dfn}

Note that the condition $l\leq n$ in the definition is not too
restrictive because if $l>n$ then the application rule is in fact ``wider'' than the abstration
and it can be replaced by an application of exactly $n$ terms
followed by another application for the remaining terms $N_{n+1},
\ldots, N_l$.


\todobox{Define the safe reduction:
Consider the safe-redex $(\lambda \overline{x} . M) N_1 \ldots N_l$, it reduces
to $\lambda x_l \ldots x_n . M \subst{N_1 \ldots N_l}{x_1 \ldots x_l}$. The relation $\beta_s$ is defined
on safe-redex: $(s\mapsto t) \in \beta_s$ iff $s \equiv (\lambda \overline{x} . M) N_1 \ldots N_l$ is a safe redex and
$t \equiv \lambda x_l \ldots x_n . M \subst{N_1 \ldots N_l}{x_1 \ldots x_l}$
}

\todobox{Show that $\betasred \subseteq \betared^*$.}


\begin{lem}
\label{lem:safereduction} A safe redex reduces to a safe term.
\end{lem}

This lemma, which is a consequence of lemma \ref{lem:subst_preserve_i}, is the counterpart of lemma \ref{lem:homoh_safered_preserve_safety} in the homogeneous safe lambda calculus.
Their proofs are identical.

\subsection{Examples}
\subsubsection{Example 1}
Let $f,g:o\rightarrow o$, $x,y:o\rightarrow
o$, $\Gamma = g:o\rightarrow o$ and $\Gamma' = g:o\rightarrow o,
y:o$. The term $(\lambda f x . x) g y $ is safe. One possible proof tree is:
$$ \rulef{
        \rulef{
            \rulef{
                \rulef{\vdots}{\Gamma \vdash \lambda f x. x}      \qquad \axiomf{\Gamma \vdash g} }
            {\Gamma \vdash (\lambda f x. x) g} \rulename{app}
        }
        { \Gamma' \vdash (\lambda f x. x) g } \rulename{wk}
        \qquad \axiomf{\Gamma' \vdash y}
    }
    { \Gamma' \vdash (\lambda f x. x) g y } \rulename{app}
$$
Here is another proof for the same judgment:
$$ \rulef{  \rulef{ \rulef{\vdots}{\Gamma \vdash \lambda f x. x} }{\Gamma' \vdash \lambda f x. x} \rulename{wk}    \qquad \rulef{}{\Gamma' \vdash g} \qquad \rulef{}{\Gamma' \vdash y}}
    {\Gamma' \vdash (\lambda f x. x) g y } \rulename{app}$$

We see on this particular example that there may exist different proof tree
deriving the same judgment.

\subsubsection{Example 2 - Damien Sereni SCT counter-example}
In \cite{serenistypesct05}, the following counter-example is given
to show that not all simply-typed terms are size-change terminating
(see \cite{jones01} for a definition of size-change termination):

$$ E =  (\lambda a . a (\lambda b . a (\lambda c d .d))) (\lambda e . e (\lambda f .f))$$
where:
\begin{eqnarray*}
a &:& ((\tau \typear \tau) \typear \mu \typear \mu) \typear \mu \typear \mu \\
b &:& \tau \typear \tau \\
c &:& \tau \typear \tau \\
d &:& \mu \\
e &:& (\tau \typear \tau) \typear \mu \typear \mu \\
f &:& \tau
\end{eqnarray*}


\subsection{Particular case of homogeneously-safe lambda terms}

In this section, we will refine the rules of the non-homogenous safe lambda calculus to the homogeneous case.

We recall the definition of type homogeneity given in section \ref{sec:homotypes}:
a type $(A_1, A_2, \ldots A_n, o)$ is said to be homogeneous whenever $\ord{A_1} \geq \ord{A_2} \geq
\ldots \geq  \ord{A_n}$ and each of the $A_i$ are homogeneous. A term is said homogeneous if its type is homogeneous.

Safety in the sense of Knapik et al. (\cite{KNU02}) is defined for homogeneous recursion scheme.
A recursion scheme is homogeneous if
\begin{itemize}
    \item[(i)] the $\Sigma$ constants are of order 1 at most and therefore have homogeneous types;
    \item[(ii)] the variables in the alphabet $\Delta$ have homogeneous types,
    \item[(iii)] and every recursion equations of a safe recursion scheme has a homogeneous type.
\end{itemize}

We now impose the same restrictions on the terms generated by our system rules.
The first and second restriction imposes that every applicative terms in $\mathcal{T}(\Delta)$ must be homogeneous.

Abstractions in simply-typed terms correspond to recursion equations of recursion schemes,
therefore by imposing restriction (iii) to our calculus, all the sequents generated by the rules must be of homogeneous type.

We say that a term is \emph{homogeneously-safe} if its type is homogeneous
and there is a proof tree showing its safety where all the sequents
of the proof tree are of homogenous type.

We say that $\Gamma \vdash M : A$ verifies $P_i$ for $i \in \zset$ if the
variables in $\Gamma$ all have orders at least $\ord{A}+i$. We introduce the notation $\Gamma \vdash^{i} M : A$ for $i \in
\zset$ to mean that $\Gamma \vdash M : A$ is a valid judgment satisfying $P_i$.

Lemma \ref{lem:nonhomosafe_basic_prop} can be restated as follows:

\begin{lem}[Context reduction]
\label{lem:context_reduction} If $\Gamma \vdash^i M : A$ then  $fv(M) \vdash^0 M : A$.
\end{lem}


\begin{lem}
\label{lem:homog_judg_zero_minusone} Suppose $\Gamma \vdash^0 S : T_s$ is homogeneously-safe
then there is valid proof tree showing $\Gamma \vdash^0 S : T_S$ containing
only judgments of the form $\Gamma \vdash^0 M : T$ or $\Gamma \vdash^{-1} M : T$.
\end{lem}

\begin{proof}
Consider an homogeneously-safe term $\Gamma \vdash^{0} S : T_S$. We
prove the result by induction on the size of the proof tree and by
case analysis on the last rule used to obtain $\Gamma \vdash^{0} S :
T_S$.

We give the details of the proof for the application and abstraction
case:
\begin{itemize}
\item Rule $\rulename{abs}$:
$$ \rulename{abs} \quad  \rulef{\Gamma \union \overline{x} : \overline{A} \vdash M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A},B)} \qquad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{\overline{A},B}$$

Type homogeneity requires that for all $i$: $\ord{x_i} = \ord{A_i} \geq
\ord{B}$. Therefore the premise of the rule verifies $P_0$:
$$\Gamma, \overline{x} : \overline{A} \vdash^0 M : B.$$

The induction hypothesis permits to conclude.

\item Rule $\rulename{app}$:
$$ \rulename{app} \ \rulef{\Gamma \vdash^{-1} M : (A,\ldots,A_l,B)
                                        \quad \Gamma \vdash^{0} N_1 : A_1
                                        \  \ldots \ \Gamma \vdash^{0} N_l : A_l  }
                                   {\Gamma  \vdash^0 M N_1 \ldots N_l : B}
                                    \
                                   \forall y \in \Gamma : \ord{y} \geq \ord{B}$$

We apply lemma \ref{lem:context_reduction} to the first premise of the rule:
$$ \Gamma' \vdash^{0} M : (A,\ldots,A_l,B) $$
where $\Gamma' = fv(M)$.

By the induction hypothesis we know that there is a proof tree
showing $\Gamma' \vdash^{0} M : (A,\ldots,A_l,B)$ with judgement of
the form $\Sigma \vdash^{k} P : T$ with $k\in \{-1,0\}$.

By applying the the weakening rule to the root of the proof tree, we lift this result to $\Gamma
\vdash^{0} M : (A,\ldots,A_l,B)$.

For all the other premises we can directly apply the induction
hypothesis.

We conclude using the rule $\rulename{app}$.
\end{itemize}
\end{proof}

This lemma permits us to derive rules specialized for the
homogeneously-safe lambda calculus.

\subsubsection{The application rule} Let us derive the
application rules specialized for the case of homogeneous types. We
recall the rule $\rulename{app}$:
$$ \rulename{app} \  \rulef{\Gamma \vdash^{-1} M : (A,\ldots,A_l,B)
                                        \qquad \Gamma \vdash^{0} N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash^{0} N_l : A_l  }
                                   {\Gamma  \vdash^0 M N_1 \ldots N_l : B}
                                    \quad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{B}$$

Type homogeneity implies that $\ord{A_1} \geq \ldots \geq \ord{A_l}
\geq \ord{B} - 1$.

We can make the assumption that $\ord{A_1} = \ldots = \ord{A_l}$ (if it is not the case,
we can replace the application rule by several consecutive application rules
respecting this condition).


\begin{itemize}
\item Suppose that $A_1, \ldots A_l$ forms a type partition, then we
have $\ord{A_l} \geq \ord{B}$, the side-condition disappears and
the rule becomes:
$$ \rulename{app_1} \quad  \rulef{\Gamma \vdash^{-1} M : \overline{A} | B
                                        \qquad \Gamma \vdash^{0} N_1 :
                                        A_1
                                        \quad \ldots \quad \Gamma \vdash^{0} N_l :
                                        A_l
                                        }
                                   {\Gamma  \vdash^{0} M N_1 \ldots N_l : B}
$$

where $\overline{A} = A_1, \ldots A_l$

\item  Suppose that $A_1, \ldots A_l$ do not form a type partition, then we
have $\ord{A_l} = \ord{B} - 1$. The side-condition becomes
$\forall y \in \Gamma : \ord{y} \geq 1 +\ord{A_l} = \ord{\overline{A}|B}$. Therefore the side-condition
can be omitted provided that we replace the $-1$ exponent in the first premise by a $0$:
$$ \rulename{app_2} \quad  \rulef{\Gamma \vdash^0 M : (A,\ldots,A_l,B)
                                        \qquad \Gamma \vdash^{0} N_1 : A_1
                                        \quad \ldots
                                        \quad \Gamma \vdash^{0} N_l : A_l
                                   }
                                   {\Gamma  \vdash^0 M N_1 \ldots N_l : B}
$$

Equivalently we can replace this rule by the following one:
$$ \rulename{app_2'} \quad  \rulef{\Gamma \vdash^0 M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A }
                                {\Gamma  \vdash^{0} M N : B}$$
\end{itemize}

\subsubsection{The abstraction rule}

Let us derive the abstraction rule specialized for the case of
homogeneous types. We recall the rule $\rulename{abs}$:
$$ \rulename{abs^i} \quad  \rulef{\Gamma, \overline{x} : \overline{A} \vdash^{i} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A},B)} \qquad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{\overline{A},B}$$

The context $\Gamma$ is now partitionned according to the order of
the variables. The partitions are written in decreasing order of
type order. The notation $\Gamma | \overline{x}:\overline{A}$ means
that $\overline{x}:\overline{A}$ is the lowest partition of the
context.

We also use the notation $(\overline{A}|B)$ to denote the
homogeneous type $(A_1, A_2, \ldots A_n, B)$ where $\ord{A_1} =
\ord{A_2} =  \ldots \ord{A_n} \geq \ord{B} -1$.


Suppose that we abstract the single variable $\overline{x} = x$,
then in order to respect the side condition, we need to abstract all
variables of order lower or equal to $\ord{x}$. In particular we
need to abstract the partition of the order of $x$.

Moreover to respect type homogeneity, we need to abstract variables
of the lowest order first.

Hence we can change the abstraction rule so that it only allows
abstraction of the lowest variable partition. The rule can then be
used repeatedely if further partitions need to be abstracted. We
obtained the following rule where the side-condition has
disappeared:

$$ \rulename{abs^i} \quad  \rulef{\Gamma| \overline{x} : \overline{A} \vdash^{-1} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A}|B)}$$


\subsubsection{The complete set of rules of the homogeneous safe $\lambda$-calculus}

Table \ref{tab:homosafelmd_rules} recapitulates the entire set of rules:

\begin{table}[htbp]
$$  \rulename{perm}
    \rulef{
       \Gamma \vdash^0 M:B \qquad \sigma(\Gamma)  \hbox{ homogeneous}
    }
    { \sigma(\Gamma) \vdash^0 M : B }
\qquad \rulename{seq} \quad \rulef{\Gamma \vdash^{0} M : A}{\Gamma
\vdash^{-1} M : A}
$$

$$
 \rulename{const}
    \rulef{}{ \vdash^0 b : o^r \rightarrow o} \quad b : o^r \rightarrow o \in \Sigma
\qquad
 \rulename{var} \quad  \rulef{}{x : A\vdash^{0} x : A} $$

$$ \rulename{wk^{0}} \quad  \rulef{\Gamma \vdash^{0} M : A}{\Gamma , x : B \vdash^{0} M : A} \quad \ord{B} \geq \ord{A} $$

$$ \rulename{wk^{-1}} \quad  \rulef{\Gamma \vdash^{-1} M : A}{\Gamma , x : B \vdash^{-1} M : A} \quad \ord{B} \geq \ord{A} -1$$

$$ \rulename{app} \quad  \rulef{\Gamma \vdash^{-1} M : \overline{A} | B
                                        \qquad \Gamma \vdash^{0} N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash^{0} N_l : A_l
                                        \qquad l = |\overline{A}|
                                        }
                                   {\Gamma  \vdash^{0} M N_1 \ldots N_l : B}
$$


$$ \rulename{app^0} \quad  \rulef{\Gamma \vdash^0 M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A
                                   }
                                   {\Gamma  \vdash^{0} M N : B}$$

$$ \rulename{abs} \quad  \rulef{\Gamma| \overline{x} : \overline{A} \vdash^{-1} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A}|B)}$$
\caption{Rules of the homogeneous safe lambda calculus}
\label{tab:homosafelmd_rules}
\end{table}


We observe that these rules correspond exactly to the rules given in the previous section
in table \ref{tab:homosafelmd_rules_refined}.
