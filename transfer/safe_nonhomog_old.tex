\clearpage
\section{Old version of the non-homogeneous safe $\lambda$-calculus}

In section \ref{sec:safe_alt}, we have presented a safe lambda calculus in the setting of homogeneous types.
In this section, we try to give a general notion of safety for the simply typed $\lambda$-calculus.
The rules we give here do not assume homogeneity of the types.

We will call safe terms the simply typed lambda terms that are typable within the following system of formation rules:

\subsection{Rules}

 We use a set of sequents of the form $\Gamma \vdash^{i} M :
A$ where the meaning is ``variables in $\Gamma$ have orders at least
$\ord{A}+i$'' where $i \in \zset$. The following set of rules are
defined for $i \in \zset$:

$$ \mathbf{(seq^i_\delta)} \quad \rulef{\Gamma \vdash^{i} M : A}{\Gamma \vdash^{i-\delta} M : A} \quad i \in \zset, \delta > 0  $$

$$ \mathbf{(var)} \quad  \rulef{}{x : A\vdash^{0} x : A} $$

$$ \mathbf{(wk^i)} \quad  \rulef{\Gamma \vdash^i M : A}{\Gamma , x : B \vdash^i M : A} \quad \ord{B} \geq \ord{A} + i $$

$$ \mathbf{(app^i)} \quad  \rulef{\Gamma \vdash^i M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A}
                                   {\Gamma  \vdash^{i+\delta} M N : B}
                                    \qquad
                                   \delta = \max\left(0, 1 + \ord{A} - \ord{B}\right)$$

$$ \mathbf{(abs^i)} \quad  \rulef{\Gamma, \overline{x} : \overline{A} \vdash^{i} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A},B)} \qquad
                                   \left\{
                                     \begin{array}{ll}
                                       \forall y \in \Gamma : \ord{y} \geq \ord{\overline{A},B}\\
                                       \forall y \in fv(M) : \ord{y} \geq \ord{B}
                                     \end{array}
                                   \right.
                                   $$


Note that:
\begin{itemize}
\item $(\overline{A},B)$ denotes the type $(A_1,A_2, \ldots, A_n, B)$;
\item all the types appearing in the rule are not required to be homogeneous. For instance in the rule $\mathbf{(app^i)}$, the type $A \rightarrow B$ is not necessarily
homogeneous;
\item the environment $\Gamma, \overline{x}$ is not stratified. In particular, variables in $\overline{x}$ do not necessarily have the same order. Also
there may be variable in $\Gamma$ of order smaller than $\ord{x}$
for some variable $x$ in $\overline{x}$.
\item The sequents $\Gamma \vdash^0 M$ are the \emph{safe terms} that we want to generate.
Other terms are only used as intermediate sequents in a proof tree.
\end{itemize}


\begin{rem}
\label{rem:rulesineg}

This set of rules is equivalent (in term of safe terms that can be
generated) to the same set of rules where $i$ is restricted to be a
negative integer and where the rule $\mathbf{(app^i)}$ becomes:
$$ \mathbf{(app^i)} \quad  \rulef{\Gamma \vdash^i M : A\rightarrow B
                                        \qquad \Gamma \vdash^{0} N : A}
                                   {\Gamma  \vdash^{\min(i+\delta,0)} M N : B}
                                    \qquad
                                   \delta = \max\left(0, 1 + \ord{A} - \ord{B}\right) \quad i \leq 0 $$

With this new set of rules, the sequents of the form $\Gamma
\vdash^{k} M$ with $k>0$ cannot be derived anymore, however, the set
of safe terms that can built remain the same. Indeed, suppose that
we derive $\Gamma \vdash^0 M$ using the sequent $\Gamma \vdash^k N$
with $k>0$ somewhere in the proof. Then an easy induction shows that
the sequent $\Gamma \vdash^0 N$ can as well be derived (using
the rule $(seq^i_\delta)$ for $i\leq 0$).
\end{rem}

\begin{lem}[Basic properties]
\label{lem:nonhomosafe_basic_prop} Suppose $\Gamma \vdash^0 M : B$
is a valid judgment then every variable in $\Gamma$ has order at
least $ord(M)$.
\end{lem}
\begin{proof}
An easy induction on the proof tree shows that if $\Gamma \vdash^{i}
M : A$ then the variables in $\Gamma$ have orders at least
$\ord{A}+i$. The induction step for the application is: suppose
$\Gamma  \vdash^{i+\delta} M N : B$ where $\Gamma \vdash^i M :
A\rightarrow B$. Then by induction we have $\forall y \in \Gamma :
\ord{y} \geq \ord{A\rightarrow B} + i = \max(1+\ord{A}, \ord{B})+i =
\delta + \ord{B} + i$.
\end{proof}

\subsection{Substitution in the safe lambda calculus}

The traditional notion of substitution, on which the $\lambda$-calculus is based on, is the following one:
\begin{dfn}[Substitution]
\label{dfn:subst}
\begin{eqnarray*}
c \subst{t}{x} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
x \subst{t}{x} &=& t\\
 y\subst{t}{x} &=& y \quad \mbox{for } x \not \neq y,\\
(M_1 M_2) \subst{t}{x} &=& (M_1 \subst{t}{x}) (M_2 \subst{t}{x})\\
(\lambda x . M) \subst{t}{x} &=& \lambda x . M\\
(\lambda y . M) \subst{t}{x} &=& \lambda z . M \subst{z}{y}
\subst{t}{x} \mbox{where $z$ is a fresh variable and $x\not = y$}
\end{eqnarray*}
\end{dfn}

In the setting of the safe lambda calculus, the notion of substitution can be simplified.
Indeed, we remark that for safe $\lambda$-terms there is no need to rename variables
when performing substitution:

\begin{lem}[No variable capture lemma]
\label{lem:noclash}
There is no variable capture when performing substitution on a safe term.
\end{lem}
\begin{proof}
Suppose that a capture occurs during the substitution $M[N/\varphi]$
where $M$ and $N$ are safe. Then the following conditions must hold:
\begin{enumerate}
\item $\varphi:A, \Gamma \vdash^0 M$,
\item $\Gamma' \vdash^0 N$,
\item there is a subterm $\lambda \overline{x} . L$ in $M$ (where the abstraction is taken as wide as possible) such that:
\item $\varphi \in fv(\lambda \overline{x} . L)$ (and therefore $\varphi \in fv(L)$),
\item $x \in fv(N)$ for some $x \in \overline{x}$.
\end{enumerate}

By lemma \ref{lem:nonhomosafe_basic_prop} and (v) we have:

\begin{equation}
\ord{x} \geq \ord{N} = \ord{\varphi} \label{eq:xigeqphi}
\end{equation}

The abstraction $\lambda \overline{x} . L$ (taken as large as possible)
is a subterm of $M$, therefore there is a node $\Sigma \vdash^u \lambda \overline{x} . L$  for some $u$ in the
proof tree of $\varphi:A, \Gamma \vdash^0 M$.

There are only three kinds of rules that can produce an abstraction:
$\mathbf{(abs^i)}$, $\mathbf{(seq^i_\delta)}$ and $\mathbf{(wk^i)}$.
The only one that can introduce the abstraction is
$\mathbf{(abs^i)}$. Therefore the proof tree has the following form:

$$ \rulef{
    \rulef{
        \rulef{
            \rulef  {\ldots}
                   {\Sigma' \vdash^0 \lambda \overline{x} . L} \mathbf{(abs^i)}
        }
        {\ldots} r_1
    }
    {\vdots} r_2
    }
    { \Sigma \vdash^u \lambda \overline{x} . L } r_l
    \qquad \mbox{where } r_j \in \{ \mathbf{(seq^i_\delta)},\ \mathbf{(wk^i)}\ |\ i \in \zset, \delta > 0 \},
            \quad j\in 1..l.
$$


Since $\varphi \in fv (L)$ we must have $\varphi \in \Sigma'$ and
since $\Sigma' \vdash^0 \lambda \overline{x} . L$, by lemma
\ref{lem:nonhomosafe_basic_prop} we have:

$$\ord{\varphi} \geq \ord{\lambda \overline{x} . L} \geq \max(1+ \ord{x}, \ord{L}) > \ord{x}$$

which contradicts equation (\ref{eq:xigeqphi}).
\end{proof}

Hence, in the safe lambda calculus setting, we can omit to
to rename variable when performing substitution. The equation
$$(\lambda x . M) \subst{t}{y} = \lambda z . M \subst{z}{x}
\subst{t}{y} \mbox{where $z$ is a fresh variable}$$
becomes
$$(\lambda x . M) \subst{t}{y} = \lambda x . M \subst{t}{y}$$



Unfortunately, this notion of substitution is still not adequate for the purpose of the
safe simply type lambda calculus. The problem is that performing a single
$\beta$-reduction on a safe term will not necessarily produce another safe term.

To fix this problem, we need to be able to reduce several consecutive
$\beta$-redex at the same time until we obtain a safe term. In other words, we need a mean of performing
several substitutions at the same time.
To achieve this, we introduce the \emph{simultaneous substitution}. It is
 a generalization of the standard substitution given in definition \ref{dfn:subst}.

\begin{dfn}[Simultaneous substitution]
\label{dnf:simsubst}
 We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
(M N) \subst{\overline{N}}{\overline{x}} &=& (M \subst{\overline{N}}{\overline{x}}) (N \subst{\overline{N}}{\overline{x}}) \\
(\lambda x_i . M) \subst{\overline{N}}{\overline{x}} &=& \lambda x_i . M
\subst{N_1 \ldots N_{i-1} N_{i+1}\ldots N_n}{x_1 \ldots x_{i-1} x_{i+1}\ldots x_n} \\
(\lambda y . M)
\subst{\overline{N}}{\overline{x}} &=& \lambda z . M \subst{z}{y} \subst{\overline{N}}{\overline{x}} \\
&& \mbox{where $z$ is a fresh variables and } y \neq x_i \mbox{ for all } i
\end{eqnarray*}
\end{dfn}

In general, variable captures should be avoided, this explains why the definition
of simultaneous substitution uses auxiliary fresh variables.
However in the current setting, lemma \ref{lem:noclash} can clearly be transposed to
the simultaneous substitution therefore there is no need to rename variable.

The notion of substitution that we need is therefore
the \emph{capture permitting simultaneous substitution} defined as follow:

\begin{dfn}[Capture permitting simultaneous substitution]
 We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
 x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{where } x \not \neq y_i \mbox{ for all } i,\\
(M_1 M_2) \subst{\overline{N}}{\overline{x}} &=& (M_1 \subst{\overline{N}}{\overline{x}}) (M_2 \subst{\overline{N}}{\overline{x}})\\
(\lambda x_i . M) \subst{\overline{N}}{\overline{x}} &=& \lambda x_i . M
\subst{N_1 \ldots N_{i-1} N_{i+1}\ldots N_n}{x_1 \ldots x_{i-1} x_{i+1}\ldots x_n} \\
(\lambda y . M) \subst{\overline{N}}{\overline{x}} &=& \lambda y . M \subst{\overline{N}}{\overline{x}} \mbox{where $y \not = x_i$ for all $i$}
\qquad \mathbf{(\star)}
\end{eqnarray*}
The symbol $\mathbf{(\star)}$ identifies the equation that changed compared to the previous definition.
\end{dfn}

\begin{prop}
$$ \Gamma,\overline{x} \vdash^i M : A
\quad \mbox{and} \quad \Gamma \vdash^0 N_k : B_k \mbox{, } k \in 1..n
\qquad \mbox{ implies } \qquad
\Gamma \vdash^i M[\overline{N}/\overline{x}]$$
\end{prop}

\begin{proof}
Suppose that $\Gamma,\overline{x} \vdash^i M : A$ and  $\Gamma \vdash^0 N_k : B_k$ for $k \in 1..n$.

We prove $\Gamma \vdash^i M[\overline{N}/\overline{x}]$ by induction on the size of the proof
tree of $\Gamma,\overline{x} \vdash^i M : A$ and by case analysis on the last rule used.
We just give the detail for the abstraction case. Suppose that the property is verified for terms whose proof tree is
smaller than $M$. Suppose $\Gamma,\overline{x} \vdash^0 \lambda \overline{y} : \overline{C}. T : (\overline{C}|D)$ where
$\Gamma, \overline{y}:\overline{C},\overline{x} \vdash^i T : D$, then
by the induction hypothesis $\Gamma, \overline{y}:\overline{C} \vdash^i T\subst{\overline{N}}{\overline{x}} : D$.
We can then apply the rule $\mathbf{(abs^i)}$ and we get
$\Gamma \vdash^0 \lambda \overline{y}:\overline{C} . T \subst{\overline{N}}{\overline{x}}$.
\end{proof}


\begin{cor}[Simultaneous substitution preserves safety]
\label{cor:subst_preserve_safety}
If $M$ is safe and $N_k$ is safe for $k \in 1..n$ then  $M[\overline{N}/\overline{x}]$ is safe
\end{cor}

\begin{cor}
Consider a safe multi-redex $(\lambda \overline{x} . M ) \overline{N}$ where the $N_i$ are safe, then
we can reduced it to $M\subst{\overline{N}}{\overline{x}}$. This reduction produces
a safe term \textbf{provided that $M$ is also a safe term}.
\end{cor}


It is important to note that not all multi-$\beta$-reduction conserve safety. Only the reductions that
peal off enough $\lambda$-abstraction will reach a safe term and therefore preserve safety.\\
