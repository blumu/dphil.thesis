\section{Presentation}

\subsection{Homogeneous type}
\label{sec:homotypes}

Let $Types$ be the set of simple types generated by the grammar $A
\, ::= \, o \; | \; A \funsp A$. Any type different from the base
type $o$ can be written $(A_1, \cdots, A_n, o)$ for some $n \geq 1$,
which is a shorthand for $A_1 \funsp \cdots \funsp A_n \funsp o$ (by
convention, $\rightarrow$ associates to the right).

We suppose that a ranking function has been defined: ${\sf rank} :
Types \funto (L, \leq)$ where $(L, \leq)$ is any linearly ordered
set. Possible candidates for the ranking function are:
\begin{itemize}
\item ${\sf order} : Types \funto (\nat,\leq)$ with $\order{o} = 0$
and $\order{A \funsp B} = \max(\order{A}+1, \order{B})$.
\item ${\sf height} : Types \funto (\nat,\leq)$ with $\slheight{o} = 0$
and $\slheight{A \funsp B} = 1 + \max(\slheight{A}, \slheight{B})$.
\item ${\sf nparam} : Types \funto (\nat,\leq)$ with $\nparam{o} = 0$
and $\nparam{A_1, \cdots, A_n} = n$.
\item ${\sf ordernp} : Types \funto (\nat \times \nat,\leq)$ with $ {\sf ordernp} (t)  = (\order{t}, \nparam{t})$ for $t \in Types$.
\end{itemize}


Following \cite{KNU02}, a type is rank-homogeneous if it is $o$ or
if it is $(A_1, \cdots, A_n, o)$ with the condition that $rank(A_1)
\geq rank(A_2)\geq \cdots \geq rank(A_n)$ and each $A_1$, \ldots,
$A_n$ is rank-homogeneous.



Suppose that $\overline{A_1}$, $\overline{A_2}$, \ldots,
$\overline{A_n}$ are $n$ lists of types, where $A_{ij}$ denotes the
$j^{th}$ type of list $\overline{A_i}$ and $l_i$ the size of
$\overline{A_i}$. Then the notation $A \; = \; (\overline{A_1} \, |
\, \cdots \, | \, \overline{A_r} \, | \, o)$ means that
\begin{itemize}
  \item $A$ is the type $(A_{11},A_{12},\cdots, A_{1l_1}, A_{21}, \cdots,A_{2l_2}, \cdots A_{n1},\cdots, A_{nl_n},o)$
  \item $\forall i: \forall u,v \in A_i : \rank u = \rank v $
  \item $\forall i,j . \forall u \in A_i . \forall v \in A_j . i<j \implies \rank u >
   \rank v $
\end{itemize}
Consequently, $A$ is rank-homogenous. This notation organises the
$A_{ij}$s into partitions according to their ranks. Suppose $B =
(\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)$.
We write $(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, |
\, {B})$ to mean
\[(\overline{A_1} \, | \, \cdots \, | \, \overline{A_n} \, | \,
\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o).\]

From now on, the rank function that we consider is {\sf order}, the type order. The term ``homogeneous'' will refer to order-homogeneity.


\subsection{Rules }

These rules are a corrected version of
\cite{DBLP:conf/fossacs/AehligMO05}

 In the following we shall
consider terms-in-context $\seq{\Gamma}{M : A}$ of the simply-typed
$\lambda$-calculus. Let $\Delta$ be a simply-typed alphabet i.e.,
each symbol in $\Delta$ has a simple type. We write
$\terms{A}{\Delta}$ for the set of terms of type $A$ built up from
the set $\Delta$ understood as constant symbols, \emph{without}
using $\lambda$-abstraction.


The \textbfit{Safe $\lambda$-Calculus} is a sub-system of the
simply-typed $\lambda$-calculus. Typing judgements (or
terms-in-context) are of the form
\begin{equation}
\nonumber \seq{\overline{x_1}:\overline{A_1} \, | \, \cdots \, | \,
\overline{x_n} :  \overline{A_n}}{M : B}
\end{equation}
which is shorthand for $\seq{x_{11} : A_{11}, \cdots, x_{1r}:
A_{1r}, \cdots}{M : B}$. \emph{Valid typing judgements} of the
system are defined by induction over the following rules, where
$\Delta$ is a given homogeneously-typed alphabet:

\[ {    { \seq{\Sigma}{M:B} \qquad {\Sigma \subset \Delta} }
    \over
        { \seq{\Delta }{M : B}}
   }
   (\mbox{wk})
\]

\[  {
      { \seq{\Gamma}{M:B} \qquad \sigma(\Gamma) \hbox{ homogeneous} }
    \over
      { \seq{\sigma(\Gamma)}{M : B} }
    }
    (\mbox{perm})
\]


\[{ {b : o^r \rightarrow o \in \Sigma } \over {\seq{}{b : o^r \rightarrow o}}}  (\Sigma\mbox{-const})  \]

\[{ \over
{\seq{\overline{x_{ij}} : \overline{A_{ij}}\, }{x_{ij} :
A_{ij}}}}(\mbox{var})\]

\[
{ {\seq{\overline{x_1} : \overline{A_1}\, | \, \cdots\, | \,
\overline{x_{n+1}} : \overline{A_{n+1}}}{M : B}} \qquad
\ord{\overline{A_{n+1}}} \geq \ord{B} \over {\seq{\overline{x_1} :
\overline{A_1}\, | \, \cdots\, | \, \overline{x_{n}} :
\overline{A_{n}}}{\lterm{\overline{x_{n+1}} : \overline{A_{n+1}}}{M}
: (\overline{A_{n+1}} \, | \, B)}} } (\mbox{$\lambda$-abs})\]

\[ {{\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
\seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} : B_{1l}} \qquad l = |\overline{B_1}|
}
\over{ \seq{\Gamma}{M N_1 \cdots N_{l_1} :
(\overline{B_2} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)}}}
(\mbox{app})\]


\[ {{\seq{\Gamma}{M : (\overline{B_1} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)} \qquad
\seq{\Gamma}{N_1 : B_{11}} \quad \cdots \quad \seq{\Gamma}{N_{l} : B_{1l}} \qquad l < |\overline{B_1}|
}
\over{ \seq{\Gamma}{M N_1 \cdots N_{l_1} :
(\overline{B_2} \, | \, \cdots \, | \, \overline{B_m} \, | \, o)}}}
(\mbox{app+})\]

where $\overline{B_1} = B_{11}, \ldots, B_{1l},\overline{B}$ with the condition that every variable in $\Sigma$
has an order greater than $\ord{\overline{B_1}}$.








\begin{lem}[Basic properties]
\label{lem:safe_basic_prop} Suppose $\Gamma \vdash_s M : B$ is a
valid judgment then

\begin{itemize}
\item[(i)] $B$ is homogeneous
\item[(ii)] Every free variables of $M$ has order at least $ord(M)$
\end{itemize}
\end{lem}


\subsection{Substitution in the safe lambda calculus}

The traditional notion of substitution on which the $\lambda$-calculus is based on is the following:
\begin{dfn}[Substitution]
\begin{eqnarray*}
x \subst{t}{x} &=& t\\
 y\subst{t}{x} &=& y \quad \mbox{for } x \not \neq y,\\
(M_1 M_2) \subst{t}{y} &=& (M_1 \subst{t}{y}) (M_2 \subst{t}{y})\\
(\lambda x . M) \subst{t}{y} &=& \lambda z . M \subst{z}{x}
\subst{t}{y} \mbox{where $z$ is a fresh variable}
\end{eqnarray*}
\end{dfn}

In the setting of the safe lambda calculus, the notion of substitution can be simplified.
Indeed, we remark that for terms that satisfy the property \ref{lem:safe_basic_prop} (ii), there is no need to rename variables
when performing substitution. In particular, this is true for safe $\lambda$-terms.

\begin{lem}[No variable clash]
Suppose that $M$ and $N$ are simply typed $\lambda$-terms verifying the property
that every free variables occurring in $M$ and $N$ has an order at least $\ord{M}$ and $\ord{N}$ respectively. Then
there is no clash of variable name when performing the substitution:
\[ \qquad M[N / x] \]
for any variable $x$.
\end{lem}

\begin{proof}
We proceed by structural induction on $M$. The variable and application cases are trivial.
Suppose that $M$ is the abstraction $\lambda y . L$ and
suppose that there is no variable capture during the substitution $L[N/x]$ then the only case of variable
capture than can happen is when:
\begin{enumerate}
\item[(i)] the variable $x \neq y$ occurs freely in $L$ (and therefore occurs
freely in $M = \lambda y . L$ as well);
\item[(ii)] the variable $y$ (the captured variable) occurs freely in $N$
\end{enumerate}

Since $x$ is free in $M$, the property assumed on $M$ gives us:
$$ \ord{x} \geq \ord{\lambda y . L} \geq \max(1+ ord{y}, \ord{L}) > ord{y}$$

Since $y$ occurs freely in term $N$, the property assumed on $N$ gives us:
$$ \ord{y} \geq \ord{N} = \ord{x}  $$

We therefore reach a contradiction.
\end{proof}


Hence, under the assumption \ref{lem:safe_basic_prop}(ii), we can therefore simplify
the definition of the substitution and replace
$$(\lambda x . M) \subst{t}{y} = \lambda z . M \subst{z}{x}
\subst{t}{y} \mbox{where $z$ is a fresh variable}$$
by
$$(\lambda x . M) \subst{t}{y} = \lambda x . M \subst{t}{y}$$




We remark that homogeneity is preserved by substitution and (therefore by single $\beta$-reduction).
However property \ref{lem:safe_basic_prop}(ii) is not preserved by a single $\beta$-reduction.

To fix this problem, we introduce the notion of simultaneous substitution:



% provided
%that the substitution is performed \emph{simultaneously} on all free
%variables of the same order.

%The requirement that the substitution is performed simultaneously is
%quite strong: implementing simultaneously substitution requires to
%have access to an unbound number of fresh variables. Therefore in
%safe lambda calculus the fact that there is no variable capture
%during substitution does not really lead to a complete economy of
%variable names.
%
Hence under the assumptionin such setting,

%First we note that if the substitution is not simultaneous ($M
%\subst{N_1}{x_1}\ldots \subst{N_n}{x_n}$), then a variable capture
%arises if some $N_i$ has a free occurrence of a variable $x_j$ with
%$j>i$. However this capture does not happen when performing the
%substitutions simultaneously as follow: $M \subst{N_1, \ldots
%N_n}{x_1, \ldots x_n}$.




We will prove The first interesting property that we will prove for the safe
$\lambda$-calculus is that when performing substitution on safe
$\lambda$ term, there is no need to rename bound variables.

We

Substitution for simply typed lambda term is defined as follow:
Simultaneous substitution is defined as follow:

$$M\subst{N_1 \ldots N_n}{x_1 \ldots x_n} = M \subst{z_2}{x_2} \ldots \subst{z_n}{x_n} \subst{N_1}{x_1} \subst{N_2}{z_2} \ldots \subst{N_n}{z_n} $$
where $z_2 \ldots z_n$ are fresh variables.


In presence of constant symbols, (this is the case in the safe
lambda calculus), we add the following definition:
$$f \subst{t}{x} = f \quad \mbox{ where $f \in \Sigma$ is a first-order constant}$$






In fact, we can define the simultaneous substitution inductively
without relying on the definition of the standard substitution. Here
is the definition specialized to the safe lambda calculus case:

\begin{dfn}[Simultaneous substitution in the safe-lambda calculus]
\label{dnf:safe_simsubst}
 We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
f \subst{\overline{N}}{\overline{x}} &=& f \quad \mbox{ where $f\in\Sigma$ is a first-order constant} \\
x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
(M N_1 \ldots N_l) \subst{\overline{N}}{\overline{x}} &=& (M \subst{\overline{N}}{\overline{x}}) (N_1 \subst{\overline{N}}{\overline{x}}) \ldots  (N_l \subst{\overline{N}}{\overline{x}})\\
(\lambda \overline{y} : \overline{A}. T)
\subst{\overline{N}}{\overline{x}} &=& \lambda \overline{z} . T
\subst{\overline{z}}{\overline{y}}
\subst{\overline{N}}{\overline{x}} \\
&& \mbox{where $T$ is a safe
term and $\overline{z} = z_1, \ldots z_p$ are all fresh variables}
\end{eqnarray*}
\end{dfn}

This alternative definition permits us to observe the following two
properties:

\begin{property}[Simultaneous substitution on safe terms]
\label{prop:subst_preserve_safety} \
\begin{enumerate}
\item Performing simultaneous substitution on a safe term can be
achieved by inductively applying the simultaneous substitution on
other \emph{safe} sub-terms only.

\item Simultaneous substitution of safe terms preserves safety.
\end{enumerate}
\end{property}

\begin{proof}
\begin{enumerate}
\item By analysing the inductive definition \ref{dnf:safe_simsubst}, we
observe that each substitution is performed on a safe term provided
that the original term is safe. For the abstraction case, we remark
that the substitution $\subst{\overline{z}}{\overline{y}}$ is just a
renaming of variable that preserve safety.

\item Consider the safe terms $\Gamma \vdash_s S : A$ and  $\Gamma \vdash_s N_i : B_i$ for $i = 1..n$.

We prove that $S \subst{\overline{x}}{\overline{N}}$ is safe by
induction on the size of the proof tree of $\Gamma \vdash_s S : A$.
We just give the detail for the abstraction case:

Assume that we proved the property for all term whose proof tree is
smaller than $S$. Suppose $S = \lambda \overline{y} : \overline{A}.
T$ where $T$ is a safe term, then $T
\subst{\overline{z}}{\overline{y}}$ is just the term $T$ with its
variable $\overline{y}$ renamed to fresh names therefore it is safe.
By the induction hypothesis,
$T\subst{\overline{z}}{\overline{y}}\subst{\overline{N}}{\overline{x}}$
is also safe. We can apply the rule (abs) of the safe-lambda
calculus and we get that $\lambda \overline{z} . T
\subst{\overline{z}}{\overline{y}}
\subst{\overline{N}}{\overline{x}}$ is safe.
\end{enumerate}
\end{proof}


\subsection{Simultaneous substitution does not involve renaming}



%\begin{lem}[No variable clash lemma]
%In the safe $\lambda$-calculus, there is no clash of variable name
%when performing substitution:
%\[ \qquad M[N_1 / x_1 , \cdots, N_n / x_n] \]
% provided the substitution is performed simultaneously on
%\emph{all} free variables of the same order in $M$
%i.e.~$\makeset{x_1, \cdots, x_n}$ is the set variables of the same
%order as $x_1$ that occur free in $M$.
%\end{lem}
%
%\begin{proof}
%First we note that if the substitution is not simultaneous ($M
%\subst{N_1}{x_1}\ldots \subst{N_n}{x_n}$), then a variable capture
%arises if some $N_i$ has a free occurrence of a variable $x_j$ with
%$j>i$. However this capture does not happen when performing the
%substitutions simultaneously as follow: $M \subst{N_1, \ldots
%N_n}{x_1, \ldots x_n}$.
%
%
%
%Suppose that a variable capture occurs in the term $M$: $M$ has a
%subterm $\lambda y_1 \ldots y_p. T$ such that some $x_i$ appears
%freely in $T$ and some $y_k$ appears freely in $N_i$. By Property
%\ref{prop:subst_preserve_safety}, we can assume that the subterm
%$\lambda y_1 \ldots y_p . T$ is safe.
%
%Since $x_i$ appears freely in the safe term $\lambda y_1 \ldots y_p
%. T$, by Lemma \ref{lem:safe_basic_prop} (ii) we get:
%$$ ord(x_i) \geq ord(\lambda y_1 \ldots y_p . T) \geq 1+ ord(y_k) > ord(y_k)$$
%
%Since $y_k$ appears freely in the safe term $N_i$, Lemma
%\ref{lem:safe_basic_prop} (ii) gives:
%
%$$ ord(y_k) \geq ord(N_i) = ord(x_i)$$
%
%Hence we reach a contradiction.
%\end{proof}


\subsection{Simultaneous $\beta$ reduction}

We now define a notion of beta reduction that realizes simultaneous
substitution. Consider a simply-typed term $P$. A simultaneous
$\beta$-redex is a $P$ sub-term of the kind

$$R_1 \equiv (\lambda x_1 x_2 \ldots x_n . M) N_1 N_2 \ldots N_n$$

Reduction is only performed if the simultaneous $\beta$-redex
encompasses as many lambda abstraction of the same order as
possible. Such a redex (which cannot be extended to take into
account one more lambda abstraction of the same order) is called a
$\beta_s$-redex.


Example: consider a term $P$ with a subterm $((\lambda x_1 x_2
\ldots x_n . M) N_1 N_2 \ldots N_n) N_{n+1}$. Suppose that $M$ is
the abstraction $M \equiv \lambda x_{n+1} . U$ where $ord(x_{n+1}) =
x_1$. Then the redex $R_1$ will not be considered since it can be
enlarged as the redex $(\lambda x_1 x_2 \ldots x_n x_{n+1}. M) N_1
N_2 \ldots N_n N_{n+1}$. Now suppose instead that the term is formed
in such a way that there is no $N_{n+1}$ applied on the right of
$R_1$ then the redex $R_1$ will be considered (whether or not $M$ is
an abstraction).

We now give the formal definitions:

The following abbreviations are used $\overline{x} = x_1 \ldots
x_n$, $\overline{N} = N_1 \ldots N_n$, $\overline{x_l} = x_1 \ldots
x_l$, $\overline{x_r} = x_{l+1} \ldots x_n$, $\overline{N_l} = N_1
\ldots N_l$ and $\lambda \overline{x} : \overline{A} . T = \lambda
x_1^{A_1} \ldots x_1^{A_n} . T$.

\begin{dfn}[$\beta_s$-redex]
A safe simply typed lambda term is a redex if it has one of the
following forms:
\begin{itemize}
\item $(\lambda \overline{x} : \overline{A} . T) \overline{N}$
\quad with $|\overline{x}| = |\overline{N}| = n$, $ord(T) \leq
ord(\overline{x}) = ord(x_1) = \ldots = ord(x_n)$.

\item $(\lambda \overline{x_l} : \overline{A_l} \ \overline{x_r}: \overline{A_r} . T) \overline{N_l}$
\quad with $|\overline{x_l}| = |\overline{N_l}| = l$, $ord(T) \leq
ord(\overline{x}) = ord(x_1) = \ldots = ord(x_n)$.
\end{itemize}

These two cases correspond respectively to the formation rules (App)
and (App+) of the safe lambda calculus.

\end{dfn}

\begin{dfn}[Simultaneous $\beta$-reduction] \
\begin{itemize}
\item The relation $\beta_s$ is defined on the set of $\beta_s$-redex.
\begin{eqnarray*}
\beta_s &=&
 \{  \left( (\lambda \overline{x} : \overline{A} . T) \overline{N}, T\subst{\overline{x}}{\overline{N}} \right) \\
&& \mbox{ where }
     |\overline{x}| = |\overline{N}| = n \mbox{ and } ord(T) \leq ord(\overline{x}) = ord(x_1) = \ldots = ord(x_n)
\} \\
 && \union \quad \\
&& \{
    \left( (\lambda \overline{x_l} : \overline{A_l} \  \overline{x_r}: \overline{A_r} . T) \overline{N_l}, \lambda \overline{x_r}: \overline{A_r} . T\subst{\overline{x_l}}{\overline{N_l}} \right) \\
&& \mbox{ where }
 |\overline{x}| = |\overline{N}| = n \mbox{ and } ord(T) \leq ord(\overline{x}) = ord(x_1) = \ldots = ord(x_n)
\}
\end{eqnarray*}

Note that in the second case, the substitution is done under the
$\lambda \overline{x_r}$. The side condition of the formation rule
(App+) guarantees that there will not be any variable capture.

\item
The simultaneous $\beta$-reduction noted $\betasred$ is the closure
of the relation $\beta_s$ by compatibility with the formation rules
of the safe $\lambda$-calculus.
\end{itemize}
\end{dfn}

Note that $\beta_s$-redex are the only redex that can be reduced by
$\betasred$.




\subsection{Some properties of $\beta_s$ reduction}

We remark that $\betasred \subset \betaredtr$ (i.e. the simultaneous
$\beta$-reduction relation) is included in the transitive closure of
the $\beta$-reduction relation. More precisely, if $M \betasred N$
then $M \betaredtr N$. Simultaneous $\beta$-reduction is a certain
kind of multi-steps $\beta$-reduction.

\begin{lem} In the simply typed $\lambda$-calculus setting:
\begin{enumerate}
\item $\betasred$ is strongly normalizing.
\item $\beta_s$ has the unique normal form property.
\item $\beta_s$ has the Church-Rosser property.
\end{enumerate}
\end{lem}

\begin{proof}
\begin{enumerate}

%Proof of weak normalization:
%We know that $\betared$ is strongly normalizing: any reduction
%strategy leads to a normal form. In particular any strategy that
%performs consecutive $\beta$-redex of the same order consecutively
%will lead to a normal form. Since any such $\beta$ reduction
%strategy is also a $\beta_s$ reduction strategy, we can conclude
%that $\betasred$ is weakly normalizing.

\item This is because $\betasred \subset \betaredtr$ and $\betared$ is strongly normalizing (in the simply typed lambda calculus).

\item
A term has a $\beta_s$-redex iff it has a $\beta$-redex therefore
the set of $\beta_s$ normal form is equal to the set of $\beta_s$
normal form. Hence, the unicity of $\beta$ normal form implies the
unicity of $\beta_s$ normal form.

\item is a consequence of (i) and (ii).
\end{enumerate}
\end{proof}


%%
%%\begin{dfn}[Safe sub-terms]
%%Given a safe term $\Gamma \vdash_s M : A$, we define the set
%%$Safesub(M)$ of safe sub-terms of a $M$:
%%
%%\def\longtype#1#2{(\overline{{#1}_1} \, | \, \cdots \, | \, \overline{{#1}_{#2}} \, | \, o)}
%%
%%\begin{eqnarray*}
%%Safesub(b) &=& b  \qquad \mbox{ ($b \in \Sigma$ a first order constant)} \\
%%Safesub(x) &=& x \qquad \mbox{ ($x$ a variable) } \\
%%Safesub(M N_1 \ldots N_l) &=& \{M N_1 \ldots N_l \} \union Safesub(M) \union \Union_{i=1..l} Safesub(N_i) \\
%%&&\mbox{ where $M : \longtype{B}{n}$ and $ord(N_1) = \ldots =
%%ord(N_l) = ord(\overline{B})$}.\\
%%Safesub(\lambda x_1 \ldots x_n . N) &=& \{ \lambda x_1 \ldots x_n . N \} \union Safesub(R) \\
%%&&\mbox{ where $ord(x_1) = \ldots = ord(x_n)$ and $ord(x_1) \geq ord(N)$}\\
%%&&\mbox{ and $R = N$ if $x_1 \in fv(M)$ and $R = \lambda x_2 \ldots x_n . N$ otherwise.}\\
%%\end{eqnarray*}
%%
%%\end{dfn}
%%
%%It is easy to check that $Safesub(M)$ is indeed the set of all safe
%%sub-terms of $M$.



\begin{lem}
$\beta_s$-reduction preserves safety. (i.e. $M$ safe term and $M
\beta_s N$ implies $N$ safe)
\end{lem}


\begin{proof}
Simultaneous substitution preserves safety (property
\ref{prop:subst_preserve_safety}), therefore we just need to prove
that the relation $\beta_s$ preserves safety and the result will
follow:

 Suppose $s\ \beta_s\ t$ then $s$ is a $\beta_s$-redex. There are two kinds of them
 depending on which rule has been used last to form the redex.

\begin{itemize}
\item Suppose the last rules used is (App), then the redex is
$$s \equiv (\lambda x_1 \ldots x_n . M) N_1 \ldots N_n \qquad \betasred \qquad M[N_1 / x_1 , \cdots, N_n / x_n] \equiv t$$
where $ord(M) \leq ord(x_1) = \ldots = ord(x_n)$

The first premise of the rule (App) tells us that $M$ is safe,
therefore since substitution preserves safety, (property
\ref{prop:subst_preserve_safety}), $t$ is safe.

\item Suppose the last rules used is (App+), then the redex is

 $$
s \equiv  (\lambda \overline{x_l} : \overline{A_l} \
\overline{x_r}: \overline{A_r} . T) \overline{N_l} \qquad \betasred
\qquad \lambda \overline{x_r}: \overline{A_r} .
T\subst{\overline{x_l}}{\overline{N_l}} \equiv  t
$$
where $ord(T) \leq ord(x_1) = \ldots = ord(x_n)$

$T\subst{\overline{x_l}}{\overline{N_l}}$ is safe for the same
reason as in the first case. We can then apply the rule (Abs) and
that prove the safety of $t$.
\end{itemize}
\end{proof}



\begin{rem}
\label{rem:betasred_notpreserv_unsafety} While $\betasred$ preserves
safety it does not however preserves un-safety: given two terms of
the same type, one safe $\Gamma \vdash_s S : A$ and the other unsafe
$\Gamma \vdash U : A$, the term $(\lambda x y . y) U S$ is unsafe
but it $\beta_s$-reduces to $S$ which is safe.
\end{rem}

\subsection{Pointer-less strategies}
\label{subsec:ptrless_strat}

Up to order 2, the semantics of PCF terms is entirely defined by
pointer-less strategies. In other words, the pointers can be
uniquely reconstructed from any non justified sequence of moves
satisfying the visibility and well-bracketing condition.

At level 3 however, pointers cannot be omitted. There is an example
in \cite{abramsky:game-semantics} to illustrate this. Consider the
following two terms of type $((\nat \typar \nat) \typar \nat) \typar
\nat$:

$$M_1 = \lambda f . f (\lambda x . f (\lambda y .y ))$$
$$M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$$

We assign tags to the types in order to identify in which arena the
questions are asked: $((\nat^1 \typar \nat^2) \typar \nat^3) \typar
\nat^4$. Consider now the following pointer-less sequence of moves
$s = q^4 q^3 q^2 q^3 q^2 q^1$. It is possible to retrieve the
pointers of the first five moves but there is an ambiguity for the
last move: does it point to the first or second occurrence of $q^3$
in the sequence $s$?

Note that the visibility condition does not eliminate the ambiguity,
since the two occurrences of $q^3$ both appear in the P-view at that
point (after recovering the pointers of $s$ up to the second last
move we get $s = \justseq{ q^4 & q^3 \pointto{l} & q^2 \pointto{l} &
q^3 \pointto{ll} & q^2 \pointto{l} & q^1 }$ , therefore the P-view
of $s$ is $s$ itself.)

In fact these two different possibilities correspond to two
different strategies. Suppose that the link goes to the first
occurrence of $q^3$ then it means that the proponent is requesting
the value of the variable $x$ bound in the subterm $\lambda x . f (
\lambda y. ... )$. If P needs to know the value of $x$, this is
because P is in fact following the strategy of the subterm $\lambda
y . x$. And the entire play is part of the strategy $\sem{M_2}$.

Similarly, if the link points to the second occurrence of $q^3$ then
the play belongs to the strategy $\sem{M_1}$.

\subsection{Game semantics of safe $\lambda$ terms}

We would like to find out whether the safety condition defined in
\cite{Ong2005} leads to a pointer economy in the corresponding game
semantics.

The example of section \ref{subsec:ptrless_strat} is a good example
to start with. We observe that for this particular example and in
the safe $\lambda$-calculus setting, the ambiguity that led us to
the addition of pointers to strategies disappear. More precisely,
$M_1$ is a safe term whereas $M_2$ is not. Indeed, there is a free
occurrence of the variable $x$ of type $o$ in the subterm $f
(\lambda y . x)$ which is not abstracted together with $y$ of type
$o$.


\begin{enumerate}
\item
Is it the case that in general, the pointers from the semantics of
safe $\lambda$-terms can be reconstructed uniquely from the moves of
the play?


\item
Is there any unsafe term whose game semantics is a strategy where
pointers can be recovered?

The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
where $i =1..2$ and $\Gamma \vdash_s S : A$. $T_1$ and $T_2$ both
$\beta$-reduce to the safe term $S$, therefore
$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
unsafe. Since it is possible to recover the pointer from the game
semantics of $S$, it is as well possible to recover the pointer from
the semantics of $T_2$ which is unsafe.

\item
Is there any unsafe $\beta$-normal form whose game semantics is a
strategy where pointers can be recovered?


\end{enumerate}


\subsection{$\eta$-extension}

Let $\eta$-normal form of a term is the term obtained after
hereditarily $\eta$-expanding every subterm.

\def\etanfaux#1{\lceil#1 \rceil}
\def\etanf#1{\eta-nf\left( #1 \right)}

\begin{eqnarray*}
%\etanf{\lambda x . M} = \lambda x . \etanf{M}\\
\end{eqnarray*}

\subsection{Pointers in the game semantics of safe terms are recoverable}

We claim that the pointers in the game semantics of a safe term are
uniquely recoverable.

Consider a term $M$ safe, we can assume that $M$ is in $\eta$ normal
form (provided that safety is preserved by $\eta$-expansion.

The term can be represented by a computation tree: nodes at even
depth (starting at level 0) correspond to $\lambda$ and nodes at odd
length corresponds to either application $@$, variable $x$ or
variable followed by an application $f@$. A $\lambda$ node
represented consecutive abstraction of variables.

There justification pointers going upward from variable occurrences
to their bindings.

In the game semantics of the term $M$, the pointers for O and P
answers can be recovered by using the well-bracketing condition.

For O-question, the justification pointer always points to its
parent node in the computation tree.

For P-question, suppose P ask for the value of variable $x$. Then
there may be several choices for the destination of the pointer but
we claim that in the case of safe terms, it should point to the
closest parent node (in the path from the root to P-question) whose
order is greater than the order of $x$.
