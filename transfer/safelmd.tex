\section{Non homogeneous safe $\lambda$-calculus}

In section \ref{sec:safe_alt}, we have presented a safe lambda calculus in the setting of homogeneous types.
In this section, we try to give a general notion of safety for the simply typed $\lambda$-calculus.
The rules we give here do not assume homogeneity of the types.

We will call safe terms the simply typed lambda terms that are typable within the following system of formation rules:

\subsection{Rules}

 We use a set of sequents of the form $\Gamma \vdash^{i} M :
A$ where the meaning is ``variables in $\Gamma$ have orders at least
$\ord{A}+i$'' where $i \in \nat$. The following set of rules are
defined for $i \in \nat$:

$$ \mathbf{(seq^i_\delta)} \quad \rulef{\Gamma \vdash^{i} M : A}{\Gamma \vdash^{i-\delta} M : A} \quad i \in \nat, \delta > 0  $$

$$ \mathbf{(var)} \quad  \rulef{}{x : A\vdash^{0} x : A} $$

$$ \mathbf{(wk^i)} \quad  \rulef{\Gamma \vdash^i M : A}{\Gamma , x : B \vdash^i M : A} \quad \ord{B} \geq \ord{A} + i $$

$$ \mathbf{(app)} \quad  \rulef{\Gamma \vdash^{-1} M : (A,\ldots,A_l,B)
                                        \qquad \Gamma \vdash^{0} N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash^{0} N_l : A_l  }
                                   {\Gamma  \vdash^0 M N_1 \ldots N_l : B}
                                    \qquad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{B}$$

$$ \mathbf{(abs^i)} \quad  \rulef{\Gamma, \overline{x} : \overline{A} \vdash^{i} M : B}
                                   {\Gamma  \vdash^{0} \lambda \overline{x} : \overline{A} . M : (\overline{A},B)} \qquad
                                   \forall y \in \Gamma : \ord{y} \geq \ord{\overline{A},B}$$


Note that:
\begin{itemize}
\item $(\overline{A},B)$ denotes the type $(A_1,A_2, \ldots, A_n, B)$;
\item all the types appearing in the rule are not required to be homogeneous. For instance in the rule $\mathbf{(app)}$,
for the type $(A,\ldots,A_l,B)$, we do not necessary have $\ord{A_l} \geq \ord{B}$;
\item the environment $\Gamma, \overline{x}:\overline{A}$ is not stratified. In particular, variables in $\overline{x}$ do not necessarily have the same order.

\item In the abstraction rule, the side-condition imposes that at least all the variable of the lowest order
in the context are abstracted. However other variables can also be abstracted together with the lowest order variables.
Moreover there is not constraint on the order on which the variables are abstracted
(contrary to what happens in the homogeneous case).
\item The sequents $\Gamma \vdash^0 M$ are the \emph{safe terms} that we want to generate.
Other terms are only used as intermediate sequents in a proof tree.
\end{itemize}

\begin{exmp}
Suppose $x:o$, $f:o\rightarrow o$ and $\varphi:(o\rightarrow o)\rightarrow o$ then the
term $$\vdash^0 \lambda x f \varphi . \varphi : o \rightarrow (o\rightarrow o) \rightarrow ((o\rightarrow o)\rightarrow o) \rightarrow (o\rightarrow o)\rightarrow o$$ is valid although its type is not homogeneous
\end{exmp}


\begin{lem}[Basic properties]
\label{lem:nonhomosafe_basic_prop} Suppose $\Gamma \vdash^0 M : B$
is a valid judgment then every variable in $\Gamma$ has order at
least $ord(M)$.
\end{lem}
\begin{proof}
An easy induction on the proof tree shows that if $\Gamma \vdash^{i}
M : A$ then the variables in $\Gamma$ have orders at least
$\ord{A}+i$.
\end{proof}

\subsection{Substitution in the safe lambda calculus}

The traditional notion of substitution, on which the $\lambda$-calculus is based on, is the following one:
\begin{dfn}[Substitution]
\label{dfn:subst}
\begin{eqnarray*}
c \subst{t}{x} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
x \subst{t}{x} &=& t\\
 y\subst{t}{x} &=& y \quad \mbox{for } x \not \neq y,\\
(M_1 M_2) \subst{t}{x} &=& (M_1 \subst{t}{x}) (M_2 \subst{t}{x})\\
(\lambda x . M) \subst{t}{x} &=& \lambda x . M\\
(\lambda y . M) \subst{t}{x} &=& \lambda z . M \subst{z}{y}
\subst{t}{x} \mbox{where $z$ is a fresh variable and $x\not = y$}
\end{eqnarray*}
\end{dfn}

In the setting of the safe lambda calculus, the notion of substitution can be simplified.
Indeed, we remark that for safe $\lambda$-terms there is no need to rename variables
when performing substitution:

\begin{lem}[No variable capture lemma]
\label{lem:noclash}
There is no variable capture when performing substitution on a safe term.
\end{lem}
\begin{proof}
Suppose that a capture occurs during the substitution $M[N/\varphi]$
where $M$ and $N$ are safe. Then the following conditions must hold:
\begin{enumerate}
\item $\varphi:A, \Gamma \vdash^0 M$,
\item $\Gamma' \vdash^0 N$,
\item there is a subterm $\lambda \overline{x} . L$ in $M$ (where the abstraction is taken as wide as possible) such that:
\item $\varphi \in fv(\lambda \overline{x} . L)$ (and therefore $\varphi \in fv(L)$),
\item $x \in fv(N)$ for some $x \in \overline{x}$.
\end{enumerate}

By lemma \ref{lem:nonhomosafe_basic_prop} and (v) we have:

\begin{equation}
\ord{x} \geq \ord{N} = \ord{\varphi} \label{eq:xigeqphi}
\end{equation}

The abstraction $\lambda \overline{x} . L$ (taken as large as possible)
is a subterm of $M$, therefore there is a node $\Sigma \vdash^u \lambda \overline{x} . L$  for some $u$ in the
proof tree of $\varphi:A, \Gamma \vdash^0 M$.

There are only three kinds of rules that can produce an abstraction:
$\mathbf{(abs^i)}$, $\mathbf{(seq^i_\delta)}$ and $\mathbf{(wk^i)}$.
The only one that can introduce the abstraction is
$\mathbf{(abs^i)}$. Therefore the proof tree has the following form:

$$ \rulef{
    \rulef{
        \rulef{
            \rulef  {\ldots}
                   {\Sigma' \vdash^0 \lambda \overline{x} . L} \mathbf{(abs^i)}
        }
        {\ldots} r_1
    }
    {\vdots} r_2
    }
    { \Sigma \vdash^u \lambda \overline{x} . L } r_l
    \qquad \mbox{where } r_j \in \{ \mathbf{(seq^i_\delta)},\ \mathbf{(wk^i)}\ |\ i \in \nat, \delta > 0 \},
            \quad j\in 1..l.
$$


Since $\varphi \in fv (L)$ we must have $\varphi \in \Sigma'$ and
since $\Sigma' \vdash^0 \lambda \overline{x} . L$, by lemma
\ref{lem:nonhomosafe_basic_prop} we have:

$$\ord{\varphi} \geq \ord{\lambda \overline{x} . L} \geq \max(1+ \ord{x}, \ord{L}) > \ord{x}$$

which contradicts equation (\ref{eq:xigeqphi}).
\end{proof}

Hence, in the safe lambda calculus setting, we can omit to
to rename variable when performing substitution. The equation
$$(\lambda x . M) \subst{t}{y} = \lambda z . M \subst{z}{x}
\subst{t}{y} \mbox{where $z$ is a fresh variable}$$
becomes
$$(\lambda x . M) \subst{t}{y} = \lambda x . M \subst{t}{y}$$



Unfortunately, this notion of substitution is still not adequate for the purpose of the
safe simply-typed lambda calculus. The problem is that performing a single
$\beta$-reduction on a safe term will not necessarily produce another safe term.

To fix this problem, we need to be able to reduce several consecutive
$\beta$-redex at the same time until we obtain a safe term. Consequently, we need a mean of performing
several substitutions at the same time.
To achieve this, we introduce the \emph{simultaneous substitution},
 a generalization of the standard substitution given in definition \ref{dfn:subst}.

\begin{dfn}[Simultaneous substitution]
\label{dnf:simsubst}
 We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{ if } y \not \neq x_i \mbox{ for all } i,\\
(M N) \subst{\overline{N}}{\overline{x}} &=& (M \subst{\overline{N}}{\overline{x}}) (N \subst{\overline{N}}{\overline{x}}) \\
(\lambda x_i . M) \subst{\overline{N}}{\overline{x}} &=& \lambda x_i . M
\subst{N_1 \ldots N_{i-1} N_{i+1}\ldots N_n}{x_1 \ldots x_{i-1} x_{i+1}\ldots x_n} \\
(\lambda y . M)
\subst{\overline{N}}{\overline{x}} &=& \lambda z . M \subst{z}{y} \subst{\overline{N}}{\overline{x}} \\
&& \mbox{where $z$ is a fresh variables and } y \neq x_i \mbox{ for all } i
\end{eqnarray*}
\end{dfn}

In general, variable captures should be avoided, this explains why the definition
of simultaneous substitution uses auxiliary fresh variables.
However in the current setting, lemma \ref{lem:noclash} can clearly be transposed to
the simultaneous substitution therefore there is no need to rename variable.

The notion of substitution that we need is therefore
the \emph{capture permitting simultaneous substitution} defined as follow:

\begin{dfn}[Capture permitting simultaneous substitution]
 We use the notation
$\subst{\overline{N}}{\overline{x}}$ for $\subst{N_1 \ldots N_n}{x_1
\ldots x_n}$:
\begin{eqnarray*}
c \subst{\overline{N}}{\overline{x}} &=& c \quad \mbox{where $c$ is a $\Sigma$-constant}\\
 x_i \subst{\overline{N}}{\overline{x}} &=& N_i\\
 y \subst{\overline{N}}{\overline{x}} &=& y \quad \mbox{where } x \not \neq y_i \mbox{ for all } i,\\
(M_1 M_2) \subst{\overline{N}}{\overline{x}} &=& (M_1 \subst{\overline{N}}{\overline{x}}) (M_2 \subst{\overline{N}}{\overline{x}})\\
(\lambda x_i . M) \subst{\overline{N}}{\overline{x}} &=& \lambda x_i . M
\subst{N_1 \ldots N_{i-1} N_{i+1}\ldots N_n}{x_1 \ldots x_{i-1} x_{i+1}\ldots x_n} \\
(\lambda y . M) \subst{\overline{N}}{\overline{x}} &=& \lambda y . M \subst{\overline{N}}{\overline{x}} \mbox{where $y \not = x_i$ for all $i$}
\qquad \mathbf{(\star)}
\end{eqnarray*}
The symbol $\mathbf{(\star)}$ identifies the equation that changed compared to the previous definition.
\end{dfn}

\begin{lem}
$$ \Gamma,\overline{x} : \overline{A}\vdash^i M : T
\quad \mbox{and} \quad \Gamma \vdash^0 N_k : B_k \mbox{, } k \in 1..n
\qquad \mbox{ implies } \qquad
\Gamma \vdash^i M[\overline{N}/\overline{x}] : T$$
\end{lem}

\begin{proof}
Suppose that $\Gamma,\overline{x}: \overline{A} \vdash^i M :T$ and  $\Gamma \vdash^0 N_k : B_k$ for $k \in 1..n$.

We prove $\Gamma \vdash^i M[\overline{N}/\overline{x}]$ by induction on the size of the proof
tree of $\Gamma,\overline{x}:\overline{A} \vdash^i M : T$ and by case analysis on the last rule used.
We just give the detail for the abstraction case. Suppose that the property is verified for terms whose proof tree is
smaller than $M$. Suppose $\Gamma,\overline{x}:\overline{A} \vdash^0 \lambda \overline{y} : \overline{C}. P : (\overline{C}|D)$ where
$\Gamma, \overline{x}:\overline{A}, \overline{y}:\overline{C} \vdash^i P : D$, then
by the induction hypothesis $\Gamma, \overline{y}:\overline{C} \vdash^i P\subst{\overline{N}}{\overline{x}} : D$.
Applying the rule $\mathbf{(abs^i)}$ gives
$\Gamma \vdash^0 \lambda \overline{y}:\overline{C} . P \subst{\overline{N}}{\overline{x}}$. Then the rule
$\mathbf{(seq^i_\delta)}$ gives the result wanted.
\end{proof}

In the simply-typed lambda calculus a redex is a term of the form $(\lambda x . M) N$.
We generalize this definition to the safe lambda calculus:
\begin{dfn}[Safe redex]
We call safe redex a term of the form $(\lambda \overline{x} . M) N_1 \ldots N_l$
such that:
\begin{itemize}
\item $ \Gamma \vdash^0 (\lambda \overline{x} . M) N_1 \ldots N_l $
\item the variable $\overline{x}=x_1\ldots x_n$ are abstracted altogether by one occurrence of the rule \textbf{(abs)} in the proof tree.
\item The terms $(\lambda \overline{x} . M)$, $N_1$, $N_l$ are applied together at once using the \textbf{(app)} rule :
$$   \rulef{
            \Sigma \vdash^{-1} \lambda \overline{x} . M
            \quad
            \Sigma \vdash^0 N_1         \quad \ldots \quad \Sigma \vdash^0 N_l
    }
    {
       \Sigma \vdash^0 (\lambda \overline{x} . L) N_1 \ldots N_l
    } (\mathbf{app})
$$
Consequently each $N_i$ is safe.

\item $l\leq n$
\end{itemize}
\end{dfn}

Note that the condition $l\leq n$ in the definition is not too restrictive because if $l>n$ then
the application rule is too wide and can in fact be replaced by an application of exactly
$n$ terms followed by another application for the remaining terms $N_{n+1}, \ldots, N_l$.

A safe redex $(\lambda \overline{x} . M) N_1 \ldots N_l$ can be reduced simultaneously to
$\lambda x_l \ldots x_n . M \subst{N_1 \ldots N_l}{x_1 \ldots x_l}$

Using the previous lemma, we will now prove that this reduction produces a safe term:

\begin{lem}
\label{lem:safereduction}
A safe redex reduces to a safe term.
\end{lem}

\begin{proof}
We note $\overline{A}$ for $A_1, \ldots , A_n$. A safe redex in the safe $\lambda$-calculus
must have a proof tree of the following form:
$$
   \rulef{
        \rulef{
            \rulef{
                \rulef{
                    \rulef
                        { \rulef
                            {\vdots}
                            {\Sigma',\overline{x}:\overline{A}\vdash^i L:C  }
                        }
                        {\Sigma' \vdash^0 \lambda \overline{x} . L : \overline{A}|C} \mathbf{(abs^i)}
                }
                {\vdots} r_1
            }
            {\vdots} r_2
            }
            { \Sigma \vdash^{-1} \lambda \overline{x} . L : A_1, \ldots , A_l|B} r_q
            \quad
            \Sigma \vdash^0 N_1 : A_1
            \quad \ldots \quad \Sigma \vdash^0 N_l : A_l
    }
    {
       \Sigma \vdash^0 (\lambda \overline{x} . L) N_1 \ldots N_l : B
    } (\mathbf{app})
$$
with the following conditions:
\begin{enumerate}
\item for $j\in 1..q$, $r_j \in \{ \mathbf{(seq^0_{1})}, \mathbf{(wk^0)}, \mathbf{(wk^{-1})} \}$ therefore
$\Sigma = \Sigma' \union \Delta$ where $\Delta$ contains the variables introduced
by the rules $r_1 \ldots r_q$.

\item $A_1, \ldots , A_l|B = A_1, \ldots , A_n|C$ and $l\leq n$. Therefore
$\ord{B} \geq \ord{C}$.
\item The side condition of the rule \textbf{(abs)} gives: $\forall z \in \Sigma : \ord{z} \geq \ord{B}$
\end{enumerate}

We use the notation $\overline{x}'$ and $\overline{x}''$ for $x_1 \ldots x_l$ and
$x_{l+1} \ldots x_n$ respectively.

The conditions 2 and 3 ensure that $\forall z \in \Delta : \ord{z} \geq \ord{C}$ therefore
we can use the weakening rule to introduce all the variable of $\Delta$ in the context of the
sequent $\Sigma',\overline{x}:\overline{A}\vdash^i L:C$:

$$\rulef{\rulef{ \Sigma',\overline{x}:\overline{A}\vdash^i L:C  }
        {\vdots} (wk^i_0)}
        {\Sigma,\overline{x}:\overline{A}\vdash^i L:C} (wk^i_0)
$$

By lemma \ref{lem:safereduction} we obtain:
$$ \Sigma, \overline{x}'':\overline{A}'' \vdash^i L\subst{N_1 \ldots N_l}{\overline{x}'}$$
Finally using the abstraction rule:
$$ \Sigma \vdash^0 \lambda \overline{x}'':\overline{A}'' . L\subst{N_1 \ldots N_l}{\overline{x}'}$$
\end{proof}





\subsection{Game semantics of safe $\lambda$ terms}

We would like to find out whether the safety condition defined in
\cite{Ong2005} leads to a pointer economy in the corresponding game
semantics.

The example of section \ref{subsec:ptrless_strat} is a good example
to start with. We observe that for this particular example and in
the safe $\lambda$-calculus setting, the ambiguity that led us to
the addition of pointers to strategies disappear. More precisely,
$M_1$ is a safe term whereas $M_2$ is not. Indeed, there is a free
occurrence of the variable $x$ of type $o$ in the subterm $f
(\lambda y . x)$ which is not abstracted together with $y$ of type
$o$.


\begin{enumerate}
\item
Is it the case that in general, the pointers from the semantics of
safe $\lambda$-terms can be reconstructed uniquely from the moves of
the play?


\item
Is there any unsafe term whose game semantics is a strategy where
pointers can be recovered?

The answer is yes: take the term $T_i = (\lambda x y . y) M_i S$
where $i =1..2$ and $\Gamma \vdash  S : A$. $T_1$ and $T_2$ both
$\beta$-reduce to the safe term $S$, therefore
$\sem{T_1}=\sem{T_2}=\sem{S}$. But $T_1$ is safe whereas $T_2$ is
unsafe. Since it is possible to recover the pointer from the game
semantics of $S$, it is as well possible to recover the pointer from
the semantics of $T_2$ which is unsafe.

\item
Is there any unsafe $\beta$-normal form whose game semantics is a
strategy where pointers can be recovered?


\end{enumerate}


\subsection{$\eta$-extension}
\todobox{definition of $\eta$-extension, $\eta$-normal form}

Let $\eta$-normal form of a term is the term obtained after
hereditarily $\eta$-expanding every subterm.

\def\etanfaux#1{\lceil#1 \rceil}
\def\etanf#1{\eta-nf\left( #1 \right)}

\begin{eqnarray*}
%\etanf{\lambda x . M} = \lambda x . \etanf{M}\\
\end{eqnarray*}

\subsection{Pointers in the game semantics of safe terms are recoverable}

\todomargin{rework this paragraph!}

We claim that the pointers in the game semantics of a safe term are
uniquely recoverable.

\todobox{Need to prove that safety is preserved by $\eta$-expansion.}

Consider a term $M$ safe, we can assume that $M$ is in $\eta$ normal
form.

The term can be represented by a computation tree: nodes at even
depth (starting at level 0) correspond to $\lambda$ and nodes at odd
length corresponds to either application $@$, variable $x$ or
variable followed by an application $f@$. A $\lambda$ node
represented consecutive abstraction of variables.

There justification pointers going upward from variable occurrences
to their bindings.

In the game semantics of the term $M$, the pointers for O and P
answers can be recovered by using the well-bracketing condition.

For O-question, the justification pointer always points to its
parent node in the computation tree.

For P-question, suppose P ask for the value of variable $x$. Then
there may be several choices for the destination of the pointer but
we claim that in the case of safe terms, it should point to the
closest parent node (in the path from the root to P-question) whose
order is greater than the order of $x$.
