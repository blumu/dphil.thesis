\ifx\incrcompilation\undefined \input preamble.tex \fi

\newcommand\highlight{\textcolor{blue}}
\newcommand\pcfsucc{\texttt{succ}}
\newcommand\nat{\mathbb{N}}
\newcommand\prefset{\textsf{Pref}}


\title{\texorpdfstring{The Safe $\lambda$-Calculus}{The Safe Lambda-Calculus}}
\author[W. Blum]{William Blum}

\institute[University Of Oxford]{ \color{red}{Oxford University Computing Laboratory}
\vspace{20pt}

\textcolor{black}{\small PRS Transfer}}
\date{\small 6 December 2006}


\begin{document}

\section{Title page}
  \frame{\titlepage}

%\section<presentation>*{Outline}
%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents[part=1]
%\end{frame}
%\AtBeginSection[] {
%   \begin{frame}<beamer>
%     \frametitle{Outline}
%     \tableofcontents[currentpart,currentsection]
%   \end{frame}
% }
%
%\part<presentation>{Main Talk}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}
\frame{\frametitle{Overview}

\begin{itemize}
\item \textcolor{blue}{Safety} is a restriction for higher-order grammars.
\item It can be transposed to the $\lambda$-calculus, giving rise to the \textcolor{blue}{Safe $\lambda$-calculus}.
\item Safety has nice algorithmic properties, automata-theoretic and game-semantic characterizations.
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Outline for this talk}
%\frame{
%\frametitle{Outline for this talk}
%\begin{enumerate}
%\item The Safety Restriction
%\item The simply typed $\lambda$-calculus
%\item The Safe $\lambda$-calculus
%\item Game-semantic characterisation
%\end{enumerate}
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{What is the Safety Restriction?}
\frame{\frametitle{What is the Safety Restriction?}
\begin{itemize}
\item First appeared under the name ``restriction of derived types'' in ``IO and OI Hierarchies'' by W. Damm, TCS 1982
\item It is a \highlight{syntactic restriction} for higher-order grammars that constrains the occurrences
of the variables in the grammar equations according to their orders.
\begin{thm}[Knapik, Niwi\'nski and Urzyczyn (2001,2002)]
\begin{enumerate}
\item
The Monadic Second Order (MSO) model checking problem for trees generated by \alert{safe} higher-order grammars of any order is decidable.
\item \highlight{Automata-theoretic characterization}:
Safe grammars of order $n$ are as expressive as pushdown automata of order $n$.
\end{enumerate}
\end{thm}
\item Aehlig, de~Miranda, Ong (2004) introduced the \highlight{Safe $\lambda$-calculus}.
\end{itemize}

\note{
\begin{itemize}
\item PDA = finite state machines + stack
\item 1PDA = recognizes context-free language.
\item nPDA
\item MSO is very expressive: more than the modal mu-calculus (into which LTL CTL CTL* can be embedded.)
\end{itemize}
}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simply Typed \texorpdfstring{$\lambda$}{Lambda}-Calculus}
\frame{\frametitle{Simply Typed $\lambda$-Calculus}
\begin{itemize}
\item \highlight{Simple types} $A := o\ |\ A \rightarrow A$.
%We write $(A_1,\ldots, A_n)$ for $A_1\rightarrow \ldots \rightarrow A_n$.
\pause
\item The \highlight{order} of a type is given by $\textsf{order}(o) = 0$,
$\textsf{order}(A \rightarrow B) = \max(\textsf{order}(A) + 1, \textsf{order}(B))$.
\pause
\item Jugdements of the form $ \Gamma \vdash M : T $ where $\Gamma$ is the context, $M$ is the term and $T$ is the type :
$$ \rulename{var} \   \rulef{}{x : A\vdash x : A}
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash M : A}{\Delta \vdash M : A} \ \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash M : A \rightarrow B \quad \Gamma \vdash N : A }
                           {\Gamma  \vdash M N : B}
\quad \rulename{abs} \   \rulef{\Gamma, x : A \vdash M : B}
                                {\Gamma  \vdash \lambda x^A. M : A \rightarrow B}$$
\pause
\item Example: $f:o\rightarrow o\rightarrow o, x:o \vdash (\lambda \varphi^{o \rightarrow o} x^o . \varphi\ x) (f\ x)$
\pause
\item A single rule: \highlight{$\beta$-reduction}. e.g. $(\lambda x. M) N \betared M [N/x]$
\end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Variable Capture}
\frame{\frametitle{Variable Capture} \highlight{The usual
``problem'' in $\lambda$-calculus}: avoid \alert{variable capture}
when performing substitution: $ (\lambda x . (\lambda y . x)) y
\betared (\lambda \underline{y} . x) [\underline{y}/x] \neq \lambda
y . y$\pause
\begin{enumerate}
\item \highlight{Standard solution}: Barendregt's convention. Variables are renamed so that free variables and bound variables have different names.
Eg. $(\lambda x . (\lambda y . x)) y$ becomes $(\lambda x . (\lambda
z . x)) y$ which reduces to $(\lambda z . x) [y/x] = \lambda z . y$
\pause

\alert{Drawback:} requires to have access to an unbounded supply of names to perform
a given sequence of $\beta$-reductions.
\note{Drawback 1, eg. $(\lambda x_1 \ldots x_n . (\lambda y_1 \ldots y_n . x_1 \ldots x_n)) y_1 \ldots y_n$}
\pause

\item \highlight{Another solution}: switch to the $\lambda$-calculus \`a la de Brujin where variable binding is specified by an index instead of a name.
Variable renaming then becomes unnecessary.
\pause

\alert{Drawback:} the conversion to nameless de Brujin $\lambda$-terms requires an unbounded supply of indices.
\pause
\end{enumerate}
\alert{Safety avoids the need for variable renaming!} }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Safe \texorpdfstring{$\lambda$}{Lambda}-Calculus}
\begin{frame} \frametitle{The Safe $\lambda$-Calculus}
\begin{block}{The formation rules}
$$ \rulename{var} \   \rulef{}{x : A\vdash_s x : A}
\qquad  \rulename{wk} \   \rulef{\Gamma \vdash_s M : A}{\Delta \vdash_s
M : A} \ \Gamma \subset \Delta$$
$$ \rulename{app} \  \rulef{\Gamma \vdash M : (A,\ldots,A_l,B)
                                        \quad \Gamma \vdash_s N_1 : A_1
                                        \quad \ldots \quad \Gamma \vdash_s N_l : A_l  }
                                   {\Gamma  \vdash_s M N_1 \ldots N_l : B}$$
\hfill with the side-condition $\textcolor{red}{\forall y \in \Gamma
: \ord{y} \geq \ord{B}}$
$$ \rulename{abs} \   \rulef{\Gamma, x_1:A_1 \ldots x_n : A_n \vdash_s M : B}
                                   {\Gamma  \vdash_s \lambda x_1:A_1 \ldots x_n : A_n . M : A_1 \rightarrow \ldots \rightarrow A_n \rightarrow B}$$
\hfill with the side-condition $\textcolor{red}{\forall y \in \Gamma
: \ord{y} \geq \ord{A_1 \rightarrow \ldots \rightarrow A_n
\rightarrow B}}$
\end{block}
\pause
\begin{block}{Property}
In the Safe $\lambda$-calculus there is no need to rename variables when
performing $\beta$-reduction.
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example}
\frame{\frametitle{Example}
\begin{itemize}
\item
Contracting the $\beta$-redex in the following term
$$f:o\rightarrow o\rightarrow o, x:o \vdash (\lambda \varphi^{o \rightarrow o} x^o . \varphi\ x) (\temporal<2>{f\ x}{\underline{f\ \alert{x}}}{\underline{f\ \alert{x}}})$$
leads to variable capture:
$$(\lambda \varphi x . \varphi\ x) (f\ x) \not\betared (\lambda \alert{x} . (f\ \alert{x}) x).$$
\pause
Hence the term is \alert{unsafe}.

Indeed, $\ord{x} = 0 \leq 1 = \ord{f\ x}$.
\pause

\item The term $(\lambda \varphi^{o \rightarrow o} x^o . \varphi\ x) (\lambda y^o . y )$ is safe.
\end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\def\highlightat#1#2{\temporal<#1>{#2}{\underline{#2}}{\textcolor{blue}{#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Correspondence Theorem}
\frame{ \frametitle{The Correspondence Theorem}
Let $M:T$ be a pure simply typed term.



\begin{itemize}
\item \highlight{Game-semantics} provides a model of $\lambda$-calculus.
$M$ is denoted by a strategy $\sem{M}$ on a game induced by $T$.
\item A \highlight{strategy} is represented by a set of sequences of moves together with \highlight{links} (each move points
to a preceding move).
\pause
\item \textcolor{DarkGreen}{Computation tree} = canonical tree representation of a term.
\item \textcolor{DarkGreen}{Traversals $\travset(M)$ } = sequences of nodes with links respecting some formation rules.
\end{itemize}
\pause

\begin{block}{}
The game semantics of a term can be represented on the computation
tree:
$$ \textcolor{DarkGreen}{\travset(M)} \cong \textcolor{blue}{\intersem{M}} $$
$$ \textcolor{DarkGreen}{Reduction(\travset(M))} \cong \textcolor{blue}{\sem{M}}$$
where $\textcolor{blue}{\intersem{M}}$ is the revealed game-semantic denotion (i.e. internal moves are uncovered).
\end{block}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Game-semantic Characterisation of Safety}
\frame{ \frametitle{Game-semantic Characterisation of Safety}

\begin{itemize}
\item Computation tree of safe terms are \highlight{incrementally-bound} :
each variable $x$ is bound by the first $\lambda$ node occurring in
\emph{the path to the root} with order $> \ord{x}$.
\pause

\item By the Correspondence theorem, this implies that
safe terms are denoted by \highlight{incrementally-justified strategies}: each move $m$ points to the
last other player's move with order $> \ord{m}$.
\end{itemize}
\pause

\begin{block}{Corollary}
Justification pointers are redundant in the game-semantics of safe
terms. Hence the game semantics of a safe term has a
\highlight{succinct} representation.
\end{block}
}

\section{Recent results}
\frame{ \frametitle{Recent results}

\begin{theorem}
Functions definable in the safe $\lambda$-calculus are exactly the polynomials.
\end{theorem}
\begin{corollary}
The conditional operator $C:I\rightarrow I\rightarrow I \rightarrow I$ verifying:
\begin{eqnarray*}
C t y z &\rightarrow_\beta& y \mbox{, if } t \rightarrow_\beta \encode{0} \\
C t y z &\rightarrow_\beta& z \mbox{, if } t \rightarrow_\beta \encode{n+1}
\end{eqnarray*}
is not definable in the safe simply typed $\lambda$-calculus.
\end{corollary}
E.g. $$ C = \lambda F G H \alpha x . H ( \underline{\lambda y . G \alpha x} ) (F \alpha x) \ .$$
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion and Further Work}
\frame{ \frametitle{Conclusion and Further Work}

\highlight{Conclusion:}

Safety is a syntactic constraint with nice algorithmic and
game-semantic properties.

\highlight{Related works:}
\begin{itemize}
\item Forthcoming thesis of Jolie G. de Miranda about unsafety.
\item Ong introduced computation trees in LICS2006 to prove decidability of MSO theory on infinite trees
generated by higher-order grammars (whether safe or not).
\item Stirling recently proved decidability of higher-order pattern matching with a game-semantic approach
relying on equivalent notions of computation tree and traversal.
\end{itemize}

\highlight{Open questions:}
\begin{itemize}
\item Complexity classes characterised with the Safe $\lambda$-calculus?
\item Does the pointer economy extend to Safe Idealized Algol? Decidability of contextual equivalence?
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bibliography}
\begin{frame} \frametitle<presentation>{Bibliography}

  \begin{thebibliography}{10}
  \beamertemplatearticlebibitems
    \bibitem{abramsky:game-semantics-tutorial}
    Samson Abramsky and Guy McCusker.
    \newblock Game semantics, Lecture notes.
    \newblock In {\em Proceedings of the 1997 Marktoberdorf Summer School}. Springer-Verlag, 1998.

    \bibitem{safety-mirlong2004}
    Klaus Aehlig, Jolie~G. de~Miranda, and C.-H.~Luke Ong.
    \newblock Safety is not a restriction at level 2 for string languages.
    \newblock Technical report. University of Oxford, 2004.

    \bibitem{OngLics2006}
    C.-H.~Luke Ong.
    \newblock On model-checking trees generating by higher-order recursion schemes.
    \newblock In {\em Proceedings of LICS.} Computer Society Press, 2006.

    \bibitem{DBLP:conf/icalp/Stirling06}
    Colin Stirling
    \newblock A Game-Theoretic Approach to Deciding Higher-Order Matching.
    \newblock In {\em Proceedings of ICALP.} Springer, 2006.

  \end{thebibliography}
\end{frame}

\end{document}
