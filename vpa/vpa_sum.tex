\documentclass{article}
\usepackage{latexsym}
\usepackage{amssymb,amsmath,latexsym}

\def\nat{\mathbb{N}}


\author{William Blum}
\date{\today}
\title{Visibly Pushdown Languages, by Rajeev Alur and P. Madhusudan}

\begin{document}
\maketitle

Visibly pushdown languages:
\begin{itemize}
\item rich enough for modelling programs
\item nice properties
\end{itemize}

A visibly pushdown automaton is a pushdown automaton where the input symbol determines whether 
the automaton push or pop from the stack.



\section{Definition}

The alphabet $\Sigma$ is partitioned into three different alphabets: one for call symbols, one for return symbols, and one for internal actions.

$$\Sigma = \Sigma _c \cup \Sigma _r \cup \Sigma _{int}$$

If a call symbol is read, the automaton has to push an element on the stack. If it is a return symbol, it pops from the stack. Otherwise, for internal actions, it does not push or pop.


A visibly pushdown automaton on finite words over the alphabet $\hat{\Sigma} = \langle \Sigma_c, \Sigma_r, \Sigma_{int} \rangle$ is a tuple $M = (Q,Q_{in},\Sigma,\delta,Q_{F})$. $Q$ is the set of states, $Q_{in}$ the set of initial states. $\Gamma$ is the alphabet use for the stack (finite) containing the emtpy stack symbol $\perp$.
$\delta \subset (Q \times \Sigma_C \times Q \times (\Gamma \setminus \{ \perp \} ))
\cup (Q \times \Sigma_r \times \Gamma \times Q)
\cup (Q \times \Sigma_{int} \times  Q)
$, $Q_F$ is the set of final states.

There are three types of transition depending on the kind of symbol read.

The stack is nonempty finite sequence of element of $\Gamma$.


The languages recognized by VPA are the \textsl{visibly pushdown languages}: VPL.


VPA languages are a strict subclass of context-free languages
(take $L = \{ a^n b a^n \mbox{ for } n \in \nat \}$).


However for any context-free language, it is possible to associate a VPA over a different alphabet: every symbol of the initial alphabet is augmented with some information about the stack state. There is an isomorphism between the set of CFL and the set of CFL transformed into VPL.


\subsection{Theorem 1: closure}
 VPL are closed under: 
\begin{itemize}
\item union
\item intersection
\item complementation
\item renaming
\item concatenation
\item Kleene-*
\end{itemize}


\subsection{Theorem 2}
Non deterministic VPA can be determinized.


\subsection{Theorem 3}
Universality and inclusion problem undecidable for 
Context-free languages (CFL) becomes EXPTIME-complete for VPL languages.


\section{Logical characterization}

Let MSO$_\mu$ be the MSO theory (Monadic Second Order logic) augmented with a binary matching  predicate $\mu(x,y)$. Then MSO$_\mu$ is equivalent to VPL.

\subsection{Theorem 4}

L is VPL iff there is an MSO$_\mu$ sentence $\psi$ (over the same alphabet as L) that defines L.

\section{Regular Tree Languages}

We fixed an alphabet $\hat{\Sigma}$, then we can associate a tree to any word of $\Sigma^+$. These tree are called stack trees: $STree$.

Regular tree languages are the languages recognized by a 
special kind of automata over trees.

\subsection{Theorem 5}
The class VPL coincides with regular tree languages

\section{Visibly pushdown $\omega$-languages : $\omega$-VPL}

$\omega$-VPL: VPA on $\omega$-words using Büchi or Muller acceptance condition.

Decision problems: same complexity as for VPL.

\subsection{Theorem 6 and 8 - Closure}

The resulting class is closed under union, intersection, renaming, complementation.

\subsection{Theorem 7}
Nondeterministic Büchi VPA are stricly more expressive than deterministic Büchi or Muller VPA.

This is the main difference between VPL and $\omega$-VPL.

\subsection{Theorem 9 : MSO$_{\mu}$ characterization}

$\omega$-VPL are characterized by MSO$_\mu$ formulas.

\subsection{Theorem 10}

Same as for VPL where stack-trees are defined using Büchi automaton on trees.


\end{document}